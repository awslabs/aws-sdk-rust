// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddTagsToResourceInputBody<'a> {
    /// <p>Specifies the type of resource you are tagging.</p>
    /// <note>
    /// <p>The ManagedInstance type for this API action is for on-premises managed instances. You must
    /// specify the name of the managed instance in the following format: mi-ID_number. For example,
    /// mi-1a2b3c4d5e6f.</p>
    /// </note>
    pub resource_type: &'a std::option::Option<crate::model::ResourceTypeForTagging>,
    /// <p>The resource ID you want to tag.</p>
    /// <p>Use the ID of the resource. Here are some examples:</p>
    /// <p>ManagedInstance: mi-012345abcde</p>
    /// <p>MaintenanceWindow: mw-012345abcde</p>
    /// <p>PatchBaseline: pb-012345abcde</p>
    /// <p>OpsMetadata object: <code>ResourceID</code> for tagging is created from the Amazon Resource
    /// Name (ARN) for the object. Specifically, <code>ResourceID</code> is created from the strings that
    /// come after the word <code>opsmetadata</code> in the ARN. For example, an OpsMetadata object with
    /// an ARN of <code>arn:aws:ssm:us-east-2:1234567890:opsmetadata/aws/ssm/MyGroup/appmanager</code>
    /// has a <code>ResourceID</code> of either <code>aws/ssm/MyGroup/appmanager</code> or
    /// <code>/aws/ssm/MyGroup/appmanager</code>.</p>
    /// <p>For the Document and Parameter values, use the name of the resource.</p>
    /// <note>
    /// <p>The ManagedInstance type for this API action is only for on-premises managed instances. You
    /// must specify the name of the managed instance in the following format: mi-ID_number. For
    /// example, mi-1a2b3c4d5e6f.</p>
    /// </note>
    pub resource_id: &'a std::option::Option<std::string::String>,
    /// <p>One or more tags. The value parameter is required.</p>
    /// <important>
    /// <p>Do not enter personally identifiable information in this field.</p>
    /// </important>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for AddTagsToResourceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddTagsToResourceInputBody");
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateOpsItemRelatedItemInputBody<'a> {
    /// <p>The ID of the OpsItem to which you want to associate a resource as a related item.</p>
    pub ops_item_id: &'a std::option::Option<std::string::String>,
    /// <p>The type of association that you want to create between an OpsItem and a resource. OpsCenter
    /// supports <code>IsParentOf</code> and <code>RelatesTo</code> association types.</p>
    pub association_type: &'a std::option::Option<std::string::String>,
    /// <p>The type of resource that you want to associate with an OpsItem. OpsCenter supports the
    /// following types:</p>
    /// <p>
    /// <code>AWS::SSMIncidents::IncidentRecord</code>: an Incident Manager incident. Incident
    /// Manager is a capability of AWS Systems Manager.</p>
    /// <p>
    /// <code>AWS::SSM::Document</code>: a Systems Manager (SSM) document.</p>
    pub resource_type: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the AWS resource that you want to associate with the
    /// OpsItem.</p>
    pub resource_uri: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for AssociateOpsItemRelatedItemInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateOpsItemRelatedItemInputBody");
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.field("association_type", &self.association_type);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_uri", &self.resource_uri);
        formatter.finish()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelCommandInputBody<'a> {
    /// <p>The ID of the command you want to cancel.</p>
    pub command_id: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) A list of instance IDs on which you want to cancel the command. If not provided,
    /// the command is canceled on every instance on which it was requested.</p>
    pub instance_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for CancelCommandInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelCommandInputBody");
        formatter.field("command_id", &self.command_id);
        formatter.field("instance_ids", &self.instance_ids);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelMaintenanceWindowExecutionInputBody<'a> {
    /// <p>The ID of the maintenance window execution to stop.</p>
    pub window_execution_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CancelMaintenanceWindowExecutionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelMaintenanceWindowExecutionInputBody");
        formatter.field("window_execution_id", &self.window_execution_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateActivationInputBody<'a> {
    /// <p>A user-defined description of the resource that you want to register with Systems Manager. </p>
    /// <important>
    /// <p>Do not enter personally identifiable information in this field.</p>
    /// </important>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The name of the registered, managed instance as it will appear in the Systems Manager console or when
    /// you use the AWS command line tools to list Systems Manager resources.</p>
    /// <important>
    /// <p>Do not enter personally identifiable information in this field.</p>
    /// </important>
    pub default_instance_name: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Identity and Access Management (IAM) role that you want to assign to the managed
    /// instance. This IAM role must provide AssumeRole permissions for the Systems Manager service principal
    /// <code>ssm.amazonaws.com</code>. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-service-role.html">Create an IAM service role for a
    /// hybrid environment</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    pub iam_role: &'a std::option::Option<std::string::String>,
    /// <p>Specify the maximum number of managed instances you want to register. The default value is 1
    /// instance.</p>
    pub registration_limit: &'a std::option::Option<i32>,
    /// <p>The date by which this activation request should expire, in timestamp format, such as
    /// "2021-07-07T00:00:00". You can specify a date up to 30 days in advance. If you don't provide an
    /// expiration date, the activation code expires in 24 hours.</p>
    pub expiration_date: &'a std::option::Option<smithy_types::Instant>,
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
    /// different ways, such as by purpose, owner, or environment. For example, you might want to tag an
    /// activation to identify which servers or virtual machines (VMs) in your on-premises environment
    /// you intend to activate. In this case, you could specify the following key name/value
    /// pairs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Key=OS,Value=Windows</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Key=Environment,Value=Production</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <important>
    /// <p>When you install SSM Agent on your on-premises servers and VMs, you specify an activation
    /// ID and code. When you specify the activation ID and code, tags assigned to the activation are
    /// automatically applied to the on-premises servers or VMs.</p>
    /// </important>
    /// <p>You can't add tags to or delete tags from an existing activation. You can tag your
    /// on-premises servers and VMs after they connect to Systems Manager for the first time and are assigned a
    /// managed instance ID. This means they are listed in the AWS Systems Manager console with an ID that is
    /// prefixed with "mi-". For information about how to add tags to your managed instances, see <a>AddTagsToResource</a>. For information about how to remove tags from your managed
    /// instances, see <a>RemoveTagsFromResource</a>.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateActivationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateActivationInputBody");
        formatter.field("description", &self.description);
        formatter.field("default_instance_name", &self.default_instance_name);
        formatter.field("iam_role", &self.iam_role);
        formatter.field("registration_limit", &self.registration_limit);
        formatter.field("expiration_date", &self.expiration_date);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAssociationInputBody<'a> {
    /// <p>The name of the SSM document that contains the configuration information for the instance.
    /// You can specify Command or Automation documents.</p>
    /// <p>You can specify AWS-predefined documents, documents you created, or a document that is
    /// shared with you from another account.</p>
    /// <p>For SSM documents that are shared with you from other AWS accounts, you must specify the
    /// complete SSM document ARN, in the following format:</p>
    /// <p>
    /// <code>arn:<i>partition</i>:ssm:<i>region</i>:<i>account-id</i>:document/<i>document-name</i>
    /// </code>
    /// </p>
    /// <p>For example:</p>
    /// <p>
    /// <code>arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document</code>
    /// </p>
    /// <p>For AWS-predefined documents and SSM documents you created in your account, you only need to
    /// specify the document name. For example, <code>AWS-ApplyPatchBaseline</code> or
    /// <code>My-Document</code>.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The document version you want to associate with the target(s). Can be a specific version or
    /// the default version.</p>
    pub document_version: &'a std::option::Option<std::string::String>,
    /// <p>The instance ID.</p>
    /// <note>
    /// <p>
    /// <code>InstanceId</code> has been deprecated. To specify an instance ID for an association,
    /// use the <code>Targets</code> parameter. Requests that include the
    /// parameter <code>InstanceID</code> with SSM documents that use schema version 2.0 or later will
    /// fail. In addition, if you use the parameter <code>InstanceId</code>, you
    /// cannot use the parameters <code>AssociationName</code>, <code>DocumentVersion</code>,
    /// <code>MaxErrors</code>, <code>MaxConcurrency</code>, <code>OutputLocation</code>, or
    /// <code>ScheduleExpression</code>. To use these parameters, you must use the <code>Targets</code>
    /// parameter.</p>
    /// </note>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>The parameters for the runtime configuration of the document.</p>
    pub parameters: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The targets for the association. You can target instances by using tags, AWS Resource
    /// Groups, all instances in an AWS account, or individual instance IDs. For more information about
    /// choosing targets for an association, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-state-manager-targets-and-rate-controls.html">Using targets and rate controls with State Manager associations</a> in the
    /// <i>AWS Systems Manager User Guide</i>.</p>
    pub targets: &'a std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>A cron expression when the association will be applied to the target(s).</p>
    pub schedule_expression: &'a std::option::Option<std::string::String>,
    /// <p>An S3 bucket where you want to store the output details of the request.</p>
    pub output_location: &'a std::option::Option<crate::model::InstanceAssociationOutputLocation>,
    /// <p>Specify a descriptive name for the association.</p>
    pub association_name: &'a std::option::Option<std::string::String>,
    /// <p>Specify the target for the association. This target is required for associations that use an
    /// Automation document and target resources by using rate controls.</p>
    pub automation_target_parameter_name: &'a std::option::Option<std::string::String>,
    /// <p>The number of errors that are allowed before the system stops sending requests to run the
    /// association on additional targets. You can specify either an absolute number of errors, for
    /// example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
    /// the system stops sending requests when the fourth error is received. If you specify 0, then the
    /// system stops sending requests after the first error is returned. If you run an association on 50
    /// instances and set MaxError to 10%, then the system stops sending the request when the sixth error
    /// is received.</p>
    /// <p>Executions that are already running an association when MaxErrors is reached are allowed to
    /// complete, but some of these executions may fail as well. If you need to ensure that there won't
    /// be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
    /// at a time.</p>
    pub max_errors: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of targets allowed to run the association at the same time. You can
    /// specify a number, for example 10, or a percentage of the target set, for example 10%. The default
    /// value is 100%, which means all targets run the association at the same time.</p>
    /// <p>If a new instance starts and attempts to run an association while Systems Manager is running
    /// MaxConcurrency associations, the association is allowed to run. During the next association
    /// interval, the new instance will process its association within the limit specified for
    /// MaxConcurrency.</p>
    pub max_concurrency: &'a std::option::Option<std::string::String>,
    /// <p>The severity level to assign to the association.</p>
    pub compliance_severity: &'a std::option::Option<crate::model::AssociationComplianceSeverity>,
    /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
    /// <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
    /// execution to determine the compliance status. If the association execution runs successfully,
    /// then the association is <code>COMPLIANT</code>. If the association execution doesn't run
    /// successfully, the association is <code>NON-COMPLIANT</code>.</p>
    /// <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
    /// for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
    /// managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
    /// <p>By default, all associations use <code>AUTO</code> mode.</p>
    pub sync_compliance: &'a std::option::Option<crate::model::AssociationSyncCompliance>,
    /// <p>By default, when you create a new association, the system runs it immediately after it is
    /// created and then according to the schedule you specified. Specify this option if you don't want
    /// an association to run immediately after you create it. This parameter is not supported for rate
    /// expressions.</p>
    pub apply_only_at_cron_interval: &'a bool,
    /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager Change Calendar type
    /// documents you want to gate your associations under. The associations only run when that Change
    /// Calendar is open. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar">AWS Systems Manager Change
    /// Calendar</a>.</p>
    pub calendar_names: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A location is a combination of AWS Regions and AWS accounts where you want to run the
    /// association. Use this action to create an association in multiple Regions and multiple
    /// accounts.</p>
    pub target_locations: &'a std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
}
impl<'a> std::fmt::Debug for CreateAssociationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAssociationInputBody");
        formatter.field("name", &self.name);
        formatter.field("document_version", &self.document_version);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("parameters", &self.parameters);
        formatter.field("targets", &self.targets);
        formatter.field("schedule_expression", &self.schedule_expression);
        formatter.field("output_location", &self.output_location);
        formatter.field("association_name", &self.association_name);
        formatter.field(
            "automation_target_parameter_name",
            &self.automation_target_parameter_name,
        );
        formatter.field("max_errors", &self.max_errors);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("compliance_severity", &self.compliance_severity);
        formatter.field("sync_compliance", &self.sync_compliance);
        formatter.field(
            "apply_only_at_cron_interval",
            &self.apply_only_at_cron_interval,
        );
        formatter.field("calendar_names", &self.calendar_names);
        formatter.field("target_locations", &self.target_locations);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAssociationBatchInputBody<'a> {
    /// <p>One or more associations.</p>
    pub entries:
        &'a std::option::Option<std::vec::Vec<crate::model::CreateAssociationBatchRequestEntry>>,
}
impl<'a> std::fmt::Debug for CreateAssociationBatchInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAssociationBatchInputBody");
        formatter.field("entries", &self.entries);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDocumentInputBody<'a> {
    /// <p>The content for the new SSM document in JSON or YAML format. We recommend storing the
    /// contents for your new document in an external JSON or YAML file and referencing the file in a
    /// command.</p>
    /// <p>For examples, see the following topics in the <i>AWS Systems Manager User Guide</i>.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-api.html">Create an SSM document
    /// (AWS API)</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-cli.html">Create an SSM document
    /// (AWS CLI)</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-api.html">Create an SSM document
    /// (API)</a>
    /// </p>
    /// </li>
    /// </ul>
    pub content: &'a std::option::Option<std::string::String>,
    /// <p>A list of SSM documents required by a document. This parameter is used exclusively by AWS
    /// AppConfig. When a user creates an AppConfig configuration in an SSM document, the user must also
    /// specify a required document for validation purposes. In this case, an
    /// <code>ApplicationConfiguration</code> document requires an
    /// <code>ApplicationConfigurationSchema</code> document for validation purposes. For more
    /// information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/appconfig.html">AWS AppConfig</a> in the
    /// <i>AWS Systems Manager User Guide</i>.</p>
    pub requires: &'a std::option::Option<std::vec::Vec<crate::model::DocumentRequires>>,
    /// <p>A list of key and value pairs that describe attachments to a version of a document.</p>
    pub attachments: &'a std::option::Option<std::vec::Vec<crate::model::AttachmentsSource>>,
    /// <p>A name for the Systems Manager document.</p>
    /// <important>
    /// <p>You can't use the following strings as document name prefixes. These are reserved by AWS
    /// for use as document name prefixes:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>aws-</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>amazon</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>amzn</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </important>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>An optional field where you can specify a friendly name for the Systems Manager document. This value
    /// can differ for each version of the document. You can update this value at a later time using the
    /// <a>UpdateDocument</a> action.</p>
    pub display_name: &'a std::option::Option<std::string::String>,
    /// <p>An optional field specifying the version of the artifact you are creating with the document.
    /// For example, "Release 12, Update 6". This value is unique across all versions of a document, and
    /// cannot be changed.</p>
    pub version_name: &'a std::option::Option<std::string::String>,
    /// <p>The type of document to create.</p>
    pub document_type: &'a std::option::Option<crate::model::DocumentType>,
    /// <p>Specify the document format for the request. The document format can be JSON, YAML, or TEXT.
    /// JSON is the default format.</p>
    pub document_format: &'a std::option::Option<crate::model::DocumentFormat>,
    /// <p>Specify a target type to define the kinds of resources the document can run on. For example,
    /// to run a document on EC2 instances, specify the following value: /AWS::EC2::Instance. If you
    /// specify a value of '/' the document can run on all types of resources. If you don't specify a
    /// value, the document can't run on any resources. For a list of valid resource types, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS resource and property types
    /// reference</a> in the <i>AWS CloudFormation User Guide</i>. </p>
    pub target_type: &'a std::option::Option<std::string::String>,
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
    /// different ways, such as by purpose, owner, or environment. For example, you might want to tag an
    /// SSM document to identify the types of targets or the environment where it will run. In this case,
    /// you could specify the following key name/value pairs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Key=OS,Value=Windows</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Key=Environment,Value=Production</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>To add tags to an existing SSM document, use the <a>AddTagsToResource</a>
    /// action.</p>
    /// </note>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateDocumentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDocumentInputBody");
        formatter.field("content", &self.content);
        formatter.field("requires", &self.requires);
        formatter.field("attachments", &self.attachments);
        formatter.field("name", &self.name);
        formatter.field("display_name", &self.display_name);
        formatter.field("version_name", &self.version_name);
        formatter.field("document_type", &self.document_type);
        formatter.field("document_format", &self.document_format);
        formatter.field("target_type", &self.target_type);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMaintenanceWindowInputBody<'a> {
    /// <p>The name of the maintenance window.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>An optional description for the maintenance window. We recommend specifying a description to
    /// help you organize your maintenance windows. </p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO-8601 Extended format, for when you want the maintenance window to
    /// become active. StartDate allows you to delay activation of the maintenance window until the
    /// specified future date.</p>
    pub start_date: &'a std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO-8601 Extended format, for when you want the maintenance window to
    /// become inactive. EndDate allows you to set a date and time in the future when the maintenance
    /// window will no longer run.</p>
    pub end_date: &'a std::option::Option<std::string::String>,
    /// <p>The schedule of the maintenance window in the form of a cron or rate expression.</p>
    pub schedule: &'a std::option::Option<std::string::String>,
    /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
    /// Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or
    /// "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time
    /// Zone Database</a> on the IANA website.</p>
    pub schedule_timezone: &'a std::option::Option<std::string::String>,
    /// <p>The number of days to wait after the date and time specified by a CRON expression before
    /// running the maintenance window.</p>
    /// <p>For example, the following cron expression schedules a maintenance window to run on the
    /// third Tuesday of every month at 11:30 PM.</p>
    /// <p>
    /// <code>cron(30 23 ? * TUE#3 *)</code>
    /// </p>
    /// <p>If the schedule offset is <code>2</code>, the maintenance window won't run until two days
    /// later.</p>
    pub schedule_offset: &'a std::option::Option<i32>,
    /// <p>The duration of the maintenance window in hours.</p>
    pub duration: &'a i32,
    /// <p>The number of hours before the end of the maintenance window that Systems Manager stops scheduling new
    /// tasks for execution.</p>
    pub cutoff: &'a i32,
    /// <p>Enables a maintenance window task to run on managed instances, even if you have not
    /// registered those instances as targets. If enabled, then you must specify the unregistered
    /// instances (by instance ID) when you register a task with the maintenance window.</p>
    /// <p>If you don't enable this option, then you must specify previously-registered targets when
    /// you register a task with the maintenance window.</p>
    pub allow_unassociated_targets: &'a bool,
    /// <p>User-provided idempotency token.</p>
    pub client_token: &'a std::option::Option<std::string::String>,
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
    /// different ways, such as by purpose, owner, or environment. For example, you might want to tag a
    /// maintenance window to identify the type of tasks it will run, the types of targets, and the
    /// environment it will run in. In this case, you could specify the following key name/value
    /// pairs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Key=TaskType,Value=AgentUpdate</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Key=OS,Value=Windows</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Key=Environment,Value=Production</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>To add tags to an existing maintenance window, use the <a>AddTagsToResource</a>
    /// action.</p>
    /// </note>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateMaintenanceWindowInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMaintenanceWindowInputBody");
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("start_date", &self.start_date);
        formatter.field("end_date", &self.end_date);
        formatter.field("schedule", &self.schedule);
        formatter.field("schedule_timezone", &self.schedule_timezone);
        formatter.field("schedule_offset", &self.schedule_offset);
        formatter.field("duration", &self.duration);
        formatter.field("cutoff", &self.cutoff);
        formatter.field(
            "allow_unassociated_targets",
            &self.allow_unassociated_targets,
        );
        formatter.field("client_token", &self.client_token);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateOpsItemInputBody<'a> {
    /// <p>Information about the OpsItem. </p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The type of OpsItem to create. Currently, the only valid values are
    /// <code>/aws/changerequest</code> and <code>/aws/issue</code>.</p>
    pub ops_item_type: &'a std::option::Option<std::string::String>,
    /// <p>Operational data is custom data that provides useful reference details about the OpsItem.
    /// For example, you can specify log files, error strings, license keys, troubleshooting tips, or
    /// other relevant data. You enter operational data as key-value pairs. The key has a maximum length
    /// of 128 characters. The value has a maximum size of 20 KB.</p>
    /// <important>
    /// <p>Operational data keys <i>can't</i> begin with the following: amazon, aws,
    /// amzn, ssm, /amazon, /aws, /amzn, /ssm.</p>
    /// </important>
    /// <p>You can choose to make the data searchable by other users in the account or you can restrict
    /// search access. Searchable data means that all users with access to the OpsItem Overview page (as
    /// provided by the <a>DescribeOpsItems</a> API action) can view and search on the
    /// specified data. Operational data that is not searchable is only viewable by users who have access
    /// to the OpsItem (as provided by the <a>GetOpsItem</a> API action).</p>
    /// <p>Use the <code>/aws/resources</code> key in OperationalData to specify a related resource in
    /// the request. Use the <code>/aws/automations</code> key in OperationalData to associate an
    /// Automation runbook with the OpsItem. To view AWS CLI example commands that use these keys, see
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems">Creating OpsItems manually</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    pub operational_data: &'a std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::OpsItemDataValue>,
    >,
    /// <p>The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this
    /// OpsItem is edited or changed.</p>
    pub notifications: &'a std::option::Option<std::vec::Vec<crate::model::OpsItemNotification>>,
    /// <p>The importance of this OpsItem in relation to other OpsItems in the system.</p>
    pub priority: &'a std::option::Option<i32>,
    /// <p>One or more OpsItems that share something in common with the current OpsItems. For example,
    /// related OpsItems can include OpsItems with similar error messages, impacted resources, or
    /// statuses for the impacted resource.</p>
    pub related_ops_items: &'a std::option::Option<std::vec::Vec<crate::model::RelatedOpsItem>>,
    /// <p>The origin of the OpsItem, such as Amazon EC2 or Systems Manager.</p>
    /// <note>
    /// <p>The source name can't contain the following strings: aws, amazon, and amzn. </p>
    /// </note>
    pub source: &'a std::option::Option<std::string::String>,
    /// <p>A short heading that describes the nature of the OpsItem and the impacted resource.</p>
    pub title: &'a std::option::Option<std::string::String>,
    /// <p>Optional metadata that you assign to a resource. You can restrict access to OpsItems by
    /// using an inline IAM policy that specifies tags. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-getting-started.html#OpsCenter-getting-started-user-permissions">Getting started with OpsCenter</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    /// <p>Tags use a key-value pair. For example:</p>
    /// <p>
    /// <code>Key=Department,Value=Finance</code>
    /// </p>
    /// <note>
    /// <p>To add tags to an existing OpsItem, use the <a>AddTagsToResource</a>
    /// action.</p>
    /// </note>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Specify a category to assign to an OpsItem. </p>
    pub category: &'a std::option::Option<std::string::String>,
    /// <p>Specify a severity to assign to an OpsItem.</p>
    pub severity: &'a std::option::Option<std::string::String>,
    /// <p>The time a runbook workflow started. Currently reported only for the OpsItem type
    /// <code>/aws/changerequest</code>.</p>
    pub actual_start_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The time a runbook workflow ended. Currently reported only for the OpsItem type
    /// <code>/aws/changerequest</code>.</p>
    pub actual_end_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The time specified in a change request for a runbook workflow to start. Currently supported
    /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
    pub planned_start_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The time specified in a change request for a runbook workflow to end. Currently supported
    /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
    pub planned_end_time: &'a std::option::Option<smithy_types::Instant>,
}
impl<'a> std::fmt::Debug for CreateOpsItemInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateOpsItemInputBody");
        formatter.field("description", &self.description);
        formatter.field("ops_item_type", &self.ops_item_type);
        formatter.field("operational_data", &self.operational_data);
        formatter.field("notifications", &self.notifications);
        formatter.field("priority", &self.priority);
        formatter.field("related_ops_items", &self.related_ops_items);
        formatter.field("source", &self.source);
        formatter.field("title", &self.title);
        formatter.field("tags", &self.tags);
        formatter.field("category", &self.category);
        formatter.field("severity", &self.severity);
        formatter.field("actual_start_time", &self.actual_start_time);
        formatter.field("actual_end_time", &self.actual_end_time);
        formatter.field("planned_start_time", &self.planned_start_time);
        formatter.field("planned_end_time", &self.planned_end_time);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateOpsMetadataInputBody<'a> {
    /// <p>A resource ID for a new Application Manager application.</p>
    pub resource_id: &'a std::option::Option<std::string::String>,
    /// <p>Metadata for a new Application Manager application. </p>
    pub metadata: &'a std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::MetadataValue>,
    >,
    /// <p>Optional metadata that you assign to a resource. You can specify a maximum of five tags for
    /// an OpsMetadata object. Tags enable you to categorize a resource in different ways, such as by
    /// purpose, owner, or environment. For example, you might want to tag an OpsMetadata object to
    /// identify an environment or target AWS Region. In this case, you could specify the following
    /// key-value pairs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Key=Environment,Value=Production</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Key=Region,Value=us-east-2</code>
    /// </p>
    /// </li>
    /// </ul>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateOpsMetadataInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateOpsMetadataInputBody");
        formatter.field("resource_id", &self.resource_id);
        formatter.field("metadata", &self.metadata);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePatchBaselineInputBody<'a> {
    /// <p>Defines the operating system the patch baseline applies to. The Default value is
    /// WINDOWS.</p>
    pub operating_system: &'a std::option::Option<crate::model::OperatingSystem>,
    /// <p>The name of the patch baseline.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>A set of global filters used to include patches in the baseline.</p>
    pub global_filters: &'a std::option::Option<crate::model::PatchFilterGroup>,
    /// <p>A set of rules used to include patches in the baseline.</p>
    pub approval_rules: &'a std::option::Option<crate::model::PatchRuleGroup>,
    /// <p>A list of explicitly approved patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches,
    /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
    /// package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    pub approved_patches: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Defines the compliance level for approved patches. When an approved patch is reported as
    /// missing, this value describes the severity of the compliance violation. The default value is
    /// UNSPECIFIED.</p>
    pub approved_patches_compliance_level:
        &'a std::option::Option<crate::model::PatchComplianceLevel>,
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be
    /// applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
    pub approved_patches_enable_non_security: &'a std::option::Option<bool>,
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches,
    /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
    /// package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    pub rejected_patches: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The action for Patch Manager to take on patches included in the RejectedPackages
    /// list.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>ALLOW_AS_DEPENDENCY</b>: A package in the Rejected patches
    /// list is installed only if it is a dependency of another package. It is considered compliant
    /// with the patch baseline, and its status is reported as <i>InstalledOther</i>.
    /// This is the default action if no option is specified.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>BLOCK</b>: Packages in the RejectedPatches list, and packages
    /// that include them as dependencies, are not installed under any circumstances. If a package was
    /// installed before it was added to the Rejected patches list, it is considered non-compliant with
    /// the patch baseline, and its status is reported as
    /// <i>InstalledRejected</i>.</p>
    /// </li>
    /// </ul>
    pub rejected_patches_action: &'a std::option::Option<crate::model::PatchAction>,
    /// <p>A description of the patch baseline.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>Information about the patches to use to update the instances, including target operating
    /// systems and source repositories. Applies to Linux instances only.</p>
    pub sources: &'a std::option::Option<std::vec::Vec<crate::model::PatchSource>>,
    /// <p>User-provided idempotency token.</p>
    pub client_token: &'a std::option::Option<std::string::String>,
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
    /// different ways, such as by purpose, owner, or environment. For example, you might want to tag a
    /// patch baseline to identify the severity level of patches it specifies and the operating system
    /// family it applies to. In this case, you could specify the following key name/value pairs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Key=PatchSeverity,Value=Critical</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Key=OS,Value=Windows</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>To add tags to an existing patch baseline, use the <a>AddTagsToResource</a>
    /// action.</p>
    /// </note>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreatePatchBaselineInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePatchBaselineInputBody");
        formatter.field("operating_system", &self.operating_system);
        formatter.field("name", &self.name);
        formatter.field("global_filters", &self.global_filters);
        formatter.field("approval_rules", &self.approval_rules);
        formatter.field("approved_patches", &self.approved_patches);
        formatter.field(
            "approved_patches_compliance_level",
            &self.approved_patches_compliance_level,
        );
        formatter.field(
            "approved_patches_enable_non_security",
            &self.approved_patches_enable_non_security,
        );
        formatter.field("rejected_patches", &self.rejected_patches);
        formatter.field("rejected_patches_action", &self.rejected_patches_action);
        formatter.field("description", &self.description);
        formatter.field("sources", &self.sources);
        formatter.field("client_token", &self.client_token);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateResourceDataSyncInputBody<'a> {
    /// <p>A name for the configuration.</p>
    pub sync_name: &'a std::option::Option<std::string::String>,
    /// <p>Amazon S3 configuration details for the sync. This parameter is required if the
    /// <code>SyncType</code> value is SyncToDestination.</p>
    pub s3_destination: &'a std::option::Option<crate::model::ResourceDataSyncS3Destination>,
    /// <p>Specify <code>SyncToDestination</code> to create a resource data sync that synchronizes data
    /// to an S3 bucket for Inventory. If you specify <code>SyncToDestination</code>, you must provide a
    /// value for <code>S3Destination</code>. Specify <code>SyncFromSource</code> to synchronize data
    /// from a single account and multiple Regions, or multiple AWS accounts and Regions, as listed in
    /// AWS Organizations for Explorer. If you specify <code>SyncFromSource</code>, you must provide a value for
    /// <code>SyncSource</code>. The default value is <code>SyncToDestination</code>.</p>
    pub sync_type: &'a std::option::Option<std::string::String>,
    /// <p>Specify information about the data sources to synchronize. This parameter is required if the
    /// <code>SyncType</code> value is SyncFromSource.</p>
    pub sync_source: &'a std::option::Option<crate::model::ResourceDataSyncSource>,
}
impl<'a> std::fmt::Debug for CreateResourceDataSyncInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateResourceDataSyncInputBody");
        formatter.field("sync_name", &self.sync_name);
        formatter.field("s3_destination", &self.s3_destination);
        formatter.field("sync_type", &self.sync_type);
        formatter.field("sync_source", &self.sync_source);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteActivationInputBody<'a> {
    /// <p>The ID of the activation that you want to delete.</p>
    pub activation_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteActivationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteActivationInputBody");
        formatter.field("activation_id", &self.activation_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAssociationInputBody<'a> {
    /// <p>The name of the Systems Manager document.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The ID of the instance.</p>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>The association ID that you want to delete.</p>
    pub association_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteAssociationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAssociationInputBody");
        formatter.field("name", &self.name);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("association_id", &self.association_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDocumentInputBody<'a> {
    /// <p>The name of the document.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The version of the document that you want to delete. If not provided, all versions of the
    /// document are deleted.</p>
    pub document_version: &'a std::option::Option<std::string::String>,
    /// <p>The version name of the document that you want to delete. If not provided, all versions of
    /// the document are deleted.</p>
    pub version_name: &'a std::option::Option<std::string::String>,
    /// <p>Some SSM document types require that you specify a <code>Force</code> flag before you can
    /// delete the document. For example, you must specify a <code>Force</code> flag to delete a document
    /// of type <code>ApplicationConfigurationSchema</code>. You can restrict access to the
    /// <code>Force</code> flag in an AWS Identity and Access Management (IAM) policy.</p>
    pub force: &'a bool,
}
impl<'a> std::fmt::Debug for DeleteDocumentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDocumentInputBody");
        formatter.field("name", &self.name);
        formatter.field("document_version", &self.document_version);
        formatter.field("version_name", &self.version_name);
        formatter.field("force", &self.force);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteInventoryInputBody<'a> {
    /// <p>The name of the custom inventory type for which you want to delete either all previously
    /// collected data or the inventory type itself. </p>
    pub type_name: &'a std::option::Option<std::string::String>,
    /// <p>Use the <code>SchemaDeleteOption</code> to delete a custom inventory type (schema). If you
    /// don't choose this option, the system only deletes existing inventory data associated with the
    /// custom inventory type. Choose one of the following options:</p>
    /// <p>DisableSchema: If you choose this option, the system ignores all inventory data for the
    /// specified version, and any earlier versions. To enable this schema again, you must call the
    /// <code>PutInventory</code> action for a version greater than the disabled version.</p>
    /// <p>DeleteSchema: This option deletes the specified custom type from the Inventory service. You
    /// can recreate the schema later, if you want.</p>
    pub schema_delete_option: &'a std::option::Option<crate::model::InventorySchemaDeleteOption>,
    /// <p>Use this option to view a summary of the deletion request without deleting any data or the
    /// data type. This option is useful when you only want to understand what will be deleted. Once you
    /// validate that the data to be deleted is what you intend to delete, you can run the same command
    /// without specifying the <code>DryRun</code> option.</p>
    pub dry_run: &'a bool,
    /// <p>User-provided idempotency token.</p>
    pub client_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteInventoryInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteInventoryInputBody");
        formatter.field("type_name", &self.type_name);
        formatter.field("schema_delete_option", &self.schema_delete_option);
        formatter.field("dry_run", &self.dry_run);
        formatter.field("client_token", &self.client_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMaintenanceWindowInputBody<'a> {
    /// <p>The ID of the maintenance window to delete.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteMaintenanceWindowInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMaintenanceWindowInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteOpsMetadataInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of an OpsMetadata Object to delete.</p>
    pub ops_metadata_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteOpsMetadataInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteOpsMetadataInputBody");
        formatter.field("ops_metadata_arn", &self.ops_metadata_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteParameterInputBody<'a> {
    /// <p>The name of the parameter to delete.</p>
    pub name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteParameterInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteParameterInputBody");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteParametersInputBody<'a> {
    /// <p>The names of the parameters to delete.</p>
    pub names: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for DeleteParametersInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteParametersInputBody");
        formatter.field("names", &self.names);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePatchBaselineInputBody<'a> {
    /// <p>The ID of the patch baseline to delete.</p>
    pub baseline_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeletePatchBaselineInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePatchBaselineInputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteResourceDataSyncInputBody<'a> {
    /// <p>The name of the configuration to delete.</p>
    pub sync_name: &'a std::option::Option<std::string::String>,
    /// <p>Specify the type of resource data sync to delete.</p>
    pub sync_type: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteResourceDataSyncInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteResourceDataSyncInputBody");
        formatter.field("sync_name", &self.sync_name);
        formatter.field("sync_type", &self.sync_type);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterManagedInstanceInputBody<'a> {
    /// <p>The ID assigned to the managed instance when you registered it using the activation process.
    /// </p>
    pub instance_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeregisterManagedInstanceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterManagedInstanceInputBody");
        formatter.field("instance_id", &self.instance_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterPatchBaselineForPatchGroupInputBody<'a> {
    /// <p>The ID of the patch baseline to deregister the patch group from.</p>
    pub baseline_id: &'a std::option::Option<std::string::String>,
    /// <p>The name of the patch group that should be deregistered from the patch baseline.</p>
    pub patch_group: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeregisterPatchBaselineForPatchGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterPatchBaselineForPatchGroupInputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("patch_group", &self.patch_group);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterTargetFromMaintenanceWindowInputBody<'a> {
    /// <p>The ID of the maintenance window the target should be removed from.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
    /// <p>The ID of the target definition to remove.</p>
    pub window_target_id: &'a std::option::Option<std::string::String>,
    /// <p>The system checks if the target is being referenced by a task. If the target is being
    /// referenced, the system returns an error and does not deregister the target from the maintenance
    /// window.</p>
    pub safe: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for DeregisterTargetFromMaintenanceWindowInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterTargetFromMaintenanceWindowInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_target_id", &self.window_target_id);
        formatter.field("safe", &self.safe);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterTaskFromMaintenanceWindowInputBody<'a> {
    /// <p>The ID of the maintenance window the task should be removed from.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
    /// <p>The ID of the task to remove from the maintenance window.</p>
    pub window_task_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeregisterTaskFromMaintenanceWindowInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterTaskFromMaintenanceWindowInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_task_id", &self.window_task_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeActivationsInputBody<'a> {
    /// <p>A filter to view information about your activations.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::DescribeActivationsFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeActivationsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeActivationsInputBody");
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAssociationInputBody<'a> {
    /// <p>The name of the Systems Manager document.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The instance ID.</p>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>The association ID for which you want information.</p>
    pub association_id: &'a std::option::Option<std::string::String>,
    /// <p>Specify the association version to retrieve. To view the latest version, either specify
    /// <code>$LATEST</code> for this parameter, or omit this parameter. To view a list of all
    /// associations for an instance, use <a>ListAssociations</a>. To get a list of versions
    /// for a specific association, use <a>ListAssociationVersions</a>. </p>
    pub association_version: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeAssociationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAssociationInputBody");
        formatter.field("name", &self.name);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("association_id", &self.association_id);
        formatter.field("association_version", &self.association_version);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAssociationExecutionsInputBody<'a> {
    /// <p>The association ID for which you want to view execution history details.</p>
    pub association_id: &'a std::option::Option<std::string::String>,
    /// <p>Filters for the request. You can specify the following filters and values.</p>
    /// <p>ExecutionId (EQUAL)</p>
    /// <p>Status (EQUAL)</p>
    /// <p>CreatedTime (EQUAL, GREATER_THAN, LESS_THAN)</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::AssociationExecutionFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeAssociationExecutionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAssociationExecutionsInputBody");
        formatter.field("association_id", &self.association_id);
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAssociationExecutionTargetsInputBody<'a> {
    /// <p>The association ID that includes the execution for which you want to view details.</p>
    pub association_id: &'a std::option::Option<std::string::String>,
    /// <p>The execution ID for which you want to view details.</p>
    pub execution_id: &'a std::option::Option<std::string::String>,
    /// <p>Filters for the request. You can specify the following filters and values.</p>
    /// <p>Status (EQUAL)</p>
    /// <p>ResourceId (EQUAL)</p>
    /// <p>ResourceType (EQUAL)</p>
    pub filters:
        &'a std::option::Option<std::vec::Vec<crate::model::AssociationExecutionTargetsFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeAssociationExecutionTargetsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAssociationExecutionTargetsInputBody");
        formatter.field("association_id", &self.association_id);
        formatter.field("execution_id", &self.execution_id);
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAutomationExecutionsInputBody<'a> {
    /// <p>Filters used to limit the scope of executions that are requested.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::AutomationExecutionFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeAutomationExecutionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAutomationExecutionsInputBody");
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAutomationStepExecutionsInputBody<'a> {
    /// <p>The Automation execution ID for which you want step execution descriptions.</p>
    pub automation_execution_id: &'a std::option::Option<std::string::String>,
    /// <p>One or more filters to limit the number of step executions returned by the request.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::StepExecutionFilter>>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>Indicates whether to list step executions in reverse order by start time. The default value
    /// is 'false'.</p>
    pub reverse_order: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for DescribeAutomationStepExecutionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAutomationStepExecutionsInputBody");
        formatter.field("automation_execution_id", &self.automation_execution_id);
        formatter.field("filters", &self.filters);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("reverse_order", &self.reverse_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAvailablePatchesInputBody<'a> {
    /// <p>Filters used to scope down the returned patches.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::PatchOrchestratorFilter>>,
    /// <p>The maximum number of patches to return (per page).</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeAvailablePatchesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAvailablePatchesInputBody");
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDocumentInputBody<'a> {
    /// <p>The name of the Systems Manager document.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The document version for which you want information. Can be a specific version or the
    /// default version.</p>
    pub document_version: &'a std::option::Option<std::string::String>,
    /// <p>An optional field specifying the version of the artifact associated with the document. For
    /// example, "Release 12, Update 6". This value is unique across all versions of a document, and
    /// cannot be changed.</p>
    pub version_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeDocumentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDocumentInputBody");
        formatter.field("name", &self.name);
        formatter.field("document_version", &self.document_version);
        formatter.field("version_name", &self.version_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDocumentPermissionInputBody<'a> {
    /// <p>The name of the document for which you are the owner.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The permission type for the document. The permission type can be
    /// <i>Share</i>.</p>
    pub permission_type: &'a std::option::Option<crate::model::DocumentPermissionType>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeDocumentPermissionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDocumentPermissionInputBody");
        formatter.field("name", &self.name);
        formatter.field("permission_type", &self.permission_type);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEffectiveInstanceAssociationsInputBody<'a> {
    /// <p>The instance ID for which you want to view all associations.</p>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeEffectiveInstanceAssociationsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEffectiveInstanceAssociationsInputBody");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEffectivePatchesForPatchBaselineInputBody<'a> {
    /// <p>The ID of the patch baseline to retrieve the effective patches for.</p>
    pub baseline_id: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of patches to return (per page).</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeEffectivePatchesForPatchBaselineInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEffectivePatchesForPatchBaselineInputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInstanceAssociationsStatusInputBody<'a> {
    /// <p>The instance IDs for which you want association status information.</p>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeInstanceAssociationsStatusInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInstanceAssociationsStatusInputBody");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInstanceInformationInputBody<'a> {
    /// <p>This is a legacy method. We recommend that you don't use this method. Instead, use the
    /// <code>Filters</code> data type. <code>Filters</code> enables you to return instance information
    /// by filtering based on tags applied to managed instances.</p>
    /// <note>
    /// <p>Attempting to use <code>InstanceInformationFilterList</code> and <code>Filters</code> leads
    /// to an exception error. </p>
    /// </note>
    pub instance_information_filter_list:
        &'a std::option::Option<std::vec::Vec<crate::model::InstanceInformationFilter>>,
    /// <p>One or more filters. Use a filter to return a more specific list of instances. You can
    /// filter based on tags applied to EC2 instances. Use this <code>Filters</code> data type instead of
    /// <code>InstanceInformationFilterList</code>, which is deprecated.</p>
    pub filters:
        &'a std::option::Option<std::vec::Vec<crate::model::InstanceInformationStringFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results. </p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeInstanceInformationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInstanceInformationInputBody");
        formatter.field(
            "instance_information_filter_list",
            &self.instance_information_filter_list,
        );
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInstancePatchesInputBody<'a> {
    /// <p>The ID of the instance whose patch state information should be retrieved.</p>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>An array of structures. Each entry in the array is a structure containing a Key, Value
    /// combination. Valid values for Key are <code>Classification</code> | <code>KBId</code> |
    /// <code>Severity</code> | <code>State</code>.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::PatchOrchestratorFilter>>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of patches to return (per page).</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for DescribeInstancePatchesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInstancePatchesInputBody");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("filters", &self.filters);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInstancePatchStatesInputBody<'a> {
    /// <p>The ID of the instance whose patch state information should be retrieved.</p>
    pub instance_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of instances to return (per page).</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for DescribeInstancePatchStatesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInstancePatchStatesInputBody");
        formatter.field("instance_ids", &self.instance_ids);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInstancePatchStatesForPatchGroupInputBody<'a> {
    /// <p>The name of the patch group for which the patch state information should be
    /// retrieved.</p>
    pub patch_group: &'a std::option::Option<std::string::String>,
    /// <p>Each entry in the array is a structure containing:</p>
    /// <p>Key (string between 1 and 200 characters)</p>
    /// <p> Values (array containing a single string)</p>
    /// <p> Type (string "Equal", "NotEqual", "LessThan", "GreaterThan")</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::InstancePatchStateFilter>>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of patches to return (per page).</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for DescribeInstancePatchStatesForPatchGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInstancePatchStatesForPatchGroupInputBody");
        formatter.field("patch_group", &self.patch_group);
        formatter.field("filters", &self.filters);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInventoryDeletionsInputBody<'a> {
    /// <p>Specify the delete inventory ID for which you want information. This ID was returned by the
    /// <code>DeleteInventory</code> action.</p>
    pub deletion_id: &'a std::option::Option<std::string::String>,
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for DescribeInventoryDeletionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInventoryDeletionsInputBody");
        formatter.field("deletion_id", &self.deletion_id);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowExecutionsInputBody<'a> {
    /// <p>The ID of the maintenance window whose executions should be retrieved.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
    /// <p>Each entry in the array is a structure containing:</p>
    /// <p>Key (string, between 1 and 128 characters)</p>
    /// <p>Values (array of strings, each string is between 1 and 256 characters)</p>
    /// <p>The supported Keys are ExecutedBefore and ExecutedAfter with the value being a date/time
    /// string such as 2016-11-04T05:00:00Z.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeMaintenanceWindowExecutionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowExecutionsInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowExecutionTaskInvocationsInputBody<'a> {
    /// <p>The ID of the maintenance window execution the task is part of.</p>
    pub window_execution_id: &'a std::option::Option<std::string::String>,
    /// <p>The ID of the specific task in the maintenance window task that should be retrieved.</p>
    pub task_id: &'a std::option::Option<std::string::String>,
    /// <p>Optional filters used to scope down the returned task invocations. The supported filter key
    /// is STATUS with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT,
    /// CANCELLING, and CANCELLED.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeMaintenanceWindowExecutionTaskInvocationsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("DescribeMaintenanceWindowExecutionTaskInvocationsInputBody");
        formatter.field("window_execution_id", &self.window_execution_id);
        formatter.field("task_id", &self.task_id);
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowExecutionTasksInputBody<'a> {
    /// <p>The ID of the maintenance window execution whose task executions should be retrieved.</p>
    pub window_execution_id: &'a std::option::Option<std::string::String>,
    /// <p>Optional filters used to scope down the returned tasks. The supported filter key is STATUS
    /// with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT, CANCELLING, and
    /// CANCELLED. </p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeMaintenanceWindowExecutionTasksInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowExecutionTasksInputBody");
        formatter.field("window_execution_id", &self.window_execution_id);
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowsInputBody<'a> {
    /// <p>Optional filters used to narrow down the scope of the returned maintenance windows.
    /// Supported filter keys are <b>Name</b> and <b>Enabled</b>.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeMaintenanceWindowsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowsInputBody");
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowScheduleInputBody<'a> {
    /// <p>The ID of the maintenance window to retrieve information about.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
    /// <p>The instance ID or key/value pair to retrieve information about.</p>
    pub targets: &'a std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The type of resource you want to retrieve information about. For example, "INSTANCE".</p>
    pub resource_type: &'a std::option::Option<crate::model::MaintenanceWindowResourceType>,
    /// <p>Filters used to limit the range of results. For example, you can limit maintenance window
    /// executions to only those scheduled before or after a certain date and time.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::PatchOrchestratorFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeMaintenanceWindowScheduleInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowScheduleInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("targets", &self.targets);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowsForTargetInputBody<'a> {
    /// <p>The instance ID or key/value pair to retrieve information about.</p>
    pub targets: &'a std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The type of resource you want to retrieve information about. For example, "INSTANCE".</p>
    pub resource_type: &'a std::option::Option<crate::model::MaintenanceWindowResourceType>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeMaintenanceWindowsForTargetInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowsForTargetInputBody");
        formatter.field("targets", &self.targets);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowTargetsInputBody<'a> {
    /// <p>The ID of the maintenance window whose targets should be retrieved.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
    /// <p>Optional filters that can be used to narrow down the scope of the returned window targets.
    /// The supported filter keys are Type, WindowTargetId and OwnerInformation.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeMaintenanceWindowTargetsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowTargetsInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowTasksInputBody<'a> {
    /// <p>The ID of the maintenance window whose tasks should be retrieved.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
    /// <p>Optional filters used to narrow down the scope of the returned tasks. The supported filter
    /// keys are WindowTaskId, TaskArn, Priority, and TaskType.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeMaintenanceWindowTasksInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowTasksInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeOpsItemsInputBody<'a> {
    /// <p>One or more filters to limit the response.</p>
    /// <ul>
    /// <li>
    /// <p>Key: CreatedTime</p>
    /// <p>Operations: GreaterThan, LessThan</p>
    /// </li>
    /// <li>
    /// <p>Key: LastModifiedBy</p>
    /// <p>Operations: Contains, Equals</p>
    /// </li>
    /// <li>
    /// <p>Key: LastModifiedTime</p>
    /// <p>Operations: GreaterThan, LessThan</p>
    /// </li>
    /// <li>
    /// <p>Key: Priority</p>
    /// <p>Operations: Equals</p>
    /// </li>
    /// <li>
    /// <p>Key: Source</p>
    /// <p>Operations: Contains, Equals</p>
    /// </li>
    /// <li>
    /// <p>Key: Status</p>
    /// <p>Operations: Equals</p>
    /// </li>
    /// <li>
    /// <p>Key: Title</p>
    /// <p>Operations: Contains</p>
    /// </li>
    /// <li>
    /// <p>Key: OperationalData*</p>
    /// <p>Operations: Equals</p>
    /// </li>
    /// <li>
    /// <p>Key: OperationalDataKey</p>
    /// <p>Operations: Equals</p>
    /// </li>
    /// <li>
    /// <p>Key: OperationalDataValue</p>
    /// <p>Operations: Equals, Contains</p>
    /// </li>
    /// <li>
    /// <p>Key: OpsItemId</p>
    /// <p>Operations: Equals</p>
    /// </li>
    /// <li>
    /// <p>Key: ResourceId</p>
    /// <p>Operations: Contains</p>
    /// </li>
    /// <li>
    /// <p>Key: AutomationId</p>
    /// <p>Operations: Equals</p>
    /// </li>
    /// </ul>
    /// <p>*If you filter the response by using the OperationalData operator, specify a key-value pair
    /// by using the following JSON format: {"key":"key_name","value":"a_value"}</p>
    pub ops_item_filters: &'a std::option::Option<std::vec::Vec<crate::model::OpsItemFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A token to start the list. Use this token to get the next set of results.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeOpsItemsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeOpsItemsInputBody");
        formatter.field("ops_item_filters", &self.ops_item_filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeParametersInputBody<'a> {
    /// <p>This data type is deprecated. Instead, use <code>ParameterFilters</code>.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::ParametersFilter>>,
    /// <p>Filters to limit the request results.</p>
    pub parameter_filters:
        &'a std::option::Option<std::vec::Vec<crate::model::ParameterStringFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeParametersInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeParametersInputBody");
        formatter.field("filters", &self.filters);
        formatter.field("parameter_filters", &self.parameter_filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePatchBaselinesInputBody<'a> {
    /// <p>Each element in the array is a structure containing: </p>
    /// <p>Key: (string, "NAME_PREFIX" or "OWNER")</p>
    /// <p>Value: (array of strings, exactly 1 entry, between 1 and 255 characters)</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::PatchOrchestratorFilter>>,
    /// <p>The maximum number of patch baselines to return (per page).</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribePatchBaselinesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePatchBaselinesInputBody");
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePatchGroupsInputBody<'a> {
    /// <p>The maximum number of patch groups to return (per page).</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
    /// <p>For <code>DescribePatchGroups</code>,valid filter keys include the following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NAME_PREFIX</code>: The name of the patch group. Wildcards (*) are accepted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OPERATING_SYSTEM</code>: The supported operating system type to return results for.
    /// For valid operating system values, see <a>GetDefaultPatchBaselineRequest$OperatingSystem</a> in <a>CreatePatchBaseline</a>.</p>
    /// <p>Examples:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>--filters Key=NAME_PREFIX,Values=MyPatchGroup*</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>--filters Key=OPERATING_SYSTEM,Values=AMAZON_LINUX_2</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// </ul>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::PatchOrchestratorFilter>>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribePatchGroupsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePatchGroupsInputBody");
        formatter.field("max_results", &self.max_results);
        formatter.field("filters", &self.filters);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePatchGroupStateInputBody<'a> {
    /// <p>The name of the patch group whose patch snapshot should be retrieved.</p>
    pub patch_group: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribePatchGroupStateInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePatchGroupStateInputBody");
        formatter.field("patch_group", &self.patch_group);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePatchPropertiesInputBody<'a> {
    /// <p>The operating system type for which to list patches.</p>
    pub operating_system: &'a std::option::Option<crate::model::OperatingSystem>,
    /// <p>The patch property for which you want to view patch details. </p>
    pub property: &'a std::option::Option<crate::model::PatchProperty>,
    /// <p>Indicates whether to list patches for the Windows operating system or for Microsoft
    /// applications. Not applicable for the Linux or macOS operating systems.</p>
    pub patch_set: &'a std::option::Option<crate::model::PatchSet>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribePatchPropertiesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePatchPropertiesInputBody");
        formatter.field("operating_system", &self.operating_system);
        formatter.field("property", &self.property);
        formatter.field("patch_set", &self.patch_set);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSessionsInputBody<'a> {
    /// <p>The session status to retrieve a list of sessions for. For example, "Active".</p>
    pub state: &'a std::option::Option<crate::model::SessionState>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>One or more filters to limit the type of sessions returned by the request.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::SessionFilter>>,
}
impl<'a> std::fmt::Debug for DescribeSessionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSessionsInputBody");
        formatter.field("state", &self.state);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("filters", &self.filters);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateOpsItemRelatedItemInputBody<'a> {
    /// <p>The ID of the OpsItem for which you want to delete an association between the OpsItem and a
    /// related resource.</p>
    pub ops_item_id: &'a std::option::Option<std::string::String>,
    /// <p>The ID of the association for which you want to delete an association between the OpsItem
    /// and a related resource.</p>
    pub association_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DisassociateOpsItemRelatedItemInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateOpsItemRelatedItemInputBody");
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.field("association_id", &self.association_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAutomationExecutionInputBody<'a> {
    /// <p>The unique identifier for an existing automation execution to examine. The execution ID is
    /// returned by StartAutomationExecution when the execution of an Automation document is
    /// initiated.</p>
    pub automation_execution_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetAutomationExecutionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAutomationExecutionInputBody");
        formatter.field("automation_execution_id", &self.automation_execution_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCalendarStateInputBody<'a> {
    /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager documents that represent the calendar
    /// entries for which you want to get the state.</p>
    pub calendar_names: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>(Optional) The specific time for which you want to get calendar state information, in <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format. If you do not add
    /// <code>AtTime</code>, the current time is assumed.</p>
    pub at_time: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetCalendarStateInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCalendarStateInputBody");
        formatter.field("calendar_names", &self.calendar_names);
        formatter.field("at_time", &self.at_time);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCommandInvocationInputBody<'a> {
    /// <p>(Required) The parent command ID of the invocation plugin.</p>
    pub command_id: &'a std::option::Option<std::string::String>,
    /// <p>(Required) The ID of the managed instance targeted by the command. A managed instance can be
    /// an Amazon Elastic Compute Cloud (Amazon EC2) instance or an instance in your hybrid environment that is configured for
    /// AWS Systems Manager.</p>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>The name of the plugin for which you want detailed results. If the document contains only
    /// one plugin, you can omit the name and details for that plugin. If the document contains more than
    /// one plugin, you must specify the name of the plugin for which you want to view details.</p>
    /// <p>Plugin names are also referred to as <i>step names</i> in Systems Manager documents. For
    /// example, <code>aws:RunShellScript</code> is a plugin.</p>
    /// <p>To find the <code>PluginName</code>, check the document content and find the name of the
    /// plugin. Alternatively, use <a>ListCommandInvocations</a> with the
    /// <code>CommandId</code> and <code>Details</code> parameters. The <code>PluginName</code> is the
    /// <code>Name</code> attribute of the <code>CommandPlugin</code> object in the
    /// <code>CommandPlugins</code> list.</p>
    pub plugin_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetCommandInvocationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCommandInvocationInputBody");
        formatter.field("command_id", &self.command_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("plugin_name", &self.plugin_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetConnectionStatusInputBody<'a> {
    /// <p>The ID of the instance.</p>
    pub target: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetConnectionStatusInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetConnectionStatusInputBody");
        formatter.field("target", &self.target);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDefaultPatchBaselineInputBody<'a> {
    /// <p>Returns the default patch baseline for the specified operating system.</p>
    pub operating_system: &'a std::option::Option<crate::model::OperatingSystem>,
}
impl<'a> std::fmt::Debug for GetDefaultPatchBaselineInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDefaultPatchBaselineInputBody");
        formatter.field("operating_system", &self.operating_system);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDeployablePatchSnapshotForInstanceInputBody<'a> {
    /// <p>The ID of the instance for which the appropriate patch snapshot should be retrieved.</p>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>The user-defined snapshot ID.</p>
    pub snapshot_id: &'a std::option::Option<std::string::String>,
    /// <p>Defines the basic information about a patch baseline override.</p>
    pub baseline_override: &'a std::option::Option<crate::model::BaselineOverride>,
}
impl<'a> std::fmt::Debug for GetDeployablePatchSnapshotForInstanceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDeployablePatchSnapshotForInstanceInputBody");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("baseline_override", &self.baseline_override);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDocumentInputBody<'a> {
    /// <p>The name of the Systems Manager document.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>An optional field specifying the version of the artifact associated with the document. For
    /// example, "Release 12, Update 6". This value is unique across all versions of a document and can't
    /// be changed.</p>
    pub version_name: &'a std::option::Option<std::string::String>,
    /// <p>The document version for which you want information.</p>
    pub document_version: &'a std::option::Option<std::string::String>,
    /// <p>Returns the document in the specified format. The document format can be either JSON or
    /// YAML. JSON is the default format.</p>
    pub document_format: &'a std::option::Option<crate::model::DocumentFormat>,
}
impl<'a> std::fmt::Debug for GetDocumentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDocumentInputBody");
        formatter.field("name", &self.name);
        formatter.field("version_name", &self.version_name);
        formatter.field("document_version", &self.document_version);
        formatter.field("document_format", &self.document_format);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInventoryInputBody<'a> {
    /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::InventoryFilter>>,
    /// <p>Returns counts of inventory types based on one or more expressions. For example, if you
    /// aggregate by using an expression that uses the <code>AWS:InstanceInformation.PlatformType</code>
    /// type, you can see a count of how many Windows and Linux instances exist in your inventoried
    /// fleet.</p>
    pub aggregators: &'a std::option::Option<std::vec::Vec<crate::model::InventoryAggregator>>,
    /// <p>The list of inventory item types to return.</p>
    pub result_attributes: &'a std::option::Option<std::vec::Vec<crate::model::ResultAttribute>>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for GetInventoryInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInventoryInputBody");
        formatter.field("filters", &self.filters);
        formatter.field("aggregators", &self.aggregators);
        formatter.field("result_attributes", &self.result_attributes);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInventorySchemaInputBody<'a> {
    /// <p>The type of inventory item to return.</p>
    pub type_name: &'a std::option::Option<std::string::String>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>Returns inventory schemas that support aggregation. For example, this call returns the
    /// <code>AWS:InstanceInformation</code> type, because it supports aggregation based on the
    /// <code>PlatformName</code>, <code>PlatformType</code>, and <code>PlatformVersion</code>
    /// attributes.</p>
    pub aggregator: &'a bool,
    /// <p>Returns the sub-type schema for a specified inventory type.</p>
    pub sub_type: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for GetInventorySchemaInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInventorySchemaInputBody");
        formatter.field("type_name", &self.type_name);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("aggregator", &self.aggregator);
        formatter.field("sub_type", &self.sub_type);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMaintenanceWindowInputBody<'a> {
    /// <p>The ID of the maintenance window for which you want to retrieve information.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetMaintenanceWindowInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMaintenanceWindowInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMaintenanceWindowExecutionInputBody<'a> {
    /// <p>The ID of the maintenance window execution that includes the task.</p>
    pub window_execution_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetMaintenanceWindowExecutionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMaintenanceWindowExecutionInputBody");
        formatter.field("window_execution_id", &self.window_execution_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMaintenanceWindowExecutionTaskInputBody<'a> {
    /// <p>The ID of the maintenance window execution that includes the task.</p>
    pub window_execution_id: &'a std::option::Option<std::string::String>,
    /// <p>The ID of the specific task execution in the maintenance window task that should be
    /// retrieved.</p>
    pub task_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetMaintenanceWindowExecutionTaskInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMaintenanceWindowExecutionTaskInputBody");
        formatter.field("window_execution_id", &self.window_execution_id);
        formatter.field("task_id", &self.task_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMaintenanceWindowExecutionTaskInvocationInputBody<'a> {
    /// <p>The ID of the maintenance window execution for which the task is a part.</p>
    pub window_execution_id: &'a std::option::Option<std::string::String>,
    /// <p>The ID of the specific task in the maintenance window task that should be retrieved. </p>
    pub task_id: &'a std::option::Option<std::string::String>,
    /// <p>The invocation ID to retrieve.</p>
    pub invocation_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetMaintenanceWindowExecutionTaskInvocationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMaintenanceWindowExecutionTaskInvocationInputBody");
        formatter.field("window_execution_id", &self.window_execution_id);
        formatter.field("task_id", &self.task_id);
        formatter.field("invocation_id", &self.invocation_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMaintenanceWindowTaskInputBody<'a> {
    /// <p>The maintenance window ID that includes the task to retrieve.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
    /// <p>The maintenance window task ID to retrieve.</p>
    pub window_task_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetMaintenanceWindowTaskInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMaintenanceWindowTaskInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_task_id", &self.window_task_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetOpsItemInputBody<'a> {
    /// <p>The ID of the OpsItem that you want to get.</p>
    pub ops_item_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetOpsItemInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetOpsItemInputBody");
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetOpsMetadataInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of an OpsMetadata Object to view.</p>
    pub ops_metadata_arn: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A token to start the list. Use this token to get the next set of results.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetOpsMetadataInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetOpsMetadataInputBody");
        formatter.field("ops_metadata_arn", &self.ops_metadata_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetOpsSummaryInputBody<'a> {
    /// <p>Specify the name of a resource data sync to get.</p>
    pub sync_name: &'a std::option::Option<std::string::String>,
    /// <p>Optional filters used to scope down the returned OpsItems. </p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::OpsFilter>>,
    /// <p>Optional aggregators that return counts of OpsItems based on one or more expressions.</p>
    pub aggregators: &'a std::option::Option<std::vec::Vec<crate::model::OpsAggregator>>,
    /// <p>The OpsItem data type to return.</p>
    pub result_attributes: &'a std::option::Option<std::vec::Vec<crate::model::OpsResultAttribute>>,
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for GetOpsSummaryInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetOpsSummaryInputBody");
        formatter.field("sync_name", &self.sync_name);
        formatter.field("filters", &self.filters);
        formatter.field("aggregators", &self.aggregators);
        formatter.field("result_attributes", &self.result_attributes);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetParameterInputBody<'a> {
    /// <p>The name of the parameter you want to query.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>Return decrypted values for secure string parameters. This flag is ignored for String and
    /// StringList parameter types.</p>
    pub with_decryption: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for GetParameterInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetParameterInputBody");
        formatter.field("name", &self.name);
        formatter.field("with_decryption", &self.with_decryption);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetParameterHistoryInputBody<'a> {
    /// <p>The name of the parameter for which you want to review history.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>Return decrypted values for secure string parameters. This flag is ignored for String and
    /// StringList parameter types.</p>
    pub with_decryption: &'a std::option::Option<bool>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetParameterHistoryInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetParameterHistoryInputBody");
        formatter.field("name", &self.name);
        formatter.field("with_decryption", &self.with_decryption);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetParametersInputBody<'a> {
    /// <p>Names of the parameters for which you want to query information.</p>
    pub names: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Return decrypted secure string value. Return decrypted values for secure string parameters.
    /// This flag is ignored for String and StringList parameter types.</p>
    pub with_decryption: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for GetParametersInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetParametersInputBody");
        formatter.field("names", &self.names);
        formatter.field("with_decryption", &self.with_decryption);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetParametersByPathInputBody<'a> {
    /// <p>The hierarchy for the parameter. Hierarchies start with a forward slash (/). The hierachy is
    /// the parameter name except the last part of the parameter. For the API call to succeeed, the last
    /// part of the parameter name cannot be in the path. A parameter name hierarchy can have a maximum
    /// of 15 levels. Here is an example of a hierarchy: <code>/Finance/Prod/IAD/WinServ2016/license33
    /// </code>
    /// </p>
    pub path: &'a std::option::Option<std::string::String>,
    /// <p>Retrieve all parameters within a hierarchy.</p>
    /// <important>
    /// <p>If a user has access to a path, then the user can access all levels of that path. For
    /// example, if a user has permission to access path <code>/a</code>, then the user can also access
    /// <code>/a/b</code>. Even if a user has explicitly been denied access in IAM for parameter
    /// <code>/a/b</code>, they can still call the GetParametersByPath API action recursively for
    /// <code>/a</code> and view <code>/a/b</code>.</p>
    /// </important>
    pub recursive: &'a std::option::Option<bool>,
    /// <p>Filters to limit the request results.</p>
    /// <note>
    /// <p>For <code>GetParametersByPath</code>, the following filter <code>Key</code> names are
    /// supported: <code>Type</code>, <code>KeyId</code>, <code>Label</code>, and
    /// <code>DataType</code>.</p>
    /// <p>The following <code>Key</code> values are not supported for
    /// <code>GetParametersByPath</code>: <code>tag</code>, <code>Name</code>, <code>Path</code>, and
    /// <code>Tier</code>.</p>
    /// </note>
    pub parameter_filters:
        &'a std::option::Option<std::vec::Vec<crate::model::ParameterStringFilter>>,
    /// <p>Retrieve all parameters in a hierarchy with their value decrypted.</p>
    pub with_decryption: &'a std::option::Option<bool>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetParametersByPathInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetParametersByPathInputBody");
        formatter.field("path", &self.path);
        formatter.field("recursive", &self.recursive);
        formatter.field("parameter_filters", &self.parameter_filters);
        formatter.field("with_decryption", &self.with_decryption);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPatchBaselineInputBody<'a> {
    /// <p>The ID of the patch baseline to retrieve.</p>
    pub baseline_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetPatchBaselineInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPatchBaselineInputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPatchBaselineForPatchGroupInputBody<'a> {
    /// <p>The name of the patch group whose patch baseline should be retrieved.</p>
    pub patch_group: &'a std::option::Option<std::string::String>,
    /// <p>Returns he operating system rule specified for patch groups using the patch baseline.</p>
    pub operating_system: &'a std::option::Option<crate::model::OperatingSystem>,
}
impl<'a> std::fmt::Debug for GetPatchBaselineForPatchGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPatchBaselineForPatchGroupInputBody");
        formatter.field("patch_group", &self.patch_group);
        formatter.field("operating_system", &self.operating_system);
        formatter.finish()
    }
}

/// <p>The request body of the GetServiceSetting API action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetServiceSettingInputBody<'a> {
    /// <p>The ID of the service setting to get. The setting ID can be one of the following.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>/ssm/automation/customer-script-log-destination</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/automation/customer-script-log-group-name</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/documents/console/public-sharing-permission</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/parameter-store/default-parameter-tier</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/parameter-store/high-throughput-enabled</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/managed-instance/activation-tier</code>
    /// </p>
    /// </li>
    /// </ul>
    pub setting_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetServiceSettingInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetServiceSettingInputBody");
        formatter.field("setting_id", &self.setting_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelParameterVersionInputBody<'a> {
    /// <p>The parameter name on which you want to attach one or more labels.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The specific version of the parameter on which you want to attach one or more labels. If no
    /// version is specified, the system attaches the label to the latest version.</p>
    pub parameter_version: &'a std::option::Option<i64>,
    /// <p>One or more labels to attach to the specified parameter version.</p>
    pub labels: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for LabelParameterVersionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelParameterVersionInputBody");
        formatter.field("name", &self.name);
        formatter.field("parameter_version", &self.parameter_version);
        formatter.field("labels", &self.labels);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAssociationsInputBody<'a> {
    /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
    /// <note>
    /// <p>Filtering associations using the <code>InstanceID</code> attribute only returns legacy
    /// associations created using the <code>InstanceID</code> attribute. Associations targeting the
    /// instance that are part of the Target Attributes <code>ResourceGroup</code> or <code>Tags</code>
    /// are not returned.</p>
    /// </note>
    pub association_filter_list:
        &'a std::option::Option<std::vec::Vec<crate::model::AssociationFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListAssociationsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAssociationsInputBody");
        formatter.field("association_filter_list", &self.association_filter_list);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAssociationVersionsInputBody<'a> {
    /// <p>The association ID for which you want to view all versions.</p>
    pub association_id: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListAssociationVersionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAssociationVersionsInputBody");
        formatter.field("association_id", &self.association_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCommandInvocationsInputBody<'a> {
    /// <p>(Optional) The invocations for a specific command ID.</p>
    pub command_id: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) The command execution details for a specific instance ID.</p>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) The maximum number of items to return for this call. The call also returns a
    /// token that you can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>(Optional) The token for the next set of items to return. (You received this token from a
    /// previous call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) One or more filters. Use a filter to return a more specific list of
    /// results.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::CommandFilter>>,
    /// <p>(Optional) If set this returns the response of the command executions and any command
    /// output. The default value is 'false'. </p>
    pub details: &'a bool,
}
impl<'a> std::fmt::Debug for ListCommandInvocationsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCommandInvocationsInputBody");
        formatter.field("command_id", &self.command_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("filters", &self.filters);
        formatter.field("details", &self.details);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCommandsInputBody<'a> {
    /// <p>(Optional) If provided, lists only the specified command.</p>
    pub command_id: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Lists commands issued against this instance ID.</p>
    /// <note>
    /// <p>You can't specify an instance ID in the same command that you specify <code>Status</code> =
    /// <code>Pending</code>. This is because the command has not reached the instance yet.</p>
    /// </note>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) The maximum number of items to return for this call. The call also returns a
    /// token that you can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>(Optional) The token for the next set of items to return. (You received this token from a
    /// previous call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) One or more filters. Use a filter to return a more specific list of results.
    /// </p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::CommandFilter>>,
}
impl<'a> std::fmt::Debug for ListCommandsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCommandsInputBody");
        formatter.field("command_id", &self.command_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("filters", &self.filters);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListComplianceItemsInputBody<'a> {
    /// <p>One or more compliance filters. Use a filter to return a more specific list of
    /// results.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::ComplianceStringFilter>>,
    /// <p>The ID for the resources from which to get compliance information. Currently, you can only
    /// specify one resource ID.</p>
    pub resource_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The type of resource from which to get compliance information. Currently, the only supported
    /// resource type is <code>ManagedInstance</code>.</p>
    pub resource_types: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListComplianceItemsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListComplianceItemsInputBody");
        formatter.field("filters", &self.filters);
        formatter.field("resource_ids", &self.resource_ids);
        formatter.field("resource_types", &self.resource_types);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListComplianceSummariesInputBody<'a> {
    /// <p>One or more compliance or inventory filters. Use a filter to return a more specific list of
    /// results.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::ComplianceStringFilter>>,
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. Currently, you can specify null or 50.
    /// The call also returns a token that you can specify in a subsequent call to get the next set of
    /// results.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListComplianceSummariesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListComplianceSummariesInputBody");
        formatter.field("filters", &self.filters);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDocumentMetadataHistoryInputBody<'a> {
    /// <p>The name of the document.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The version of the document.</p>
    pub document_version: &'a std::option::Option<std::string::String>,
    /// <p>The type of data for which details are being requested. Currently, the only supported value
    /// is <code>DocumentReviews</code>.</p>
    pub metadata: &'a std::option::Option<crate::model::DocumentMetadataEnum>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListDocumentMetadataHistoryInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDocumentMetadataHistoryInputBody");
        formatter.field("name", &self.name);
        formatter.field("document_version", &self.document_version);
        formatter.field("metadata", &self.metadata);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDocumentsInputBody<'a> {
    /// <p>This data type is deprecated. Instead, use <code>Filters</code>.</p>
    pub document_filter_list: &'a std::option::Option<std::vec::Vec<crate::model::DocumentFilter>>,
    /// <p>One or more <code>DocumentKeyValuesFilter</code> objects. Use a filter to return a more
    /// specific list of results. For keys, you can specify one or more key-value pair tags that have
    /// been applied to a document. Other valid keys include <code>Owner</code>, <code>Name</code>,
    /// <code>PlatformTypes</code>, <code>DocumentType</code>, and <code>TargetType</code>. For example,
    /// to return documents you own use <code>Key=Owner,Values=Self</code>. To specify a custom key-value
    /// pair, use the format <code>Key=tag:tagName,Values=valueName</code>.</p>
    /// <note>
    /// <p>This API action only supports filtering documents by using a single tag key and one or more
    /// tag values. For example: <code>Key=tag:tagName,Values=valueName1,valueName2</code>
    /// </p>
    /// </note>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::DocumentKeyValuesFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListDocumentsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDocumentsInputBody");
        formatter.field("document_filter_list", &self.document_filter_list);
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDocumentVersionsInputBody<'a> {
    /// <p>The name of the document. You can specify an Amazon Resource Name (ARN).</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListDocumentVersionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDocumentVersionsInputBody");
        formatter.field("name", &self.name);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListInventoryEntriesInputBody<'a> {
    /// <p>The instance ID for which you want inventory information.</p>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>The type of inventory item for which you want information.</p>
    pub type_name: &'a std::option::Option<std::string::String>,
    /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::InventoryFilter>>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListInventoryEntriesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListInventoryEntriesInputBody");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("type_name", &self.type_name);
        formatter.field("filters", &self.filters);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOpsItemEventsInputBody<'a> {
    /// <p>One or more OpsItem filters. Use a filter to return a more specific list of results. </p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::OpsItemEventFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results. </p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListOpsItemEventsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOpsItemEventsInputBody");
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOpsItemRelatedItemsInputBody<'a> {
    /// <p>The ID of the OpsItem for which you want to list all related-item resources.</p>
    pub ops_item_id: &'a std::option::Option<std::string::String>,
    /// <p>One or more OpsItem filters. Use a filter to return a more specific list of results. </p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::OpsItemRelatedItemsFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListOpsItemRelatedItemsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOpsItemRelatedItemsInputBody");
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOpsMetadataInputBody<'a> {
    /// <p>One or more filters to limit the number of OpsMetadata objects returned by the call.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::OpsMetadataFilter>>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>A token to start the list. Use this token to get the next set of results.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListOpsMetadataInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOpsMetadataInputBody");
        formatter.field("filters", &self.filters);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListResourceComplianceSummariesInputBody<'a> {
    /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::ComplianceStringFilter>>,
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListResourceComplianceSummariesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListResourceComplianceSummariesInputBody");
        formatter.field("filters", &self.filters);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListResourceDataSyncInputBody<'a> {
    /// <p>View a list of resource data syncs according to the sync type. Specify
    /// <code>SyncToDestination</code> to view resource data syncs that synchronize data to an Amazon S3
    /// bucket. Specify <code>SyncFromSource</code> to view resource data syncs from AWS Organizations or from
    /// multiple AWS Regions.</p>
    pub sync_type: &'a std::option::Option<std::string::String>,
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListResourceDataSyncInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListResourceDataSyncInputBody");
        formatter.field("sync_type", &self.sync_type);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInputBody<'a> {
    /// <p>Returns a list of tags for a specific resource type.</p>
    pub resource_type: &'a std::option::Option<crate::model::ResourceTypeForTagging>,
    /// <p>The resource ID for which you want to see a list of tags.</p>
    pub resource_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListTagsForResourceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInputBody");
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_id", &self.resource_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModifyDocumentPermissionInputBody<'a> {
    /// <p>The name of the document that you want to share.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The permission type for the document. The permission type can be
    /// <i>Share</i>.</p>
    pub permission_type: &'a std::option::Option<crate::model::DocumentPermissionType>,
    /// <p>The AWS user accounts that should have access to the document. The account IDs can either be
    /// a group of account IDs or <i>All</i>.</p>
    pub account_ids_to_add: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The AWS user accounts that should no longer have access to the document. The AWS user
    /// account can either be a group of account IDs or <i>All</i>. This action has a
    /// higher priority than <i>AccountIdsToAdd</i>. If you specify an account ID to add
    /// and the same ID to remove, the system removes access to the document.</p>
    pub account_ids_to_remove: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>(Optional) The version of the document to share. If it's not specified, the system choose
    /// the <code>Default</code> version to share.</p>
    pub shared_document_version: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ModifyDocumentPermissionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModifyDocumentPermissionInputBody");
        formatter.field("name", &self.name);
        formatter.field("permission_type", &self.permission_type);
        formatter.field("account_ids_to_add", &self.account_ids_to_add);
        formatter.field("account_ids_to_remove", &self.account_ids_to_remove);
        formatter.field("shared_document_version", &self.shared_document_version);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutComplianceItemsInputBody<'a> {
    /// <p>Specify an ID for this resource. For a managed instance, this is the instance ID.</p>
    pub resource_id: &'a std::option::Option<std::string::String>,
    /// <p>Specify the type of resource. <code>ManagedInstance</code> is currently the only supported
    /// resource type.</p>
    pub resource_type: &'a std::option::Option<std::string::String>,
    /// <p>Specify the compliance type. For example, specify Association (for a State Manager
    /// association), Patch, or Custom:<code>string</code>.</p>
    pub compliance_type: &'a std::option::Option<std::string::String>,
    /// <p>A summary of the call execution that includes an execution ID, the type of execution (for
    /// example, <code>Command</code>), and the date/time of the execution using a datetime object that
    /// is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.</p>
    pub execution_summary: &'a std::option::Option<crate::model::ComplianceExecutionSummary>,
    /// <p>Information about the compliance as defined by the resource type. For example, for a patch
    /// compliance type, <code>Items</code> includes information about the PatchSeverity, Classification,
    /// and so on.</p>
    pub items: &'a std::option::Option<std::vec::Vec<crate::model::ComplianceItemEntry>>,
    /// <p>MD5 or SHA-256 content hash. The content hash is used to determine if existing information
    /// should be overwritten or ignored. If the content hashes match, the request to put compliance
    /// information is ignored.</p>
    pub item_content_hash: &'a std::option::Option<std::string::String>,
    /// <p>The mode for uploading compliance items. You can specify <code>COMPLETE</code> or
    /// <code>PARTIAL</code>. In <code>COMPLETE</code> mode, the system overwrites all existing
    /// compliance information for the resource. You must provide a full list of compliance items each
    /// time you send the request.</p>
    /// <p>In <code>PARTIAL</code> mode, the system overwrites compliance information for a specific
    /// association. The association must be configured with <code>SyncCompliance</code> set to
    /// <code>MANUAL</code>. By default, all requests use <code>COMPLETE</code> mode.</p>
    /// <note>
    /// <p>This attribute is only valid for association compliance.</p>
    /// </note>
    pub upload_type: &'a std::option::Option<crate::model::ComplianceUploadType>,
}
impl<'a> std::fmt::Debug for PutComplianceItemsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutComplianceItemsInputBody");
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("compliance_type", &self.compliance_type);
        formatter.field("execution_summary", &self.execution_summary);
        formatter.field("items", &self.items);
        formatter.field("item_content_hash", &self.item_content_hash);
        formatter.field("upload_type", &self.upload_type);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutInventoryInputBody<'a> {
    /// <p>An instance ID where you want to add or update inventory items.</p>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>The inventory items that you want to add or update on instances.</p>
    pub items: &'a std::option::Option<std::vec::Vec<crate::model::InventoryItem>>,
}
impl<'a> std::fmt::Debug for PutInventoryInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutInventoryInputBody");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("items", &self.items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutParameterInputBody<'a> {
    /// <p>The fully qualified name of the parameter that you want to add to the system. The fully
    /// qualified name includes the complete hierarchy of the parameter path and name. For parameters in
    /// a hierarchy, you must include a leading forward slash character (/) when you create or reference
    /// a parameter. For example: <code>/Dev/DBServer/MySQL/db-string13</code>
    /// </p>
    /// <p>Naming Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Parameter names are case sensitive.</p>
    /// </li>
    /// <li>
    /// <p>A parameter name must be unique within an AWS Region</p>
    /// </li>
    /// <li>
    /// <p>A parameter name can't be prefixed with "aws" or "ssm" (case-insensitive).</p>
    /// </li>
    /// <li>
    /// <p>Parameter names can include only the following symbols and letters:
    /// <code>a-zA-Z0-9_.-</code>
    /// </p>
    /// <p>In addition, the slash character ( / ) is used to delineate hierarchies in parameter
    /// names. For example: <code>/Dev/Production/East/Project-ABC/MyParameter</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>A parameter name can't include spaces.</p>
    /// </li>
    /// <li>
    /// <p>Parameter hierarchies are limited to a maximum depth of fifteen levels.</p>
    /// </li>
    /// </ul>
    /// <p>For additional information about valid values for parameter names, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-su-create.html">Creating Systems Manager parameters</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    /// <note>
    /// <p>The maximum length constraint listed below includes capacity for additional system
    /// attributes that are not part of the name. The maximum length for a parameter name, including the
    /// full length of the parameter ARN, is 1011 characters. For example, the length of the following
    /// parameter name is 65 characters, not 20 characters:</p>
    /// <p>
    /// <code>arn:aws:ssm:us-east-2:111122223333:parameter/ExampleParameterName</code>
    /// </p>
    /// </note>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>Information about the parameter that you want to add to the system. Optional but
    /// recommended.</p>
    /// <important>
    /// <p>Do not enter personally identifiable information in this field.</p>
    /// </important>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The parameter value that you want to add to the system. Standard parameters have a value
    /// limit of 4 KB. Advanced parameters have a value limit of 8 KB.</p>
    /// <note>
    /// <p>Parameters can't be referenced or nested in the values of other parameters. You can't
    /// include <code>{{}}</code> or <code>{{ssm:<i>parameter-name</i>}}</code> in a
    /// parameter value.</p>
    /// </note>
    pub value: &'a std::option::Option<std::string::String>,
    /// <p>The type of parameter that you want to add to the system.</p>
    /// <note>
    /// <p>
    /// <code>SecureString</code> is not currently supported for AWS CloudFormation
    /// templates.</p>
    /// </note>
    /// <p>Items in a <code>StringList</code> must be separated by a comma (,). You can't
    /// use other punctuation or special character to escape items in the list. If you have a parameter
    /// value that requires a comma, then use the <code>String</code> data type.</p>
    /// <important>
    /// <p>Specifying a parameter type is not required when updating a parameter. You must specify a
    /// parameter type when creating a parameter.</p>
    /// </important>
    pub r#type: &'a std::option::Option<crate::model::ParameterType>,
    /// <p>The KMS Key ID that you want to use to encrypt a parameter. Either the default AWS Key
    /// Management Service (AWS KMS) key automatically assigned to your AWS account or a custom key.
    /// Required for parameters that use the <code>SecureString</code> data type.</p>
    /// <p>If you don't specify a key ID, the system uses the default key associated with your AWS
    /// account.</p>
    /// <ul>
    /// <li>
    /// <p>To use your default AWS KMS key, choose the <code>SecureString</code> data
    /// type, and do <i>not</i> specify the <code>Key ID</code> when you
    /// create the parameter. The system automatically populates <code>Key ID</code> with
    /// your default KMS key.</p>
    /// </li>
    /// <li>
    /// <p>To use a custom KMS key, choose the <code>SecureString</code> data type with
    /// the <code>Key ID</code> parameter.</p>
    /// </li>
    /// </ul>
    pub key_id: &'a std::option::Option<std::string::String>,
    /// <p>Overwrite an existing parameter. The default value is 'false'.</p>
    pub overwrite: &'a std::option::Option<bool>,
    /// <p>A regular expression used to validate the parameter value. For example, for String types
    /// with values restricted to numbers, you can specify the following: AllowedPattern=^\d+$ </p>
    pub allowed_pattern: &'a std::option::Option<std::string::String>,
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
    /// different ways, such as by purpose, owner, or environment. For example, you might want to tag a
    /// Systems Manager parameter to identify the type of resource to which it applies, the environment, or the
    /// type of configuration data referenced by the parameter. In this case, you could specify the
    /// following key name/value pairs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Key=Resource,Value=S3bucket</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Key=OS,Value=Windows</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Key=ParameterType,Value=LicenseKey</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>To add tags to an existing Systems Manager parameter, use the <a>AddTagsToResource</a>
    /// action.</p>
    /// </note>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The parameter tier to assign to a parameter.</p>
    /// <p>Parameter Store offers a standard tier and an advanced tier for parameters. Standard
    /// parameters have a content size limit of 4 KB and can't be configured to use parameter policies.
    /// You can create a maximum of 10,000 standard parameters for each Region in an AWS account.
    /// Standard parameters are offered at no additional cost. </p>
    /// <p>Advanced parameters have a content size limit of 8 KB and can be configured to use parameter
    /// policies. You can create a maximum of 100,000 advanced parameters for each Region in an AWS
    /// account. Advanced parameters incur a charge. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-advanced-parameters.html">Standard and
    /// advanced parameter tiers</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    /// <p>You can change a standard parameter to an advanced parameter any time. But you can't revert
    /// an advanced parameter to a standard parameter. Reverting an advanced parameter to a standard
    /// parameter would result in data loss because the system would truncate the size of the parameter
    /// from 8 KB to 4 KB. Reverting would also remove any policies attached to the parameter. Lastly,
    /// advanced parameters use a different form of encryption than standard parameters. </p>
    /// <p>If you no longer need an advanced parameter, or if you no longer want to incur charges for
    /// an advanced parameter, you must delete it and recreate it as a new standard parameter. </p>
    /// <p>
    /// <b>Using the Default Tier Configuration</b>
    /// </p>
    /// <p>In <code>PutParameter</code> requests, you can specify the tier to create the parameter in.
    /// Whenever you specify a tier in the request, Parameter Store creates or updates the parameter
    /// according to that request. However, if you do not specify a tier in a request, Parameter Store
    /// assigns the tier based on the current Parameter Store default tier configuration.</p>
    /// <p>The default tier when you begin using Parameter Store is the standard-parameter tier. If you
    /// use the advanced-parameter tier, you can specify one of the following as the default:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Advanced</b>: With this option, Parameter Store evaluates all
    /// requests as advanced parameters. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Intelligent-Tiering</b>: With this option, Parameter Store
    /// evaluates each request to determine if the parameter is standard or advanced. </p>
    /// <p>If the request doesn't include any options that require an advanced parameter, the
    /// parameter is created in the standard-parameter tier. If one or more options requiring an
    /// advanced parameter are included in the request, Parameter Store create a parameter in the
    /// advanced-parameter tier.</p>
    /// <p>This approach helps control your parameter-related costs by always creating standard
    /// parameters unless an advanced parameter is necessary. </p>
    /// </li>
    /// </ul>
    /// <p>Options that require an advanced parameter include the following:</p>
    /// <ul>
    /// <li>
    /// <p>The content size of the parameter is more than 4 KB.</p>
    /// </li>
    /// <li>
    /// <p>The parameter uses a parameter policy.</p>
    /// </li>
    /// <li>
    /// <p>More than 10,000 parameters already exist in your AWS account in the current
    /// Region.</p>
    /// </li>
    /// </ul>
    /// <p>For more information about configuring the default tier option, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/ps-default-tier.html">Specifying a
    /// default parameter tier</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    pub tier: &'a std::option::Option<crate::model::ParameterTier>,
    /// <p>One or more policies to apply to a parameter. This action takes a JSON array. Parameter
    /// Store supports the following policy types:</p>
    /// <p>Expiration: This policy deletes the parameter after it expires. When you create the policy,
    /// you specify the expiration date. You can update the expiration date and time by updating the
    /// policy. Updating the <i>parameter</i> does not affect the expiration date and time.
    /// When the expiration time is reached, Parameter Store deletes the parameter.</p>
    /// <p>ExpirationNotification: This policy triggers an event in Amazon CloudWatch Events that
    /// notifies you about the expiration. By using this policy, you can receive notification before or
    /// after the expiration time is reached, in units of days or hours.</p>
    /// <p>NoChangeNotification: This policy triggers a CloudWatch event if a parameter has not been
    /// modified for a specified period of time. This policy type is useful when, for example, a secret
    /// needs to be changed within a period of time, but it has not been changed.</p>
    /// <p>All existing policies are preserved until you send new policies or an empty policy. For more
    /// information about parameter policies, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html">Assigning parameter
    /// policies</a>. </p>
    pub policies: &'a std::option::Option<std::string::String>,
    /// <p>The data type for a <code>String</code> parameter. Supported data types include plain text
    /// and Amazon Machine Image IDs.</p>
    /// <p>
    /// <b>The following data type values are supported.</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>text</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>aws:ec2:image</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>When you create a <code>String</code> parameter and specify <code>aws:ec2:image</code>,
    /// Systems Manager validates the parameter value is in the required format, such as
    /// <code>ami-12345abcdeEXAMPLE</code>, and that the specified AMI is available in your AWS account.
    /// For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-ec2-aliases.html">Native
    /// parameter support for Amazon Machine Image IDs</a> in the
    /// <i>AWS Systems Manager User Guide</i>.</p>
    pub data_type: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PutParameterInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutParameterInputBody");
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("value", &self.value);
        formatter.field("r#type", &self.r#type);
        formatter.field("key_id", &self.key_id);
        formatter.field("overwrite", &self.overwrite);
        formatter.field("allowed_pattern", &self.allowed_pattern);
        formatter.field("tags", &self.tags);
        formatter.field("tier", &self.tier);
        formatter.field("policies", &self.policies);
        formatter.field("data_type", &self.data_type);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterDefaultPatchBaselineInputBody<'a> {
    /// <p>The ID of the patch baseline that should be the default patch baseline.</p>
    pub baseline_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for RegisterDefaultPatchBaselineInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterDefaultPatchBaselineInputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterPatchBaselineForPatchGroupInputBody<'a> {
    /// <p>The ID of the patch baseline to register the patch group with.</p>
    pub baseline_id: &'a std::option::Option<std::string::String>,
    /// <p>The name of the patch group that should be registered with the patch baseline.</p>
    pub patch_group: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for RegisterPatchBaselineForPatchGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterPatchBaselineForPatchGroupInputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("patch_group", &self.patch_group);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterTargetWithMaintenanceWindowInputBody<'a> {
    /// <p>The ID of the maintenance window the target should be registered with.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
    /// <p>The type of target being registered with the maintenance window.</p>
    pub resource_type: &'a std::option::Option<crate::model::MaintenanceWindowResourceType>,
    /// <p>The targets to register with the maintenance window. In other words, the instances to run
    /// commands on when the maintenance window runs.</p>
    /// <note>
    /// <p>If a single maintenance window task is registered with multiple targets, its task
    /// invocations occur sequentially and not in parallel. If your task must run on multiple targets at
    /// the same time, register a task for each target individually and assign each task the same
    /// priority level.</p>
    /// </note>
    /// <p>You can specify targets using instance IDs, resource group names, or tags that have been
    /// applied to instances.</p>
    /// <p>
    /// <b>Example 1</b>: Specify instance IDs</p>
    /// <p>
    /// <code>Key=InstanceIds,Values=<i>instance-id-1</i>,<i>instance-id-2</i>,<i>instance-id-3</i>
    /// </code>
    /// </p>
    /// <p>
    /// <b>Example 2</b>: Use tag key-pairs applied to instances</p>
    /// <p>
    /// <code>Key=tag:<i>my-tag-key</i>,Values=<i>my-tag-value-1</i>,<i>my-tag-value-2</i>
    /// </code>
    /// </p>
    /// <p>
    /// <b>Example 3</b>: Use tag-keys applied to instances</p>
    /// <p>
    /// <code>Key=tag-key,Values=<i>my-tag-key-1</i>,<i>my-tag-key-2</i>
    /// </code>
    /// </p>
    /// <p>
    /// <b>Example 4</b>: Use resource group names</p>
    /// <p>
    /// <code>Key=resource-groups:Name,Values=<i>resource-group-name</i>
    /// </code>
    /// </p>
    /// <p>
    /// <b>Example 5</b>: Use filters for resource group types</p>
    /// <p>
    /// <code>Key=resource-groups:ResourceTypeFilters,Values=<i>resource-type-1</i>,<i>resource-type-2</i>
    /// </code>
    /// </p>
    /// <note>
    /// <p>For <code>Key=resource-groups:ResourceTypeFilters</code>, specify resource types in the
    /// following format</p>
    /// <p>
    /// <code>Key=resource-groups:ResourceTypeFilters,Values=<i>AWS::EC2::INSTANCE</i>,<i>AWS::EC2::VPC</i>
    /// </code>
    /// </p>
    /// </note>
    /// <p>For more information about these examples formats, including the best use case for each one,
    /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-tutorial-targets-examples.html">Examples: Register
    /// targets with a maintenance window</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    pub targets: &'a std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>User-provided value that will be included in any CloudWatch events raised while running
    /// tasks for these targets in this maintenance window.</p>
    pub owner_information: &'a std::option::Option<std::string::String>,
    /// <p>An optional name for the target.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>An optional description for the target.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>User-provided idempotency token.</p>
    pub client_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for RegisterTargetWithMaintenanceWindowInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterTargetWithMaintenanceWindowInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("targets", &self.targets);
        formatter.field("owner_information", &"*** Sensitive Data Redacted ***");
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("client_token", &self.client_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterTaskWithMaintenanceWindowInputBody<'a> {
    /// <p>The ID of the maintenance window the task should be added to.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
    /// <p>The targets (either instances or maintenance window targets).</p>
    /// <note>
    /// <p>One or more targets must be specified for maintenance window Run Command-type tasks.
    /// Depending on the task, targets are optional for other maintenance window task types (Automation,
    /// AWS Lambda, and AWS Step Functions). For more information about running tasks that do not
    /// specify targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html">Registering
    /// maintenance window tasks without targets</a> in the
    /// <i>AWS Systems Manager User Guide</i>.</p>
    /// </note>
    /// <p>Specify instances using the following format: </p>
    /// <p>
    /// <code>Key=InstanceIds,Values=<instance-id-1>,<instance-id-2></code>
    /// </p>
    /// <p>Specify maintenance window targets using the following format:</p>
    /// <p>
    /// <code>Key=WindowTargetIds,Values=<window-target-id-1>,<window-target-id-2></code>
    /// </p>
    pub targets: &'a std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The ARN of the task to run.</p>
    pub task_arn: &'a std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM service role for Systems Manager to assume when running a
    /// maintenance window task. If you do not specify a service role ARN, Systems Manager uses your account's
    /// service-linked role.  If no service-linked role for Systems Manager exists in your account, it is created when you run
    /// <code>RegisterTaskWithMaintenanceWindow</code>.</p>
    /// <p>For more information, see the following topics in the in the <i>AWS Systems Manager User Guide</i>:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/using-service-linked-roles.html#slr-permissions">Using
    /// service-linked roles for Systems Manager</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html#maintenance-window-tasks-service-role">Should I use a service-linked role or a custom service role to run maintenance window tasks?
    /// </a>
    /// </p>
    /// </li>
    /// </ul>
    pub service_role_arn: &'a std::option::Option<std::string::String>,
    /// <p>The type of task being registered.</p>
    pub task_type: &'a std::option::Option<crate::model::MaintenanceWindowTaskType>,
    /// <p>The parameters that should be passed to the task when it is run.</p>
    /// <note>
    /// <p>
    /// <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    /// instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    /// about how Systems Manager handles these options for the supported maintenance window task
    /// types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    /// </note>
    pub task_parameters: &'a std::option::Option<
        std::collections::HashMap<
            std::string::String,
            crate::model::MaintenanceWindowTaskParameterValueExpression,
        >,
    >,
    /// <p>The parameters that the task should use during execution. Populate only the fields that
    /// match the task type. All other fields should be empty. </p>
    pub task_invocation_parameters:
        &'a std::option::Option<crate::model::MaintenanceWindowTaskInvocationParameters>,
    /// <p>The priority of the task in the maintenance window, the lower the number the higher the
    /// priority. Tasks in a maintenance window are scheduled in priority order with tasks that have the
    /// same priority scheduled in parallel.</p>
    pub priority: &'a std::option::Option<i32>,
    /// <p>The maximum number of targets this task can be run for in parallel.</p>
    /// <note>
    /// <p>For maintenance window tasks without a target specified, you cannot supply a value for this
    /// option. Instead, the system inserts a placeholder value of <code>1</code>. This value does not
    /// affect the running of your task.</p>
    /// </note>
    pub max_concurrency: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of errors allowed before this task stops being scheduled.</p>
    /// <note>
    /// <p>For maintenance window tasks without a target specified, you cannot supply a value for this
    /// option. Instead, the system inserts a placeholder value of <code>1</code>. This value does not
    /// affect the running of your task.</p>
    /// </note>
    pub max_errors: &'a std::option::Option<std::string::String>,
    /// <p>A structure containing information about an S3 bucket to write instance-level logs to. </p>
    /// <note>
    /// <p>
    /// <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
    /// <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
    /// For information about how Systems Manager handles these options for the supported maintenance
    /// window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    /// </note>
    pub logging_info: &'a std::option::Option<crate::model::LoggingInfo>,
    /// <p>An optional name for the task.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>An optional description for the task.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>User-provided idempotency token.</p>
    pub client_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for RegisterTaskWithMaintenanceWindowInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterTaskWithMaintenanceWindowInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("targets", &self.targets);
        formatter.field("task_arn", &self.task_arn);
        formatter.field("service_role_arn", &self.service_role_arn);
        formatter.field("task_type", &self.task_type);
        formatter.field("task_parameters", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "task_invocation_parameters",
            &self.task_invocation_parameters,
        );
        formatter.field("priority", &self.priority);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("logging_info", &self.logging_info);
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("client_token", &self.client_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveTagsFromResourceInputBody<'a> {
    /// <p>The type of resource from which you want to remove a tag.</p>
    /// <note>
    /// <p>The ManagedInstance type for this API action is only for on-premises managed instances.
    /// Specify the name of the managed instance in the following format: mi-ID_number. For example,
    /// mi-1a2b3c4d5e6f.</p>
    /// </note>
    pub resource_type: &'a std::option::Option<crate::model::ResourceTypeForTagging>,
    /// <p>The ID of the resource from which you want to remove tags. For example:</p>
    /// <p>ManagedInstance: mi-012345abcde</p>
    /// <p>MaintenanceWindow: mw-012345abcde</p>
    /// <p>PatchBaseline: pb-012345abcde</p>
    /// <p>OpsMetadata object: <code>ResourceID</code> for tagging is created from the Amazon Resource
    /// Name (ARN) for the object. Specifically, <code>ResourceID</code> is created from the strings that
    /// come after the word <code>opsmetadata</code> in the ARN. For example, an OpsMetadata object with
    /// an ARN of <code>arn:aws:ssm:us-east-2:1234567890:opsmetadata/aws/ssm/MyGroup/appmanager</code>
    /// has a <code>ResourceID</code> of either <code>aws/ssm/MyGroup/appmanager</code> or
    /// <code>/aws/ssm/MyGroup/appmanager</code>.</p>
    /// <p>For the Document and Parameter values, use the name of the resource.</p>
    /// <note>
    /// <p>The ManagedInstance type for this API action is only for on-premises managed instances.
    /// Specify the name of the managed instance in the following format: mi-ID_number. For example,
    /// mi-1a2b3c4d5e6f.</p>
    /// </note>
    pub resource_id: &'a std::option::Option<std::string::String>,
    /// <p>Tag keys that you want to remove from the specified resource.</p>
    pub tag_keys: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for RemoveTagsFromResourceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RemoveTagsFromResourceInputBody");
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

/// <p>The request body of the ResetServiceSetting API action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResetServiceSettingInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the service setting to reset. The setting ID can be one of the following.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>/ssm/automation/customer-script-log-destination</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/automation/customer-script-log-group-name</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/documents/console/public-sharing-permission</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/parameter-store/default-parameter-tier</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/parameter-store/high-throughput-enabled</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/managed-instance/activation-tier</code>
    /// </p>
    /// </li>
    /// </ul>
    pub setting_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ResetServiceSettingInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResetServiceSettingInputBody");
        formatter.field("setting_id", &self.setting_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResumeSessionInputBody<'a> {
    /// <p>The ID of the disconnected session to resume.</p>
    pub session_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ResumeSessionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResumeSessionInputBody");
        formatter.field("session_id", &self.session_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendAutomationSignalInputBody<'a> {
    /// <p>The unique identifier for an existing Automation execution that you want to send the signal
    /// to.</p>
    pub automation_execution_id: &'a std::option::Option<std::string::String>,
    /// <p>The type of signal to send to an Automation execution. </p>
    pub signal_type: &'a std::option::Option<crate::model::SignalType>,
    /// <p>The data sent with the signal. The data schema depends on the type of signal used in the
    /// request.</p>
    /// <p>For <code>Approve</code> and <code>Reject</code> signal types, the payload is an optional
    /// comment that you can send with the signal type. For example:</p>
    /// <p>
    /// <code>Comment="Looks good"</code>
    /// </p>
    /// <p>For <code>StartStep</code> and <code>Resume</code> signal types, you must send the name of
    /// the Automation step to start or resume as the payload. For example:</p>
    /// <p>
    /// <code>StepName="step1"</code>
    /// </p>
    /// <p>For the <code>StopStep</code> signal type, you must send the step execution ID as the
    /// payload. For example:</p>
    /// <p>
    /// <code>StepExecutionId="97fff367-fc5a-4299-aed8-0123456789ab"</code>
    /// </p>
    pub payload: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
}
impl<'a> std::fmt::Debug for SendAutomationSignalInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendAutomationSignalInputBody");
        formatter.field("automation_execution_id", &self.automation_execution_id);
        formatter.field("signal_type", &self.signal_type);
        formatter.field("payload", &self.payload);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendCommandInputBody<'a> {
    /// <p>The IDs of the instances where the command should run. Specifying instance IDs is most
    /// useful when you are targeting a limited number of instances, though you can specify up to 50
    /// IDs.</p>
    /// <p>To target a larger number of instances, or if you prefer not to list individual instance
    /// IDs, we recommend using the <code>Targets</code> option instead. Using <code>Targets</code>,
    /// which accepts tag key-value pairs to identify the instances to send commands to, you can a send
    /// command to tens, hundreds, or thousands of instances at once.</p>
    /// <p>For more information about how to use targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html">Using targets and rate
    /// controls to send commands to a fleet</a> in the
    /// <i>AWS Systems Manager User Guide</i>.</p>
    pub instance_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of search criteria that targets instances using a <code>Key,Value</code>
    /// combination that you specify. Specifying targets is most useful when you want to send a command
    /// to a large number of instances at once. Using <code>Targets</code>, which accepts tag key-value
    /// pairs to identify instances, you can send a command to tens, hundreds, or thousands of instances
    /// at once.</p>
    /// <p>To send a command to a smaller number of instances, you can use the <code>InstanceIds</code>
    /// option instead.</p>
    /// <p>For more information about how to use targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html">Sending commands to a
    /// fleet</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    pub targets: &'a std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The name of the Systems Manager document to run. This can be a public document or a custom document.
    /// To run a shared document belonging to another account, specify the document ARN. For more
    /// information about how to use shared documents, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-using-shared.html">Using shared SSM documents</a>
    /// in the <i>AWS Systems Manager User Guide</i>.</p>
    pub document_name: &'a std::option::Option<std::string::String>,
    /// <p>The SSM document version to use in the request. You can specify $DEFAULT, $LATEST, or a
    /// specific version number. If you run commands by using the AWS CLI, then you must escape the first
    /// two options by using a backslash. If you specify a version number, then you don't need to use the
    /// backslash. For example:</p>
    /// <p>--document-version "\$DEFAULT"</p>
    /// <p>--document-version "\$LATEST"</p>
    /// <p>--document-version "3"</p>
    pub document_version: &'a std::option::Option<std::string::String>,
    /// <p>The Sha256 or Sha1 hash created by the system when the document was created. </p>
    /// <note>
    /// <p>Sha1 hashes have been deprecated.</p>
    /// </note>
    pub document_hash: &'a std::option::Option<std::string::String>,
    /// <p>Sha256 or Sha1.</p>
    /// <note>
    /// <p>Sha1 hashes have been deprecated.</p>
    /// </note>
    pub document_hash_type: &'a std::option::Option<crate::model::DocumentHashType>,
    /// <p>If this time is reached and the command has not already started running, it will not
    /// run.</p>
    pub timeout_seconds: &'a std::option::Option<i32>,
    /// <p>User-specified information about the command, such as a brief description of what the
    /// command should do.</p>
    pub comment: &'a std::option::Option<std::string::String>,
    /// <p>The required and optional parameters specified in the document being run.</p>
    pub parameters: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager
    /// automatically determines the Region of the S3 bucket.</p>
    pub output_s3_region: &'a std::option::Option<std::string::String>,
    /// <p>The name of the S3 bucket where command execution responses should be stored.</p>
    pub output_s3_bucket_name: &'a std::option::Option<std::string::String>,
    /// <p>The directory structure within the S3 bucket where the responses should be stored.</p>
    pub output_s3_key_prefix: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) The maximum number of instances that are allowed to run the command at the same
    /// time. You can specify a number such as 10 or a percentage such as 10%. The default value is 50.
    /// For more information about how to use MaxConcurrency, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-velocity">Using
    /// concurrency controls</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    pub max_concurrency: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of errors allowed without the command failing. When the command fails one
    /// more time beyond the value of MaxErrors, the systems stops sending the command to additional
    /// targets. You can specify a number like 10 or a percentage like 10%. The default value is 0. For
    /// more information about how to use MaxErrors, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-maxerrors">Using
    /// error controls</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    pub max_errors: &'a std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for Run
    /// Command commands.</p>
    pub service_role_arn: &'a std::option::Option<std::string::String>,
    /// <p>Configurations for sending notifications.</p>
    pub notification_config: &'a std::option::Option<crate::model::NotificationConfig>,
    /// <p>Enables Systems Manager to send Run Command output to Amazon CloudWatch Logs. </p>
    pub cloud_watch_output_config: &'a std::option::Option<crate::model::CloudWatchOutputConfig>,
}
impl<'a> std::fmt::Debug for SendCommandInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendCommandInputBody");
        formatter.field("instance_ids", &self.instance_ids);
        formatter.field("targets", &self.targets);
        formatter.field("document_name", &self.document_name);
        formatter.field("document_version", &self.document_version);
        formatter.field("document_hash", &self.document_hash);
        formatter.field("document_hash_type", &self.document_hash_type);
        formatter.field("timeout_seconds", &self.timeout_seconds);
        formatter.field("comment", &self.comment);
        formatter.field("parameters", &self.parameters);
        formatter.field("output_s3_region", &self.output_s3_region);
        formatter.field("output_s3_bucket_name", &self.output_s3_bucket_name);
        formatter.field("output_s3_key_prefix", &self.output_s3_key_prefix);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("service_role_arn", &self.service_role_arn);
        formatter.field("notification_config", &self.notification_config);
        formatter.field("cloud_watch_output_config", &self.cloud_watch_output_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartAssociationsOnceInputBody<'a> {
    /// <p>The association IDs that you want to run immediately and only one time.</p>
    pub association_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for StartAssociationsOnceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartAssociationsOnceInputBody");
        formatter.field("association_ids", &self.association_ids);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartAutomationExecutionInputBody<'a> {
    /// <p>The name of the Systems Manager document to run. This can be a public document or a custom document.
    /// To run a shared document belonging to another account, specify the document ARN. For more
    /// information about how to use shared documents, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-using-shared.html">Using shared SSM documents</a>
    /// in the <i>AWS Systems Manager User Guide</i>.</p>
    pub document_name: &'a std::option::Option<std::string::String>,
    /// <p>The version of the Automation document to use for this execution.</p>
    pub document_version: &'a std::option::Option<std::string::String>,
    /// <p>A key-value map of execution parameters, which match the declared parameters in the
    /// Automation document.</p>
    pub parameters: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>User-provided idempotency token. The token must be unique, is case insensitive, enforces the
    /// UUID format, and can't be reused.</p>
    pub client_token: &'a std::option::Option<std::string::String>,
    /// <p>The execution mode of the automation. Valid modes include the following: Auto and
    /// Interactive. The default mode is Auto.</p>
    pub mode: &'a std::option::Option<crate::model::ExecutionMode>,
    /// <p>The name of the parameter used as the target resource for the rate-controlled execution.
    /// Required if you specify targets.</p>
    pub target_parameter_name: &'a std::option::Option<std::string::String>,
    /// <p>A key-value mapping to target resources. Required if you specify TargetParameterName.</p>
    pub targets: &'a std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>A key-value mapping of document parameters to target resources. Both Targets and TargetMaps
    /// cannot be specified together.</p>
    pub target_maps: &'a std::option::Option<
        std::vec::Vec<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
    >,
    /// <p>The maximum number of targets allowed to run this task in parallel. You can specify a
    /// number, such as 10, or a percentage, such as 10%. The default value is 10.</p>
    pub max_concurrency: &'a std::option::Option<std::string::String>,
    /// <p>The number of errors that are allowed before the system stops running the automation on
    /// additional targets. You can specify either an absolute number of errors, for example 10, or a
    /// percentage of the target set, for example 10%. If you specify 3, for example, the system stops
    /// running the automation when the fourth error is received. If you specify 0, then the system stops
    /// running the automation on additional targets after the first error result is returned. If you run
    /// an automation on 50 resources and set max-errors to 10%, then the system stops running the
    /// automation on additional targets when the sixth error is received.</p>
    /// <p>Executions that are already running an automation when max-errors is reached are allowed to
    /// complete, but some of these executions may fail as well. If you need to ensure that there won't
    /// be more than max-errors failed executions, set max-concurrency to 1 so the executions proceed one
    /// at a time.</p>
    pub max_errors: &'a std::option::Option<std::string::String>,
    /// <p>A location is a combination of AWS Regions and/or AWS accounts where you want to run the
    /// Automation. Use this action to start an Automation in multiple Regions and multiple accounts. For
    /// more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-automation-multiple-accounts-and-regions.html">Running Automation workflows in multiple AWS Regions and accounts</a> in the
    /// <i>AWS Systems Manager User Guide</i>. </p>
    pub target_locations: &'a std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
    /// <p>Optional metadata that you assign to a resource. You can specify a maximum of five tags for
    /// an automation. Tags enable you to categorize a resource in different ways, such as by purpose,
    /// owner, or environment. For example, you might want to tag an automation to identify an
    /// environment or operating system. In this case, you could specify the following key name/value
    /// pairs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Key=environment,Value=test</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Key=OS,Value=Windows</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>To add tags to an existing patch baseline, use the <a>AddTagsToResource</a>
    /// action.</p>
    /// </note>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for StartAutomationExecutionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartAutomationExecutionInputBody");
        formatter.field("document_name", &self.document_name);
        formatter.field("document_version", &self.document_version);
        formatter.field("parameters", &self.parameters);
        formatter.field("client_token", &self.client_token);
        formatter.field("mode", &self.mode);
        formatter.field("target_parameter_name", &self.target_parameter_name);
        formatter.field("targets", &self.targets);
        formatter.field("target_maps", &self.target_maps);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("target_locations", &self.target_locations);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartChangeRequestExecutionInputBody<'a> {
    /// <p>The date and time specified in the change request to run the Automation runbooks.</p>
    /// <note>
    /// <p>The Automation runbooks specified for the runbook workflow can't run until all required
    /// approvals for the change request have been received.</p>
    /// </note>
    pub scheduled_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The name of the change template document to run during the runbook workflow.</p>
    pub document_name: &'a std::option::Option<std::string::String>,
    /// <p>The version of the change template document to run during the runbook workflow.</p>
    pub document_version: &'a std::option::Option<std::string::String>,
    /// <p>A key-value map of parameters that match the declared parameters in the change template
    /// document.</p>
    pub parameters: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The name of the change request associated with the runbook workflow to be run.</p>
    pub change_request_name: &'a std::option::Option<std::string::String>,
    /// <p>The user-provided idempotency token. The token must be unique, is case insensitive, enforces
    /// the UUID format, and can't be reused.</p>
    pub client_token: &'a std::option::Option<std::string::String>,
    /// <p>Information about the Automation runbooks (Automation documents) that are run during the
    /// runbook workflow.</p>
    /// <note>
    /// <p>The Automation runbooks specified for the runbook workflow can't run until all required
    /// approvals for the change request have been received.</p>
    /// </note>
    pub runbooks: &'a std::option::Option<std::vec::Vec<crate::model::Runbook>>,
    /// <p>Optional metadata that you assign to a resource. You can specify a maximum of five tags for
    /// a change request. Tags enable you to categorize a resource in different ways, such as by
    /// purpose, owner, or environment. For example, you might want to tag a change request to identify
    /// an environment or target AWS Region. In this case, you could specify the following key-value
    /// pairs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Key=Environment,Value=Production</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Key=Region,Value=us-east-2</code>
    /// </p>
    /// </li>
    /// </ul>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The time that the requester expects the runbook workflow related to the change request to
    /// complete. The time is an estimate only that the requester provides for reviewers.</p>
    pub scheduled_end_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>User-provided details about the change. If no details are provided, content specified in the
    /// <b>Template information</b> section of the associated change template
    /// is added.</p>
    pub change_details: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StartChangeRequestExecutionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartChangeRequestExecutionInputBody");
        formatter.field("scheduled_time", &self.scheduled_time);
        formatter.field("document_name", &self.document_name);
        formatter.field("document_version", &self.document_version);
        formatter.field("parameters", &self.parameters);
        formatter.field("change_request_name", &self.change_request_name);
        formatter.field("client_token", &self.client_token);
        formatter.field("runbooks", &self.runbooks);
        formatter.field("tags", &self.tags);
        formatter.field("scheduled_end_time", &self.scheduled_end_time);
        formatter.field("change_details", &self.change_details);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartSessionInputBody<'a> {
    /// <p>The instance to connect to for the session.</p>
    pub target: &'a std::option::Option<std::string::String>,
    /// <p>The name of the SSM document to define the parameters and plugin settings for the session.
    /// For example, <code>SSM-SessionManagerRunShell</code>. You can call the <a>GetDocument</a> API to verify the document exists before attempting to start a session.
    /// If no document name is provided, a shell to the instance is launched by default.</p>
    pub document_name: &'a std::option::Option<std::string::String>,
    /// <p>Reserved for future use.</p>
    pub parameters: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
}
impl<'a> std::fmt::Debug for StartSessionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartSessionInputBody");
        formatter.field("target", &self.target);
        formatter.field("document_name", &self.document_name);
        formatter.field("parameters", &self.parameters);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopAutomationExecutionInputBody<'a> {
    /// <p>The execution ID of the Automation to stop.</p>
    pub automation_execution_id: &'a std::option::Option<std::string::String>,
    /// <p>The stop request type. Valid types include the following: Cancel and Complete. The default
    /// type is Cancel.</p>
    pub r#type: &'a std::option::Option<crate::model::StopType>,
}
impl<'a> std::fmt::Debug for StopAutomationExecutionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopAutomationExecutionInputBody");
        formatter.field("automation_execution_id", &self.automation_execution_id);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TerminateSessionInputBody<'a> {
    /// <p>The ID of the session to terminate.</p>
    pub session_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for TerminateSessionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TerminateSessionInputBody");
        formatter.field("session_id", &self.session_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnlabelParameterVersionInputBody<'a> {
    /// <p>The parameter name of which you want to delete one or more labels.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The specific version of the parameter which you want to delete one or more labels from. If
    /// it is not present, the call will fail.</p>
    pub parameter_version: &'a std::option::Option<i64>,
    /// <p>One or more labels to delete from the specified parameter version.</p>
    pub labels: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for UnlabelParameterVersionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnlabelParameterVersionInputBody");
        formatter.field("name", &self.name);
        formatter.field("parameter_version", &self.parameter_version);
        formatter.field("labels", &self.labels);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAssociationInputBody<'a> {
    /// <p>The ID of the association you want to update. </p>
    pub association_id: &'a std::option::Option<std::string::String>,
    /// <p>The parameters you want to update for the association. If you create a parameter using
    /// Parameter Store, you can reference the parameter using {{ssm:parameter-name}}</p>
    pub parameters: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The document version you want update for the association. </p>
    pub document_version: &'a std::option::Option<std::string::String>,
    /// <p>The cron expression used to schedule the association that you want to update.</p>
    pub schedule_expression: &'a std::option::Option<std::string::String>,
    /// <p>An S3 bucket where you want to store the results of this request.</p>
    pub output_location: &'a std::option::Option<crate::model::InstanceAssociationOutputLocation>,
    /// <p>The name of the SSM document that contains the configuration information for the instance.
    /// You can specify Command or Automation documents.</p>
    /// <p>You can specify AWS-predefined documents, documents you created, or a document that is
    /// shared with you from another account.</p>
    /// <p>For SSM documents that are shared with you from other AWS accounts, you must specify the
    /// complete SSM document ARN, in the following format:</p>
    /// <p>
    /// <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:document/<i>document-name</i>
    /// </code>
    /// </p>
    /// <p>For example:</p>
    /// <p>
    /// <code>arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document</code>
    /// </p>
    /// <p>For AWS-predefined documents and SSM documents you created in your account, you only need to
    /// specify the document name. For example, <code>AWS-ApplyPatchBaseline</code> or
    /// <code>My-Document</code>.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The targets of the association.</p>
    pub targets: &'a std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The name of the association that you want to update.</p>
    pub association_name: &'a std::option::Option<std::string::String>,
    /// <p>This parameter is provided for concurrency control purposes. You must specify the latest
    /// association version in the service. If you want to ensure that this request succeeds, either
    /// specify <code>$LATEST</code>, or omit this parameter.</p>
    pub association_version: &'a std::option::Option<std::string::String>,
    /// <p>Specify the target for the association. This target is required for associations that use an
    /// Automation document and target resources by using rate controls.</p>
    pub automation_target_parameter_name: &'a std::option::Option<std::string::String>,
    /// <p>The number of errors that are allowed before the system stops sending requests to run the
    /// association on additional targets. You can specify either an absolute number of errors, for
    /// example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
    /// the system stops sending requests when the fourth error is received. If you specify 0, then the
    /// system stops sending requests after the first error is returned. If you run an association on 50
    /// instances and set MaxError to 10%, then the system stops sending the request when the sixth error
    /// is received.</p>
    /// <p>Executions that are already running an association when MaxErrors is reached are allowed to
    /// complete, but some of these executions may fail as well. If you need to ensure that there won't
    /// be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
    /// at a time.</p>
    pub max_errors: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of targets allowed to run the association at the same time. You can
    /// specify a number, for example 10, or a percentage of the target set, for example 10%. The default
    /// value is 100%, which means all targets run the association at the same time.</p>
    /// <p>If a new instance starts and attempts to run an association while Systems Manager is running
    /// MaxConcurrency associations, the association is allowed to run. During the next association
    /// interval, the new instance will process its association within the limit specified for
    /// MaxConcurrency.</p>
    pub max_concurrency: &'a std::option::Option<std::string::String>,
    /// <p>The severity level to assign to the association.</p>
    pub compliance_severity: &'a std::option::Option<crate::model::AssociationComplianceSeverity>,
    /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
    /// <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
    /// execution to determine the compliance status. If the association execution runs successfully,
    /// then the association is <code>COMPLIANT</code>. If the association execution doesn't run
    /// successfully, the association is <code>NON-COMPLIANT</code>.</p>
    /// <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
    /// for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
    /// managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
    /// <p>By default, all associations use <code>AUTO</code> mode.</p>
    pub sync_compliance: &'a std::option::Option<crate::model::AssociationSyncCompliance>,
    /// <p>By default, when you update an association, the system runs it immediately after it is
    /// updated and then according to the schedule you specified. Specify this option if you don't want
    /// an association to run immediately after you update it. This parameter is not supported for rate
    /// expressions.</p>
    /// <p>Also, if you specified this option when you created the association, you can reset it. To do
    /// so, specify the <code>no-apply-only-at-cron-interval</code> parameter when you update the
    /// association from the command line. This parameter forces the association to run immediately after
    /// updating it and according to the interval specified.</p>
    pub apply_only_at_cron_interval: &'a bool,
    /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager Change Calendar type
    /// documents you want to gate your associations under. The associations only run when that Change
    /// Calendar is open. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar">AWS Systems Manager Change
    /// Calendar</a>.</p>
    pub calendar_names: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A location is a combination of AWS Regions and AWS accounts where you want to run the
    /// association. Use this action to update an association in multiple Regions and multiple
    /// accounts.</p>
    pub target_locations: &'a std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
}
impl<'a> std::fmt::Debug for UpdateAssociationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAssociationInputBody");
        formatter.field("association_id", &self.association_id);
        formatter.field("parameters", &self.parameters);
        formatter.field("document_version", &self.document_version);
        formatter.field("schedule_expression", &self.schedule_expression);
        formatter.field("output_location", &self.output_location);
        formatter.field("name", &self.name);
        formatter.field("targets", &self.targets);
        formatter.field("association_name", &self.association_name);
        formatter.field("association_version", &self.association_version);
        formatter.field(
            "automation_target_parameter_name",
            &self.automation_target_parameter_name,
        );
        formatter.field("max_errors", &self.max_errors);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("compliance_severity", &self.compliance_severity);
        formatter.field("sync_compliance", &self.sync_compliance);
        formatter.field(
            "apply_only_at_cron_interval",
            &self.apply_only_at_cron_interval,
        );
        formatter.field("calendar_names", &self.calendar_names);
        formatter.field("target_locations", &self.target_locations);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAssociationStatusInputBody<'a> {
    /// <p>The name of the Systems Manager document.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The ID of the instance.</p>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>The association status.</p>
    pub association_status: &'a std::option::Option<crate::model::AssociationStatus>,
}
impl<'a> std::fmt::Debug for UpdateAssociationStatusInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAssociationStatusInputBody");
        formatter.field("name", &self.name);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("association_status", &self.association_status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDocumentInputBody<'a> {
    /// <p>A valid JSON or YAML string.</p>
    pub content: &'a std::option::Option<std::string::String>,
    /// <p>A list of key and value pairs that describe attachments to a version of a document.</p>
    pub attachments: &'a std::option::Option<std::vec::Vec<crate::model::AttachmentsSource>>,
    /// <p>The name of the Systems Manager document that you want to update.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The friendly name of the Systems Manager document that you want to update. This value can differ for
    /// each version of the document. If you do not specify a value for this parameter in your request,
    /// the existing value is applied to the new document version.</p>
    pub display_name: &'a std::option::Option<std::string::String>,
    /// <p>An optional field specifying the version of the artifact you are updating with the document.
    /// For example, "Release 12, Update 6". This value is unique across all versions of a document, and
    /// cannot be changed.</p>
    pub version_name: &'a std::option::Option<std::string::String>,
    /// <p>The version of the document that you want to update. Currently, Systems Manager supports updating only
    /// the latest version of the document. You can specify the version number of the latest version or
    /// use the <code>$LATEST</code> variable.</p>
    pub document_version: &'a std::option::Option<std::string::String>,
    /// <p>Specify the document format for the new document version. Systems Manager supports JSON and YAML
    /// documents. JSON is the default format.</p>
    pub document_format: &'a std::option::Option<crate::model::DocumentFormat>,
    /// <p>Specify a new target type for the document.</p>
    pub target_type: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateDocumentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDocumentInputBody");
        formatter.field("content", &self.content);
        formatter.field("attachments", &self.attachments);
        formatter.field("name", &self.name);
        formatter.field("display_name", &self.display_name);
        formatter.field("version_name", &self.version_name);
        formatter.field("document_version", &self.document_version);
        formatter.field("document_format", &self.document_format);
        formatter.field("target_type", &self.target_type);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDocumentDefaultVersionInputBody<'a> {
    /// <p>The name of a custom document that you want to set as the default version.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The version of a custom document that you want to set as the default version.</p>
    pub document_version: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateDocumentDefaultVersionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDocumentDefaultVersionInputBody");
        formatter.field("name", &self.name);
        formatter.field("document_version", &self.document_version);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDocumentMetadataInputBody<'a> {
    /// <p>The name of the document for which a version is to be updated.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The version of a document to update.</p>
    pub document_version: &'a std::option::Option<std::string::String>,
    /// <p>The document review details to update.</p>
    pub document_reviews: &'a std::option::Option<crate::model::DocumentReviews>,
}
impl<'a> std::fmt::Debug for UpdateDocumentMetadataInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDocumentMetadataInputBody");
        formatter.field("name", &self.name);
        formatter.field("document_version", &self.document_version);
        formatter.field("document_reviews", &self.document_reviews);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMaintenanceWindowInputBody<'a> {
    /// <p>The ID of the maintenance window to update.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
    /// <p>The name of the maintenance window.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>An optional description for the update request.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
    /// Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or
    /// "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time
    /// Zone Database</a> on the IANA website.</p>
    pub start_date: &'a std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO-8601 Extended format, for when you want the maintenance window to
    /// become inactive. EndDate allows you to set a date and time in the future when the maintenance
    /// window will no longer run.</p>
    pub end_date: &'a std::option::Option<std::string::String>,
    /// <p>The schedule of the maintenance window in the form of a cron or rate expression.</p>
    pub schedule: &'a std::option::Option<std::string::String>,
    /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
    /// Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or
    /// "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time
    /// Zone Database</a> on the IANA website.</p>
    pub schedule_timezone: &'a std::option::Option<std::string::String>,
    /// <p>The number of days to wait after the date and time specified by a CRON expression before
    /// running the maintenance window.</p>
    /// <p>For example, the following cron expression schedules a maintenance window to run the third
    /// Tuesday of every month at 11:30 PM.</p>
    /// <p>
    /// <code>cron(30 23 ? * TUE#3 *)</code>
    /// </p>
    /// <p>If the schedule offset is <code>2</code>, the maintenance window won't run until two days
    /// later.</p>
    pub schedule_offset: &'a std::option::Option<i32>,
    /// <p>The duration of the maintenance window in hours.</p>
    pub duration: &'a std::option::Option<i32>,
    /// <p>The number of hours before the end of the maintenance window that Systems Manager stops scheduling new
    /// tasks for execution.</p>
    pub cutoff: &'a std::option::Option<i32>,
    /// <p>Whether targets must be registered with the maintenance window before tasks can be defined
    /// for those targets.</p>
    pub allow_unassociated_targets: &'a std::option::Option<bool>,
    /// <p>Whether the maintenance window is enabled.</p>
    pub enabled: &'a std::option::Option<bool>,
    /// <p>If True, then all fields that are required by the CreateMaintenanceWindow action are also
    /// required for this API request. Optional fields that are not specified are set to null. </p>
    pub replace: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for UpdateMaintenanceWindowInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMaintenanceWindowInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("start_date", &self.start_date);
        formatter.field("end_date", &self.end_date);
        formatter.field("schedule", &self.schedule);
        formatter.field("schedule_timezone", &self.schedule_timezone);
        formatter.field("schedule_offset", &self.schedule_offset);
        formatter.field("duration", &self.duration);
        formatter.field("cutoff", &self.cutoff);
        formatter.field(
            "allow_unassociated_targets",
            &self.allow_unassociated_targets,
        );
        formatter.field("enabled", &self.enabled);
        formatter.field("replace", &self.replace);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMaintenanceWindowTargetInputBody<'a> {
    /// <p>The maintenance window ID with which to modify the target.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
    /// <p>The target ID to modify.</p>
    pub window_target_id: &'a std::option::Option<std::string::String>,
    /// <p>The targets to add or replace.</p>
    pub targets: &'a std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>User-provided value that will be included in any CloudWatch events raised while running
    /// tasks for these targets in this maintenance window.</p>
    pub owner_information: &'a std::option::Option<std::string::String>,
    /// <p>A name for the update.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>An optional description for the update.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>If True, then all fields that are required by the RegisterTargetWithMaintenanceWindow action
    /// are also required for this API request. Optional fields that are not specified are set to
    /// null.</p>
    pub replace: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for UpdateMaintenanceWindowTargetInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMaintenanceWindowTargetInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_target_id", &self.window_target_id);
        formatter.field("targets", &self.targets);
        formatter.field("owner_information", &"*** Sensitive Data Redacted ***");
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("replace", &self.replace);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMaintenanceWindowTaskInputBody<'a> {
    /// <p>The maintenance window ID that contains the task to modify.</p>
    pub window_id: &'a std::option::Option<std::string::String>,
    /// <p>The task ID to modify.</p>
    pub window_task_id: &'a std::option::Option<std::string::String>,
    /// <p>The targets (either instances or tags) to modify. Instances are specified using
    /// Key=instanceids,Values=instanceID_1,instanceID_2. Tags are specified using
    /// Key=tag_name,Values=tag_value. </p>
    /// <note>
    /// <p>One or more targets must be specified for maintenance window Run Command-type tasks.
    /// Depending on the task, targets are optional for other maintenance window task types (Automation,
    /// AWS Lambda, and AWS Step Functions). For more information about running tasks that do not
    /// specify targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html">Registering
    /// maintenance window tasks without targets</a> in the
    /// <i>AWS Systems Manager User Guide</i>.</p>
    /// </note>
    pub targets: &'a std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The task ARN to modify.</p>
    pub task_arn: &'a std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM service role for Systems Manager to assume when running a
    /// maintenance window task. If you do not specify a service role ARN, Systems Manager uses your account's
    /// service-linked role.  If no service-linked role for Systems Manager exists in your account, it is created when you run
    /// <code>RegisterTaskWithMaintenanceWindow</code>.</p>
    /// <p>For more information, see the following topics in the in the <i>AWS Systems Manager User Guide</i>:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/using-service-linked-roles.html#slr-permissions">Using
    /// service-linked roles for Systems Manager</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html#maintenance-window-tasks-service-role">Should I use a service-linked role or a custom service role to run maintenance window tasks?
    /// </a>
    /// </p>
    /// </li>
    /// </ul>
    pub service_role_arn: &'a std::option::Option<std::string::String>,
    /// <p>The parameters to modify.</p>
    /// <note>
    /// <p>
    /// <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    /// instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    /// about how Systems Manager handles these options for the supported maintenance window task
    /// types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    /// </note>
    /// <p>The map has the following format:</p>
    /// <p>Key: string, between 1 and 255 characters</p>
    /// <p>Value: an array of strings, each string is between 1 and 255 characters</p>
    pub task_parameters: &'a std::option::Option<
        std::collections::HashMap<
            std::string::String,
            crate::model::MaintenanceWindowTaskParameterValueExpression,
        >,
    >,
    /// <p>The parameters that the task should use during execution. Populate only the fields that
    /// match the task type. All other fields should be empty.</p>
    /// <important>
    /// <p>When you update a maintenance window task that has options specified in
    /// <code>TaskInvocationParameters</code>, you must provide again all the
    /// <code>TaskInvocationParameters</code> values that you want to retain. The values you do not
    /// specify again are removed. For example, suppose that when you registered a Run Command task, you
    /// specified <code>TaskInvocationParameters</code> values for <code>Comment</code>,
    /// <code>NotificationConfig</code>, and <code>OutputS3BucketName</code>. If you update the
    /// maintenance window task and specify only a different <code>OutputS3BucketName</code> value, the
    /// values for <code>Comment</code> and <code>NotificationConfig</code> are removed.</p>
    /// </important>
    pub task_invocation_parameters:
        &'a std::option::Option<crate::model::MaintenanceWindowTaskInvocationParameters>,
    /// <p>The new task priority to specify. The lower the number, the higher the priority. Tasks that
    /// have the same priority are scheduled in parallel.</p>
    pub priority: &'a std::option::Option<i32>,
    /// <p>The new <code>MaxConcurrency</code> value you want to specify. <code>MaxConcurrency</code>
    /// is the number of targets that are allowed to run this task in parallel.</p>
    /// <note>
    /// <p>For maintenance window tasks without a target specified, you cannot supply a value for this
    /// option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported
    /// in the response to this command. This value does not affect the running of your task and can be
    /// ignored.</p>
    /// </note>
    pub max_concurrency: &'a std::option::Option<std::string::String>,
    /// <p>The new <code>MaxErrors</code> value to specify. <code>MaxErrors</code> is the maximum
    /// number of errors that are allowed before the task stops being scheduled.</p>
    /// <note>
    /// <p>For maintenance window tasks without a target specified, you cannot supply a value for this
    /// option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported
    /// in the response to this command. This value does not affect the running of your task and can be
    /// ignored.</p>
    /// </note>
    pub max_errors: &'a std::option::Option<std::string::String>,
    /// <p>The new logging location in Amazon S3 to specify.</p>
    /// <note>
    /// <p>
    /// <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
    /// <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
    /// For information about how Systems Manager handles these options for the supported maintenance
    /// window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    /// </note>
    pub logging_info: &'a std::option::Option<crate::model::LoggingInfo>,
    /// <p>The new task name to specify.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The new task description to specify.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>If True, then all fields that are required by the RegisterTaskWithMaintenanceWindow action
    /// are also required for this API request. Optional fields that are not specified are set to
    /// null.</p>
    pub replace: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for UpdateMaintenanceWindowTaskInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMaintenanceWindowTaskInputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_task_id", &self.window_task_id);
        formatter.field("targets", &self.targets);
        formatter.field("task_arn", &self.task_arn);
        formatter.field("service_role_arn", &self.service_role_arn);
        formatter.field("task_parameters", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "task_invocation_parameters",
            &self.task_invocation_parameters,
        );
        formatter.field("priority", &self.priority);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("logging_info", &self.logging_info);
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("replace", &self.replace);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateManagedInstanceRoleInputBody<'a> {
    /// <p>The ID of the managed instance where you want to update the role.</p>
    pub instance_id: &'a std::option::Option<std::string::String>,
    /// <p>The IAM role you want to assign or change.</p>
    pub iam_role: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateManagedInstanceRoleInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateManagedInstanceRoleInputBody");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("iam_role", &self.iam_role);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateOpsItemInputBody<'a> {
    /// <p>Update the information about the OpsItem. Provide enough information so that users reading
    /// this OpsItem for the first time understand the issue. </p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>Add new keys or edit existing key-value pairs of the OperationalData map in the OpsItem
    /// object.</p>
    /// <p>Operational data is custom data that provides useful reference details about the OpsItem.
    /// For example, you can specify log files, error strings, license keys, troubleshooting tips, or
    /// other relevant data. You enter operational data as key-value pairs. The key has a maximum length
    /// of 128 characters. The value has a maximum size of 20 KB.</p>
    /// <important>
    /// <p>Operational data keys <i>can't</i> begin with the following: amazon, aws,
    /// amzn, ssm, /amazon, /aws, /amzn, /ssm.</p>
    /// </important>
    /// <p>You can choose to make the data searchable by other users in the account or you can restrict
    /// search access. Searchable data means that all users with access to the OpsItem Overview page (as
    /// provided by the <a>DescribeOpsItems</a> API action) can view and search on the
    /// specified data. Operational data that is not searchable is only viewable by users who have access
    /// to the OpsItem (as provided by the <a>GetOpsItem</a> API action).</p>
    /// <p>Use the <code>/aws/resources</code> key in OperationalData to specify a related resource in
    /// the request. Use the <code>/aws/automations</code> key in OperationalData to associate an
    /// Automation runbook with the OpsItem. To view AWS CLI example commands that use these keys, see
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems">Creating OpsItems manually</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    pub operational_data: &'a std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::OpsItemDataValue>,
    >,
    /// <p>Keys that you want to remove from the OperationalData map.</p>
    pub operational_data_to_delete: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this
    /// OpsItem is edited or changed.</p>
    pub notifications: &'a std::option::Option<std::vec::Vec<crate::model::OpsItemNotification>>,
    /// <p>The importance of this OpsItem in relation to other OpsItems in the system.</p>
    pub priority: &'a std::option::Option<i32>,
    /// <p>One or more OpsItems that share something in common with the current OpsItems. For example,
    /// related OpsItems can include OpsItems with similar error messages, impacted resources, or
    /// statuses for the impacted resource.</p>
    pub related_ops_items: &'a std::option::Option<std::vec::Vec<crate::model::RelatedOpsItem>>,
    /// <p>The OpsItem status. Status can be <code>Open</code>, <code>In Progress</code>, or
    /// <code>Resolved</code>. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-working-with-OpsItems.html#OpsCenter-working-with-OpsItems-editing-details">Editing OpsItem details</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    pub status: &'a std::option::Option<crate::model::OpsItemStatus>,
    /// <p>The ID of the OpsItem.</p>
    pub ops_item_id: &'a std::option::Option<std::string::String>,
    /// <p>A short heading that describes the nature of the OpsItem and the impacted resource.</p>
    pub title: &'a std::option::Option<std::string::String>,
    /// <p>Specify a new category for an OpsItem.</p>
    pub category: &'a std::option::Option<std::string::String>,
    /// <p>Specify a new severity for an OpsItem.</p>
    pub severity: &'a std::option::Option<std::string::String>,
    /// <p>The time a runbook workflow started. Currently reported only for the OpsItem type
    /// <code>/aws/changerequest</code>.</p>
    pub actual_start_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The time a runbook workflow ended. Currently reported only for the OpsItem type
    /// <code>/aws/changerequest</code>.</p>
    pub actual_end_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The time specified in a change request for a runbook workflow to start. Currently supported
    /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
    pub planned_start_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The time specified in a change request for a runbook workflow to end. Currently supported
    /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
    pub planned_end_time: &'a std::option::Option<smithy_types::Instant>,
}
impl<'a> std::fmt::Debug for UpdateOpsItemInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateOpsItemInputBody");
        formatter.field("description", &self.description);
        formatter.field("operational_data", &self.operational_data);
        formatter.field(
            "operational_data_to_delete",
            &self.operational_data_to_delete,
        );
        formatter.field("notifications", &self.notifications);
        formatter.field("priority", &self.priority);
        formatter.field("related_ops_items", &self.related_ops_items);
        formatter.field("status", &self.status);
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.field("title", &self.title);
        formatter.field("category", &self.category);
        formatter.field("severity", &self.severity);
        formatter.field("actual_start_time", &self.actual_start_time);
        formatter.field("actual_end_time", &self.actual_end_time);
        formatter.field("planned_start_time", &self.planned_start_time);
        formatter.field("planned_end_time", &self.planned_end_time);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateOpsMetadataInputBody<'a> {
    /// <p>The Amazon Resoure Name (ARN) of the OpsMetadata Object to update.</p>
    pub ops_metadata_arn: &'a std::option::Option<std::string::String>,
    /// <p>Metadata to add to an OpsMetadata object.</p>
    pub metadata_to_update: &'a std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::MetadataValue>,
    >,
    /// <p>The metadata keys to delete from the OpsMetadata object. </p>
    pub keys_to_delete: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for UpdateOpsMetadataInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateOpsMetadataInputBody");
        formatter.field("ops_metadata_arn", &self.ops_metadata_arn);
        formatter.field("metadata_to_update", &self.metadata_to_update);
        formatter.field("keys_to_delete", &self.keys_to_delete);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePatchBaselineInputBody<'a> {
    /// <p>The ID of the patch baseline to update.</p>
    pub baseline_id: &'a std::option::Option<std::string::String>,
    /// <p>The name of the patch baseline.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>A set of global filters used to include patches in the baseline.</p>
    pub global_filters: &'a std::option::Option<crate::model::PatchFilterGroup>,
    /// <p>A set of rules used to include patches in the baseline.</p>
    pub approval_rules: &'a std::option::Option<crate::model::PatchRuleGroup>,
    /// <p>A list of explicitly approved patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches,
    /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
    /// package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    pub approved_patches: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Assigns a new compliance severity level to an existing patch baseline.</p>
    pub approved_patches_compliance_level:
        &'a std::option::Option<crate::model::PatchComplianceLevel>,
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be
    /// applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
    pub approved_patches_enable_non_security: &'a std::option::Option<bool>,
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches,
    /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
    /// package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    pub rejected_patches: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The action for Patch Manager to take on patches included in the RejectedPackages
    /// list.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>ALLOW_AS_DEPENDENCY</b>: A package in the Rejected patches
    /// list is installed only if it is a dependency of another package. It is considered compliant
    /// with the patch baseline, and its status is reported as <i>InstalledOther</i>.
    /// This is the default action if no option is specified.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>BLOCK</b>: Packages in the RejectedPatches list, and packages
    /// that include them as dependencies, are not installed under any circumstances. If a package was
    /// installed before it was added to the Rejected patches list, it is considered non-compliant with
    /// the patch baseline, and its status is reported as
    /// <i>InstalledRejected</i>.</p>
    /// </li>
    /// </ul>
    pub rejected_patches_action: &'a std::option::Option<crate::model::PatchAction>,
    /// <p>A description of the patch baseline.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>Information about the patches to use to update the instances, including target operating
    /// systems and source repositories. Applies to Linux instances only.</p>
    pub sources: &'a std::option::Option<std::vec::Vec<crate::model::PatchSource>>,
    /// <p>If True, then all fields that are required by the CreatePatchBaseline action are also
    /// required for this API request. Optional fields that are not specified are set to null.</p>
    pub replace: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for UpdatePatchBaselineInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePatchBaselineInputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("name", &self.name);
        formatter.field("global_filters", &self.global_filters);
        formatter.field("approval_rules", &self.approval_rules);
        formatter.field("approved_patches", &self.approved_patches);
        formatter.field(
            "approved_patches_compliance_level",
            &self.approved_patches_compliance_level,
        );
        formatter.field(
            "approved_patches_enable_non_security",
            &self.approved_patches_enable_non_security,
        );
        formatter.field("rejected_patches", &self.rejected_patches);
        formatter.field("rejected_patches_action", &self.rejected_patches_action);
        formatter.field("description", &self.description);
        formatter.field("sources", &self.sources);
        formatter.field("replace", &self.replace);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateResourceDataSyncInputBody<'a> {
    /// <p>The name of the resource data sync you want to update.</p>
    pub sync_name: &'a std::option::Option<std::string::String>,
    /// <p>The type of resource data sync. The supported <code>SyncType</code> is
    /// SyncFromSource.</p>
    pub sync_type: &'a std::option::Option<std::string::String>,
    /// <p>Specify information about the data sources to synchronize.</p>
    pub sync_source: &'a std::option::Option<crate::model::ResourceDataSyncSource>,
}
impl<'a> std::fmt::Debug for UpdateResourceDataSyncInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateResourceDataSyncInputBody");
        formatter.field("sync_name", &self.sync_name);
        formatter.field("sync_type", &self.sync_type);
        formatter.field("sync_source", &self.sync_source);
        formatter.finish()
    }
}

/// <p>The request body of the UpdateServiceSetting API action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateServiceSettingInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the service setting to reset. For example,
    /// <code>arn:aws:ssm:us-east-1:111122223333:servicesetting/ssm/parameter-store/high-throughput-enabled</code>.
    /// The setting ID can be one of the following.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>/ssm/automation/customer-script-log-destination</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/automation/customer-script-log-group-name</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/documents/console/public-sharing-permission</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/parameter-store/default-parameter-tier</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/parameter-store/high-throughput-enabled</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>/ssm/managed-instance/activation-tier</code>
    /// </p>
    /// </li>
    /// </ul>
    pub setting_id: &'a std::option::Option<std::string::String>,
    /// <p>The new value to specify for the service setting. For the
    /// <code>/ssm/parameter-store/default-parameter-tier</code> setting ID, the setting value can be
    /// one of the following.</p>
    /// <ul>
    /// <li>
    /// <p>Standard</p>
    /// </li>
    /// <li>
    /// <p>Advanced</p>
    /// </li>
    /// <li>
    /// <p>Intelligent-Tiering</p>
    /// </li>
    /// </ul>
    /// <p>For the <code>/ssm/parameter-store/high-throughput-enabled</code>, and
    /// <code>/ssm/managed-instance/activation-tier</code> setting IDs, the setting value can be true or
    /// false.</p>
    /// <p>For the <code>/ssm/automation/customer-script-log-destination</code> setting ID, the setting
    /// value can be CloudWatch.</p>
    /// <p>For the <code>/ssm/automation/customer-script-log-group-name</code> setting ID, the setting
    /// value can be the name of a CloudWatch Logs log group.</p>
    /// <p>For the <code>/ssm/documents/console/public-sharing-permission</code> setting ID, the setting
    /// value can be Enable or Disable.</p>
    pub setting_value: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateServiceSettingInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateServiceSettingInputBody");
        formatter.field("setting_id", &self.setting_id);
        formatter.field("setting_value", &self.setting_value);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateOpsItemRelatedItemOutputBody {
    /// <p>The association ID.</p>
    #[serde(rename = "AssociationId")]
    #[serde(default)]
    pub association_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociateOpsItemRelatedItemOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateOpsItemRelatedItemOutputBody");
        formatter.field("association_id", &self.association_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelMaintenanceWindowExecutionOutputBody {
    /// <p>The ID of the maintenance window execution that has been stopped.</p>
    #[serde(rename = "WindowExecutionId")]
    #[serde(default)]
    pub window_execution_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CancelMaintenanceWindowExecutionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelMaintenanceWindowExecutionOutputBody");
        formatter.field("window_execution_id", &self.window_execution_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateActivationOutputBody {
    /// <p>The ID number generated by the system when it processed the activation. The activation ID
    /// functions like a user name.</p>
    #[serde(rename = "ActivationId")]
    #[serde(default)]
    pub activation_id: std::option::Option<std::string::String>,
    /// <p>The code the system generates when it processes the activation. The activation code
    /// functions like a password to validate the activation ID. </p>
    #[serde(rename = "ActivationCode")]
    #[serde(default)]
    pub activation_code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateActivationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateActivationOutputBody");
        formatter.field("activation_id", &self.activation_id);
        formatter.field("activation_code", &self.activation_code);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAssociationOutputBody {
    /// <p>Information about the association.</p>
    #[serde(rename = "AssociationDescription")]
    #[serde(default)]
    pub association_description: std::option::Option<crate::model::AssociationDescription>,
}
impl std::fmt::Debug for CreateAssociationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAssociationOutputBody");
        formatter.field("association_description", &self.association_description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAssociationBatchOutputBody {
    /// <p>Information about the associations that succeeded.</p>
    #[serde(rename = "Successful")]
    #[serde(default)]
    pub successful: std::option::Option<std::vec::Vec<crate::model::AssociationDescription>>,
    /// <p>Information about the associations that failed.</p>
    #[serde(rename = "Failed")]
    #[serde(default)]
    pub failed: std::option::Option<std::vec::Vec<crate::model::FailedCreateAssociation>>,
}
impl std::fmt::Debug for CreateAssociationBatchOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAssociationBatchOutputBody");
        formatter.field("successful", &self.successful);
        formatter.field("failed", &self.failed);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDocumentOutputBody {
    /// <p>Information about the Systems Manager document.</p>
    #[serde(rename = "DocumentDescription")]
    #[serde(default)]
    pub document_description: std::option::Option<crate::model::DocumentDescription>,
}
impl std::fmt::Debug for CreateDocumentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDocumentOutputBody");
        formatter.field("document_description", &self.document_description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMaintenanceWindowOutputBody {
    /// <p>The ID of the created maintenance window.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateMaintenanceWindowOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMaintenanceWindowOutputBody");
        formatter.field("window_id", &self.window_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateOpsItemOutputBody {
    /// <p>The ID of the OpsItem.</p>
    #[serde(rename = "OpsItemId")]
    #[serde(default)]
    pub ops_item_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateOpsItemOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateOpsItemOutputBody");
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateOpsMetadataOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the OpsMetadata Object or blob created by the call.</p>
    #[serde(rename = "OpsMetadataArn")]
    #[serde(default)]
    pub ops_metadata_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateOpsMetadataOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateOpsMetadataOutputBody");
        formatter.field("ops_metadata_arn", &self.ops_metadata_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePatchBaselineOutputBody {
    /// <p>The ID of the created patch baseline.</p>
    #[serde(rename = "BaselineId")]
    #[serde(default)]
    pub baseline_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreatePatchBaselineOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePatchBaselineOutputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteInventoryOutputBody {
    /// <p>Every <code>DeleteInventory</code> action is assigned a unique ID. This option returns a
    /// unique ID. You can use this ID to query the status of a delete operation. This option is useful
    /// for ensuring that a delete operation has completed before you begin other actions. </p>
    #[serde(rename = "DeletionId")]
    #[serde(default)]
    pub deletion_id: std::option::Option<std::string::String>,
    /// <p>The name of the inventory data type specified in the request.</p>
    #[serde(rename = "TypeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
    /// <p>A summary of the delete operation. For more information about this summary, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-custom.html#sysman-inventory-delete-summary">Deleting custom inventory</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "DeletionSummary")]
    #[serde(default)]
    pub deletion_summary: std::option::Option<crate::model::InventoryDeletionSummary>,
}
impl std::fmt::Debug for DeleteInventoryOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteInventoryOutputBody");
        formatter.field("deletion_id", &self.deletion_id);
        formatter.field("type_name", &self.type_name);
        formatter.field("deletion_summary", &self.deletion_summary);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMaintenanceWindowOutputBody {
    /// <p>The ID of the deleted maintenance window.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteMaintenanceWindowOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMaintenanceWindowOutputBody");
        formatter.field("window_id", &self.window_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteParametersOutputBody {
    /// <p>The names of the deleted parameters.</p>
    #[serde(rename = "DeletedParameters")]
    #[serde(default)]
    pub deleted_parameters: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The names of parameters that weren't deleted because the parameters are not valid.</p>
    #[serde(rename = "InvalidParameters")]
    #[serde(default)]
    pub invalid_parameters: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DeleteParametersOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteParametersOutputBody");
        formatter.field("deleted_parameters", &self.deleted_parameters);
        formatter.field("invalid_parameters", &self.invalid_parameters);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePatchBaselineOutputBody {
    /// <p>The ID of the deleted patch baseline.</p>
    #[serde(rename = "BaselineId")]
    #[serde(default)]
    pub baseline_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeletePatchBaselineOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePatchBaselineOutputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterPatchBaselineForPatchGroupOutputBody {
    /// <p>The ID of the patch baseline the patch group was deregistered from.</p>
    #[serde(rename = "BaselineId")]
    #[serde(default)]
    pub baseline_id: std::option::Option<std::string::String>,
    /// <p>The name of the patch group deregistered from the patch baseline.</p>
    #[serde(rename = "PatchGroup")]
    #[serde(default)]
    pub patch_group: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeregisterPatchBaselineForPatchGroupOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterPatchBaselineForPatchGroupOutputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("patch_group", &self.patch_group);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterTargetFromMaintenanceWindowOutputBody {
    /// <p>The ID of the maintenance window the target was removed from.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
    /// <p>The ID of the removed target definition.</p>
    #[serde(rename = "WindowTargetId")]
    #[serde(default)]
    pub window_target_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeregisterTargetFromMaintenanceWindowOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterTargetFromMaintenanceWindowOutputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_target_id", &self.window_target_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterTaskFromMaintenanceWindowOutputBody {
    /// <p>The ID of the maintenance window the task was removed from.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
    /// <p>The ID of the task removed from the maintenance window.</p>
    #[serde(rename = "WindowTaskId")]
    #[serde(default)]
    pub window_task_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeregisterTaskFromMaintenanceWindowOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterTaskFromMaintenanceWindowOutputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_task_id", &self.window_task_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeActivationsOutputBody {
    /// <p>A list of activations for your AWS account.</p>
    #[serde(rename = "ActivationList")]
    #[serde(default)]
    pub activation_list: std::option::Option<std::vec::Vec<crate::model::Activation>>,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results. </p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeActivationsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeActivationsOutputBody");
        formatter.field("activation_list", &self.activation_list);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAssociationOutputBody {
    /// <p>Information about the association.</p>
    #[serde(rename = "AssociationDescription")]
    #[serde(default)]
    pub association_description: std::option::Option<crate::model::AssociationDescription>,
}
impl std::fmt::Debug for DescribeAssociationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAssociationOutputBody");
        formatter.field("association_description", &self.association_description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAssociationExecutionsOutputBody {
    /// <p>A list of the executions for the specified association ID.</p>
    #[serde(rename = "AssociationExecutions")]
    #[serde(default)]
    pub association_executions:
        std::option::Option<std::vec::Vec<crate::model::AssociationExecution>>,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeAssociationExecutionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAssociationExecutionsOutputBody");
        formatter.field("association_executions", &self.association_executions);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAssociationExecutionTargetsOutputBody {
    /// <p>Information about the execution.</p>
    #[serde(rename = "AssociationExecutionTargets")]
    #[serde(default)]
    pub association_execution_targets:
        std::option::Option<std::vec::Vec<crate::model::AssociationExecutionTarget>>,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeAssociationExecutionTargetsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAssociationExecutionTargetsOutputBody");
        formatter.field(
            "association_execution_targets",
            &self.association_execution_targets,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAutomationExecutionsOutputBody {
    /// <p>The list of details about each automation execution which has occurred which matches the
    /// filter specification, if any.</p>
    #[serde(rename = "AutomationExecutionMetadataList")]
    #[serde(default)]
    pub automation_execution_metadata_list:
        std::option::Option<std::vec::Vec<crate::model::AutomationExecutionMetadata>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeAutomationExecutionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAutomationExecutionsOutputBody");
        formatter.field(
            "automation_execution_metadata_list",
            &self.automation_execution_metadata_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAutomationStepExecutionsOutputBody {
    /// <p>A list of details about the current state of all steps that make up an execution.</p>
    #[serde(rename = "StepExecutions")]
    #[serde(default)]
    pub step_executions: std::option::Option<std::vec::Vec<crate::model::StepExecution>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeAutomationStepExecutionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAutomationStepExecutionsOutputBody");
        formatter.field("step_executions", &self.step_executions);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAvailablePatchesOutputBody {
    /// <p>An array of patches. Each entry in the array is a patch structure.</p>
    #[serde(rename = "Patches")]
    #[serde(default)]
    pub patches: std::option::Option<std::vec::Vec<crate::model::Patch>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeAvailablePatchesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAvailablePatchesOutputBody");
        formatter.field("patches", &self.patches);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDocumentOutputBody {
    /// <p>Information about the Systems Manager document.</p>
    #[serde(rename = "Document")]
    #[serde(default)]
    pub document: std::option::Option<crate::model::DocumentDescription>,
}
impl std::fmt::Debug for DescribeDocumentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDocumentOutputBody");
        formatter.field("document", &self.document);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDocumentPermissionOutputBody {
    /// <p>The account IDs that have permission to use this document. The ID can be either an AWS
    /// account or <i>All</i>.</p>
    #[serde(rename = "AccountIds")]
    #[serde(default)]
    pub account_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of AWS accounts where the current document is shared and the version shared with each
    /// account.</p>
    #[serde(rename = "AccountSharingInfoList")]
    #[serde(default)]
    pub account_sharing_info_list:
        std::option::Option<std::vec::Vec<crate::model::AccountSharingInfo>>,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeDocumentPermissionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDocumentPermissionOutputBody");
        formatter.field("account_ids", &self.account_ids);
        formatter.field("account_sharing_info_list", &self.account_sharing_info_list);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEffectiveInstanceAssociationsOutputBody {
    /// <p>The associations for the requested instance.</p>
    #[serde(rename = "Associations")]
    #[serde(default)]
    pub associations: std::option::Option<std::vec::Vec<crate::model::InstanceAssociation>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeEffectiveInstanceAssociationsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEffectiveInstanceAssociationsOutputBody");
        formatter.field("associations", &self.associations);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEffectivePatchesForPatchBaselineOutputBody {
    /// <p>An array of patches and patch status.</p>
    #[serde(rename = "EffectivePatches")]
    #[serde(default)]
    pub effective_patches: std::option::Option<std::vec::Vec<crate::model::EffectivePatch>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeEffectivePatchesForPatchBaselineOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEffectivePatchesForPatchBaselineOutputBody");
        formatter.field("effective_patches", &self.effective_patches);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInstanceAssociationsStatusOutputBody {
    /// <p>Status information about the association.</p>
    #[serde(rename = "InstanceAssociationStatusInfos")]
    #[serde(default)]
    pub instance_association_status_infos:
        std::option::Option<std::vec::Vec<crate::model::InstanceAssociationStatusInfo>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeInstanceAssociationsStatusOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInstanceAssociationsStatusOutputBody");
        formatter.field(
            "instance_association_status_infos",
            &self.instance_association_status_infos,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInstanceInformationOutputBody {
    /// <p>The instance information list.</p>
    #[serde(rename = "InstanceInformationList")]
    #[serde(default)]
    pub instance_information_list:
        std::option::Option<std::vec::Vec<crate::model::InstanceInformation>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty. </p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeInstanceInformationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInstanceInformationOutputBody");
        formatter.field("instance_information_list", &self.instance_information_list);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInstancePatchesOutputBody {
    /// <p>Each entry in the array is a structure containing:</p>
    /// <p>Title (string)</p>
    /// <p>KBId (string)</p>
    /// <p>Classification (string)</p>
    /// <p>Severity (string)</p>
    /// <p>State (string, such as "INSTALLED" or "FAILED")</p>
    /// <p>InstalledTime (DateTime)</p>
    /// <p>InstalledBy (string)</p>
    #[serde(rename = "Patches")]
    #[serde(default)]
    pub patches: std::option::Option<std::vec::Vec<crate::model::PatchComplianceData>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeInstancePatchesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInstancePatchesOutputBody");
        formatter.field("patches", &self.patches);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInstancePatchStatesOutputBody {
    /// <p>The high-level patch state for the requested instances.</p>
    #[serde(rename = "InstancePatchStates")]
    #[serde(default)]
    pub instance_patch_states: std::option::Option<std::vec::Vec<crate::model::InstancePatchState>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeInstancePatchStatesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInstancePatchStatesOutputBody");
        formatter.field("instance_patch_states", &self.instance_patch_states);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInstancePatchStatesForPatchGroupOutputBody {
    /// <p>The high-level patch state for the requested instances. </p>
    #[serde(rename = "InstancePatchStates")]
    #[serde(default)]
    pub instance_patch_states: std::option::Option<std::vec::Vec<crate::model::InstancePatchState>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeInstancePatchStatesForPatchGroupOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInstancePatchStatesForPatchGroupOutputBody");
        formatter.field("instance_patch_states", &self.instance_patch_states);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInventoryDeletionsOutputBody {
    /// <p>A list of status items for deleted inventory.</p>
    #[serde(rename = "InventoryDeletions")]
    #[serde(default)]
    pub inventory_deletions:
        std::option::Option<std::vec::Vec<crate::model::InventoryDeletionStatusItem>>,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeInventoryDeletionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInventoryDeletionsOutputBody");
        formatter.field("inventory_deletions", &self.inventory_deletions);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowExecutionsOutputBody {
    /// <p>Information about the maintenance window executions.</p>
    #[serde(rename = "WindowExecutions")]
    #[serde(default)]
    pub window_executions:
        std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowExecution>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeMaintenanceWindowExecutionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowExecutionsOutputBody");
        formatter.field("window_executions", &self.window_executions);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowExecutionTaskInvocationsOutputBody {
    /// <p>Information about the task invocation results per invocation.</p>
    #[serde(rename = "WindowExecutionTaskInvocationIdentities")]
    #[serde(default)]
    pub window_execution_task_invocation_identities: std::option::Option<
        std::vec::Vec<crate::model::MaintenanceWindowExecutionTaskInvocationIdentity>,
    >,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeMaintenanceWindowExecutionTaskInvocationsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("DescribeMaintenanceWindowExecutionTaskInvocationsOutputBody");
        formatter.field(
            "window_execution_task_invocation_identities",
            &self.window_execution_task_invocation_identities,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowExecutionTasksOutputBody {
    /// <p>Information about the task executions.</p>
    #[serde(rename = "WindowExecutionTaskIdentities")]
    #[serde(default)]
    pub window_execution_task_identities:
        std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowExecutionTaskIdentity>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeMaintenanceWindowExecutionTasksOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowExecutionTasksOutputBody");
        formatter.field(
            "window_execution_task_identities",
            &self.window_execution_task_identities,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowsOutputBody {
    /// <p>Information about the maintenance windows.</p>
    #[serde(rename = "WindowIdentities")]
    #[serde(default)]
    pub window_identities:
        std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowIdentity>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeMaintenanceWindowsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowsOutputBody");
        formatter.field("window_identities", &self.window_identities);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowScheduleOutputBody {
    /// <p>Information about maintenance window executions scheduled for the specified time
    /// range.</p>
    #[serde(rename = "ScheduledWindowExecutions")]
    #[serde(default)]
    pub scheduled_window_executions:
        std::option::Option<std::vec::Vec<crate::model::ScheduledWindowExecution>>,
    /// <p>The token for the next set of items to return. (You use this token in the next call.)</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeMaintenanceWindowScheduleOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowScheduleOutputBody");
        formatter.field(
            "scheduled_window_executions",
            &self.scheduled_window_executions,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowsForTargetOutputBody {
    /// <p>Information about the maintenance window targets and tasks an instance is associated
    /// with.</p>
    #[serde(rename = "WindowIdentities")]
    #[serde(default)]
    pub window_identities:
        std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowIdentityForTarget>>,
    /// <p>The token for the next set of items to return. (You use this token in the next call.)</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeMaintenanceWindowsForTargetOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowsForTargetOutputBody");
        formatter.field("window_identities", &self.window_identities);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowTargetsOutputBody {
    /// <p>Information about the targets in the maintenance window.</p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowTarget>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeMaintenanceWindowTargetsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowTargetsOutputBody");
        formatter.field("targets", &self.targets);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMaintenanceWindowTasksOutputBody {
    /// <p>Information about the tasks in the maintenance window.</p>
    #[serde(rename = "Tasks")]
    #[serde(default)]
    pub tasks: std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowTask>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeMaintenanceWindowTasksOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMaintenanceWindowTasksOutputBody");
        formatter.field("tasks", &self.tasks);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeOpsItemsOutputBody {
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of OpsItems.</p>
    #[serde(rename = "OpsItemSummaries")]
    #[serde(default)]
    pub ops_item_summaries: std::option::Option<std::vec::Vec<crate::model::OpsItemSummary>>,
}
impl std::fmt::Debug for DescribeOpsItemsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeOpsItemsOutputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("ops_item_summaries", &self.ops_item_summaries);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeParametersOutputBody {
    /// <p>Parameters returned by the request.</p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<std::vec::Vec<crate::model::ParameterMetadata>>,
    /// <p>The token to use when requesting the next set of items.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeParametersOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeParametersOutputBody");
        formatter.field("parameters", &self.parameters);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePatchBaselinesOutputBody {
    /// <p>An array of PatchBaselineIdentity elements.</p>
    #[serde(rename = "BaselineIdentities")]
    #[serde(default)]
    pub baseline_identities:
        std::option::Option<std::vec::Vec<crate::model::PatchBaselineIdentity>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribePatchBaselinesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePatchBaselinesOutputBody");
        formatter.field("baseline_identities", &self.baseline_identities);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePatchGroupsOutputBody {
    /// <p>Each entry in the array contains:</p>
    /// <p>PatchGroup: string (between 1 and 256 characters, Regex:
    /// ^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$)</p>
    /// <p>PatchBaselineIdentity: A PatchBaselineIdentity element. </p>
    #[serde(rename = "Mappings")]
    #[serde(default)]
    pub mappings: std::option::Option<std::vec::Vec<crate::model::PatchGroupPatchBaselineMapping>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribePatchGroupsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePatchGroupsOutputBody");
        formatter.field("mappings", &self.mappings);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePatchGroupStateOutputBody {
    /// <p>The number of instances in the patch group.</p>
    #[serde(rename = "Instances")]
    #[serde(default)]
    pub instances: i32,
    /// <p>The number of instances with installed patches.</p>
    #[serde(rename = "InstancesWithInstalledPatches")]
    #[serde(default)]
    pub instances_with_installed_patches: i32,
    /// <p>The number of instances with patches installed that aren't defined in the patch
    /// baseline.</p>
    #[serde(rename = "InstancesWithInstalledOtherPatches")]
    #[serde(default)]
    pub instances_with_installed_other_patches: i32,
    /// <p>The number of instances with patches installed by Patch Manager that have not been rebooted
    /// after the patch installation. The status of these instances is NON_COMPLIANT.</p>
    #[serde(rename = "InstancesWithInstalledPendingRebootPatches")]
    #[serde(default)]
    pub instances_with_installed_pending_reboot_patches: std::option::Option<i32>,
    /// <p>The number of instances with patches installed that are specified in a RejectedPatches list.
    /// Patches with a status of <i>INSTALLED_REJECTED</i> were typically installed before
    /// they were added to a RejectedPatches list.</p>
    /// <note>
    /// <p>If ALLOW_AS_DEPENDENCY is the specified option for RejectedPatchesAction, the value of
    /// InstancesWithInstalledRejectedPatches will always be 0 (zero).</p>
    /// </note>
    #[serde(rename = "InstancesWithInstalledRejectedPatches")]
    #[serde(default)]
    pub instances_with_installed_rejected_patches: std::option::Option<i32>,
    /// <p>The number of instances with missing patches from the patch baseline.</p>
    #[serde(rename = "InstancesWithMissingPatches")]
    #[serde(default)]
    pub instances_with_missing_patches: i32,
    /// <p>The number of instances with patches from the patch baseline that failed to install.</p>
    #[serde(rename = "InstancesWithFailedPatches")]
    #[serde(default)]
    pub instances_with_failed_patches: i32,
    /// <p>The number of instances with patches that aren't applicable.</p>
    #[serde(rename = "InstancesWithNotApplicablePatches")]
    #[serde(default)]
    pub instances_with_not_applicable_patches: i32,
    /// <p>The number of instances with <code>NotApplicable</code> patches beyond the supported limit,
    /// which are not reported by name to Systems Manager Inventory.</p>
    #[serde(rename = "InstancesWithUnreportedNotApplicablePatches")]
    #[serde(default)]
    pub instances_with_unreported_not_applicable_patches: std::option::Option<i32>,
    /// <p>The number of instances where patches that are specified as "Critical" for compliance
    /// reporting in the patch baseline are not installed. These patches might be missing, have failed
    /// installation, were rejected, or were installed but awaiting a required instance reboot. The
    /// status of these instances is <code>NON_COMPLIANT</code>.</p>
    #[serde(rename = "InstancesWithCriticalNonCompliantPatches")]
    #[serde(default)]
    pub instances_with_critical_non_compliant_patches: std::option::Option<i32>,
    /// <p>The number of instances where patches that are specified as "Security" in a patch advisory
    /// are not installed. These patches might be missing, have failed installation, were rejected, or
    /// were installed but awaiting a required instance reboot. The status of these instances is
    /// <code>NON_COMPLIANT</code>.</p>
    #[serde(rename = "InstancesWithSecurityNonCompliantPatches")]
    #[serde(default)]
    pub instances_with_security_non_compliant_patches: std::option::Option<i32>,
    /// <p>The number of instances with patches installed that are specified as other than "Critical"
    /// or "Security" but are not compliant with the patch baseline. The status of these instances is
    /// NON_COMPLIANT.</p>
    #[serde(rename = "InstancesWithOtherNonCompliantPatches")]
    #[serde(default)]
    pub instances_with_other_non_compliant_patches: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribePatchGroupStateOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePatchGroupStateOutputBody");
        formatter.field("instances", &self.instances);
        formatter.field(
            "instances_with_installed_patches",
            &self.instances_with_installed_patches,
        );
        formatter.field(
            "instances_with_installed_other_patches",
            &self.instances_with_installed_other_patches,
        );
        formatter.field(
            "instances_with_installed_pending_reboot_patches",
            &self.instances_with_installed_pending_reboot_patches,
        );
        formatter.field(
            "instances_with_installed_rejected_patches",
            &self.instances_with_installed_rejected_patches,
        );
        formatter.field(
            "instances_with_missing_patches",
            &self.instances_with_missing_patches,
        );
        formatter.field(
            "instances_with_failed_patches",
            &self.instances_with_failed_patches,
        );
        formatter.field(
            "instances_with_not_applicable_patches",
            &self.instances_with_not_applicable_patches,
        );
        formatter.field(
            "instances_with_unreported_not_applicable_patches",
            &self.instances_with_unreported_not_applicable_patches,
        );
        formatter.field(
            "instances_with_critical_non_compliant_patches",
            &self.instances_with_critical_non_compliant_patches,
        );
        formatter.field(
            "instances_with_security_non_compliant_patches",
            &self.instances_with_security_non_compliant_patches,
        );
        formatter.field(
            "instances_with_other_non_compliant_patches",
            &self.instances_with_other_non_compliant_patches,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePatchPropertiesOutputBody {
    /// <p>A list of the properties for patches matching the filter request parameters.</p>
    #[serde(rename = "Properties")]
    #[serde(default)]
    pub properties: std::option::Option<
        std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
    >,
    /// <p>The token for the next set of items to return. (You use this token in the next call.)</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribePatchPropertiesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePatchPropertiesOutputBody");
        formatter.field("properties", &self.properties);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSessionsOutputBody {
    /// <p>A list of sessions meeting the request parameters.</p>
    #[serde(rename = "Sessions")]
    #[serde(default)]
    pub sessions: std::option::Option<std::vec::Vec<crate::model::Session>>,
    /// <p>The token for the next set of items to return. (You received this token from a previous
    /// call.)</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeSessionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSessionsOutputBody");
        formatter.field("sessions", &self.sessions);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAutomationExecutionOutputBody {
    /// <p>Detailed information about the current state of an automation execution.</p>
    #[serde(rename = "AutomationExecution")]
    #[serde(default)]
    pub automation_execution: std::option::Option<crate::model::AutomationExecution>,
}
impl std::fmt::Debug for GetAutomationExecutionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAutomationExecutionOutputBody");
        formatter.field("automation_execution", &self.automation_execution);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCalendarStateOutputBody {
    /// <p>The state of the calendar. An <code>OPEN</code> calendar indicates that actions are allowed
    /// to proceed, and a <code>CLOSED</code> calendar indicates that actions are not allowed to
    /// proceed.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::CalendarState>,
    /// <p>The time, as an <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> string,
    /// that you specified in your command. If you did not specify a time, <code>GetCalendarState</code>
    /// uses the current time.</p>
    #[serde(rename = "AtTime")]
    #[serde(default)]
    pub at_time: std::option::Option<std::string::String>,
    /// <p>The time, as an <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> string,
    /// that the calendar state will change. If the current calendar state is <code>OPEN</code>,
    /// <code>NextTransitionTime</code> indicates when the calendar state changes to
    /// <code>CLOSED</code>, and vice-versa.</p>
    #[serde(rename = "NextTransitionTime")]
    #[serde(default)]
    pub next_transition_time: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetCalendarStateOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCalendarStateOutputBody");
        formatter.field("state", &self.state);
        formatter.field("at_time", &self.at_time);
        formatter.field("next_transition_time", &self.next_transition_time);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCommandInvocationOutputBody {
    /// <p>The parent command ID of the invocation plugin.</p>
    #[serde(rename = "CommandId")]
    #[serde(default)]
    pub command_id: std::option::Option<std::string::String>,
    /// <p>The ID of the managed instance targeted by the command. A managed instance can be an EC2
    /// instance or an instance in your hybrid environment that is configured for Systems Manager.</p>
    #[serde(rename = "InstanceId")]
    #[serde(default)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The comment text for the command.</p>
    #[serde(rename = "Comment")]
    #[serde(default)]
    pub comment: std::option::Option<std::string::String>,
    /// <p>The name of the document that was run. For example, <code>AWS-RunShellScript</code>.</p>
    #[serde(rename = "DocumentName")]
    #[serde(default)]
    pub document_name: std::option::Option<std::string::String>,
    /// <p>The SSM document version used in the request.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The name of the plugin, or <i>step name</i>, for which details are reported.
    /// For example, <code>aws:RunShellScript</code> is a plugin.</p>
    #[serde(rename = "PluginName")]
    #[serde(default)]
    pub plugin_name: std::option::Option<std::string::String>,
    /// <p>The error level response code for the plugin script. If the response code is
    /// <code>-1</code>, then the command has not started running on the instance, or it was not received
    /// by the instance.</p>
    #[serde(rename = "ResponseCode")]
    #[serde(default)]
    pub response_code: i32,
    /// <p>The date and time the plugin started running. Date and time are written in ISO 8601 format.
    /// For example, June 7, 2017 is represented as 2017-06-7. The following sample AWS CLI command uses
    /// the <code>InvokedBefore</code> filter.</p>
    /// <p>
    /// <code>aws ssm list-commands --filters key=InvokedBefore,value=2017-06-07T00:00:00Z</code>
    /// </p>
    /// <p>If the plugin has not started to run, the string is empty.</p>
    #[serde(rename = "ExecutionStartDateTime")]
    #[serde(default)]
    pub execution_start_date_time: std::option::Option<std::string::String>,
    /// <p>Duration since <code>ExecutionStartDateTime</code>.</p>
    #[serde(rename = "ExecutionElapsedTime")]
    #[serde(default)]
    pub execution_elapsed_time: std::option::Option<std::string::String>,
    /// <p>The date and time the plugin finished running. Date and time are written in ISO 8601 format.
    /// For example, June 7, 2017 is represented as 2017-06-7. The following sample AWS CLI command uses
    /// the <code>InvokedAfter</code> filter.</p>
    /// <p>
    /// <code>aws ssm list-commands --filters key=InvokedAfter,value=2017-06-07T00:00:00Z</code>
    /// </p>
    /// <p>If the plugin has not started to run, the string is empty.</p>
    #[serde(rename = "ExecutionEndDateTime")]
    #[serde(default)]
    pub execution_end_date_time: std::option::Option<std::string::String>,
    /// <p>The status of this invocation plugin. This status can be different than
    /// <code>StatusDetails</code>.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::CommandInvocationStatus>,
    /// <p>A detailed status of the command execution for an invocation. <code>StatusDetails</code>
    /// includes more information than <code>Status</code> because it includes states resulting from
    /// error and concurrency control parameters. <code>StatusDetails</code> can show different results
    /// than <code>Status</code>. For more information about these statuses, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding
    /// command statuses</a> in the <i>AWS Systems Manager User Guide</i>.
    /// <code>StatusDetails</code> can be one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>Pending: The command has not been sent to the instance.</p>
    /// </li>
    /// <li>
    /// <p>In Progress: The command has been sent to the instance but has not reached a terminal
    /// state.</p>
    /// </li>
    /// <li>
    /// <p>Delayed: The system attempted to send the command to the target, but the target was not
    /// available. The instance might not be available because of network issues, because the instance
    /// was stopped, or for similar reasons. The system will try to send the command again.</p>
    /// </li>
    /// <li>
    /// <p>Success: The command or plugin ran successfully. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Delivery Timed Out: The command was not delivered to the instance before the delivery
    /// timeout expired. Delivery timeouts do not count against the parent command's
    /// <code>MaxErrors</code> limit, but they do contribute to whether the parent command status is
    /// Success or Incomplete. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Execution Timed Out: The command started to run on the instance, but the execution was not
    /// complete before the timeout expired. Execution timeouts count against the
    /// <code>MaxErrors</code> limit of the parent command. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Failed: The command wasn't run successfully on the instance. For a plugin, this indicates
    /// that the result code was not zero. For a command invocation, this indicates that the result
    /// code for one or more plugins was not zero. Invocation failures count against the
    /// <code>MaxErrors</code> limit of the parent command. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Canceled: The command was terminated before it was completed. This is a terminal
    /// state.</p>
    /// </li>
    /// <li>
    /// <p>Undeliverable: The command can't be delivered to the instance. The instance might not
    /// exist or might not be responding. Undeliverable invocations don't count against the parent
    /// command's <code>MaxErrors</code> limit and don't contribute to whether the parent command
    /// status is Success or Incomplete. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Terminated: The parent command exceeded its <code>MaxErrors</code> limit and subsequent
    /// command invocations were canceled by the system. This is a terminal state.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "StatusDetails")]
    #[serde(default)]
    pub status_details: std::option::Option<std::string::String>,
    /// <p>The first 24,000 characters written by the plugin to <code>stdout</code>. If the command has
    /// not finished running, if <code>ExecutionStatus</code> is neither Succeeded nor Failed, then this
    /// string is empty.</p>
    #[serde(rename = "StandardOutputContent")]
    #[serde(default)]
    pub standard_output_content: std::option::Option<std::string::String>,
    /// <p>The URL for the complete text written by the plugin to <code>stdout</code> in Amazon Simple Storage Service
    /// (Amazon S3). If an S3 bucket was not specified, then this string is empty.</p>
    #[serde(rename = "StandardOutputUrl")]
    #[serde(default)]
    pub standard_output_url: std::option::Option<std::string::String>,
    /// <p>The first 8,000 characters written by the plugin to <code>stderr</code>. If the command has
    /// not finished running, then this string is empty.</p>
    #[serde(rename = "StandardErrorContent")]
    #[serde(default)]
    pub standard_error_content: std::option::Option<std::string::String>,
    /// <p>The URL for the complete text written by the plugin to <code>stderr</code>. If the command
    /// has not finished running, then this string is empty.</p>
    #[serde(rename = "StandardErrorUrl")]
    #[serde(default)]
    pub standard_error_url: std::option::Option<std::string::String>,
    /// <p>CloudWatch Logs information where Systems Manager sent the command output.</p>
    #[serde(rename = "CloudWatchOutputConfig")]
    #[serde(default)]
    pub cloud_watch_output_config: std::option::Option<crate::model::CloudWatchOutputConfig>,
}
impl std::fmt::Debug for GetCommandInvocationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCommandInvocationOutputBody");
        formatter.field("command_id", &self.command_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("comment", &self.comment);
        formatter.field("document_name", &self.document_name);
        formatter.field("document_version", &self.document_version);
        formatter.field("plugin_name", &self.plugin_name);
        formatter.field("response_code", &self.response_code);
        formatter.field("execution_start_date_time", &self.execution_start_date_time);
        formatter.field("execution_elapsed_time", &self.execution_elapsed_time);
        formatter.field("execution_end_date_time", &self.execution_end_date_time);
        formatter.field("status", &self.status);
        formatter.field("status_details", &self.status_details);
        formatter.field("standard_output_content", &self.standard_output_content);
        formatter.field("standard_output_url", &self.standard_output_url);
        formatter.field("standard_error_content", &self.standard_error_content);
        formatter.field("standard_error_url", &self.standard_error_url);
        formatter.field("cloud_watch_output_config", &self.cloud_watch_output_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetConnectionStatusOutputBody {
    /// <p>The ID of the instance to check connection status. </p>
    #[serde(rename = "Target")]
    #[serde(default)]
    pub target: std::option::Option<std::string::String>,
    /// <p>The status of the connection to the instance. For example, 'Connected' or 'Not
    /// Connected'.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::ConnectionStatus>,
}
impl std::fmt::Debug for GetConnectionStatusOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetConnectionStatusOutputBody");
        formatter.field("target", &self.target);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDefaultPatchBaselineOutputBody {
    /// <p>The ID of the default patch baseline.</p>
    #[serde(rename = "BaselineId")]
    #[serde(default)]
    pub baseline_id: std::option::Option<std::string::String>,
    /// <p>The operating system for the returned patch baseline. </p>
    #[serde(rename = "OperatingSystem")]
    #[serde(default)]
    pub operating_system: std::option::Option<crate::model::OperatingSystem>,
}
impl std::fmt::Debug for GetDefaultPatchBaselineOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDefaultPatchBaselineOutputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("operating_system", &self.operating_system);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDeployablePatchSnapshotForInstanceOutputBody {
    /// <p>The ID of the instance.</p>
    #[serde(rename = "InstanceId")]
    #[serde(default)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The user-defined snapshot ID.</p>
    #[serde(rename = "SnapshotId")]
    #[serde(default)]
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>A pre-signed Amazon S3 URL that can be used to download the patch snapshot.</p>
    #[serde(rename = "SnapshotDownloadUrl")]
    #[serde(default)]
    pub snapshot_download_url: std::option::Option<std::string::String>,
    /// <p>Returns the specific operating system (for example Windows Server 2012 or Amazon Linux
    /// 2015.09) on the instance for the specified patch snapshot.</p>
    #[serde(rename = "Product")]
    #[serde(default)]
    pub product: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetDeployablePatchSnapshotForInstanceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDeployablePatchSnapshotForInstanceOutputBody");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("snapshot_download_url", &self.snapshot_download_url);
        formatter.field("product", &self.product);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDocumentOutputBody {
    /// <p>The name of the Systems Manager document.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The date the Systems Manager document was created.</p>
    #[serde(rename = "CreatedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_date: std::option::Option<smithy_types::Instant>,
    /// <p>The friendly name of the Systems Manager document. This value can differ for each version of the
    /// document. If you want to update this value, see <a>UpdateDocument</a>.</p>
    #[serde(rename = "DisplayName")]
    #[serde(default)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The version of the artifact associated with the document. For example, "Release 12, Update
    /// 6". This value is unique across all versions of a document, and cannot be changed.</p>
    #[serde(rename = "VersionName")]
    #[serde(default)]
    pub version_name: std::option::Option<std::string::String>,
    /// <p>The document version.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The status of the Systems Manager document, such as <code>Creating</code>, <code>Active</code>,
    /// <code>Updating</code>, <code>Failed</code>, and <code>Deleting</code>.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::DocumentStatus>,
    /// <p>A message returned by AWS Systems Manager that explains the <code>Status</code> value. For example, a
    /// <code>Failed</code> status might be explained by the <code>StatusInformation</code> message,
    /// "The specified S3 bucket does not exist. Verify that the URL of the S3 bucket is correct."</p>
    #[serde(rename = "StatusInformation")]
    #[serde(default)]
    pub status_information: std::option::Option<std::string::String>,
    /// <p>The contents of the Systems Manager document.</p>
    #[serde(rename = "Content")]
    #[serde(default)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The document type.</p>
    #[serde(rename = "DocumentType")]
    #[serde(default)]
    pub document_type: std::option::Option<crate::model::DocumentType>,
    /// <p>The document format, either JSON or YAML.</p>
    #[serde(rename = "DocumentFormat")]
    #[serde(default)]
    pub document_format: std::option::Option<crate::model::DocumentFormat>,
    /// <p>A list of SSM documents required by a document. For example, an
    /// <code>ApplicationConfiguration</code> document requires an
    /// <code>ApplicationConfigurationSchema</code> document.</p>
    #[serde(rename = "Requires")]
    #[serde(default)]
    pub requires: std::option::Option<std::vec::Vec<crate::model::DocumentRequires>>,
    /// <p>A description of the document attachments, including names, locations, sizes, and so
    /// on.</p>
    #[serde(rename = "AttachmentsContent")]
    #[serde(default)]
    pub attachments_content: std::option::Option<std::vec::Vec<crate::model::AttachmentContent>>,
    /// <p>The current review status of a new custom Systems Manager document (SSM document) created by a member
    /// of your organization, or of the latest version of an existing SSM document.</p>
    /// <p>Only one version of an SSM document can be in the APPROVED state at a time. When a new
    /// version is approved, the status of the previous version changes to REJECTED.</p>
    /// <p>Only one version of an SSM document can be in review, or PENDING, at a time.</p>
    #[serde(rename = "ReviewStatus")]
    #[serde(default)]
    pub review_status: std::option::Option<crate::model::ReviewStatus>,
}
impl std::fmt::Debug for GetDocumentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDocumentOutputBody");
        formatter.field("name", &self.name);
        formatter.field("created_date", &self.created_date);
        formatter.field("display_name", &self.display_name);
        formatter.field("version_name", &self.version_name);
        formatter.field("document_version", &self.document_version);
        formatter.field("status", &self.status);
        formatter.field("status_information", &self.status_information);
        formatter.field("content", &self.content);
        formatter.field("document_type", &self.document_type);
        formatter.field("document_format", &self.document_format);
        formatter.field("requires", &self.requires);
        formatter.field("attachments_content", &self.attachments_content);
        formatter.field("review_status", &self.review_status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInventoryOutputBody {
    /// <p>Collection of inventory entities such as a collection of instance inventory. </p>
    #[serde(rename = "Entities")]
    #[serde(default)]
    pub entities: std::option::Option<std::vec::Vec<crate::model::InventoryResultEntity>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetInventoryOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInventoryOutputBody");
        formatter.field("entities", &self.entities);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInventorySchemaOutputBody {
    /// <p>Inventory schemas returned by the request.</p>
    #[serde(rename = "Schemas")]
    #[serde(default)]
    pub schemas: std::option::Option<std::vec::Vec<crate::model::InventoryItemSchema>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetInventorySchemaOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInventorySchemaOutputBody");
        formatter.field("schemas", &self.schemas);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMaintenanceWindowOutputBody {
    /// <p>The ID of the created maintenance window.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
    /// <p>The name of the maintenance window.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the maintenance window.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
    /// to become active. The maintenance window will not run before this specified time.</p>
    #[serde(rename = "StartDate")]
    #[serde(default)]
    pub start_date: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
    /// to become inactive. The maintenance window will not run after this specified time.</p>
    #[serde(rename = "EndDate")]
    #[serde(default)]
    pub end_date: std::option::Option<std::string::String>,
    /// <p>The schedule of the maintenance window in the form of a cron or rate expression.</p>
    #[serde(rename = "Schedule")]
    #[serde(default)]
    pub schedule: std::option::Option<std::string::String>,
    /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
    /// Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or
    /// "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time
    /// Zone Database</a> on the IANA website.</p>
    #[serde(rename = "ScheduleTimezone")]
    #[serde(default)]
    pub schedule_timezone: std::option::Option<std::string::String>,
    /// <p>The number of days to wait to run a maintenance window after the scheduled CRON expression
    /// date and time.</p>
    #[serde(rename = "ScheduleOffset")]
    #[serde(default)]
    pub schedule_offset: std::option::Option<i32>,
    /// <p>The next time the maintenance window will actually run, taking into account any specified
    /// times for the maintenance window to become active or inactive.</p>
    #[serde(rename = "NextExecutionTime")]
    #[serde(default)]
    pub next_execution_time: std::option::Option<std::string::String>,
    /// <p>The duration of the maintenance window in hours.</p>
    #[serde(rename = "Duration")]
    #[serde(default)]
    pub duration: i32,
    /// <p>The number of hours before the end of the maintenance window that Systems Manager stops scheduling new
    /// tasks for execution.</p>
    #[serde(rename = "Cutoff")]
    #[serde(default)]
    pub cutoff: i32,
    /// <p>Whether targets must be registered with the maintenance window before tasks can be defined
    /// for those targets.</p>
    #[serde(rename = "AllowUnassociatedTargets")]
    #[serde(default)]
    pub allow_unassociated_targets: bool,
    /// <p>Indicates whether the maintenance window is enabled.</p>
    #[serde(rename = "Enabled")]
    #[serde(default)]
    pub enabled: bool,
    /// <p>The date the maintenance window was created.</p>
    #[serde(rename = "CreatedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_date: std::option::Option<smithy_types::Instant>,
    /// <p>The date the maintenance window was last modified.</p>
    #[serde(rename = "ModifiedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub modified_date: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for GetMaintenanceWindowOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMaintenanceWindowOutputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("start_date", &self.start_date);
        formatter.field("end_date", &self.end_date);
        formatter.field("schedule", &self.schedule);
        formatter.field("schedule_timezone", &self.schedule_timezone);
        formatter.field("schedule_offset", &self.schedule_offset);
        formatter.field("next_execution_time", &self.next_execution_time);
        formatter.field("duration", &self.duration);
        formatter.field("cutoff", &self.cutoff);
        formatter.field(
            "allow_unassociated_targets",
            &self.allow_unassociated_targets,
        );
        formatter.field("enabled", &self.enabled);
        formatter.field("created_date", &self.created_date);
        formatter.field("modified_date", &self.modified_date);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMaintenanceWindowExecutionOutputBody {
    /// <p>The ID of the maintenance window execution.</p>
    #[serde(rename = "WindowExecutionId")]
    #[serde(default)]
    pub window_execution_id: std::option::Option<std::string::String>,
    /// <p>The ID of the task executions from the maintenance window execution.</p>
    #[serde(rename = "TaskIds")]
    #[serde(default)]
    pub task_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The status of the maintenance window execution.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::MaintenanceWindowExecutionStatus>,
    /// <p>The details explaining the Status. Only available for certain status values.</p>
    #[serde(rename = "StatusDetails")]
    #[serde(default)]
    pub status_details: std::option::Option<std::string::String>,
    /// <p>The time the maintenance window started running.</p>
    #[serde(rename = "StartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the maintenance window finished running.</p>
    #[serde(rename = "EndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub end_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for GetMaintenanceWindowExecutionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMaintenanceWindowExecutionOutputBody");
        formatter.field("window_execution_id", &self.window_execution_id);
        formatter.field("task_ids", &self.task_ids);
        formatter.field("status", &self.status);
        formatter.field("status_details", &self.status_details);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMaintenanceWindowExecutionTaskOutputBody {
    /// <p>The ID of the maintenance window execution that includes the task.</p>
    #[serde(rename = "WindowExecutionId")]
    #[serde(default)]
    pub window_execution_id: std::option::Option<std::string::String>,
    /// <p>The ID of the specific task execution in the maintenance window task that was
    /// retrieved.</p>
    #[serde(rename = "TaskExecutionId")]
    #[serde(default)]
    pub task_execution_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the task that ran.</p>
    #[serde(rename = "TaskArn")]
    #[serde(default)]
    pub task_arn: std::option::Option<std::string::String>,
    /// <p>The role that was assumed when running the task.</p>
    #[serde(rename = "ServiceRole")]
    #[serde(default)]
    pub service_role: std::option::Option<std::string::String>,
    /// <p>The type of task that was run.</p>
    #[serde(rename = "Type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::MaintenanceWindowTaskType>,
    /// <p>The parameters passed to the task when it was run.</p>
    /// <note>
    /// <p>
    /// <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    /// instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    /// about how Systems Manager handles these options for the supported maintenance window task
    /// types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    /// </note>
    /// <p>The map has the following format:</p>
    /// <p>Key: string, between 1 and 255 characters</p>
    /// <p>Value: an array of strings, each string is between 1 and 255 characters</p>
    #[serde(rename = "TaskParameters")]
    #[serde(default)]
    pub task_parameters: std::option::Option<
        std::vec::Vec<
            std::collections::HashMap<
                std::string::String,
                crate::model::MaintenanceWindowTaskParameterValueExpression,
            >,
        >,
    >,
    /// <p>The priority of the task.</p>
    #[serde(rename = "Priority")]
    #[serde(default)]
    pub priority: i32,
    /// <p>The defined maximum number of task executions that could be run in parallel.</p>
    #[serde(rename = "MaxConcurrency")]
    #[serde(default)]
    pub max_concurrency: std::option::Option<std::string::String>,
    /// <p>The defined maximum number of task execution errors allowed before scheduling of the task
    /// execution would have been stopped.</p>
    #[serde(rename = "MaxErrors")]
    #[serde(default)]
    pub max_errors: std::option::Option<std::string::String>,
    /// <p>The status of the task.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::MaintenanceWindowExecutionStatus>,
    /// <p>The details explaining the Status. Only available for certain status values.</p>
    #[serde(rename = "StatusDetails")]
    #[serde(default)]
    pub status_details: std::option::Option<std::string::String>,
    /// <p>The time the task execution started.</p>
    #[serde(rename = "StartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the task execution completed.</p>
    #[serde(rename = "EndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub end_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for GetMaintenanceWindowExecutionTaskOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMaintenanceWindowExecutionTaskOutputBody");
        formatter.field("window_execution_id", &self.window_execution_id);
        formatter.field("task_execution_id", &self.task_execution_id);
        formatter.field("task_arn", &self.task_arn);
        formatter.field("service_role", &self.service_role);
        formatter.field("r#type", &self.r#type);
        formatter.field("task_parameters", &"*** Sensitive Data Redacted ***");
        formatter.field("priority", &self.priority);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("status", &self.status);
        formatter.field("status_details", &self.status_details);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMaintenanceWindowExecutionTaskInvocationOutputBody {
    /// <p>The maintenance window execution ID.</p>
    #[serde(rename = "WindowExecutionId")]
    #[serde(default)]
    pub window_execution_id: std::option::Option<std::string::String>,
    /// <p>The task execution ID.</p>
    #[serde(rename = "TaskExecutionId")]
    #[serde(default)]
    pub task_execution_id: std::option::Option<std::string::String>,
    /// <p>The invocation ID.</p>
    #[serde(rename = "InvocationId")]
    #[serde(default)]
    pub invocation_id: std::option::Option<std::string::String>,
    /// <p>The execution ID.</p>
    #[serde(rename = "ExecutionId")]
    #[serde(default)]
    pub execution_id: std::option::Option<std::string::String>,
    /// <p>Retrieves the task type for a maintenance window. Task types include the following: LAMBDA,
    /// STEP_FUNCTIONS, AUTOMATION, RUN_COMMAND.</p>
    #[serde(rename = "TaskType")]
    #[serde(default)]
    pub task_type: std::option::Option<crate::model::MaintenanceWindowTaskType>,
    /// <p>The parameters used at the time that the task ran.</p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<std::string::String>,
    /// <p>The task status for an invocation.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::MaintenanceWindowExecutionStatus>,
    /// <p>The details explaining the status. Details are only available for certain status
    /// values.</p>
    #[serde(rename = "StatusDetails")]
    #[serde(default)]
    pub status_details: std::option::Option<std::string::String>,
    /// <p>The time that the task started running on the target.</p>
    #[serde(rename = "StartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time that the task finished running on the target.</p>
    #[serde(rename = "EndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>User-provided value to be included in any CloudWatch events raised while running tasks for
    /// these targets in this maintenance window. </p>
    #[serde(rename = "OwnerInformation")]
    #[serde(default)]
    pub owner_information: std::option::Option<std::string::String>,
    /// <p>The maintenance window target ID.</p>
    #[serde(rename = "WindowTargetId")]
    #[serde(default)]
    pub window_target_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetMaintenanceWindowExecutionTaskInvocationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMaintenanceWindowExecutionTaskInvocationOutputBody");
        formatter.field("window_execution_id", &self.window_execution_id);
        formatter.field("task_execution_id", &self.task_execution_id);
        formatter.field("invocation_id", &self.invocation_id);
        formatter.field("execution_id", &self.execution_id);
        formatter.field("task_type", &self.task_type);
        formatter.field("parameters", &"*** Sensitive Data Redacted ***");
        formatter.field("status", &self.status);
        formatter.field("status_details", &self.status_details);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("owner_information", &"*** Sensitive Data Redacted ***");
        formatter.field("window_target_id", &self.window_target_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMaintenanceWindowTaskOutputBody {
    /// <p>The retrieved maintenance window ID.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
    /// <p>The retrieved maintenance window task ID.</p>
    #[serde(rename = "WindowTaskId")]
    #[serde(default)]
    pub window_task_id: std::option::Option<std::string::String>,
    /// <p>The targets where the task should run.</p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The resource that the task used during execution. For RUN_COMMAND and AUTOMATION task types,
    /// the TaskArn is the Systems Manager Document name/ARN. For LAMBDA tasks, the value is the function name/ARN.
    /// For STEP_FUNCTIONS tasks, the value is the state machine ARN.</p>
    #[serde(rename = "TaskArn")]
    #[serde(default)]
    pub task_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for
    /// maintenance window Run Command tasks.</p>
    #[serde(rename = "ServiceRoleArn")]
    #[serde(default)]
    pub service_role_arn: std::option::Option<std::string::String>,
    /// <p>The type of task to run.</p>
    #[serde(rename = "TaskType")]
    #[serde(default)]
    pub task_type: std::option::Option<crate::model::MaintenanceWindowTaskType>,
    /// <p>The parameters to pass to the task when it runs.</p>
    /// <note>
    /// <p>
    /// <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    /// instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    /// about how Systems Manager handles these options for the supported maintenance window task
    /// types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    /// </note>
    #[serde(rename = "TaskParameters")]
    #[serde(default)]
    pub task_parameters: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            crate::model::MaintenanceWindowTaskParameterValueExpression,
        >,
    >,
    /// <p>The parameters to pass to the task when it runs.</p>
    #[serde(rename = "TaskInvocationParameters")]
    #[serde(default)]
    pub task_invocation_parameters:
        std::option::Option<crate::model::MaintenanceWindowTaskInvocationParameters>,
    /// <p>The priority of the task when it runs. The lower the number, the higher the priority. Tasks
    /// that have the same priority are scheduled in parallel.</p>
    #[serde(rename = "Priority")]
    #[serde(default)]
    pub priority: i32,
    /// <p>The maximum number of targets allowed to run this task in parallel.</p>
    /// <note>
    /// <p>For maintenance window tasks without a target specified, you cannot supply a value for this
    /// option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported
    /// in the response to this command. This value does not affect the running of your task and can be
    /// ignored.</p>
    /// </note>
    #[serde(rename = "MaxConcurrency")]
    #[serde(default)]
    pub max_concurrency: std::option::Option<std::string::String>,
    /// <p>The maximum number of errors allowed before the task stops being scheduled.</p>
    /// <note>
    /// <p>For maintenance window tasks without a target specified, you cannot supply a value for this
    /// option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported
    /// in the response to this command. This value does not affect the running of your task and can be
    /// ignored.</p>
    /// </note>
    #[serde(rename = "MaxErrors")]
    #[serde(default)]
    pub max_errors: std::option::Option<std::string::String>,
    /// <p>The location in Amazon S3 where the task results are logged.</p>
    /// <note>
    /// <p>
    /// <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
    /// <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
    /// For information about how Systems Manager handles these options for the supported maintenance
    /// window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    /// </note>
    #[serde(rename = "LoggingInfo")]
    #[serde(default)]
    pub logging_info: std::option::Option<crate::model::LoggingInfo>,
    /// <p>The retrieved task name.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The retrieved task description.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetMaintenanceWindowTaskOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMaintenanceWindowTaskOutputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_task_id", &self.window_task_id);
        formatter.field("targets", &self.targets);
        formatter.field("task_arn", &self.task_arn);
        formatter.field("service_role_arn", &self.service_role_arn);
        formatter.field("task_type", &self.task_type);
        formatter.field("task_parameters", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "task_invocation_parameters",
            &self.task_invocation_parameters,
        );
        formatter.field("priority", &self.priority);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("logging_info", &self.logging_info);
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetOpsItemOutputBody {
    /// <p>The OpsItem.</p>
    #[serde(rename = "OpsItem")]
    #[serde(default)]
    pub ops_item: std::option::Option<crate::model::OpsItem>,
}
impl std::fmt::Debug for GetOpsItemOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetOpsItemOutputBody");
        formatter.field("ops_item", &self.ops_item);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetOpsMetadataOutputBody {
    /// <p>The resource ID of the Application Manager application.</p>
    #[serde(rename = "ResourceId")]
    #[serde(default)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>OpsMetadata for an Application Manager application.</p>
    #[serde(rename = "Metadata")]
    #[serde(default)]
    pub metadata: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::MetadataValue>,
    >,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetOpsMetadataOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetOpsMetadataOutputBody");
        formatter.field("resource_id", &self.resource_id);
        formatter.field("metadata", &self.metadata);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetOpsSummaryOutputBody {
    /// <p>The list of aggregated and filtered OpsItems.</p>
    #[serde(rename = "Entities")]
    #[serde(default)]
    pub entities: std::option::Option<std::vec::Vec<crate::model::OpsEntity>>,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetOpsSummaryOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetOpsSummaryOutputBody");
        formatter.field("entities", &self.entities);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetParameterOutputBody {
    /// <p>Information about a parameter.</p>
    #[serde(rename = "Parameter")]
    #[serde(default)]
    pub parameter: std::option::Option<crate::model::Parameter>,
}
impl std::fmt::Debug for GetParameterOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetParameterOutputBody");
        formatter.field("parameter", &self.parameter);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetParameterHistoryOutputBody {
    /// <p>A list of parameters returned by the request.</p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<std::vec::Vec<crate::model::ParameterHistory>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetParameterHistoryOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetParameterHistoryOutputBody");
        formatter.field("parameters", &self.parameters);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetParametersOutputBody {
    /// <p>A list of details for a parameter.</p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
    /// <p>A list of parameters that are not formatted correctly or do not run during an
    /// execution.</p>
    #[serde(rename = "InvalidParameters")]
    #[serde(default)]
    pub invalid_parameters: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for GetParametersOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetParametersOutputBody");
        formatter.field("parameters", &self.parameters);
        formatter.field("invalid_parameters", &self.invalid_parameters);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetParametersByPathOutputBody {
    /// <p>A list of parameters found in the specified hierarchy.</p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetParametersByPathOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetParametersByPathOutputBody");
        formatter.field("parameters", &self.parameters);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPatchBaselineOutputBody {
    /// <p>The ID of the retrieved patch baseline.</p>
    #[serde(rename = "BaselineId")]
    #[serde(default)]
    pub baseline_id: std::option::Option<std::string::String>,
    /// <p>The name of the patch baseline.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Returns the operating system specified for the patch baseline.</p>
    #[serde(rename = "OperatingSystem")]
    #[serde(default)]
    pub operating_system: std::option::Option<crate::model::OperatingSystem>,
    /// <p>A set of global filters used to exclude patches from the baseline.</p>
    #[serde(rename = "GlobalFilters")]
    #[serde(default)]
    pub global_filters: std::option::Option<crate::model::PatchFilterGroup>,
    /// <p>A set of rules used to include patches in the baseline.</p>
    #[serde(rename = "ApprovalRules")]
    #[serde(default)]
    pub approval_rules: std::option::Option<crate::model::PatchRuleGroup>,
    /// <p>A list of explicitly approved patches for the baseline.</p>
    #[serde(rename = "ApprovedPatches")]
    #[serde(default)]
    pub approved_patches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Returns the specified compliance severity level for approved patches in the patch
    /// baseline.</p>
    #[serde(rename = "ApprovedPatchesComplianceLevel")]
    #[serde(default)]
    pub approved_patches_compliance_level: std::option::Option<crate::model::PatchComplianceLevel>,
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be
    /// applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
    #[serde(rename = "ApprovedPatchesEnableNonSecurity")]
    #[serde(default)]
    pub approved_patches_enable_non_security: std::option::Option<bool>,
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    #[serde(rename = "RejectedPatches")]
    #[serde(default)]
    pub rejected_patches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The action specified to take on patches included in the RejectedPatches list. A patch can be
    /// allowed only if it is a dependency of another package, or blocked entirely along with packages
    /// that include it as a dependency.</p>
    #[serde(rename = "RejectedPatchesAction")]
    #[serde(default)]
    pub rejected_patches_action: std::option::Option<crate::model::PatchAction>,
    /// <p>Patch groups included in the patch baseline.</p>
    #[serde(rename = "PatchGroups")]
    #[serde(default)]
    pub patch_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The date the patch baseline was created.</p>
    #[serde(rename = "CreatedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_date: std::option::Option<smithy_types::Instant>,
    /// <p>The date the patch baseline was last modified.</p>
    #[serde(rename = "ModifiedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub modified_date: std::option::Option<smithy_types::Instant>,
    /// <p>A description of the patch baseline.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Information about the patches to use to update the instances, including target operating
    /// systems and source repositories. Applies to Linux instances only.</p>
    #[serde(rename = "Sources")]
    #[serde(default)]
    pub sources: std::option::Option<std::vec::Vec<crate::model::PatchSource>>,
}
impl std::fmt::Debug for GetPatchBaselineOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPatchBaselineOutputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("name", &self.name);
        formatter.field("operating_system", &self.operating_system);
        formatter.field("global_filters", &self.global_filters);
        formatter.field("approval_rules", &self.approval_rules);
        formatter.field("approved_patches", &self.approved_patches);
        formatter.field(
            "approved_patches_compliance_level",
            &self.approved_patches_compliance_level,
        );
        formatter.field(
            "approved_patches_enable_non_security",
            &self.approved_patches_enable_non_security,
        );
        formatter.field("rejected_patches", &self.rejected_patches);
        formatter.field("rejected_patches_action", &self.rejected_patches_action);
        formatter.field("patch_groups", &self.patch_groups);
        formatter.field("created_date", &self.created_date);
        formatter.field("modified_date", &self.modified_date);
        formatter.field("description", &self.description);
        formatter.field("sources", &self.sources);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPatchBaselineForPatchGroupOutputBody {
    /// <p>The ID of the patch baseline that should be used for the patch group.</p>
    #[serde(rename = "BaselineId")]
    #[serde(default)]
    pub baseline_id: std::option::Option<std::string::String>,
    /// <p>The name of the patch group.</p>
    #[serde(rename = "PatchGroup")]
    #[serde(default)]
    pub patch_group: std::option::Option<std::string::String>,
    /// <p>The operating system rule specified for patch groups using the patch baseline.</p>
    #[serde(rename = "OperatingSystem")]
    #[serde(default)]
    pub operating_system: std::option::Option<crate::model::OperatingSystem>,
}
impl std::fmt::Debug for GetPatchBaselineForPatchGroupOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPatchBaselineForPatchGroupOutputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("patch_group", &self.patch_group);
        formatter.field("operating_system", &self.operating_system);
        formatter.finish()
    }
}

/// <p>The query result body of the GetServiceSetting API action.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetServiceSettingOutputBody {
    /// <p>The query result of the current service setting.</p>
    #[serde(rename = "ServiceSetting")]
    #[serde(default)]
    pub service_setting: std::option::Option<crate::model::ServiceSetting>,
}
impl std::fmt::Debug for GetServiceSettingOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetServiceSettingOutputBody");
        formatter.field("service_setting", &self.service_setting);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelParameterVersionOutputBody {
    /// <p>The label does not meet the requirements. For information about parameter label
    /// requirements, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html">Labeling parameters</a>
    /// in the <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "InvalidLabels")]
    #[serde(default)]
    pub invalid_labels: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The version of the parameter that has been labeled.</p>
    #[serde(rename = "ParameterVersion")]
    #[serde(default)]
    pub parameter_version: i64,
}
impl std::fmt::Debug for LabelParameterVersionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelParameterVersionOutputBody");
        formatter.field("invalid_labels", &self.invalid_labels);
        formatter.field("parameter_version", &self.parameter_version);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAssociationsOutputBody {
    /// <p>The associations.</p>
    #[serde(rename = "Associations")]
    #[serde(default)]
    pub associations: std::option::Option<std::vec::Vec<crate::model::Association>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListAssociationsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAssociationsOutputBody");
        formatter.field("associations", &self.associations);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAssociationVersionsOutputBody {
    /// <p>Information about all versions of the association for the specified association ID.</p>
    #[serde(rename = "AssociationVersions")]
    #[serde(default)]
    pub association_versions:
        std::option::Option<std::vec::Vec<crate::model::AssociationVersionInfo>>,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListAssociationVersionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAssociationVersionsOutputBody");
        formatter.field("association_versions", &self.association_versions);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCommandInvocationsOutputBody {
    /// <p>(Optional) A list of all invocations. </p>
    #[serde(rename = "CommandInvocations")]
    #[serde(default)]
    pub command_invocations: std::option::Option<std::vec::Vec<crate::model::CommandInvocation>>,
    /// <p>(Optional) The token for the next set of items to return. (You received this token from a
    /// previous call.)</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListCommandInvocationsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCommandInvocationsOutputBody");
        formatter.field("command_invocations", &self.command_invocations);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCommandsOutputBody {
    /// <p>(Optional) The list of commands requested by the user. </p>
    #[serde(rename = "Commands")]
    #[serde(default)]
    pub commands: std::option::Option<std::vec::Vec<crate::model::Command>>,
    /// <p>(Optional) The token for the next set of items to return. (You received this token from a
    /// previous call.)</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListCommandsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCommandsOutputBody");
        formatter.field("commands", &self.commands);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListComplianceItemsOutputBody {
    /// <p>A list of compliance information for the specified resource ID. </p>
    #[serde(rename = "ComplianceItems")]
    #[serde(default)]
    pub compliance_items: std::option::Option<std::vec::Vec<crate::model::ComplianceItem>>,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListComplianceItemsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListComplianceItemsOutputBody");
        formatter.field("compliance_items", &self.compliance_items);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListComplianceSummariesOutputBody {
    /// <p>A list of compliant and non-compliant summary counts based on compliance types. For example,
    /// this call returns State Manager associations, patches, or custom compliance types according to
    /// the filter criteria that you specified.</p>
    #[serde(rename = "ComplianceSummaryItems")]
    #[serde(default)]
    pub compliance_summary_items:
        std::option::Option<std::vec::Vec<crate::model::ComplianceSummaryItem>>,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListComplianceSummariesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListComplianceSummariesOutputBody");
        formatter.field("compliance_summary_items", &self.compliance_summary_items);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDocumentMetadataHistoryOutputBody {
    /// <p>The name of the document.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The version of the document.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The user ID of the person in the organization who requested the document review.</p>
    #[serde(rename = "Author")]
    #[serde(default)]
    pub author: std::option::Option<std::string::String>,
    /// <p>Information about the response to the document approval request.</p>
    #[serde(rename = "Metadata")]
    #[serde(default)]
    pub metadata: std::option::Option<crate::model::DocumentMetadataResponseInfo>,
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    /// can specify in a subsequent call to get the next set of results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDocumentMetadataHistoryOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDocumentMetadataHistoryOutputBody");
        formatter.field("name", &self.name);
        formatter.field("document_version", &self.document_version);
        formatter.field("author", &self.author);
        formatter.field("metadata", &self.metadata);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDocumentsOutputBody {
    /// <p>The names of the Systems Manager documents.</p>
    #[serde(rename = "DocumentIdentifiers")]
    #[serde(default)]
    pub document_identifiers: std::option::Option<std::vec::Vec<crate::model::DocumentIdentifier>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDocumentsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDocumentsOutputBody");
        formatter.field("document_identifiers", &self.document_identifiers);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDocumentVersionsOutputBody {
    /// <p>The document versions.</p>
    #[serde(rename = "DocumentVersions")]
    #[serde(default)]
    pub document_versions: std::option::Option<std::vec::Vec<crate::model::DocumentVersionInfo>>,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDocumentVersionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDocumentVersionsOutputBody");
        formatter.field("document_versions", &self.document_versions);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListInventoryEntriesOutputBody {
    /// <p>The type of inventory item returned by the request.</p>
    #[serde(rename = "TypeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
    /// <p>The instance ID targeted by the request to query inventory information.</p>
    #[serde(rename = "InstanceId")]
    #[serde(default)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The inventory schema version used by the instance(s).</p>
    #[serde(rename = "SchemaVersion")]
    #[serde(default)]
    pub schema_version: std::option::Option<std::string::String>,
    /// <p>The time that inventory information was collected for the instance(s).</p>
    #[serde(rename = "CaptureTime")]
    #[serde(default)]
    pub capture_time: std::option::Option<std::string::String>,
    /// <p>A list of inventory items on the instance(s).</p>
    #[serde(rename = "Entries")]
    #[serde(default)]
    pub entries: std::option::Option<
        std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
    >,
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    /// return, the string is empty.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListInventoryEntriesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListInventoryEntriesOutputBody");
        formatter.field("type_name", &self.type_name);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("schema_version", &self.schema_version);
        formatter.field("capture_time", &self.capture_time);
        formatter.field("entries", &self.entries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOpsItemEventsOutputBody {
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results. </p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of event information for the specified OpsItems.</p>
    #[serde(rename = "Summaries")]
    #[serde(default)]
    pub summaries: std::option::Option<std::vec::Vec<crate::model::OpsItemEventSummary>>,
}
impl std::fmt::Debug for ListOpsItemEventsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOpsItemEventsOutputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("summaries", &self.summaries);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOpsItemRelatedItemsOutputBody {
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of related-item resources for the specified OpsItem.</p>
    #[serde(rename = "Summaries")]
    #[serde(default)]
    pub summaries: std::option::Option<std::vec::Vec<crate::model::OpsItemRelatedItemSummary>>,
}
impl std::fmt::Debug for ListOpsItemRelatedItemsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOpsItemRelatedItemsOutputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("summaries", &self.summaries);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOpsMetadataOutputBody {
    /// <p>Returns a list of OpsMetadata objects.</p>
    #[serde(rename = "OpsMetadataList")]
    #[serde(default)]
    pub ops_metadata_list: std::option::Option<std::vec::Vec<crate::model::OpsMetadata>>,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListOpsMetadataOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOpsMetadataOutputBody");
        formatter.field("ops_metadata_list", &self.ops_metadata_list);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListResourceComplianceSummariesOutputBody {
    /// <p>A summary count for specified or targeted managed instances. Summary count includes
    /// information about compliant and non-compliant State Manager associations, patch status, or custom
    /// items according to the filter criteria that you specify. </p>
    #[serde(rename = "ResourceComplianceSummaryItems")]
    #[serde(default)]
    pub resource_compliance_summary_items:
        std::option::Option<std::vec::Vec<crate::model::ResourceComplianceSummaryItem>>,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListResourceComplianceSummariesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListResourceComplianceSummariesOutputBody");
        formatter.field(
            "resource_compliance_summary_items",
            &self.resource_compliance_summary_items,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListResourceDataSyncOutputBody {
    /// <p>A list of your current Resource Data Sync configurations and their statuses.</p>
    #[serde(rename = "ResourceDataSyncItems")]
    #[serde(default)]
    pub resource_data_sync_items:
        std::option::Option<std::vec::Vec<crate::model::ResourceDataSyncItem>>,
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    /// results.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListResourceDataSyncOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListResourceDataSyncOutputBody");
        formatter.field("resource_data_sync_items", &self.resource_data_sync_items);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutputBody {
    /// <p>A list of tags.</p>
    #[serde(rename = "TagList")]
    #[serde(default)]
    pub tag_list: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ListTagsForResourceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutputBody");
        formatter.field("tag_list", &self.tag_list);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutInventoryOutputBody {
    /// <p>Information about the request.</p>
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutInventoryOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutInventoryOutputBody");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutParameterOutputBody {
    /// <p>The new version number of a parameter. If you edit a parameter value, Parameter Store
    /// automatically creates a new version and assigns this new version a unique ID. You can reference a
    /// parameter version ID in API actions or in Systems Manager documents (SSM documents). By default, if you
    /// don't specify a specific version, the system returns the latest parameter value when a parameter
    /// is called.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: i64,
    /// <p>The tier assigned to the parameter.</p>
    #[serde(rename = "Tier")]
    #[serde(default)]
    pub tier: std::option::Option<crate::model::ParameterTier>,
}
impl std::fmt::Debug for PutParameterOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutParameterOutputBody");
        formatter.field("version", &self.version);
        formatter.field("tier", &self.tier);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterDefaultPatchBaselineOutputBody {
    /// <p>The ID of the default patch baseline.</p>
    #[serde(rename = "BaselineId")]
    #[serde(default)]
    pub baseline_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RegisterDefaultPatchBaselineOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterDefaultPatchBaselineOutputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterPatchBaselineForPatchGroupOutputBody {
    /// <p>The ID of the patch baseline the patch group was registered with.</p>
    #[serde(rename = "BaselineId")]
    #[serde(default)]
    pub baseline_id: std::option::Option<std::string::String>,
    /// <p>The name of the patch group registered with the patch baseline.</p>
    #[serde(rename = "PatchGroup")]
    #[serde(default)]
    pub patch_group: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RegisterPatchBaselineForPatchGroupOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterPatchBaselineForPatchGroupOutputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("patch_group", &self.patch_group);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterTargetWithMaintenanceWindowOutputBody {
    /// <p>The ID of the target definition in this maintenance window.</p>
    #[serde(rename = "WindowTargetId")]
    #[serde(default)]
    pub window_target_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RegisterTargetWithMaintenanceWindowOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterTargetWithMaintenanceWindowOutputBody");
        formatter.field("window_target_id", &self.window_target_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterTaskWithMaintenanceWindowOutputBody {
    /// <p>The ID of the task in the maintenance window.</p>
    #[serde(rename = "WindowTaskId")]
    #[serde(default)]
    pub window_task_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RegisterTaskWithMaintenanceWindowOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterTaskWithMaintenanceWindowOutputBody");
        formatter.field("window_task_id", &self.window_task_id);
        formatter.finish()
    }
}

/// <p>The result body of the ResetServiceSetting API action.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResetServiceSettingOutputBody {
    /// <p>The current, effective service setting after calling the ResetServiceSetting API
    /// action.</p>
    #[serde(rename = "ServiceSetting")]
    #[serde(default)]
    pub service_setting: std::option::Option<crate::model::ServiceSetting>,
}
impl std::fmt::Debug for ResetServiceSettingOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResetServiceSettingOutputBody");
        formatter.field("service_setting", &self.service_setting);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResumeSessionOutputBody {
    /// <p>The ID of the session.</p>
    #[serde(rename = "SessionId")]
    #[serde(default)]
    pub session_id: std::option::Option<std::string::String>,
    /// <p>An encrypted token value containing session and caller information. Used to authenticate the
    /// connection to the instance.</p>
    #[serde(rename = "TokenValue")]
    #[serde(default)]
    pub token_value: std::option::Option<std::string::String>,
    /// <p>A URL back to SSM Agent on the instance that the Session Manager client uses to send commands and
    /// receive output from the instance. Format: <code>wss://ssmmessages.<b>region</b>.amazonaws.com/v1/data-channel/<b>session-id</b>?stream=(input|output)</code>.</p>
    /// <p>
    /// <b>region</b> represents the Region identifier for an
    /// AWS Region supported by AWS Systems Manager, such as <code>us-east-2</code> for the US East (Ohio) Region.
    /// For a list of supported <b>region</b> values, see the <b>Region</b> column in <a href="http://docs.aws.amazon.com/general/latest/gr/ssm.html#ssm_region">Systems Manager service endpoints</a> in the
    /// <i>AWS General Reference</i>.</p>
    /// <p>
    /// <b>session-id</b> represents the ID of a Session Manager session, such as
    /// <code>1a2b3c4dEXAMPLE</code>.</p>
    #[serde(rename = "StreamUrl")]
    #[serde(default)]
    pub stream_url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResumeSessionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResumeSessionOutputBody");
        formatter.field("session_id", &self.session_id);
        formatter.field("token_value", &self.token_value);
        formatter.field("stream_url", &self.stream_url);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SendCommandOutputBody {
    /// <p>The request as it was received by Systems Manager. Also provides the command ID which can be used
    /// future references to this request.</p>
    #[serde(rename = "Command")]
    #[serde(default)]
    pub command: std::option::Option<crate::model::Command>,
}
impl std::fmt::Debug for SendCommandOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendCommandOutputBody");
        formatter.field("command", &self.command);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StartAutomationExecutionOutputBody {
    /// <p>The unique ID of a newly scheduled automation execution.</p>
    #[serde(rename = "AutomationExecutionId")]
    #[serde(default)]
    pub automation_execution_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartAutomationExecutionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartAutomationExecutionOutputBody");
        formatter.field("automation_execution_id", &self.automation_execution_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StartChangeRequestExecutionOutputBody {
    /// <p>The unique ID of a runbook workflow operation. (A runbook workflow is a type of Automation
    /// operation.) </p>
    #[serde(rename = "AutomationExecutionId")]
    #[serde(default)]
    pub automation_execution_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartChangeRequestExecutionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartChangeRequestExecutionOutputBody");
        formatter.field("automation_execution_id", &self.automation_execution_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StartSessionOutputBody {
    /// <p>The ID of the session.</p>
    #[serde(rename = "SessionId")]
    #[serde(default)]
    pub session_id: std::option::Option<std::string::String>,
    /// <p>An encrypted token value containing session and caller information. Used to authenticate the
    /// connection to the instance.</p>
    #[serde(rename = "TokenValue")]
    #[serde(default)]
    pub token_value: std::option::Option<std::string::String>,
    /// <p>A URL back to SSM Agent on the instance that the Session Manager client uses to send commands and
    /// receive output from the instance. Format: <code>wss://ssmmessages.<b>region</b>.amazonaws.com/v1/data-channel/<b>session-id</b>?stream=(input|output)</code>
    /// </p>
    /// <p>
    /// <b>region</b> represents the Region identifier for an
    /// AWS Region supported by AWS Systems Manager, such as <code>us-east-2</code> for the US East (Ohio) Region.
    /// For a list of supported <b>region</b> values, see the <b>Region</b> column in <a href="http://docs.aws.amazon.com/general/latest/gr/ssm.html#ssm_region">Systems Manager service endpoints</a> in the
    /// <i>AWS General Reference</i>.</p>
    /// <p>
    /// <b>session-id</b> represents the ID of a Session Manager session, such as
    /// <code>1a2b3c4dEXAMPLE</code>.</p>
    #[serde(rename = "StreamUrl")]
    #[serde(default)]
    pub stream_url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartSessionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartSessionOutputBody");
        formatter.field("session_id", &self.session_id);
        formatter.field("token_value", &self.token_value);
        formatter.field("stream_url", &self.stream_url);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TerminateSessionOutputBody {
    /// <p>The ID of the session that has been terminated.</p>
    #[serde(rename = "SessionId")]
    #[serde(default)]
    pub session_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TerminateSessionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TerminateSessionOutputBody");
        formatter.field("session_id", &self.session_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnlabelParameterVersionOutputBody {
    /// <p>A list of all labels deleted from the parameter.</p>
    #[serde(rename = "RemovedLabels")]
    #[serde(default)]
    pub removed_labels: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The labels that are not attached to the given parameter version.</p>
    #[serde(rename = "InvalidLabels")]
    #[serde(default)]
    pub invalid_labels: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UnlabelParameterVersionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnlabelParameterVersionOutputBody");
        formatter.field("removed_labels", &self.removed_labels);
        formatter.field("invalid_labels", &self.invalid_labels);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAssociationOutputBody {
    /// <p>The description of the association that was updated.</p>
    #[serde(rename = "AssociationDescription")]
    #[serde(default)]
    pub association_description: std::option::Option<crate::model::AssociationDescription>,
}
impl std::fmt::Debug for UpdateAssociationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAssociationOutputBody");
        formatter.field("association_description", &self.association_description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAssociationStatusOutputBody {
    /// <p>Information about the association.</p>
    #[serde(rename = "AssociationDescription")]
    #[serde(default)]
    pub association_description: std::option::Option<crate::model::AssociationDescription>,
}
impl std::fmt::Debug for UpdateAssociationStatusOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAssociationStatusOutputBody");
        formatter.field("association_description", &self.association_description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDocumentOutputBody {
    /// <p>A description of the document that was updated.</p>
    #[serde(rename = "DocumentDescription")]
    #[serde(default)]
    pub document_description: std::option::Option<crate::model::DocumentDescription>,
}
impl std::fmt::Debug for UpdateDocumentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDocumentOutputBody");
        formatter.field("document_description", &self.document_description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDocumentDefaultVersionOutputBody {
    /// <p>The description of a custom document that you want to set as the default version.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<crate::model::DocumentDefaultVersionDescription>,
}
impl std::fmt::Debug for UpdateDocumentDefaultVersionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDocumentDefaultVersionOutputBody");
        formatter.field("description", &self.description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMaintenanceWindowOutputBody {
    /// <p>The ID of the created maintenance window.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
    /// <p>The name of the maintenance window.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>An optional description of the update.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
    /// to become active. The maintenance window will not run before this specified time.</p>
    #[serde(rename = "StartDate")]
    #[serde(default)]
    pub start_date: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
    /// to become inactive. The maintenance window will not run after this specified time.</p>
    #[serde(rename = "EndDate")]
    #[serde(default)]
    pub end_date: std::option::Option<std::string::String>,
    /// <p>The schedule of the maintenance window in the form of a cron or rate expression.</p>
    #[serde(rename = "Schedule")]
    #[serde(default)]
    pub schedule: std::option::Option<std::string::String>,
    /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
    /// Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or
    /// "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time
    /// Zone Database</a> on the IANA website.</p>
    #[serde(rename = "ScheduleTimezone")]
    #[serde(default)]
    pub schedule_timezone: std::option::Option<std::string::String>,
    /// <p>The number of days to wait to run a maintenance window after the scheduled CRON expression
    /// date and time.</p>
    #[serde(rename = "ScheduleOffset")]
    #[serde(default)]
    pub schedule_offset: std::option::Option<i32>,
    /// <p>The duration of the maintenance window in hours.</p>
    #[serde(rename = "Duration")]
    #[serde(default)]
    pub duration: i32,
    /// <p>The number of hours before the end of the maintenance window that Systems Manager stops scheduling new
    /// tasks for execution.</p>
    #[serde(rename = "Cutoff")]
    #[serde(default)]
    pub cutoff: i32,
    /// <p>Whether targets must be registered with the maintenance window before tasks can be defined
    /// for those targets.</p>
    #[serde(rename = "AllowUnassociatedTargets")]
    #[serde(default)]
    pub allow_unassociated_targets: bool,
    /// <p>Whether the maintenance window is enabled.</p>
    #[serde(rename = "Enabled")]
    #[serde(default)]
    pub enabled: bool,
}
impl std::fmt::Debug for UpdateMaintenanceWindowOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMaintenanceWindowOutputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("start_date", &self.start_date);
        formatter.field("end_date", &self.end_date);
        formatter.field("schedule", &self.schedule);
        formatter.field("schedule_timezone", &self.schedule_timezone);
        formatter.field("schedule_offset", &self.schedule_offset);
        formatter.field("duration", &self.duration);
        formatter.field("cutoff", &self.cutoff);
        formatter.field(
            "allow_unassociated_targets",
            &self.allow_unassociated_targets,
        );
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMaintenanceWindowTargetOutputBody {
    /// <p>The maintenance window ID specified in the update request.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
    /// <p>The target ID specified in the update request.</p>
    #[serde(rename = "WindowTargetId")]
    #[serde(default)]
    pub window_target_id: std::option::Option<std::string::String>,
    /// <p>The updated targets.</p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The updated owner.</p>
    #[serde(rename = "OwnerInformation")]
    #[serde(default)]
    pub owner_information: std::option::Option<std::string::String>,
    /// <p>The updated name.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The updated description.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateMaintenanceWindowTargetOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMaintenanceWindowTargetOutputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_target_id", &self.window_target_id);
        formatter.field("targets", &self.targets);
        formatter.field("owner_information", &"*** Sensitive Data Redacted ***");
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMaintenanceWindowTaskOutputBody {
    /// <p>The ID of the maintenance window that was updated.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
    /// <p>The task ID of the maintenance window that was updated.</p>
    #[serde(rename = "WindowTaskId")]
    #[serde(default)]
    pub window_task_id: std::option::Option<std::string::String>,
    /// <p>The updated target values.</p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The updated task ARN value.</p>
    #[serde(rename = "TaskArn")]
    #[serde(default)]
    pub task_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for
    /// maintenance window Run Command tasks.</p>
    #[serde(rename = "ServiceRoleArn")]
    #[serde(default)]
    pub service_role_arn: std::option::Option<std::string::String>,
    /// <p>The updated parameter values.</p>
    /// <note>
    /// <p>
    /// <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    /// instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    /// about how Systems Manager handles these options for the supported maintenance window task
    /// types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    /// </note>
    #[serde(rename = "TaskParameters")]
    #[serde(default)]
    pub task_parameters: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            crate::model::MaintenanceWindowTaskParameterValueExpression,
        >,
    >,
    /// <p>The updated parameter values.</p>
    #[serde(rename = "TaskInvocationParameters")]
    #[serde(default)]
    pub task_invocation_parameters:
        std::option::Option<crate::model::MaintenanceWindowTaskInvocationParameters>,
    /// <p>The updated priority value.</p>
    #[serde(rename = "Priority")]
    #[serde(default)]
    pub priority: i32,
    /// <p>The updated MaxConcurrency value.</p>
    #[serde(rename = "MaxConcurrency")]
    #[serde(default)]
    pub max_concurrency: std::option::Option<std::string::String>,
    /// <p>The updated MaxErrors value.</p>
    #[serde(rename = "MaxErrors")]
    #[serde(default)]
    pub max_errors: std::option::Option<std::string::String>,
    /// <p>The updated logging information in Amazon S3.</p>
    /// <note>
    /// <p>
    /// <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
    /// <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
    /// For information about how Systems Manager handles these options for the supported maintenance
    /// window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    /// </note>
    #[serde(rename = "LoggingInfo")]
    #[serde(default)]
    pub logging_info: std::option::Option<crate::model::LoggingInfo>,
    /// <p>The updated task name.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The updated task description.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateMaintenanceWindowTaskOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMaintenanceWindowTaskOutputBody");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_task_id", &self.window_task_id);
        formatter.field("targets", &self.targets);
        formatter.field("task_arn", &self.task_arn);
        formatter.field("service_role_arn", &self.service_role_arn);
        formatter.field("task_parameters", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "task_invocation_parameters",
            &self.task_invocation_parameters,
        );
        formatter.field("priority", &self.priority);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("logging_info", &self.logging_info);
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateOpsMetadataOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the OpsMetadata Object that was updated.</p>
    #[serde(rename = "OpsMetadataArn")]
    #[serde(default)]
    pub ops_metadata_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateOpsMetadataOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateOpsMetadataOutputBody");
        formatter.field("ops_metadata_arn", &self.ops_metadata_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePatchBaselineOutputBody {
    /// <p>The ID of the deleted patch baseline.</p>
    #[serde(rename = "BaselineId")]
    #[serde(default)]
    pub baseline_id: std::option::Option<std::string::String>,
    /// <p>The name of the patch baseline.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The operating system rule used by the updated patch baseline.</p>
    #[serde(rename = "OperatingSystem")]
    #[serde(default)]
    pub operating_system: std::option::Option<crate::model::OperatingSystem>,
    /// <p>A set of global filters used to exclude patches from the baseline.</p>
    #[serde(rename = "GlobalFilters")]
    #[serde(default)]
    pub global_filters: std::option::Option<crate::model::PatchFilterGroup>,
    /// <p>A set of rules used to include patches in the baseline.</p>
    #[serde(rename = "ApprovalRules")]
    #[serde(default)]
    pub approval_rules: std::option::Option<crate::model::PatchRuleGroup>,
    /// <p>A list of explicitly approved patches for the baseline.</p>
    #[serde(rename = "ApprovedPatches")]
    #[serde(default)]
    pub approved_patches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The compliance severity level assigned to the patch baseline after the update
    /// completed.</p>
    #[serde(rename = "ApprovedPatchesComplianceLevel")]
    #[serde(default)]
    pub approved_patches_compliance_level: std::option::Option<crate::model::PatchComplianceLevel>,
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be
    /// applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
    #[serde(rename = "ApprovedPatchesEnableNonSecurity")]
    #[serde(default)]
    pub approved_patches_enable_non_security: std::option::Option<bool>,
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    #[serde(rename = "RejectedPatches")]
    #[serde(default)]
    pub rejected_patches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The action specified to take on patches included in the RejectedPatches list. A patch can be
    /// allowed only if it is a dependency of another package, or blocked entirely along with packages
    /// that include it as a dependency.</p>
    #[serde(rename = "RejectedPatchesAction")]
    #[serde(default)]
    pub rejected_patches_action: std::option::Option<crate::model::PatchAction>,
    /// <p>The date when the patch baseline was created.</p>
    #[serde(rename = "CreatedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_date: std::option::Option<smithy_types::Instant>,
    /// <p>The date when the patch baseline was last modified.</p>
    #[serde(rename = "ModifiedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub modified_date: std::option::Option<smithy_types::Instant>,
    /// <p>A description of the Patch Baseline.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Information about the patches to use to update the instances, including target operating
    /// systems and source repositories. Applies to Linux instances only.</p>
    #[serde(rename = "Sources")]
    #[serde(default)]
    pub sources: std::option::Option<std::vec::Vec<crate::model::PatchSource>>,
}
impl std::fmt::Debug for UpdatePatchBaselineOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePatchBaselineOutputBody");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("name", &self.name);
        formatter.field("operating_system", &self.operating_system);
        formatter.field("global_filters", &self.global_filters);
        formatter.field("approval_rules", &self.approval_rules);
        formatter.field("approved_patches", &self.approved_patches);
        formatter.field(
            "approved_patches_compliance_level",
            &self.approved_patches_compliance_level,
        );
        formatter.field(
            "approved_patches_enable_non_security",
            &self.approved_patches_enable_non_security,
        );
        formatter.field("rejected_patches", &self.rejected_patches);
        formatter.field("rejected_patches_action", &self.rejected_patches_action);
        formatter.field("created_date", &self.created_date);
        formatter.field("modified_date", &self.modified_date);
        formatter.field("description", &self.description);
        formatter.field("sources", &self.sources);
        formatter.finish()
    }
}
