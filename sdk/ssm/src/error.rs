// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddTagsToResourceError {
    pub kind: AddTagsToResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddTagsToResourceErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidResourceId(crate::error::InvalidResourceId),
    InvalidResourceType(crate::error::InvalidResourceType),
    TooManyTagsError(crate::error::TooManyTagsError),
    TooManyUpdates(crate::error::TooManyUpdates),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddTagsToResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddTagsToResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::InvalidResourceId(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::InvalidResourceType(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::TooManyTagsError(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::TooManyUpdates(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddTagsToResourceError {
    fn code(&self) -> Option<&str> {
        AddTagsToResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddTagsToResourceError {
    pub fn new(kind: AddTagsToResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddTagsToResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddTagsToResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_resource_id(&self) -> bool {
        matches!(&self.kind, AddTagsToResourceErrorKind::InvalidResourceId(_))
    }
    pub fn is_invalid_resource_type(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::InvalidResourceType(_)
        )
    }
    pub fn is_too_many_tags_error(&self) -> bool {
        matches!(&self.kind, AddTagsToResourceErrorKind::TooManyTagsError(_))
    }
    pub fn is_too_many_updates(&self) -> bool {
        matches!(&self.kind, AddTagsToResourceErrorKind::TooManyUpdates(_))
    }
}
impl std::error::Error for AddTagsToResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddTagsToResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::InvalidResourceId(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::InvalidResourceType(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::TooManyTagsError(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::TooManyUpdates(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateOpsItemRelatedItemError {
    pub kind: AssociateOpsItemRelatedItemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateOpsItemRelatedItemErrorKind {
    InternalServerError(crate::error::InternalServerError),
    OpsItemInvalidParameterError(crate::error::OpsItemInvalidParameterError),
    OpsItemLimitExceededError(crate::error::OpsItemLimitExceededError),
    OpsItemNotFoundError(crate::error::OpsItemNotFoundError),
    OpsItemRelatedItemAlreadyExistsError(crate::error::OpsItemRelatedItemAlreadyExistsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateOpsItemRelatedItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateOpsItemRelatedItemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            AssociateOpsItemRelatedItemErrorKind::OpsItemInvalidParameterError(_inner) => {
                _inner.fmt(f)
            }
            AssociateOpsItemRelatedItemErrorKind::OpsItemLimitExceededError(_inner) => {
                _inner.fmt(f)
            }
            AssociateOpsItemRelatedItemErrorKind::OpsItemNotFoundError(_inner) => _inner.fmt(f),
            AssociateOpsItemRelatedItemErrorKind::OpsItemRelatedItemAlreadyExistsError(_inner) => {
                _inner.fmt(f)
            }
            AssociateOpsItemRelatedItemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateOpsItemRelatedItemError {
    fn code(&self) -> Option<&str> {
        AssociateOpsItemRelatedItemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateOpsItemRelatedItemError {
    pub fn new(kind: AssociateOpsItemRelatedItemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateOpsItemRelatedItemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateOpsItemRelatedItemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            AssociateOpsItemRelatedItemErrorKind::InternalServerError(_)
        )
    }
    pub fn is_ops_item_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            AssociateOpsItemRelatedItemErrorKind::OpsItemInvalidParameterError(_)
        )
    }
    pub fn is_ops_item_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            AssociateOpsItemRelatedItemErrorKind::OpsItemLimitExceededError(_)
        )
    }
    pub fn is_ops_item_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            AssociateOpsItemRelatedItemErrorKind::OpsItemNotFoundError(_)
        )
    }
    pub fn is_ops_item_related_item_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            AssociateOpsItemRelatedItemErrorKind::OpsItemRelatedItemAlreadyExistsError(_)
        )
    }
}
impl std::error::Error for AssociateOpsItemRelatedItemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateOpsItemRelatedItemErrorKind::InternalServerError(_inner) => Some(_inner),
            AssociateOpsItemRelatedItemErrorKind::OpsItemInvalidParameterError(_inner) => {
                Some(_inner)
            }
            AssociateOpsItemRelatedItemErrorKind::OpsItemLimitExceededError(_inner) => Some(_inner),
            AssociateOpsItemRelatedItemErrorKind::OpsItemNotFoundError(_inner) => Some(_inner),
            AssociateOpsItemRelatedItemErrorKind::OpsItemRelatedItemAlreadyExistsError(_inner) => {
                Some(_inner)
            }
            AssociateOpsItemRelatedItemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelCommandError {
    pub kind: CancelCommandErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelCommandErrorKind {
    DuplicateInstanceId(crate::error::DuplicateInstanceId),
    InternalServerError(crate::error::InternalServerError),
    InvalidCommandId(crate::error::InvalidCommandId),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelCommandError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelCommandErrorKind::DuplicateInstanceId(_inner) => _inner.fmt(f),
            CancelCommandErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CancelCommandErrorKind::InvalidCommandId(_inner) => _inner.fmt(f),
            CancelCommandErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            CancelCommandErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelCommandError {
    fn code(&self) -> Option<&str> {
        CancelCommandError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelCommandError {
    pub fn new(kind: CancelCommandErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelCommandErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelCommandErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_instance_id(&self) -> bool {
        matches!(&self.kind, CancelCommandErrorKind::DuplicateInstanceId(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CancelCommandErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_command_id(&self) -> bool {
        matches!(&self.kind, CancelCommandErrorKind::InvalidCommandId(_))
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(&self.kind, CancelCommandErrorKind::InvalidInstanceId(_))
    }
}
impl std::error::Error for CancelCommandError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelCommandErrorKind::DuplicateInstanceId(_inner) => Some(_inner),
            CancelCommandErrorKind::InternalServerError(_inner) => Some(_inner),
            CancelCommandErrorKind::InvalidCommandId(_inner) => Some(_inner),
            CancelCommandErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            CancelCommandErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelMaintenanceWindowExecutionError {
    pub kind: CancelMaintenanceWindowExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelMaintenanceWindowExecutionErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelMaintenanceWindowExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelMaintenanceWindowExecutionErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            CancelMaintenanceWindowExecutionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CancelMaintenanceWindowExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelMaintenanceWindowExecutionError {
    fn code(&self) -> Option<&str> {
        CancelMaintenanceWindowExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelMaintenanceWindowExecutionError {
    pub fn new(kind: CancelMaintenanceWindowExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelMaintenanceWindowExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelMaintenanceWindowExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelMaintenanceWindowExecutionErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelMaintenanceWindowExecutionErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for CancelMaintenanceWindowExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelMaintenanceWindowExecutionErrorKind::DoesNotExistError(_inner) => Some(_inner),
            CancelMaintenanceWindowExecutionErrorKind::InternalServerError(_inner) => Some(_inner),
            CancelMaintenanceWindowExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateActivationError {
    pub kind: CreateActivationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateActivationErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateActivationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateActivationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateActivationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateActivationError {
    fn code(&self) -> Option<&str> {
        CreateActivationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateActivationError {
    pub fn new(kind: CreateActivationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateActivationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateActivationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateActivationErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for CreateActivationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateActivationErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateActivationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAssociationError {
    pub kind: CreateAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAssociationErrorKind {
    AssociationAlreadyExists(crate::error::AssociationAlreadyExists),
    AssociationLimitExceeded(crate::error::AssociationLimitExceeded),
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidDocumentVersion(crate::error::InvalidDocumentVersion),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    InvalidOutputLocation(crate::error::InvalidOutputLocation),
    InvalidParameters(crate::error::InvalidParameters),
    InvalidSchedule(crate::error::InvalidSchedule),
    InvalidTarget(crate::error::InvalidTarget),
    UnsupportedPlatformType(crate::error::UnsupportedPlatformType),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAssociationErrorKind::AssociationAlreadyExists(_inner) => _inner.fmt(f),
            CreateAssociationErrorKind::AssociationLimitExceeded(_inner) => _inner.fmt(f),
            CreateAssociationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateAssociationErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            CreateAssociationErrorKind::InvalidDocumentVersion(_inner) => _inner.fmt(f),
            CreateAssociationErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            CreateAssociationErrorKind::InvalidOutputLocation(_inner) => _inner.fmt(f),
            CreateAssociationErrorKind::InvalidParameters(_inner) => _inner.fmt(f),
            CreateAssociationErrorKind::InvalidSchedule(_inner) => _inner.fmt(f),
            CreateAssociationErrorKind::InvalidTarget(_inner) => _inner.fmt(f),
            CreateAssociationErrorKind::UnsupportedPlatformType(_inner) => _inner.fmt(f),
            CreateAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAssociationError {
    fn code(&self) -> Option<&str> {
        CreateAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAssociationError {
    pub fn new(kind: CreateAssociationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_association_already_exists(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationErrorKind::AssociationAlreadyExists(_)
        )
    }
    pub fn is_association_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationErrorKind::AssociationLimitExceeded(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(&self.kind, CreateAssociationErrorKind::InvalidDocument(_))
    }
    pub fn is_invalid_document_version(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationErrorKind::InvalidDocumentVersion(_)
        )
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(&self.kind, CreateAssociationErrorKind::InvalidInstanceId(_))
    }
    pub fn is_invalid_output_location(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationErrorKind::InvalidOutputLocation(_)
        )
    }
    pub fn is_invalid_parameters(&self) -> bool {
        matches!(&self.kind, CreateAssociationErrorKind::InvalidParameters(_))
    }
    pub fn is_invalid_schedule(&self) -> bool {
        matches!(&self.kind, CreateAssociationErrorKind::InvalidSchedule(_))
    }
    pub fn is_invalid_target(&self) -> bool {
        matches!(&self.kind, CreateAssociationErrorKind::InvalidTarget(_))
    }
    pub fn is_unsupported_platform_type(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationErrorKind::UnsupportedPlatformType(_)
        )
    }
}
impl std::error::Error for CreateAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAssociationErrorKind::AssociationAlreadyExists(_inner) => Some(_inner),
            CreateAssociationErrorKind::AssociationLimitExceeded(_inner) => Some(_inner),
            CreateAssociationErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateAssociationErrorKind::InvalidDocument(_inner) => Some(_inner),
            CreateAssociationErrorKind::InvalidDocumentVersion(_inner) => Some(_inner),
            CreateAssociationErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            CreateAssociationErrorKind::InvalidOutputLocation(_inner) => Some(_inner),
            CreateAssociationErrorKind::InvalidParameters(_inner) => Some(_inner),
            CreateAssociationErrorKind::InvalidSchedule(_inner) => Some(_inner),
            CreateAssociationErrorKind::InvalidTarget(_inner) => Some(_inner),
            CreateAssociationErrorKind::UnsupportedPlatformType(_inner) => Some(_inner),
            CreateAssociationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAssociationBatchError {
    pub kind: CreateAssociationBatchErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAssociationBatchErrorKind {
    AssociationLimitExceeded(crate::error::AssociationLimitExceeded),
    DuplicateInstanceId(crate::error::DuplicateInstanceId),
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidDocumentVersion(crate::error::InvalidDocumentVersion),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    InvalidOutputLocation(crate::error::InvalidOutputLocation),
    InvalidParameters(crate::error::InvalidParameters),
    InvalidSchedule(crate::error::InvalidSchedule),
    InvalidTarget(crate::error::InvalidTarget),
    UnsupportedPlatformType(crate::error::UnsupportedPlatformType),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAssociationBatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAssociationBatchErrorKind::AssociationLimitExceeded(_inner) => _inner.fmt(f),
            CreateAssociationBatchErrorKind::DuplicateInstanceId(_inner) => _inner.fmt(f),
            CreateAssociationBatchErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateAssociationBatchErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            CreateAssociationBatchErrorKind::InvalidDocumentVersion(_inner) => _inner.fmt(f),
            CreateAssociationBatchErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            CreateAssociationBatchErrorKind::InvalidOutputLocation(_inner) => _inner.fmt(f),
            CreateAssociationBatchErrorKind::InvalidParameters(_inner) => _inner.fmt(f),
            CreateAssociationBatchErrorKind::InvalidSchedule(_inner) => _inner.fmt(f),
            CreateAssociationBatchErrorKind::InvalidTarget(_inner) => _inner.fmt(f),
            CreateAssociationBatchErrorKind::UnsupportedPlatformType(_inner) => _inner.fmt(f),
            CreateAssociationBatchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAssociationBatchError {
    fn code(&self) -> Option<&str> {
        CreateAssociationBatchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAssociationBatchError {
    pub fn new(kind: CreateAssociationBatchErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAssociationBatchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAssociationBatchErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_association_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationBatchErrorKind::AssociationLimitExceeded(_)
        )
    }
    pub fn is_duplicate_instance_id(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationBatchErrorKind::DuplicateInstanceId(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationBatchErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationBatchErrorKind::InvalidDocument(_)
        )
    }
    pub fn is_invalid_document_version(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationBatchErrorKind::InvalidDocumentVersion(_)
        )
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationBatchErrorKind::InvalidInstanceId(_)
        )
    }
    pub fn is_invalid_output_location(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationBatchErrorKind::InvalidOutputLocation(_)
        )
    }
    pub fn is_invalid_parameters(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationBatchErrorKind::InvalidParameters(_)
        )
    }
    pub fn is_invalid_schedule(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationBatchErrorKind::InvalidSchedule(_)
        )
    }
    pub fn is_invalid_target(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationBatchErrorKind::InvalidTarget(_)
        )
    }
    pub fn is_unsupported_platform_type(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssociationBatchErrorKind::UnsupportedPlatformType(_)
        )
    }
}
impl std::error::Error for CreateAssociationBatchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAssociationBatchErrorKind::AssociationLimitExceeded(_inner) => Some(_inner),
            CreateAssociationBatchErrorKind::DuplicateInstanceId(_inner) => Some(_inner),
            CreateAssociationBatchErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateAssociationBatchErrorKind::InvalidDocument(_inner) => Some(_inner),
            CreateAssociationBatchErrorKind::InvalidDocumentVersion(_inner) => Some(_inner),
            CreateAssociationBatchErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            CreateAssociationBatchErrorKind::InvalidOutputLocation(_inner) => Some(_inner),
            CreateAssociationBatchErrorKind::InvalidParameters(_inner) => Some(_inner),
            CreateAssociationBatchErrorKind::InvalidSchedule(_inner) => Some(_inner),
            CreateAssociationBatchErrorKind::InvalidTarget(_inner) => Some(_inner),
            CreateAssociationBatchErrorKind::UnsupportedPlatformType(_inner) => Some(_inner),
            CreateAssociationBatchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDocumentError {
    pub kind: CreateDocumentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDocumentErrorKind {
    DocumentAlreadyExists(crate::error::DocumentAlreadyExists),
    DocumentLimitExceeded(crate::error::DocumentLimitExceeded),
    InternalServerError(crate::error::InternalServerError),
    InvalidDocumentContent(crate::error::InvalidDocumentContent),
    InvalidDocumentSchemaVersion(crate::error::InvalidDocumentSchemaVersion),
    MaxDocumentSizeExceeded(crate::error::MaxDocumentSizeExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDocumentErrorKind::DocumentAlreadyExists(_inner) => _inner.fmt(f),
            CreateDocumentErrorKind::DocumentLimitExceeded(_inner) => _inner.fmt(f),
            CreateDocumentErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateDocumentErrorKind::InvalidDocumentContent(_inner) => _inner.fmt(f),
            CreateDocumentErrorKind::InvalidDocumentSchemaVersion(_inner) => _inner.fmt(f),
            CreateDocumentErrorKind::MaxDocumentSizeExceeded(_inner) => _inner.fmt(f),
            CreateDocumentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDocumentError {
    fn code(&self) -> Option<&str> {
        CreateDocumentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDocumentError {
    pub fn new(kind: CreateDocumentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDocumentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDocumentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_document_already_exists(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentErrorKind::DocumentAlreadyExists(_)
        )
    }
    pub fn is_document_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentErrorKind::DocumentLimitExceeded(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CreateDocumentErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_document_content(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentErrorKind::InvalidDocumentContent(_)
        )
    }
    pub fn is_invalid_document_schema_version(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentErrorKind::InvalidDocumentSchemaVersion(_)
        )
    }
    pub fn is_max_document_size_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentErrorKind::MaxDocumentSizeExceeded(_)
        )
    }
}
impl std::error::Error for CreateDocumentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDocumentErrorKind::DocumentAlreadyExists(_inner) => Some(_inner),
            CreateDocumentErrorKind::DocumentLimitExceeded(_inner) => Some(_inner),
            CreateDocumentErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateDocumentErrorKind::InvalidDocumentContent(_inner) => Some(_inner),
            CreateDocumentErrorKind::InvalidDocumentSchemaVersion(_inner) => Some(_inner),
            CreateDocumentErrorKind::MaxDocumentSizeExceeded(_inner) => Some(_inner),
            CreateDocumentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMaintenanceWindowError {
    pub kind: CreateMaintenanceWindowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMaintenanceWindowErrorKind {
    IdempotentParameterMismatch(crate::error::IdempotentParameterMismatch),
    InternalServerError(crate::error::InternalServerError),
    ResourceLimitExceededError(crate::error::ResourceLimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMaintenanceWindowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMaintenanceWindowErrorKind::IdempotentParameterMismatch(_inner) => _inner.fmt(f),
            CreateMaintenanceWindowErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateMaintenanceWindowErrorKind::ResourceLimitExceededError(_inner) => _inner.fmt(f),
            CreateMaintenanceWindowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMaintenanceWindowError {
    fn code(&self) -> Option<&str> {
        CreateMaintenanceWindowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMaintenanceWindowError {
    pub fn new(kind: CreateMaintenanceWindowErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMaintenanceWindowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMaintenanceWindowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_idempotent_parameter_mismatch(&self) -> bool {
        matches!(
            &self.kind,
            CreateMaintenanceWindowErrorKind::IdempotentParameterMismatch(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateMaintenanceWindowErrorKind::InternalServerError(_)
        )
    }
    pub fn is_resource_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateMaintenanceWindowErrorKind::ResourceLimitExceededError(_)
        )
    }
}
impl std::error::Error for CreateMaintenanceWindowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMaintenanceWindowErrorKind::IdempotentParameterMismatch(_inner) => Some(_inner),
            CreateMaintenanceWindowErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateMaintenanceWindowErrorKind::ResourceLimitExceededError(_inner) => Some(_inner),
            CreateMaintenanceWindowErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateOpsItemError {
    pub kind: CreateOpsItemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateOpsItemErrorKind {
    InternalServerError(crate::error::InternalServerError),
    OpsItemAlreadyExistsError(crate::error::OpsItemAlreadyExistsError),
    OpsItemInvalidParameterError(crate::error::OpsItemInvalidParameterError),
    OpsItemLimitExceededError(crate::error::OpsItemLimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateOpsItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateOpsItemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateOpsItemErrorKind::OpsItemAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateOpsItemErrorKind::OpsItemInvalidParameterError(_inner) => _inner.fmt(f),
            CreateOpsItemErrorKind::OpsItemLimitExceededError(_inner) => _inner.fmt(f),
            CreateOpsItemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateOpsItemError {
    fn code(&self) -> Option<&str> {
        CreateOpsItemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateOpsItemError {
    pub fn new(kind: CreateOpsItemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateOpsItemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateOpsItemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CreateOpsItemErrorKind::InternalServerError(_))
    }
    pub fn is_ops_item_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpsItemErrorKind::OpsItemAlreadyExistsError(_)
        )
    }
    pub fn is_ops_item_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpsItemErrorKind::OpsItemInvalidParameterError(_)
        )
    }
    pub fn is_ops_item_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpsItemErrorKind::OpsItemLimitExceededError(_)
        )
    }
}
impl std::error::Error for CreateOpsItemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateOpsItemErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateOpsItemErrorKind::OpsItemAlreadyExistsError(_inner) => Some(_inner),
            CreateOpsItemErrorKind::OpsItemInvalidParameterError(_inner) => Some(_inner),
            CreateOpsItemErrorKind::OpsItemLimitExceededError(_inner) => Some(_inner),
            CreateOpsItemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateOpsMetadataError {
    pub kind: CreateOpsMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateOpsMetadataErrorKind {
    InternalServerError(crate::error::InternalServerError),
    OpsMetadataAlreadyExistsError(crate::error::OpsMetadataAlreadyExistsError),
    OpsMetadataInvalidArgumentError(crate::error::OpsMetadataInvalidArgumentError),
    OpsMetadataLimitExceededError(crate::error::OpsMetadataLimitExceededError),
    OpsMetadataTooManyUpdatesError(crate::error::OpsMetadataTooManyUpdatesError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateOpsMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateOpsMetadataErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateOpsMetadataErrorKind::OpsMetadataAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_inner) => _inner.fmt(f),
            CreateOpsMetadataErrorKind::OpsMetadataLimitExceededError(_inner) => _inner.fmt(f),
            CreateOpsMetadataErrorKind::OpsMetadataTooManyUpdatesError(_inner) => _inner.fmt(f),
            CreateOpsMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateOpsMetadataError {
    fn code(&self) -> Option<&str> {
        CreateOpsMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateOpsMetadataError {
    pub fn new(kind: CreateOpsMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateOpsMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateOpsMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpsMetadataErrorKind::InternalServerError(_)
        )
    }
    pub fn is_ops_metadata_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpsMetadataErrorKind::OpsMetadataAlreadyExistsError(_)
        )
    }
    pub fn is_ops_metadata_invalid_argument_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_)
        )
    }
    pub fn is_ops_metadata_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpsMetadataErrorKind::OpsMetadataLimitExceededError(_)
        )
    }
    pub fn is_ops_metadata_too_many_updates_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpsMetadataErrorKind::OpsMetadataTooManyUpdatesError(_)
        )
    }
}
impl std::error::Error for CreateOpsMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateOpsMetadataErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateOpsMetadataErrorKind::OpsMetadataAlreadyExistsError(_inner) => Some(_inner),
            CreateOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_inner) => Some(_inner),
            CreateOpsMetadataErrorKind::OpsMetadataLimitExceededError(_inner) => Some(_inner),
            CreateOpsMetadataErrorKind::OpsMetadataTooManyUpdatesError(_inner) => Some(_inner),
            CreateOpsMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePatchBaselineError {
    pub kind: CreatePatchBaselineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePatchBaselineErrorKind {
    IdempotentParameterMismatch(crate::error::IdempotentParameterMismatch),
    InternalServerError(crate::error::InternalServerError),
    ResourceLimitExceededError(crate::error::ResourceLimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePatchBaselineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePatchBaselineErrorKind::IdempotentParameterMismatch(_inner) => _inner.fmt(f),
            CreatePatchBaselineErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreatePatchBaselineErrorKind::ResourceLimitExceededError(_inner) => _inner.fmt(f),
            CreatePatchBaselineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePatchBaselineError {
    fn code(&self) -> Option<&str> {
        CreatePatchBaselineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePatchBaselineError {
    pub fn new(kind: CreatePatchBaselineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePatchBaselineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePatchBaselineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_idempotent_parameter_mismatch(&self) -> bool {
        matches!(
            &self.kind,
            CreatePatchBaselineErrorKind::IdempotentParameterMismatch(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreatePatchBaselineErrorKind::InternalServerError(_)
        )
    }
    pub fn is_resource_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreatePatchBaselineErrorKind::ResourceLimitExceededError(_)
        )
    }
}
impl std::error::Error for CreatePatchBaselineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePatchBaselineErrorKind::IdempotentParameterMismatch(_inner) => Some(_inner),
            CreatePatchBaselineErrorKind::InternalServerError(_inner) => Some(_inner),
            CreatePatchBaselineErrorKind::ResourceLimitExceededError(_inner) => Some(_inner),
            CreatePatchBaselineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateResourceDataSyncError {
    pub kind: CreateResourceDataSyncErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateResourceDataSyncErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ResourceDataSyncAlreadyExistsError(crate::error::ResourceDataSyncAlreadyExistsError),
    ResourceDataSyncCountExceededError(crate::error::ResourceDataSyncCountExceededError),
    ResourceDataSyncInvalidConfigurationError(
        crate::error::ResourceDataSyncInvalidConfigurationError,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateResourceDataSyncError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateResourceDataSyncErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateResourceDataSyncErrorKind::ResourceDataSyncAlreadyExistsError(_inner) => {
                _inner.fmt(f)
            }
            CreateResourceDataSyncErrorKind::ResourceDataSyncCountExceededError(_inner) => {
                _inner.fmt(f)
            }
            CreateResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(_inner) => {
                _inner.fmt(f)
            }
            CreateResourceDataSyncErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateResourceDataSyncError {
    fn code(&self) -> Option<&str> {
        CreateResourceDataSyncError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateResourceDataSyncError {
    pub fn new(kind: CreateResourceDataSyncErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateResourceDataSyncErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateResourceDataSyncErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceDataSyncErrorKind::InternalServerError(_)
        )
    }
    pub fn is_resource_data_sync_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceDataSyncErrorKind::ResourceDataSyncAlreadyExistsError(_)
        )
    }
    pub fn is_resource_data_sync_count_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceDataSyncErrorKind::ResourceDataSyncCountExceededError(_)
        )
    }
    pub fn is_resource_data_sync_invalid_configuration_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(_)
        )
    }
}
impl std::error::Error for CreateResourceDataSyncError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateResourceDataSyncErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateResourceDataSyncErrorKind::ResourceDataSyncAlreadyExistsError(_inner) => {
                Some(_inner)
            }
            CreateResourceDataSyncErrorKind::ResourceDataSyncCountExceededError(_inner) => {
                Some(_inner)
            }
            CreateResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(_inner) => {
                Some(_inner)
            }
            CreateResourceDataSyncErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteActivationError {
    pub kind: DeleteActivationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteActivationErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidActivation(crate::error::InvalidActivation),
    InvalidActivationId(crate::error::InvalidActivationId),
    TooManyUpdates(crate::error::TooManyUpdates),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteActivationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteActivationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteActivationErrorKind::InvalidActivation(_inner) => _inner.fmt(f),
            DeleteActivationErrorKind::InvalidActivationId(_inner) => _inner.fmt(f),
            DeleteActivationErrorKind::TooManyUpdates(_inner) => _inner.fmt(f),
            DeleteActivationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteActivationError {
    fn code(&self) -> Option<&str> {
        DeleteActivationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteActivationError {
    pub fn new(kind: DeleteActivationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteActivationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteActivationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteActivationErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_activation(&self) -> bool {
        matches!(&self.kind, DeleteActivationErrorKind::InvalidActivation(_))
    }
    pub fn is_invalid_activation_id(&self) -> bool {
        matches!(
            &self.kind,
            DeleteActivationErrorKind::InvalidActivationId(_)
        )
    }
    pub fn is_too_many_updates(&self) -> bool {
        matches!(&self.kind, DeleteActivationErrorKind::TooManyUpdates(_))
    }
}
impl std::error::Error for DeleteActivationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteActivationErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteActivationErrorKind::InvalidActivation(_inner) => Some(_inner),
            DeleteActivationErrorKind::InvalidActivationId(_inner) => Some(_inner),
            DeleteActivationErrorKind::TooManyUpdates(_inner) => Some(_inner),
            DeleteActivationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAssociationError {
    pub kind: DeleteAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAssociationErrorKind {
    AssociationDoesNotExist(crate::error::AssociationDoesNotExist),
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    TooManyUpdates(crate::error::TooManyUpdates),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAssociationErrorKind::AssociationDoesNotExist(_inner) => _inner.fmt(f),
            DeleteAssociationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteAssociationErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            DeleteAssociationErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            DeleteAssociationErrorKind::TooManyUpdates(_inner) => _inner.fmt(f),
            DeleteAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAssociationError {
    fn code(&self) -> Option<&str> {
        DeleteAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAssociationError {
    pub fn new(kind: DeleteAssociationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_association_does_not_exist(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssociationErrorKind::AssociationDoesNotExist(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssociationErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(&self.kind, DeleteAssociationErrorKind::InvalidDocument(_))
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(&self.kind, DeleteAssociationErrorKind::InvalidInstanceId(_))
    }
    pub fn is_too_many_updates(&self) -> bool {
        matches!(&self.kind, DeleteAssociationErrorKind::TooManyUpdates(_))
    }
}
impl std::error::Error for DeleteAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAssociationErrorKind::AssociationDoesNotExist(_inner) => Some(_inner),
            DeleteAssociationErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteAssociationErrorKind::InvalidDocument(_inner) => Some(_inner),
            DeleteAssociationErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            DeleteAssociationErrorKind::TooManyUpdates(_inner) => Some(_inner),
            DeleteAssociationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDocumentError {
    pub kind: DeleteDocumentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDocumentErrorKind {
    AssociatedInstances(crate::error::AssociatedInstances),
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidDocumentOperation(crate::error::InvalidDocumentOperation),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDocumentErrorKind::AssociatedInstances(_inner) => _inner.fmt(f),
            DeleteDocumentErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteDocumentErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            DeleteDocumentErrorKind::InvalidDocumentOperation(_inner) => _inner.fmt(f),
            DeleteDocumentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDocumentError {
    fn code(&self) -> Option<&str> {
        DeleteDocumentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDocumentError {
    pub fn new(kind: DeleteDocumentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDocumentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDocumentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_associated_instances(&self) -> bool {
        matches!(&self.kind, DeleteDocumentErrorKind::AssociatedInstances(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteDocumentErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(&self.kind, DeleteDocumentErrorKind::InvalidDocument(_))
    }
    pub fn is_invalid_document_operation(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDocumentErrorKind::InvalidDocumentOperation(_)
        )
    }
}
impl std::error::Error for DeleteDocumentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDocumentErrorKind::AssociatedInstances(_inner) => Some(_inner),
            DeleteDocumentErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteDocumentErrorKind::InvalidDocument(_inner) => Some(_inner),
            DeleteDocumentErrorKind::InvalidDocumentOperation(_inner) => Some(_inner),
            DeleteDocumentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInventoryError {
    pub kind: DeleteInventoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInventoryErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidDeleteInventoryParametersError(crate::error::InvalidDeleteInventoryParametersError),
    InvalidInventoryRequestError(crate::error::InvalidInventoryRequestError),
    InvalidOptionError(crate::error::InvalidOptionError),
    InvalidTypeNameError(crate::error::InvalidTypeNameError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInventoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInventoryErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteInventoryErrorKind::InvalidDeleteInventoryParametersError(_inner) => {
                _inner.fmt(f)
            }
            DeleteInventoryErrorKind::InvalidInventoryRequestError(_inner) => _inner.fmt(f),
            DeleteInventoryErrorKind::InvalidOptionError(_inner) => _inner.fmt(f),
            DeleteInventoryErrorKind::InvalidTypeNameError(_inner) => _inner.fmt(f),
            DeleteInventoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInventoryError {
    fn code(&self) -> Option<&str> {
        DeleteInventoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInventoryError {
    pub fn new(kind: DeleteInventoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInventoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInventoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteInventoryErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_delete_inventory_parameters_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInventoryErrorKind::InvalidDeleteInventoryParametersError(_)
        )
    }
    pub fn is_invalid_inventory_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInventoryErrorKind::InvalidInventoryRequestError(_)
        )
    }
    pub fn is_invalid_option_error(&self) -> bool {
        matches!(&self.kind, DeleteInventoryErrorKind::InvalidOptionError(_))
    }
    pub fn is_invalid_type_name_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInventoryErrorKind::InvalidTypeNameError(_)
        )
    }
}
impl std::error::Error for DeleteInventoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInventoryErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteInventoryErrorKind::InvalidDeleteInventoryParametersError(_inner) => Some(_inner),
            DeleteInventoryErrorKind::InvalidInventoryRequestError(_inner) => Some(_inner),
            DeleteInventoryErrorKind::InvalidOptionError(_inner) => Some(_inner),
            DeleteInventoryErrorKind::InvalidTypeNameError(_inner) => Some(_inner),
            DeleteInventoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMaintenanceWindowError {
    pub kind: DeleteMaintenanceWindowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMaintenanceWindowErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMaintenanceWindowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMaintenanceWindowErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteMaintenanceWindowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMaintenanceWindowError {
    fn code(&self) -> Option<&str> {
        DeleteMaintenanceWindowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMaintenanceWindowError {
    pub fn new(kind: DeleteMaintenanceWindowErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMaintenanceWindowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMaintenanceWindowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMaintenanceWindowErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DeleteMaintenanceWindowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMaintenanceWindowErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteMaintenanceWindowErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteOpsMetadataError {
    pub kind: DeleteOpsMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteOpsMetadataErrorKind {
    InternalServerError(crate::error::InternalServerError),
    OpsMetadataInvalidArgumentError(crate::error::OpsMetadataInvalidArgumentError),
    OpsMetadataNotFoundError(crate::error::OpsMetadataNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteOpsMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteOpsMetadataErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_inner) => _inner.fmt(f),
            DeleteOpsMetadataErrorKind::OpsMetadataNotFoundError(_inner) => _inner.fmt(f),
            DeleteOpsMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteOpsMetadataError {
    fn code(&self) -> Option<&str> {
        DeleteOpsMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteOpsMetadataError {
    pub fn new(kind: DeleteOpsMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteOpsMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteOpsMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOpsMetadataErrorKind::InternalServerError(_)
        )
    }
    pub fn is_ops_metadata_invalid_argument_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_)
        )
    }
    pub fn is_ops_metadata_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOpsMetadataErrorKind::OpsMetadataNotFoundError(_)
        )
    }
}
impl std::error::Error for DeleteOpsMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteOpsMetadataErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_inner) => Some(_inner),
            DeleteOpsMetadataErrorKind::OpsMetadataNotFoundError(_inner) => Some(_inner),
            DeleteOpsMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteParameterError {
    pub kind: DeleteParameterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteParameterErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ParameterNotFound(crate::error::ParameterNotFound),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteParameterErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteParameterErrorKind::ParameterNotFound(_inner) => _inner.fmt(f),
            DeleteParameterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteParameterError {
    fn code(&self) -> Option<&str> {
        DeleteParameterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteParameterError {
    pub fn new(kind: DeleteParameterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteParameterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteParameterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteParameterErrorKind::InternalServerError(_))
    }
    pub fn is_parameter_not_found(&self) -> bool {
        matches!(&self.kind, DeleteParameterErrorKind::ParameterNotFound(_))
    }
}
impl std::error::Error for DeleteParameterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteParameterErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteParameterErrorKind::ParameterNotFound(_inner) => Some(_inner),
            DeleteParameterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteParametersError {
    pub kind: DeleteParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteParametersErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteParametersErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteParametersError {
    fn code(&self) -> Option<&str> {
        DeleteParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteParametersError {
    pub fn new(kind: DeleteParametersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteParametersErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DeleteParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteParametersErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteParametersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePatchBaselineError {
    pub kind: DeletePatchBaselineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePatchBaselineErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ResourceInUseError(crate::error::ResourceInUseError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePatchBaselineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePatchBaselineErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeletePatchBaselineErrorKind::ResourceInUseError(_inner) => _inner.fmt(f),
            DeletePatchBaselineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePatchBaselineError {
    fn code(&self) -> Option<&str> {
        DeletePatchBaselineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePatchBaselineError {
    pub fn new(kind: DeletePatchBaselineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePatchBaselineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePatchBaselineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeletePatchBaselineErrorKind::InternalServerError(_)
        )
    }
    pub fn is_resource_in_use_error(&self) -> bool {
        matches!(
            &self.kind,
            DeletePatchBaselineErrorKind::ResourceInUseError(_)
        )
    }
}
impl std::error::Error for DeletePatchBaselineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePatchBaselineErrorKind::InternalServerError(_inner) => Some(_inner),
            DeletePatchBaselineErrorKind::ResourceInUseError(_inner) => Some(_inner),
            DeletePatchBaselineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResourceDataSyncError {
    pub kind: DeleteResourceDataSyncErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResourceDataSyncErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ResourceDataSyncInvalidConfigurationError(
        crate::error::ResourceDataSyncInvalidConfigurationError,
    ),
    ResourceDataSyncNotFoundError(crate::error::ResourceDataSyncNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResourceDataSyncError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResourceDataSyncErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(_inner) => {
                _inner.fmt(f)
            }
            DeleteResourceDataSyncErrorKind::ResourceDataSyncNotFoundError(_inner) => _inner.fmt(f),
            DeleteResourceDataSyncErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResourceDataSyncError {
    fn code(&self) -> Option<&str> {
        DeleteResourceDataSyncError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResourceDataSyncError {
    pub fn new(kind: DeleteResourceDataSyncErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResourceDataSyncErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResourceDataSyncErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourceDataSyncErrorKind::InternalServerError(_)
        )
    }
    pub fn is_resource_data_sync_invalid_configuration_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(_)
        )
    }
    pub fn is_resource_data_sync_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourceDataSyncErrorKind::ResourceDataSyncNotFoundError(_)
        )
    }
}
impl std::error::Error for DeleteResourceDataSyncError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResourceDataSyncErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(_inner) => {
                Some(_inner)
            }
            DeleteResourceDataSyncErrorKind::ResourceDataSyncNotFoundError(_inner) => Some(_inner),
            DeleteResourceDataSyncErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterManagedInstanceError {
    pub kind: DeregisterManagedInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterManagedInstanceErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterManagedInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterManagedInstanceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeregisterManagedInstanceErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            DeregisterManagedInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterManagedInstanceError {
    fn code(&self) -> Option<&str> {
        DeregisterManagedInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterManagedInstanceError {
    pub fn new(kind: DeregisterManagedInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterManagedInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterManagedInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterManagedInstanceErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterManagedInstanceErrorKind::InvalidInstanceId(_)
        )
    }
}
impl std::error::Error for DeregisterManagedInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterManagedInstanceErrorKind::InternalServerError(_inner) => Some(_inner),
            DeregisterManagedInstanceErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            DeregisterManagedInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterPatchBaselineForPatchGroupError {
    pub kind: DeregisterPatchBaselineForPatchGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterPatchBaselineForPatchGroupErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidResourceId(crate::error::InvalidResourceId),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterPatchBaselineForPatchGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterPatchBaselineForPatchGroupErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DeregisterPatchBaselineForPatchGroupErrorKind::InvalidResourceId(_inner) => {
                _inner.fmt(f)
            }
            DeregisterPatchBaselineForPatchGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterPatchBaselineForPatchGroupError {
    fn code(&self) -> Option<&str> {
        DeregisterPatchBaselineForPatchGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterPatchBaselineForPatchGroupError {
    pub fn new(
        kind: DeregisterPatchBaselineForPatchGroupErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterPatchBaselineForPatchGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterPatchBaselineForPatchGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterPatchBaselineForPatchGroupErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_resource_id(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterPatchBaselineForPatchGroupErrorKind::InvalidResourceId(_)
        )
    }
}
impl std::error::Error for DeregisterPatchBaselineForPatchGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterPatchBaselineForPatchGroupErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DeregisterPatchBaselineForPatchGroupErrorKind::InvalidResourceId(_inner) => {
                Some(_inner)
            }
            DeregisterPatchBaselineForPatchGroupErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterTargetFromMaintenanceWindowError {
    pub kind: DeregisterTargetFromMaintenanceWindowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterTargetFromMaintenanceWindowErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    TargetInUseError(crate::error::TargetInUseError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterTargetFromMaintenanceWindowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterTargetFromMaintenanceWindowErrorKind::DoesNotExistError(_inner) => {
                _inner.fmt(f)
            }
            DeregisterTargetFromMaintenanceWindowErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DeregisterTargetFromMaintenanceWindowErrorKind::TargetInUseError(_inner) => {
                _inner.fmt(f)
            }
            DeregisterTargetFromMaintenanceWindowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterTargetFromMaintenanceWindowError {
    fn code(&self) -> Option<&str> {
        DeregisterTargetFromMaintenanceWindowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterTargetFromMaintenanceWindowError {
    pub fn new(
        kind: DeregisterTargetFromMaintenanceWindowErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterTargetFromMaintenanceWindowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterTargetFromMaintenanceWindowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterTargetFromMaintenanceWindowErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterTargetFromMaintenanceWindowErrorKind::InternalServerError(_)
        )
    }
    pub fn is_target_in_use_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterTargetFromMaintenanceWindowErrorKind::TargetInUseError(_)
        )
    }
}
impl std::error::Error for DeregisterTargetFromMaintenanceWindowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterTargetFromMaintenanceWindowErrorKind::DoesNotExistError(_inner) => {
                Some(_inner)
            }
            DeregisterTargetFromMaintenanceWindowErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DeregisterTargetFromMaintenanceWindowErrorKind::TargetInUseError(_inner) => {
                Some(_inner)
            }
            DeregisterTargetFromMaintenanceWindowErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterTaskFromMaintenanceWindowError {
    pub kind: DeregisterTaskFromMaintenanceWindowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterTaskFromMaintenanceWindowErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterTaskFromMaintenanceWindowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterTaskFromMaintenanceWindowErrorKind::DoesNotExistError(_inner) => {
                _inner.fmt(f)
            }
            DeregisterTaskFromMaintenanceWindowErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DeregisterTaskFromMaintenanceWindowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterTaskFromMaintenanceWindowError {
    fn code(&self) -> Option<&str> {
        DeregisterTaskFromMaintenanceWindowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterTaskFromMaintenanceWindowError {
    pub fn new(
        kind: DeregisterTaskFromMaintenanceWindowErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterTaskFromMaintenanceWindowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterTaskFromMaintenanceWindowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterTaskFromMaintenanceWindowErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterTaskFromMaintenanceWindowErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DeregisterTaskFromMaintenanceWindowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterTaskFromMaintenanceWindowErrorKind::DoesNotExistError(_inner) => Some(_inner),
            DeregisterTaskFromMaintenanceWindowErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DeregisterTaskFromMaintenanceWindowErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeActivationsError {
    pub kind: DescribeActivationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeActivationsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidFilter(crate::error::InvalidFilter),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeActivationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeActivationsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeActivationsErrorKind::InvalidFilter(_inner) => _inner.fmt(f),
            DescribeActivationsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribeActivationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeActivationsError {
    fn code(&self) -> Option<&str> {
        DescribeActivationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeActivationsError {
    pub fn new(kind: DescribeActivationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeActivationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeActivationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeActivationsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_filter(&self) -> bool {
        matches!(&self.kind, DescribeActivationsErrorKind::InvalidFilter(_))
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribeActivationsErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for DescribeActivationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeActivationsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeActivationsErrorKind::InvalidFilter(_inner) => Some(_inner),
            DescribeActivationsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribeActivationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAssociationError {
    pub kind: DescribeAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAssociationErrorKind {
    AssociationDoesNotExist(crate::error::AssociationDoesNotExist),
    InternalServerError(crate::error::InternalServerError),
    InvalidAssociationVersion(crate::error::InvalidAssociationVersion),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAssociationErrorKind::AssociationDoesNotExist(_inner) => _inner.fmt(f),
            DescribeAssociationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeAssociationErrorKind::InvalidAssociationVersion(_inner) => _inner.fmt(f),
            DescribeAssociationErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            DescribeAssociationErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            DescribeAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAssociationError {
    fn code(&self) -> Option<&str> {
        DescribeAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAssociationError {
    pub fn new(kind: DescribeAssociationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_association_does_not_exist(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssociationErrorKind::AssociationDoesNotExist(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssociationErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_association_version(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssociationErrorKind::InvalidAssociationVersion(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(&self.kind, DescribeAssociationErrorKind::InvalidDocument(_))
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssociationErrorKind::InvalidInstanceId(_)
        )
    }
}
impl std::error::Error for DescribeAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAssociationErrorKind::AssociationDoesNotExist(_inner) => Some(_inner),
            DescribeAssociationErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeAssociationErrorKind::InvalidAssociationVersion(_inner) => Some(_inner),
            DescribeAssociationErrorKind::InvalidDocument(_inner) => Some(_inner),
            DescribeAssociationErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            DescribeAssociationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAssociationExecutionsError {
    pub kind: DescribeAssociationExecutionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAssociationExecutionsErrorKind {
    AssociationDoesNotExist(crate::error::AssociationDoesNotExist),
    InternalServerError(crate::error::InternalServerError),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAssociationExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAssociationExecutionsErrorKind::AssociationDoesNotExist(_inner) => {
                _inner.fmt(f)
            }
            DescribeAssociationExecutionsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeAssociationExecutionsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribeAssociationExecutionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAssociationExecutionsError {
    fn code(&self) -> Option<&str> {
        DescribeAssociationExecutionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAssociationExecutionsError {
    pub fn new(kind: DescribeAssociationExecutionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAssociationExecutionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAssociationExecutionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_association_does_not_exist(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssociationExecutionsErrorKind::AssociationDoesNotExist(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssociationExecutionsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssociationExecutionsErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for DescribeAssociationExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAssociationExecutionsErrorKind::AssociationDoesNotExist(_inner) => Some(_inner),
            DescribeAssociationExecutionsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeAssociationExecutionsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribeAssociationExecutionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAssociationExecutionTargetsError {
    pub kind: DescribeAssociationExecutionTargetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAssociationExecutionTargetsErrorKind {
    AssociationDoesNotExist(crate::error::AssociationDoesNotExist),
    AssociationExecutionDoesNotExist(crate::error::AssociationExecutionDoesNotExist),
    InternalServerError(crate::error::InternalServerError),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAssociationExecutionTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAssociationExecutionTargetsErrorKind::AssociationDoesNotExist(_inner) => {
                _inner.fmt(f)
            }
            DescribeAssociationExecutionTargetsErrorKind::AssociationExecutionDoesNotExist(
                _inner,
            ) => _inner.fmt(f),
            DescribeAssociationExecutionTargetsErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeAssociationExecutionTargetsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribeAssociationExecutionTargetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAssociationExecutionTargetsError {
    fn code(&self) -> Option<&str> {
        DescribeAssociationExecutionTargetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAssociationExecutionTargetsError {
    pub fn new(
        kind: DescribeAssociationExecutionTargetsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAssociationExecutionTargetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAssociationExecutionTargetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_association_does_not_exist(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssociationExecutionTargetsErrorKind::AssociationDoesNotExist(_)
        )
    }
    pub fn is_association_execution_does_not_exist(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssociationExecutionTargetsErrorKind::AssociationExecutionDoesNotExist(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssociationExecutionTargetsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssociationExecutionTargetsErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for DescribeAssociationExecutionTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAssociationExecutionTargetsErrorKind::AssociationDoesNotExist(_inner) => {
                Some(_inner)
            }
            DescribeAssociationExecutionTargetsErrorKind::AssociationExecutionDoesNotExist(
                _inner,
            ) => Some(_inner),
            DescribeAssociationExecutionTargetsErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DescribeAssociationExecutionTargetsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribeAssociationExecutionTargetsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAutomationExecutionsError {
    pub kind: DescribeAutomationExecutionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAutomationExecutionsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidFilterKey(crate::error::InvalidFilterKey),
    InvalidFilterValue(crate::error::InvalidFilterValue),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAutomationExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAutomationExecutionsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeAutomationExecutionsErrorKind::InvalidFilterKey(_inner) => _inner.fmt(f),
            DescribeAutomationExecutionsErrorKind::InvalidFilterValue(_inner) => _inner.fmt(f),
            DescribeAutomationExecutionsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribeAutomationExecutionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAutomationExecutionsError {
    fn code(&self) -> Option<&str> {
        DescribeAutomationExecutionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAutomationExecutionsError {
    pub fn new(kind: DescribeAutomationExecutionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAutomationExecutionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAutomationExecutionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAutomationExecutionsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_filter_key(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAutomationExecutionsErrorKind::InvalidFilterKey(_)
        )
    }
    pub fn is_invalid_filter_value(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAutomationExecutionsErrorKind::InvalidFilterValue(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAutomationExecutionsErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for DescribeAutomationExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAutomationExecutionsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeAutomationExecutionsErrorKind::InvalidFilterKey(_inner) => Some(_inner),
            DescribeAutomationExecutionsErrorKind::InvalidFilterValue(_inner) => Some(_inner),
            DescribeAutomationExecutionsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribeAutomationExecutionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAutomationStepExecutionsError {
    pub kind: DescribeAutomationStepExecutionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAutomationStepExecutionsErrorKind {
    AutomationExecutionNotFoundError(crate::error::AutomationExecutionNotFoundError),
    InternalServerError(crate::error::InternalServerError),
    InvalidFilterKey(crate::error::InvalidFilterKey),
    InvalidFilterValue(crate::error::InvalidFilterValue),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAutomationStepExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAutomationStepExecutionsErrorKind::AutomationExecutionNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            DescribeAutomationStepExecutionsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeAutomationStepExecutionsErrorKind::InvalidFilterKey(_inner) => _inner.fmt(f),
            DescribeAutomationStepExecutionsErrorKind::InvalidFilterValue(_inner) => _inner.fmt(f),
            DescribeAutomationStepExecutionsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribeAutomationStepExecutionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAutomationStepExecutionsError {
    fn code(&self) -> Option<&str> {
        DescribeAutomationStepExecutionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAutomationStepExecutionsError {
    pub fn new(kind: DescribeAutomationStepExecutionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAutomationStepExecutionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAutomationStepExecutionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_automation_execution_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAutomationStepExecutionsErrorKind::AutomationExecutionNotFoundError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAutomationStepExecutionsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_filter_key(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAutomationStepExecutionsErrorKind::InvalidFilterKey(_)
        )
    }
    pub fn is_invalid_filter_value(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAutomationStepExecutionsErrorKind::InvalidFilterValue(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAutomationStepExecutionsErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for DescribeAutomationStepExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAutomationStepExecutionsErrorKind::AutomationExecutionNotFoundError(_inner) => {
                Some(_inner)
            }
            DescribeAutomationStepExecutionsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeAutomationStepExecutionsErrorKind::InvalidFilterKey(_inner) => Some(_inner),
            DescribeAutomationStepExecutionsErrorKind::InvalidFilterValue(_inner) => Some(_inner),
            DescribeAutomationStepExecutionsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribeAutomationStepExecutionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAvailablePatchesError {
    pub kind: DescribeAvailablePatchesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAvailablePatchesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAvailablePatchesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAvailablePatchesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeAvailablePatchesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAvailablePatchesError {
    fn code(&self) -> Option<&str> {
        DescribeAvailablePatchesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAvailablePatchesError {
    pub fn new(kind: DescribeAvailablePatchesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAvailablePatchesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAvailablePatchesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAvailablePatchesErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeAvailablePatchesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAvailablePatchesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeAvailablePatchesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDocumentError {
    pub kind: DescribeDocumentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDocumentErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidDocumentVersion(crate::error::InvalidDocumentVersion),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDocumentErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeDocumentErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            DescribeDocumentErrorKind::InvalidDocumentVersion(_inner) => _inner.fmt(f),
            DescribeDocumentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDocumentError {
    fn code(&self) -> Option<&str> {
        DescribeDocumentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDocumentError {
    pub fn new(kind: DescribeDocumentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDocumentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDocumentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDocumentErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(&self.kind, DescribeDocumentErrorKind::InvalidDocument(_))
    }
    pub fn is_invalid_document_version(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDocumentErrorKind::InvalidDocumentVersion(_)
        )
    }
}
impl std::error::Error for DescribeDocumentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDocumentErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeDocumentErrorKind::InvalidDocument(_inner) => Some(_inner),
            DescribeDocumentErrorKind::InvalidDocumentVersion(_inner) => Some(_inner),
            DescribeDocumentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDocumentPermissionError {
    pub kind: DescribeDocumentPermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDocumentPermissionErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidDocumentOperation(crate::error::InvalidDocumentOperation),
    InvalidNextToken(crate::error::InvalidNextToken),
    InvalidPermissionType(crate::error::InvalidPermissionType),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDocumentPermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDocumentPermissionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeDocumentPermissionErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            DescribeDocumentPermissionErrorKind::InvalidDocumentOperation(_inner) => _inner.fmt(f),
            DescribeDocumentPermissionErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribeDocumentPermissionErrorKind::InvalidPermissionType(_inner) => _inner.fmt(f),
            DescribeDocumentPermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDocumentPermissionError {
    fn code(&self) -> Option<&str> {
        DescribeDocumentPermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDocumentPermissionError {
    pub fn new(kind: DescribeDocumentPermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDocumentPermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDocumentPermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDocumentPermissionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDocumentPermissionErrorKind::InvalidDocument(_)
        )
    }
    pub fn is_invalid_document_operation(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDocumentPermissionErrorKind::InvalidDocumentOperation(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDocumentPermissionErrorKind::InvalidNextToken(_)
        )
    }
    pub fn is_invalid_permission_type(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDocumentPermissionErrorKind::InvalidPermissionType(_)
        )
    }
}
impl std::error::Error for DescribeDocumentPermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDocumentPermissionErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeDocumentPermissionErrorKind::InvalidDocument(_inner) => Some(_inner),
            DescribeDocumentPermissionErrorKind::InvalidDocumentOperation(_inner) => Some(_inner),
            DescribeDocumentPermissionErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribeDocumentPermissionErrorKind::InvalidPermissionType(_inner) => Some(_inner),
            DescribeDocumentPermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEffectiveInstanceAssociationsError {
    pub kind: DescribeEffectiveInstanceAssociationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEffectiveInstanceAssociationsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEffectiveInstanceAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEffectiveInstanceAssociationsErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeEffectiveInstanceAssociationsErrorKind::InvalidInstanceId(_inner) => {
                _inner.fmt(f)
            }
            DescribeEffectiveInstanceAssociationsErrorKind::InvalidNextToken(_inner) => {
                _inner.fmt(f)
            }
            DescribeEffectiveInstanceAssociationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEffectiveInstanceAssociationsError {
    fn code(&self) -> Option<&str> {
        DescribeEffectiveInstanceAssociationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEffectiveInstanceAssociationsError {
    pub fn new(
        kind: DescribeEffectiveInstanceAssociationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEffectiveInstanceAssociationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEffectiveInstanceAssociationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEffectiveInstanceAssociationsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEffectiveInstanceAssociationsErrorKind::InvalidInstanceId(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEffectiveInstanceAssociationsErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for DescribeEffectiveInstanceAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEffectiveInstanceAssociationsErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DescribeEffectiveInstanceAssociationsErrorKind::InvalidInstanceId(_inner) => {
                Some(_inner)
            }
            DescribeEffectiveInstanceAssociationsErrorKind::InvalidNextToken(_inner) => {
                Some(_inner)
            }
            DescribeEffectiveInstanceAssociationsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEffectivePatchesForPatchBaselineError {
    pub kind: DescribeEffectivePatchesForPatchBaselineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEffectivePatchesForPatchBaselineErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    InvalidResourceId(crate::error::InvalidResourceId),
    UnsupportedOperatingSystem(crate::error::UnsupportedOperatingSystem),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEffectivePatchesForPatchBaselineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEffectivePatchesForPatchBaselineErrorKind::DoesNotExistError(_inner) => {
                _inner.fmt(f)
            }
            DescribeEffectivePatchesForPatchBaselineErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeEffectivePatchesForPatchBaselineErrorKind::InvalidResourceId(_inner) => {
                _inner.fmt(f)
            }
            DescribeEffectivePatchesForPatchBaselineErrorKind::UnsupportedOperatingSystem(
                _inner,
            ) => _inner.fmt(f),
            DescribeEffectivePatchesForPatchBaselineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEffectivePatchesForPatchBaselineError {
    fn code(&self) -> Option<&str> {
        DescribeEffectivePatchesForPatchBaselineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEffectivePatchesForPatchBaselineError {
    pub fn new(
        kind: DescribeEffectivePatchesForPatchBaselineErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEffectivePatchesForPatchBaselineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEffectivePatchesForPatchBaselineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEffectivePatchesForPatchBaselineErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEffectivePatchesForPatchBaselineErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_resource_id(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEffectivePatchesForPatchBaselineErrorKind::InvalidResourceId(_)
        )
    }
    pub fn is_unsupported_operating_system(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEffectivePatchesForPatchBaselineErrorKind::UnsupportedOperatingSystem(_)
        )
    }
}
impl std::error::Error for DescribeEffectivePatchesForPatchBaselineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEffectivePatchesForPatchBaselineErrorKind::DoesNotExistError(_inner) => {
                Some(_inner)
            }
            DescribeEffectivePatchesForPatchBaselineErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DescribeEffectivePatchesForPatchBaselineErrorKind::InvalidResourceId(_inner) => {
                Some(_inner)
            }
            DescribeEffectivePatchesForPatchBaselineErrorKind::UnsupportedOperatingSystem(
                _inner,
            ) => Some(_inner),
            DescribeEffectivePatchesForPatchBaselineErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInstanceAssociationsStatusError {
    pub kind: DescribeInstanceAssociationsStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInstanceAssociationsStatusErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInstanceAssociationsStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInstanceAssociationsStatusErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeInstanceAssociationsStatusErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            DescribeInstanceAssociationsStatusErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribeInstanceAssociationsStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInstanceAssociationsStatusError {
    fn code(&self) -> Option<&str> {
        DescribeInstanceAssociationsStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInstanceAssociationsStatusError {
    pub fn new(
        kind: DescribeInstanceAssociationsStatusErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInstanceAssociationsStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInstanceAssociationsStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceAssociationsStatusErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceAssociationsStatusErrorKind::InvalidInstanceId(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceAssociationsStatusErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for DescribeInstanceAssociationsStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInstanceAssociationsStatusErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DescribeInstanceAssociationsStatusErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            DescribeInstanceAssociationsStatusErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribeInstanceAssociationsStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInstanceInformationError {
    pub kind: DescribeInstanceInformationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInstanceInformationErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidFilterKey(crate::error::InvalidFilterKey),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    InvalidInstanceInformationFilterValue(crate::error::InvalidInstanceInformationFilterValue),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInstanceInformationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInstanceInformationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeInstanceInformationErrorKind::InvalidFilterKey(_inner) => _inner.fmt(f),
            DescribeInstanceInformationErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            DescribeInstanceInformationErrorKind::InvalidInstanceInformationFilterValue(_inner) => {
                _inner.fmt(f)
            }
            DescribeInstanceInformationErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribeInstanceInformationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInstanceInformationError {
    fn code(&self) -> Option<&str> {
        DescribeInstanceInformationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInstanceInformationError {
    pub fn new(kind: DescribeInstanceInformationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInstanceInformationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInstanceInformationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceInformationErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_filter_key(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceInformationErrorKind::InvalidFilterKey(_)
        )
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceInformationErrorKind::InvalidInstanceId(_)
        )
    }
    pub fn is_invalid_instance_information_filter_value(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceInformationErrorKind::InvalidInstanceInformationFilterValue(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceInformationErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for DescribeInstanceInformationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInstanceInformationErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeInstanceInformationErrorKind::InvalidFilterKey(_inner) => Some(_inner),
            DescribeInstanceInformationErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            DescribeInstanceInformationErrorKind::InvalidInstanceInformationFilterValue(_inner) => {
                Some(_inner)
            }
            DescribeInstanceInformationErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribeInstanceInformationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInstancePatchesError {
    pub kind: DescribeInstancePatchesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInstancePatchesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidFilter(crate::error::InvalidFilter),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInstancePatchesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInstancePatchesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeInstancePatchesErrorKind::InvalidFilter(_inner) => _inner.fmt(f),
            DescribeInstancePatchesErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            DescribeInstancePatchesErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribeInstancePatchesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInstancePatchesError {
    fn code(&self) -> Option<&str> {
        DescribeInstancePatchesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInstancePatchesError {
    pub fn new(kind: DescribeInstancePatchesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInstancePatchesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInstancePatchesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstancePatchesErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_filter(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstancePatchesErrorKind::InvalidFilter(_)
        )
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstancePatchesErrorKind::InvalidInstanceId(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstancePatchesErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for DescribeInstancePatchesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInstancePatchesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeInstancePatchesErrorKind::InvalidFilter(_inner) => Some(_inner),
            DescribeInstancePatchesErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            DescribeInstancePatchesErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribeInstancePatchesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInstancePatchStatesError {
    pub kind: DescribeInstancePatchStatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInstancePatchStatesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInstancePatchStatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInstancePatchStatesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeInstancePatchStatesErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribeInstancePatchStatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInstancePatchStatesError {
    fn code(&self) -> Option<&str> {
        DescribeInstancePatchStatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInstancePatchStatesError {
    pub fn new(kind: DescribeInstancePatchStatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInstancePatchStatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInstancePatchStatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstancePatchStatesErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstancePatchStatesErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for DescribeInstancePatchStatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInstancePatchStatesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeInstancePatchStatesErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribeInstancePatchStatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInstancePatchStatesForPatchGroupError {
    pub kind: DescribeInstancePatchStatesForPatchGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInstancePatchStatesForPatchGroupErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidFilter(crate::error::InvalidFilter),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInstancePatchStatesForPatchGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInstancePatchStatesForPatchGroupErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeInstancePatchStatesForPatchGroupErrorKind::InvalidFilter(_inner) => {
                _inner.fmt(f)
            }
            DescribeInstancePatchStatesForPatchGroupErrorKind::InvalidNextToken(_inner) => {
                _inner.fmt(f)
            }
            DescribeInstancePatchStatesForPatchGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInstancePatchStatesForPatchGroupError {
    fn code(&self) -> Option<&str> {
        DescribeInstancePatchStatesForPatchGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInstancePatchStatesForPatchGroupError {
    pub fn new(
        kind: DescribeInstancePatchStatesForPatchGroupErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInstancePatchStatesForPatchGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInstancePatchStatesForPatchGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstancePatchStatesForPatchGroupErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_filter(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstancePatchStatesForPatchGroupErrorKind::InvalidFilter(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstancePatchStatesForPatchGroupErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for DescribeInstancePatchStatesForPatchGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInstancePatchStatesForPatchGroupErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DescribeInstancePatchStatesForPatchGroupErrorKind::InvalidFilter(_inner) => {
                Some(_inner)
            }
            DescribeInstancePatchStatesForPatchGroupErrorKind::InvalidNextToken(_inner) => {
                Some(_inner)
            }
            DescribeInstancePatchStatesForPatchGroupErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInventoryDeletionsError {
    pub kind: DescribeInventoryDeletionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInventoryDeletionsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidDeletionIdError(crate::error::InvalidDeletionIdError),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInventoryDeletionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInventoryDeletionsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeInventoryDeletionsErrorKind::InvalidDeletionIdError(_inner) => _inner.fmt(f),
            DescribeInventoryDeletionsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribeInventoryDeletionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInventoryDeletionsError {
    fn code(&self) -> Option<&str> {
        DescribeInventoryDeletionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInventoryDeletionsError {
    pub fn new(kind: DescribeInventoryDeletionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInventoryDeletionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInventoryDeletionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInventoryDeletionsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_deletion_id_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInventoryDeletionsErrorKind::InvalidDeletionIdError(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInventoryDeletionsErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for DescribeInventoryDeletionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInventoryDeletionsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeInventoryDeletionsErrorKind::InvalidDeletionIdError(_inner) => Some(_inner),
            DescribeInventoryDeletionsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribeInventoryDeletionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMaintenanceWindowExecutionsError {
    pub kind: DescribeMaintenanceWindowExecutionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMaintenanceWindowExecutionsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMaintenanceWindowExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMaintenanceWindowExecutionsErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeMaintenanceWindowExecutionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMaintenanceWindowExecutionsError {
    fn code(&self) -> Option<&str> {
        DescribeMaintenanceWindowExecutionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMaintenanceWindowExecutionsError {
    pub fn new(
        kind: DescribeMaintenanceWindowExecutionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMaintenanceWindowExecutionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMaintenanceWindowExecutionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceWindowExecutionsErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeMaintenanceWindowExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMaintenanceWindowExecutionsErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DescribeMaintenanceWindowExecutionsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMaintenanceWindowExecutionTaskInvocationsError {
    pub kind: DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMaintenanceWindowExecutionTaskInvocationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::DoesNotExistError(
                _inner,
            ) => _inner.fmt(f),
            DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::InternalServerError(
                _inner,
            ) => _inner.fmt(f),
            DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind
    for DescribeMaintenanceWindowExecutionTaskInvocationsError
{
    fn code(&self) -> Option<&str> {
        DescribeMaintenanceWindowExecutionTaskInvocationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMaintenanceWindowExecutionTaskInvocationsError {
    pub fn new(
        kind: DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeMaintenanceWindowExecutionTaskInvocationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::DoesNotExistError(
                _inner,
            ) => Some(_inner),
            DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::InternalServerError(
                _inner,
            ) => Some(_inner),
            DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMaintenanceWindowExecutionTasksError {
    pub kind: DescribeMaintenanceWindowExecutionTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMaintenanceWindowExecutionTasksErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMaintenanceWindowExecutionTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMaintenanceWindowExecutionTasksErrorKind::DoesNotExistError(_inner) => {
                _inner.fmt(f)
            }
            DescribeMaintenanceWindowExecutionTasksErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeMaintenanceWindowExecutionTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMaintenanceWindowExecutionTasksError {
    fn code(&self) -> Option<&str> {
        DescribeMaintenanceWindowExecutionTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMaintenanceWindowExecutionTasksError {
    pub fn new(
        kind: DescribeMaintenanceWindowExecutionTasksErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMaintenanceWindowExecutionTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMaintenanceWindowExecutionTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceWindowExecutionTasksErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceWindowExecutionTasksErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeMaintenanceWindowExecutionTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMaintenanceWindowExecutionTasksErrorKind::DoesNotExistError(_inner) => {
                Some(_inner)
            }
            DescribeMaintenanceWindowExecutionTasksErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DescribeMaintenanceWindowExecutionTasksErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMaintenanceWindowsError {
    pub kind: DescribeMaintenanceWindowsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMaintenanceWindowsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMaintenanceWindowsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMaintenanceWindowsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeMaintenanceWindowsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMaintenanceWindowsError {
    fn code(&self) -> Option<&str> {
        DescribeMaintenanceWindowsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMaintenanceWindowsError {
    pub fn new(kind: DescribeMaintenanceWindowsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMaintenanceWindowsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMaintenanceWindowsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceWindowsErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeMaintenanceWindowsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMaintenanceWindowsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeMaintenanceWindowsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMaintenanceWindowScheduleError {
    pub kind: DescribeMaintenanceWindowScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMaintenanceWindowScheduleErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMaintenanceWindowScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMaintenanceWindowScheduleErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            DescribeMaintenanceWindowScheduleErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeMaintenanceWindowScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMaintenanceWindowScheduleError {
    fn code(&self) -> Option<&str> {
        DescribeMaintenanceWindowScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMaintenanceWindowScheduleError {
    pub fn new(
        kind: DescribeMaintenanceWindowScheduleErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMaintenanceWindowScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMaintenanceWindowScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceWindowScheduleErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceWindowScheduleErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeMaintenanceWindowScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMaintenanceWindowScheduleErrorKind::DoesNotExistError(_inner) => Some(_inner),
            DescribeMaintenanceWindowScheduleErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeMaintenanceWindowScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMaintenanceWindowsForTargetError {
    pub kind: DescribeMaintenanceWindowsForTargetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMaintenanceWindowsForTargetErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMaintenanceWindowsForTargetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMaintenanceWindowsForTargetErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeMaintenanceWindowsForTargetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMaintenanceWindowsForTargetError {
    fn code(&self) -> Option<&str> {
        DescribeMaintenanceWindowsForTargetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMaintenanceWindowsForTargetError {
    pub fn new(
        kind: DescribeMaintenanceWindowsForTargetErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMaintenanceWindowsForTargetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMaintenanceWindowsForTargetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceWindowsForTargetErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeMaintenanceWindowsForTargetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMaintenanceWindowsForTargetErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DescribeMaintenanceWindowsForTargetErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMaintenanceWindowTargetsError {
    pub kind: DescribeMaintenanceWindowTargetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMaintenanceWindowTargetsErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMaintenanceWindowTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMaintenanceWindowTargetsErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            DescribeMaintenanceWindowTargetsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeMaintenanceWindowTargetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMaintenanceWindowTargetsError {
    fn code(&self) -> Option<&str> {
        DescribeMaintenanceWindowTargetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMaintenanceWindowTargetsError {
    pub fn new(kind: DescribeMaintenanceWindowTargetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMaintenanceWindowTargetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMaintenanceWindowTargetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceWindowTargetsErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceWindowTargetsErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeMaintenanceWindowTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMaintenanceWindowTargetsErrorKind::DoesNotExistError(_inner) => Some(_inner),
            DescribeMaintenanceWindowTargetsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeMaintenanceWindowTargetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMaintenanceWindowTasksError {
    pub kind: DescribeMaintenanceWindowTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMaintenanceWindowTasksErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMaintenanceWindowTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMaintenanceWindowTasksErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            DescribeMaintenanceWindowTasksErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeMaintenanceWindowTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMaintenanceWindowTasksError {
    fn code(&self) -> Option<&str> {
        DescribeMaintenanceWindowTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMaintenanceWindowTasksError {
    pub fn new(kind: DescribeMaintenanceWindowTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMaintenanceWindowTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMaintenanceWindowTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceWindowTasksErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceWindowTasksErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeMaintenanceWindowTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMaintenanceWindowTasksErrorKind::DoesNotExistError(_inner) => Some(_inner),
            DescribeMaintenanceWindowTasksErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeMaintenanceWindowTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOpsItemsError {
    pub kind: DescribeOpsItemsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOpsItemsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOpsItemsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOpsItemsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeOpsItemsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOpsItemsError {
    fn code(&self) -> Option<&str> {
        DescribeOpsItemsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOpsItemsError {
    pub fn new(kind: DescribeOpsItemsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOpsItemsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOpsItemsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOpsItemsErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeOpsItemsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOpsItemsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeOpsItemsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeParametersError {
    pub kind: DescribeParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeParametersErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidFilterKey(crate::error::InvalidFilterKey),
    InvalidFilterOption(crate::error::InvalidFilterOption),
    InvalidFilterValue(crate::error::InvalidFilterValue),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeParametersErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeParametersErrorKind::InvalidFilterKey(_inner) => _inner.fmt(f),
            DescribeParametersErrorKind::InvalidFilterOption(_inner) => _inner.fmt(f),
            DescribeParametersErrorKind::InvalidFilterValue(_inner) => _inner.fmt(f),
            DescribeParametersErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribeParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeParametersError {
    fn code(&self) -> Option<&str> {
        DescribeParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeParametersError {
    pub fn new(kind: DescribeParametersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeParametersErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_filter_key(&self) -> bool {
        matches!(&self.kind, DescribeParametersErrorKind::InvalidFilterKey(_))
    }
    pub fn is_invalid_filter_option(&self) -> bool {
        matches!(
            &self.kind,
            DescribeParametersErrorKind::InvalidFilterOption(_)
        )
    }
    pub fn is_invalid_filter_value(&self) -> bool {
        matches!(
            &self.kind,
            DescribeParametersErrorKind::InvalidFilterValue(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(&self.kind, DescribeParametersErrorKind::InvalidNextToken(_))
    }
}
impl std::error::Error for DescribeParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeParametersErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeParametersErrorKind::InvalidFilterKey(_inner) => Some(_inner),
            DescribeParametersErrorKind::InvalidFilterOption(_inner) => Some(_inner),
            DescribeParametersErrorKind::InvalidFilterValue(_inner) => Some(_inner),
            DescribeParametersErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribeParametersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribePatchBaselinesError {
    pub kind: DescribePatchBaselinesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePatchBaselinesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribePatchBaselinesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribePatchBaselinesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribePatchBaselinesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribePatchBaselinesError {
    fn code(&self) -> Option<&str> {
        DescribePatchBaselinesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePatchBaselinesError {
    pub fn new(kind: DescribePatchBaselinesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribePatchBaselinesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribePatchBaselinesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribePatchBaselinesErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribePatchBaselinesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribePatchBaselinesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribePatchBaselinesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribePatchGroupsError {
    pub kind: DescribePatchGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePatchGroupsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribePatchGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribePatchGroupsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribePatchGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribePatchGroupsError {
    fn code(&self) -> Option<&str> {
        DescribePatchGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePatchGroupsError {
    pub fn new(kind: DescribePatchGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribePatchGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribePatchGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribePatchGroupsErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribePatchGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribePatchGroupsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribePatchGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribePatchGroupStateError {
    pub kind: DescribePatchGroupStateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePatchGroupStateErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribePatchGroupStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribePatchGroupStateErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribePatchGroupStateErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribePatchGroupStateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribePatchGroupStateError {
    fn code(&self) -> Option<&str> {
        DescribePatchGroupStateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePatchGroupStateError {
    pub fn new(kind: DescribePatchGroupStateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribePatchGroupStateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribePatchGroupStateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribePatchGroupStateErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            DescribePatchGroupStateErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for DescribePatchGroupStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribePatchGroupStateErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribePatchGroupStateErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribePatchGroupStateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribePatchPropertiesError {
    pub kind: DescribePatchPropertiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePatchPropertiesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribePatchPropertiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribePatchPropertiesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribePatchPropertiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribePatchPropertiesError {
    fn code(&self) -> Option<&str> {
        DescribePatchPropertiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePatchPropertiesError {
    pub fn new(kind: DescribePatchPropertiesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribePatchPropertiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribePatchPropertiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribePatchPropertiesErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribePatchPropertiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribePatchPropertiesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribePatchPropertiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSessionsError {
    pub kind: DescribeSessionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSessionsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidFilterKey(crate::error::InvalidFilterKey),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSessionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSessionsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeSessionsErrorKind::InvalidFilterKey(_inner) => _inner.fmt(f),
            DescribeSessionsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            DescribeSessionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSessionsError {
    fn code(&self) -> Option<&str> {
        DescribeSessionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSessionsError {
    pub fn new(kind: DescribeSessionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSessionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSessionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSessionsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_filter_key(&self) -> bool {
        matches!(&self.kind, DescribeSessionsErrorKind::InvalidFilterKey(_))
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(&self.kind, DescribeSessionsErrorKind::InvalidNextToken(_))
    }
}
impl std::error::Error for DescribeSessionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSessionsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeSessionsErrorKind::InvalidFilterKey(_inner) => Some(_inner),
            DescribeSessionsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            DescribeSessionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateOpsItemRelatedItemError {
    pub kind: DisassociateOpsItemRelatedItemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateOpsItemRelatedItemErrorKind {
    InternalServerError(crate::error::InternalServerError),
    OpsItemInvalidParameterError(crate::error::OpsItemInvalidParameterError),
    OpsItemNotFoundError(crate::error::OpsItemNotFoundError),
    OpsItemRelatedItemAssociationNotFoundError(
        crate::error::OpsItemRelatedItemAssociationNotFoundError,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateOpsItemRelatedItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateOpsItemRelatedItemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DisassociateOpsItemRelatedItemErrorKind::OpsItemInvalidParameterError(_inner) => {
                _inner.fmt(f)
            }
            DisassociateOpsItemRelatedItemErrorKind::OpsItemNotFoundError(_inner) => _inner.fmt(f),
            DisassociateOpsItemRelatedItemErrorKind::OpsItemRelatedItemAssociationNotFoundError(
                _inner,
            ) => _inner.fmt(f),
            DisassociateOpsItemRelatedItemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateOpsItemRelatedItemError {
    fn code(&self) -> Option<&str> {
        DisassociateOpsItemRelatedItemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateOpsItemRelatedItemError {
    pub fn new(kind: DisassociateOpsItemRelatedItemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateOpsItemRelatedItemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateOpsItemRelatedItemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateOpsItemRelatedItemErrorKind::InternalServerError(_)
        )
    }
    pub fn is_ops_item_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateOpsItemRelatedItemErrorKind::OpsItemInvalidParameterError(_)
        )
    }
    pub fn is_ops_item_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateOpsItemRelatedItemErrorKind::OpsItemNotFoundError(_)
        )
    }
    pub fn is_ops_item_related_item_association_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateOpsItemRelatedItemErrorKind::OpsItemRelatedItemAssociationNotFoundError(_)
        )
    }
}
impl std::error::Error for DisassociateOpsItemRelatedItemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateOpsItemRelatedItemErrorKind::InternalServerError(_inner) => Some(_inner),
            DisassociateOpsItemRelatedItemErrorKind::OpsItemInvalidParameterError(_inner) => {
                Some(_inner)
            }
            DisassociateOpsItemRelatedItemErrorKind::OpsItemNotFoundError(_inner) => Some(_inner),
            DisassociateOpsItemRelatedItemErrorKind::OpsItemRelatedItemAssociationNotFoundError(
                _inner,
            ) => Some(_inner),
            DisassociateOpsItemRelatedItemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAutomationExecutionError {
    pub kind: GetAutomationExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAutomationExecutionErrorKind {
    AutomationExecutionNotFoundError(crate::error::AutomationExecutionNotFoundError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAutomationExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAutomationExecutionErrorKind::AutomationExecutionNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            GetAutomationExecutionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetAutomationExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAutomationExecutionError {
    fn code(&self) -> Option<&str> {
        GetAutomationExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAutomationExecutionError {
    pub fn new(kind: GetAutomationExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAutomationExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAutomationExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_automation_execution_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetAutomationExecutionErrorKind::AutomationExecutionNotFoundError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetAutomationExecutionErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for GetAutomationExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAutomationExecutionErrorKind::AutomationExecutionNotFoundError(_inner) => {
                Some(_inner)
            }
            GetAutomationExecutionErrorKind::InternalServerError(_inner) => Some(_inner),
            GetAutomationExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCalendarStateError {
    pub kind: GetCalendarStateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCalendarStateErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidDocumentType(crate::error::InvalidDocumentType),
    UnsupportedCalendarError(crate::error::UnsupportedCalendarError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCalendarStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCalendarStateErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetCalendarStateErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            GetCalendarStateErrorKind::InvalidDocumentType(_inner) => _inner.fmt(f),
            GetCalendarStateErrorKind::UnsupportedCalendarError(_inner) => _inner.fmt(f),
            GetCalendarStateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCalendarStateError {
    fn code(&self) -> Option<&str> {
        GetCalendarStateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCalendarStateError {
    pub fn new(kind: GetCalendarStateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCalendarStateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCalendarStateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCalendarStateErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(&self.kind, GetCalendarStateErrorKind::InvalidDocument(_))
    }
    pub fn is_invalid_document_type(&self) -> bool {
        matches!(
            &self.kind,
            GetCalendarStateErrorKind::InvalidDocumentType(_)
        )
    }
    pub fn is_unsupported_calendar_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCalendarStateErrorKind::UnsupportedCalendarError(_)
        )
    }
}
impl std::error::Error for GetCalendarStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCalendarStateErrorKind::InternalServerError(_inner) => Some(_inner),
            GetCalendarStateErrorKind::InvalidDocument(_inner) => Some(_inner),
            GetCalendarStateErrorKind::InvalidDocumentType(_inner) => Some(_inner),
            GetCalendarStateErrorKind::UnsupportedCalendarError(_inner) => Some(_inner),
            GetCalendarStateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCommandInvocationError {
    pub kind: GetCommandInvocationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommandInvocationErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidCommandId(crate::error::InvalidCommandId),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    InvalidPluginName(crate::error::InvalidPluginName),
    InvocationDoesNotExist(crate::error::InvocationDoesNotExist),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCommandInvocationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCommandInvocationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetCommandInvocationErrorKind::InvalidCommandId(_inner) => _inner.fmt(f),
            GetCommandInvocationErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            GetCommandInvocationErrorKind::InvalidPluginName(_inner) => _inner.fmt(f),
            GetCommandInvocationErrorKind::InvocationDoesNotExist(_inner) => _inner.fmt(f),
            GetCommandInvocationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCommandInvocationError {
    fn code(&self) -> Option<&str> {
        GetCommandInvocationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommandInvocationError {
    pub fn new(kind: GetCommandInvocationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCommandInvocationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCommandInvocationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCommandInvocationErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_command_id(&self) -> bool {
        matches!(
            &self.kind,
            GetCommandInvocationErrorKind::InvalidCommandId(_)
        )
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(
            &self.kind,
            GetCommandInvocationErrorKind::InvalidInstanceId(_)
        )
    }
    pub fn is_invalid_plugin_name(&self) -> bool {
        matches!(
            &self.kind,
            GetCommandInvocationErrorKind::InvalidPluginName(_)
        )
    }
    pub fn is_invocation_does_not_exist(&self) -> bool {
        matches!(
            &self.kind,
            GetCommandInvocationErrorKind::InvocationDoesNotExist(_)
        )
    }
}
impl std::error::Error for GetCommandInvocationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCommandInvocationErrorKind::InternalServerError(_inner) => Some(_inner),
            GetCommandInvocationErrorKind::InvalidCommandId(_inner) => Some(_inner),
            GetCommandInvocationErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            GetCommandInvocationErrorKind::InvalidPluginName(_inner) => Some(_inner),
            GetCommandInvocationErrorKind::InvocationDoesNotExist(_inner) => Some(_inner),
            GetCommandInvocationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetConnectionStatusError {
    pub kind: GetConnectionStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetConnectionStatusErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetConnectionStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetConnectionStatusErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetConnectionStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetConnectionStatusError {
    fn code(&self) -> Option<&str> {
        GetConnectionStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetConnectionStatusError {
    pub fn new(kind: GetConnectionStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetConnectionStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetConnectionStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetConnectionStatusErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for GetConnectionStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetConnectionStatusErrorKind::InternalServerError(_inner) => Some(_inner),
            GetConnectionStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDefaultPatchBaselineError {
    pub kind: GetDefaultPatchBaselineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDefaultPatchBaselineErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDefaultPatchBaselineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDefaultPatchBaselineErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetDefaultPatchBaselineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDefaultPatchBaselineError {
    fn code(&self) -> Option<&str> {
        GetDefaultPatchBaselineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDefaultPatchBaselineError {
    pub fn new(kind: GetDefaultPatchBaselineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDefaultPatchBaselineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDefaultPatchBaselineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDefaultPatchBaselineErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for GetDefaultPatchBaselineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDefaultPatchBaselineErrorKind::InternalServerError(_inner) => Some(_inner),
            GetDefaultPatchBaselineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDeployablePatchSnapshotForInstanceError {
    pub kind: GetDeployablePatchSnapshotForInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeployablePatchSnapshotForInstanceErrorKind {
    InternalServerError(crate::error::InternalServerError),
    UnsupportedFeatureRequiredError(crate::error::UnsupportedFeatureRequiredError),
    UnsupportedOperatingSystem(crate::error::UnsupportedOperatingSystem),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDeployablePatchSnapshotForInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDeployablePatchSnapshotForInstanceErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            GetDeployablePatchSnapshotForInstanceErrorKind::UnsupportedFeatureRequiredError(
                _inner,
            ) => _inner.fmt(f),
            GetDeployablePatchSnapshotForInstanceErrorKind::UnsupportedOperatingSystem(_inner) => {
                _inner.fmt(f)
            }
            GetDeployablePatchSnapshotForInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDeployablePatchSnapshotForInstanceError {
    fn code(&self) -> Option<&str> {
        GetDeployablePatchSnapshotForInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeployablePatchSnapshotForInstanceError {
    pub fn new(
        kind: GetDeployablePatchSnapshotForInstanceErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDeployablePatchSnapshotForInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDeployablePatchSnapshotForInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDeployablePatchSnapshotForInstanceErrorKind::InternalServerError(_)
        )
    }
    pub fn is_unsupported_feature_required_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDeployablePatchSnapshotForInstanceErrorKind::UnsupportedFeatureRequiredError(_)
        )
    }
    pub fn is_unsupported_operating_system(&self) -> bool {
        matches!(
            &self.kind,
            GetDeployablePatchSnapshotForInstanceErrorKind::UnsupportedOperatingSystem(_)
        )
    }
}
impl std::error::Error for GetDeployablePatchSnapshotForInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDeployablePatchSnapshotForInstanceErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            GetDeployablePatchSnapshotForInstanceErrorKind::UnsupportedFeatureRequiredError(
                _inner,
            ) => Some(_inner),
            GetDeployablePatchSnapshotForInstanceErrorKind::UnsupportedOperatingSystem(_inner) => {
                Some(_inner)
            }
            GetDeployablePatchSnapshotForInstanceErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDocumentError {
    pub kind: GetDocumentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDocumentErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidDocumentVersion(crate::error::InvalidDocumentVersion),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDocumentErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetDocumentErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            GetDocumentErrorKind::InvalidDocumentVersion(_inner) => _inner.fmt(f),
            GetDocumentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDocumentError {
    fn code(&self) -> Option<&str> {
        GetDocumentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDocumentError {
    pub fn new(kind: GetDocumentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDocumentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDocumentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, GetDocumentErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(&self.kind, GetDocumentErrorKind::InvalidDocument(_))
    }
    pub fn is_invalid_document_version(&self) -> bool {
        matches!(&self.kind, GetDocumentErrorKind::InvalidDocumentVersion(_))
    }
}
impl std::error::Error for GetDocumentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDocumentErrorKind::InternalServerError(_inner) => Some(_inner),
            GetDocumentErrorKind::InvalidDocument(_inner) => Some(_inner),
            GetDocumentErrorKind::InvalidDocumentVersion(_inner) => Some(_inner),
            GetDocumentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInventoryError {
    pub kind: GetInventoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInventoryErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidAggregatorError(crate::error::InvalidAggregatorError),
    InvalidFilter(crate::error::InvalidFilter),
    InvalidInventoryGroupError(crate::error::InvalidInventoryGroupError),
    InvalidNextToken(crate::error::InvalidNextToken),
    InvalidResultAttributeError(crate::error::InvalidResultAttributeError),
    InvalidTypeNameError(crate::error::InvalidTypeNameError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInventoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInventoryErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetInventoryErrorKind::InvalidAggregatorError(_inner) => _inner.fmt(f),
            GetInventoryErrorKind::InvalidFilter(_inner) => _inner.fmt(f),
            GetInventoryErrorKind::InvalidInventoryGroupError(_inner) => _inner.fmt(f),
            GetInventoryErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            GetInventoryErrorKind::InvalidResultAttributeError(_inner) => _inner.fmt(f),
            GetInventoryErrorKind::InvalidTypeNameError(_inner) => _inner.fmt(f),
            GetInventoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInventoryError {
    fn code(&self) -> Option<&str> {
        GetInventoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInventoryError {
    pub fn new(kind: GetInventoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInventoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInventoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, GetInventoryErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_aggregator_error(&self) -> bool {
        matches!(&self.kind, GetInventoryErrorKind::InvalidAggregatorError(_))
    }
    pub fn is_invalid_filter(&self) -> bool {
        matches!(&self.kind, GetInventoryErrorKind::InvalidFilter(_))
    }
    pub fn is_invalid_inventory_group_error(&self) -> bool {
        matches!(
            &self.kind,
            GetInventoryErrorKind::InvalidInventoryGroupError(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(&self.kind, GetInventoryErrorKind::InvalidNextToken(_))
    }
    pub fn is_invalid_result_attribute_error(&self) -> bool {
        matches!(
            &self.kind,
            GetInventoryErrorKind::InvalidResultAttributeError(_)
        )
    }
    pub fn is_invalid_type_name_error(&self) -> bool {
        matches!(&self.kind, GetInventoryErrorKind::InvalidTypeNameError(_))
    }
}
impl std::error::Error for GetInventoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInventoryErrorKind::InternalServerError(_inner) => Some(_inner),
            GetInventoryErrorKind::InvalidAggregatorError(_inner) => Some(_inner),
            GetInventoryErrorKind::InvalidFilter(_inner) => Some(_inner),
            GetInventoryErrorKind::InvalidInventoryGroupError(_inner) => Some(_inner),
            GetInventoryErrorKind::InvalidNextToken(_inner) => Some(_inner),
            GetInventoryErrorKind::InvalidResultAttributeError(_inner) => Some(_inner),
            GetInventoryErrorKind::InvalidTypeNameError(_inner) => Some(_inner),
            GetInventoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInventorySchemaError {
    pub kind: GetInventorySchemaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInventorySchemaErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidNextToken(crate::error::InvalidNextToken),
    InvalidTypeNameError(crate::error::InvalidTypeNameError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInventorySchemaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInventorySchemaErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetInventorySchemaErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            GetInventorySchemaErrorKind::InvalidTypeNameError(_inner) => _inner.fmt(f),
            GetInventorySchemaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInventorySchemaError {
    fn code(&self) -> Option<&str> {
        GetInventorySchemaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInventorySchemaError {
    pub fn new(kind: GetInventorySchemaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInventorySchemaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInventorySchemaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetInventorySchemaErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(&self.kind, GetInventorySchemaErrorKind::InvalidNextToken(_))
    }
    pub fn is_invalid_type_name_error(&self) -> bool {
        matches!(
            &self.kind,
            GetInventorySchemaErrorKind::InvalidTypeNameError(_)
        )
    }
}
impl std::error::Error for GetInventorySchemaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInventorySchemaErrorKind::InternalServerError(_inner) => Some(_inner),
            GetInventorySchemaErrorKind::InvalidNextToken(_inner) => Some(_inner),
            GetInventorySchemaErrorKind::InvalidTypeNameError(_inner) => Some(_inner),
            GetInventorySchemaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMaintenanceWindowError {
    pub kind: GetMaintenanceWindowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMaintenanceWindowErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMaintenanceWindowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMaintenanceWindowErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            GetMaintenanceWindowErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetMaintenanceWindowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMaintenanceWindowError {
    fn code(&self) -> Option<&str> {
        GetMaintenanceWindowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMaintenanceWindowError {
    pub fn new(kind: GetMaintenanceWindowErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMaintenanceWindowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMaintenanceWindowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            GetMaintenanceWindowErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetMaintenanceWindowErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for GetMaintenanceWindowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMaintenanceWindowErrorKind::DoesNotExistError(_inner) => Some(_inner),
            GetMaintenanceWindowErrorKind::InternalServerError(_inner) => Some(_inner),
            GetMaintenanceWindowErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMaintenanceWindowExecutionError {
    pub kind: GetMaintenanceWindowExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMaintenanceWindowExecutionErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMaintenanceWindowExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMaintenanceWindowExecutionErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            GetMaintenanceWindowExecutionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetMaintenanceWindowExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMaintenanceWindowExecutionError {
    fn code(&self) -> Option<&str> {
        GetMaintenanceWindowExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMaintenanceWindowExecutionError {
    pub fn new(kind: GetMaintenanceWindowExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMaintenanceWindowExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMaintenanceWindowExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            GetMaintenanceWindowExecutionErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetMaintenanceWindowExecutionErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for GetMaintenanceWindowExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMaintenanceWindowExecutionErrorKind::DoesNotExistError(_inner) => Some(_inner),
            GetMaintenanceWindowExecutionErrorKind::InternalServerError(_inner) => Some(_inner),
            GetMaintenanceWindowExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMaintenanceWindowExecutionTaskError {
    pub kind: GetMaintenanceWindowExecutionTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMaintenanceWindowExecutionTaskErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMaintenanceWindowExecutionTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMaintenanceWindowExecutionTaskErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            GetMaintenanceWindowExecutionTaskErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            GetMaintenanceWindowExecutionTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMaintenanceWindowExecutionTaskError {
    fn code(&self) -> Option<&str> {
        GetMaintenanceWindowExecutionTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMaintenanceWindowExecutionTaskError {
    pub fn new(
        kind: GetMaintenanceWindowExecutionTaskErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMaintenanceWindowExecutionTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMaintenanceWindowExecutionTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            GetMaintenanceWindowExecutionTaskErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetMaintenanceWindowExecutionTaskErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for GetMaintenanceWindowExecutionTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMaintenanceWindowExecutionTaskErrorKind::DoesNotExistError(_inner) => Some(_inner),
            GetMaintenanceWindowExecutionTaskErrorKind::InternalServerError(_inner) => Some(_inner),
            GetMaintenanceWindowExecutionTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMaintenanceWindowExecutionTaskInvocationError {
    pub kind: GetMaintenanceWindowExecutionTaskInvocationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMaintenanceWindowExecutionTaskInvocationErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMaintenanceWindowExecutionTaskInvocationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMaintenanceWindowExecutionTaskInvocationErrorKind::DoesNotExistError(_inner) => {
                _inner.fmt(f)
            }
            GetMaintenanceWindowExecutionTaskInvocationErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            GetMaintenanceWindowExecutionTaskInvocationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMaintenanceWindowExecutionTaskInvocationError {
    fn code(&self) -> Option<&str> {
        GetMaintenanceWindowExecutionTaskInvocationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMaintenanceWindowExecutionTaskInvocationError {
    pub fn new(
        kind: GetMaintenanceWindowExecutionTaskInvocationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMaintenanceWindowExecutionTaskInvocationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMaintenanceWindowExecutionTaskInvocationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            GetMaintenanceWindowExecutionTaskInvocationErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetMaintenanceWindowExecutionTaskInvocationErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for GetMaintenanceWindowExecutionTaskInvocationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMaintenanceWindowExecutionTaskInvocationErrorKind::DoesNotExistError(_inner) => {
                Some(_inner)
            }
            GetMaintenanceWindowExecutionTaskInvocationErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            GetMaintenanceWindowExecutionTaskInvocationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMaintenanceWindowTaskError {
    pub kind: GetMaintenanceWindowTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMaintenanceWindowTaskErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMaintenanceWindowTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMaintenanceWindowTaskErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            GetMaintenanceWindowTaskErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetMaintenanceWindowTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMaintenanceWindowTaskError {
    fn code(&self) -> Option<&str> {
        GetMaintenanceWindowTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMaintenanceWindowTaskError {
    pub fn new(kind: GetMaintenanceWindowTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMaintenanceWindowTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMaintenanceWindowTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            GetMaintenanceWindowTaskErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetMaintenanceWindowTaskErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for GetMaintenanceWindowTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMaintenanceWindowTaskErrorKind::DoesNotExistError(_inner) => Some(_inner),
            GetMaintenanceWindowTaskErrorKind::InternalServerError(_inner) => Some(_inner),
            GetMaintenanceWindowTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOpsItemError {
    pub kind: GetOpsItemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOpsItemErrorKind {
    InternalServerError(crate::error::InternalServerError),
    OpsItemNotFoundError(crate::error::OpsItemNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOpsItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOpsItemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetOpsItemErrorKind::OpsItemNotFoundError(_inner) => _inner.fmt(f),
            GetOpsItemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOpsItemError {
    fn code(&self) -> Option<&str> {
        GetOpsItemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOpsItemError {
    pub fn new(kind: GetOpsItemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOpsItemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOpsItemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, GetOpsItemErrorKind::InternalServerError(_))
    }
    pub fn is_ops_item_not_found_error(&self) -> bool {
        matches!(&self.kind, GetOpsItemErrorKind::OpsItemNotFoundError(_))
    }
}
impl std::error::Error for GetOpsItemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOpsItemErrorKind::InternalServerError(_inner) => Some(_inner),
            GetOpsItemErrorKind::OpsItemNotFoundError(_inner) => Some(_inner),
            GetOpsItemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOpsMetadataError {
    pub kind: GetOpsMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOpsMetadataErrorKind {
    InternalServerError(crate::error::InternalServerError),
    OpsMetadataInvalidArgumentError(crate::error::OpsMetadataInvalidArgumentError),
    OpsMetadataNotFoundError(crate::error::OpsMetadataNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOpsMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOpsMetadataErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_inner) => _inner.fmt(f),
            GetOpsMetadataErrorKind::OpsMetadataNotFoundError(_inner) => _inner.fmt(f),
            GetOpsMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOpsMetadataError {
    fn code(&self) -> Option<&str> {
        GetOpsMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOpsMetadataError {
    pub fn new(kind: GetOpsMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOpsMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOpsMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, GetOpsMetadataErrorKind::InternalServerError(_))
    }
    pub fn is_ops_metadata_invalid_argument_error(&self) -> bool {
        matches!(
            &self.kind,
            GetOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_)
        )
    }
    pub fn is_ops_metadata_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetOpsMetadataErrorKind::OpsMetadataNotFoundError(_)
        )
    }
}
impl std::error::Error for GetOpsMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOpsMetadataErrorKind::InternalServerError(_inner) => Some(_inner),
            GetOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_inner) => Some(_inner),
            GetOpsMetadataErrorKind::OpsMetadataNotFoundError(_inner) => Some(_inner),
            GetOpsMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOpsSummaryError {
    pub kind: GetOpsSummaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOpsSummaryErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidAggregatorError(crate::error::InvalidAggregatorError),
    InvalidFilter(crate::error::InvalidFilter),
    InvalidNextToken(crate::error::InvalidNextToken),
    InvalidTypeNameError(crate::error::InvalidTypeNameError),
    ResourceDataSyncNotFoundError(crate::error::ResourceDataSyncNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOpsSummaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOpsSummaryErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetOpsSummaryErrorKind::InvalidAggregatorError(_inner) => _inner.fmt(f),
            GetOpsSummaryErrorKind::InvalidFilter(_inner) => _inner.fmt(f),
            GetOpsSummaryErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            GetOpsSummaryErrorKind::InvalidTypeNameError(_inner) => _inner.fmt(f),
            GetOpsSummaryErrorKind::ResourceDataSyncNotFoundError(_inner) => _inner.fmt(f),
            GetOpsSummaryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOpsSummaryError {
    fn code(&self) -> Option<&str> {
        GetOpsSummaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOpsSummaryError {
    pub fn new(kind: GetOpsSummaryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOpsSummaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOpsSummaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, GetOpsSummaryErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_aggregator_error(&self) -> bool {
        matches!(
            &self.kind,
            GetOpsSummaryErrorKind::InvalidAggregatorError(_)
        )
    }
    pub fn is_invalid_filter(&self) -> bool {
        matches!(&self.kind, GetOpsSummaryErrorKind::InvalidFilter(_))
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(&self.kind, GetOpsSummaryErrorKind::InvalidNextToken(_))
    }
    pub fn is_invalid_type_name_error(&self) -> bool {
        matches!(&self.kind, GetOpsSummaryErrorKind::InvalidTypeNameError(_))
    }
    pub fn is_resource_data_sync_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetOpsSummaryErrorKind::ResourceDataSyncNotFoundError(_)
        )
    }
}
impl std::error::Error for GetOpsSummaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOpsSummaryErrorKind::InternalServerError(_inner) => Some(_inner),
            GetOpsSummaryErrorKind::InvalidAggregatorError(_inner) => Some(_inner),
            GetOpsSummaryErrorKind::InvalidFilter(_inner) => Some(_inner),
            GetOpsSummaryErrorKind::InvalidNextToken(_inner) => Some(_inner),
            GetOpsSummaryErrorKind::InvalidTypeNameError(_inner) => Some(_inner),
            GetOpsSummaryErrorKind::ResourceDataSyncNotFoundError(_inner) => Some(_inner),
            GetOpsSummaryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetParameterError {
    pub kind: GetParameterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetParameterErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidKeyId(crate::error::InvalidKeyId),
    ParameterNotFound(crate::error::ParameterNotFound),
    ParameterVersionNotFound(crate::error::ParameterVersionNotFound),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetParameterErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetParameterErrorKind::InvalidKeyId(_inner) => _inner.fmt(f),
            GetParameterErrorKind::ParameterNotFound(_inner) => _inner.fmt(f),
            GetParameterErrorKind::ParameterVersionNotFound(_inner) => _inner.fmt(f),
            GetParameterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetParameterError {
    fn code(&self) -> Option<&str> {
        GetParameterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetParameterError {
    pub fn new(kind: GetParameterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetParameterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetParameterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, GetParameterErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_key_id(&self) -> bool {
        matches!(&self.kind, GetParameterErrorKind::InvalidKeyId(_))
    }
    pub fn is_parameter_not_found(&self) -> bool {
        matches!(&self.kind, GetParameterErrorKind::ParameterNotFound(_))
    }
    pub fn is_parameter_version_not_found(&self) -> bool {
        matches!(
            &self.kind,
            GetParameterErrorKind::ParameterVersionNotFound(_)
        )
    }
}
impl std::error::Error for GetParameterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetParameterErrorKind::InternalServerError(_inner) => Some(_inner),
            GetParameterErrorKind::InvalidKeyId(_inner) => Some(_inner),
            GetParameterErrorKind::ParameterNotFound(_inner) => Some(_inner),
            GetParameterErrorKind::ParameterVersionNotFound(_inner) => Some(_inner),
            GetParameterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetParameterHistoryError {
    pub kind: GetParameterHistoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetParameterHistoryErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidKeyId(crate::error::InvalidKeyId),
    InvalidNextToken(crate::error::InvalidNextToken),
    ParameterNotFound(crate::error::ParameterNotFound),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetParameterHistoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetParameterHistoryErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetParameterHistoryErrorKind::InvalidKeyId(_inner) => _inner.fmt(f),
            GetParameterHistoryErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            GetParameterHistoryErrorKind::ParameterNotFound(_inner) => _inner.fmt(f),
            GetParameterHistoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetParameterHistoryError {
    fn code(&self) -> Option<&str> {
        GetParameterHistoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetParameterHistoryError {
    pub fn new(kind: GetParameterHistoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetParameterHistoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetParameterHistoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetParameterHistoryErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_key_id(&self) -> bool {
        matches!(&self.kind, GetParameterHistoryErrorKind::InvalidKeyId(_))
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            GetParameterHistoryErrorKind::InvalidNextToken(_)
        )
    }
    pub fn is_parameter_not_found(&self) -> bool {
        matches!(
            &self.kind,
            GetParameterHistoryErrorKind::ParameterNotFound(_)
        )
    }
}
impl std::error::Error for GetParameterHistoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetParameterHistoryErrorKind::InternalServerError(_inner) => Some(_inner),
            GetParameterHistoryErrorKind::InvalidKeyId(_inner) => Some(_inner),
            GetParameterHistoryErrorKind::InvalidNextToken(_inner) => Some(_inner),
            GetParameterHistoryErrorKind::ParameterNotFound(_inner) => Some(_inner),
            GetParameterHistoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetParametersError {
    pub kind: GetParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetParametersErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidKeyId(crate::error::InvalidKeyId),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetParametersErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetParametersErrorKind::InvalidKeyId(_inner) => _inner.fmt(f),
            GetParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetParametersError {
    fn code(&self) -> Option<&str> {
        GetParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetParametersError {
    pub fn new(kind: GetParametersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, GetParametersErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_key_id(&self) -> bool {
        matches!(&self.kind, GetParametersErrorKind::InvalidKeyId(_))
    }
}
impl std::error::Error for GetParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetParametersErrorKind::InternalServerError(_inner) => Some(_inner),
            GetParametersErrorKind::InvalidKeyId(_inner) => Some(_inner),
            GetParametersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetParametersByPathError {
    pub kind: GetParametersByPathErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetParametersByPathErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidFilterKey(crate::error::InvalidFilterKey),
    InvalidFilterOption(crate::error::InvalidFilterOption),
    InvalidFilterValue(crate::error::InvalidFilterValue),
    InvalidKeyId(crate::error::InvalidKeyId),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetParametersByPathError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetParametersByPathErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetParametersByPathErrorKind::InvalidFilterKey(_inner) => _inner.fmt(f),
            GetParametersByPathErrorKind::InvalidFilterOption(_inner) => _inner.fmt(f),
            GetParametersByPathErrorKind::InvalidFilterValue(_inner) => _inner.fmt(f),
            GetParametersByPathErrorKind::InvalidKeyId(_inner) => _inner.fmt(f),
            GetParametersByPathErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            GetParametersByPathErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetParametersByPathError {
    fn code(&self) -> Option<&str> {
        GetParametersByPathError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetParametersByPathError {
    pub fn new(kind: GetParametersByPathErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetParametersByPathErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetParametersByPathErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetParametersByPathErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_filter_key(&self) -> bool {
        matches!(
            &self.kind,
            GetParametersByPathErrorKind::InvalidFilterKey(_)
        )
    }
    pub fn is_invalid_filter_option(&self) -> bool {
        matches!(
            &self.kind,
            GetParametersByPathErrorKind::InvalidFilterOption(_)
        )
    }
    pub fn is_invalid_filter_value(&self) -> bool {
        matches!(
            &self.kind,
            GetParametersByPathErrorKind::InvalidFilterValue(_)
        )
    }
    pub fn is_invalid_key_id(&self) -> bool {
        matches!(&self.kind, GetParametersByPathErrorKind::InvalidKeyId(_))
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            GetParametersByPathErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for GetParametersByPathError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetParametersByPathErrorKind::InternalServerError(_inner) => Some(_inner),
            GetParametersByPathErrorKind::InvalidFilterKey(_inner) => Some(_inner),
            GetParametersByPathErrorKind::InvalidFilterOption(_inner) => Some(_inner),
            GetParametersByPathErrorKind::InvalidFilterValue(_inner) => Some(_inner),
            GetParametersByPathErrorKind::InvalidKeyId(_inner) => Some(_inner),
            GetParametersByPathErrorKind::InvalidNextToken(_inner) => Some(_inner),
            GetParametersByPathErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPatchBaselineError {
    pub kind: GetPatchBaselineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPatchBaselineErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    InvalidResourceId(crate::error::InvalidResourceId),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPatchBaselineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPatchBaselineErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            GetPatchBaselineErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetPatchBaselineErrorKind::InvalidResourceId(_inner) => _inner.fmt(f),
            GetPatchBaselineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPatchBaselineError {
    fn code(&self) -> Option<&str> {
        GetPatchBaselineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPatchBaselineError {
    pub fn new(kind: GetPatchBaselineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPatchBaselineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPatchBaselineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(&self.kind, GetPatchBaselineErrorKind::DoesNotExistError(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetPatchBaselineErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_resource_id(&self) -> bool {
        matches!(&self.kind, GetPatchBaselineErrorKind::InvalidResourceId(_))
    }
}
impl std::error::Error for GetPatchBaselineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPatchBaselineErrorKind::DoesNotExistError(_inner) => Some(_inner),
            GetPatchBaselineErrorKind::InternalServerError(_inner) => Some(_inner),
            GetPatchBaselineErrorKind::InvalidResourceId(_inner) => Some(_inner),
            GetPatchBaselineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPatchBaselineForPatchGroupError {
    pub kind: GetPatchBaselineForPatchGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPatchBaselineForPatchGroupErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPatchBaselineForPatchGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPatchBaselineForPatchGroupErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetPatchBaselineForPatchGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPatchBaselineForPatchGroupError {
    fn code(&self) -> Option<&str> {
        GetPatchBaselineForPatchGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPatchBaselineForPatchGroupError {
    pub fn new(kind: GetPatchBaselineForPatchGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPatchBaselineForPatchGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPatchBaselineForPatchGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetPatchBaselineForPatchGroupErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for GetPatchBaselineForPatchGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPatchBaselineForPatchGroupErrorKind::InternalServerError(_inner) => Some(_inner),
            GetPatchBaselineForPatchGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceSettingError {
    pub kind: GetServiceSettingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceSettingErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ServiceSettingNotFound(crate::error::ServiceSettingNotFound),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceSettingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceSettingErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetServiceSettingErrorKind::ServiceSettingNotFound(_inner) => _inner.fmt(f),
            GetServiceSettingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceSettingError {
    fn code(&self) -> Option<&str> {
        GetServiceSettingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServiceSettingError {
    pub fn new(kind: GetServiceSettingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceSettingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceSettingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceSettingErrorKind::InternalServerError(_)
        )
    }
    pub fn is_service_setting_not_found(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceSettingErrorKind::ServiceSettingNotFound(_)
        )
    }
}
impl std::error::Error for GetServiceSettingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceSettingErrorKind::InternalServerError(_inner) => Some(_inner),
            GetServiceSettingErrorKind::ServiceSettingNotFound(_inner) => Some(_inner),
            GetServiceSettingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct LabelParameterVersionError {
    pub kind: LabelParameterVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum LabelParameterVersionErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ParameterNotFound(crate::error::ParameterNotFound),
    ParameterVersionLabelLimitExceeded(crate::error::ParameterVersionLabelLimitExceeded),
    ParameterVersionNotFound(crate::error::ParameterVersionNotFound),
    TooManyUpdates(crate::error::TooManyUpdates),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for LabelParameterVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            LabelParameterVersionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            LabelParameterVersionErrorKind::ParameterNotFound(_inner) => _inner.fmt(f),
            LabelParameterVersionErrorKind::ParameterVersionLabelLimitExceeded(_inner) => {
                _inner.fmt(f)
            }
            LabelParameterVersionErrorKind::ParameterVersionNotFound(_inner) => _inner.fmt(f),
            LabelParameterVersionErrorKind::TooManyUpdates(_inner) => _inner.fmt(f),
            LabelParameterVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for LabelParameterVersionError {
    fn code(&self) -> Option<&str> {
        LabelParameterVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl LabelParameterVersionError {
    pub fn new(kind: LabelParameterVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: LabelParameterVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: LabelParameterVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            LabelParameterVersionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_parameter_not_found(&self) -> bool {
        matches!(
            &self.kind,
            LabelParameterVersionErrorKind::ParameterNotFound(_)
        )
    }
    pub fn is_parameter_version_label_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            LabelParameterVersionErrorKind::ParameterVersionLabelLimitExceeded(_)
        )
    }
    pub fn is_parameter_version_not_found(&self) -> bool {
        matches!(
            &self.kind,
            LabelParameterVersionErrorKind::ParameterVersionNotFound(_)
        )
    }
    pub fn is_too_many_updates(&self) -> bool {
        matches!(
            &self.kind,
            LabelParameterVersionErrorKind::TooManyUpdates(_)
        )
    }
}
impl std::error::Error for LabelParameterVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            LabelParameterVersionErrorKind::InternalServerError(_inner) => Some(_inner),
            LabelParameterVersionErrorKind::ParameterNotFound(_inner) => Some(_inner),
            LabelParameterVersionErrorKind::ParameterVersionLabelLimitExceeded(_inner) => {
                Some(_inner)
            }
            LabelParameterVersionErrorKind::ParameterVersionNotFound(_inner) => Some(_inner),
            LabelParameterVersionErrorKind::TooManyUpdates(_inner) => Some(_inner),
            LabelParameterVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAssociationsError {
    pub kind: ListAssociationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssociationsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAssociationsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListAssociationsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            ListAssociationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAssociationsError {
    fn code(&self) -> Option<&str> {
        ListAssociationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssociationsError {
    pub fn new(kind: ListAssociationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAssociationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAssociationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAssociationsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(&self.kind, ListAssociationsErrorKind::InvalidNextToken(_))
    }
}
impl std::error::Error for ListAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAssociationsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListAssociationsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            ListAssociationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAssociationVersionsError {
    pub kind: ListAssociationVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssociationVersionsErrorKind {
    AssociationDoesNotExist(crate::error::AssociationDoesNotExist),
    InternalServerError(crate::error::InternalServerError),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAssociationVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAssociationVersionsErrorKind::AssociationDoesNotExist(_inner) => _inner.fmt(f),
            ListAssociationVersionsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListAssociationVersionsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            ListAssociationVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAssociationVersionsError {
    fn code(&self) -> Option<&str> {
        ListAssociationVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssociationVersionsError {
    pub fn new(kind: ListAssociationVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAssociationVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAssociationVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_association_does_not_exist(&self) -> bool {
        matches!(
            &self.kind,
            ListAssociationVersionsErrorKind::AssociationDoesNotExist(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAssociationVersionsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            ListAssociationVersionsErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for ListAssociationVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAssociationVersionsErrorKind::AssociationDoesNotExist(_inner) => Some(_inner),
            ListAssociationVersionsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListAssociationVersionsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            ListAssociationVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCommandInvocationsError {
    pub kind: ListCommandInvocationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCommandInvocationsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidCommandId(crate::error::InvalidCommandId),
    InvalidFilterKey(crate::error::InvalidFilterKey),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCommandInvocationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCommandInvocationsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListCommandInvocationsErrorKind::InvalidCommandId(_inner) => _inner.fmt(f),
            ListCommandInvocationsErrorKind::InvalidFilterKey(_inner) => _inner.fmt(f),
            ListCommandInvocationsErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            ListCommandInvocationsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            ListCommandInvocationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCommandInvocationsError {
    fn code(&self) -> Option<&str> {
        ListCommandInvocationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCommandInvocationsError {
    pub fn new(kind: ListCommandInvocationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCommandInvocationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCommandInvocationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListCommandInvocationsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_command_id(&self) -> bool {
        matches!(
            &self.kind,
            ListCommandInvocationsErrorKind::InvalidCommandId(_)
        )
    }
    pub fn is_invalid_filter_key(&self) -> bool {
        matches!(
            &self.kind,
            ListCommandInvocationsErrorKind::InvalidFilterKey(_)
        )
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(
            &self.kind,
            ListCommandInvocationsErrorKind::InvalidInstanceId(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            ListCommandInvocationsErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for ListCommandInvocationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCommandInvocationsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListCommandInvocationsErrorKind::InvalidCommandId(_inner) => Some(_inner),
            ListCommandInvocationsErrorKind::InvalidFilterKey(_inner) => Some(_inner),
            ListCommandInvocationsErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            ListCommandInvocationsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            ListCommandInvocationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCommandsError {
    pub kind: ListCommandsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCommandsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidCommandId(crate::error::InvalidCommandId),
    InvalidFilterKey(crate::error::InvalidFilterKey),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCommandsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCommandsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListCommandsErrorKind::InvalidCommandId(_inner) => _inner.fmt(f),
            ListCommandsErrorKind::InvalidFilterKey(_inner) => _inner.fmt(f),
            ListCommandsErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            ListCommandsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            ListCommandsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCommandsError {
    fn code(&self) -> Option<&str> {
        ListCommandsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCommandsError {
    pub fn new(kind: ListCommandsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCommandsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCommandsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListCommandsErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_command_id(&self) -> bool {
        matches!(&self.kind, ListCommandsErrorKind::InvalidCommandId(_))
    }
    pub fn is_invalid_filter_key(&self) -> bool {
        matches!(&self.kind, ListCommandsErrorKind::InvalidFilterKey(_))
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(&self.kind, ListCommandsErrorKind::InvalidInstanceId(_))
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(&self.kind, ListCommandsErrorKind::InvalidNextToken(_))
    }
}
impl std::error::Error for ListCommandsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCommandsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListCommandsErrorKind::InvalidCommandId(_inner) => Some(_inner),
            ListCommandsErrorKind::InvalidFilterKey(_inner) => Some(_inner),
            ListCommandsErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            ListCommandsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            ListCommandsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListComplianceItemsError {
    pub kind: ListComplianceItemsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListComplianceItemsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidFilter(crate::error::InvalidFilter),
    InvalidNextToken(crate::error::InvalidNextToken),
    InvalidResourceId(crate::error::InvalidResourceId),
    InvalidResourceType(crate::error::InvalidResourceType),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListComplianceItemsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListComplianceItemsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListComplianceItemsErrorKind::InvalidFilter(_inner) => _inner.fmt(f),
            ListComplianceItemsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            ListComplianceItemsErrorKind::InvalidResourceId(_inner) => _inner.fmt(f),
            ListComplianceItemsErrorKind::InvalidResourceType(_inner) => _inner.fmt(f),
            ListComplianceItemsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListComplianceItemsError {
    fn code(&self) -> Option<&str> {
        ListComplianceItemsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListComplianceItemsError {
    pub fn new(kind: ListComplianceItemsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListComplianceItemsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListComplianceItemsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListComplianceItemsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_filter(&self) -> bool {
        matches!(&self.kind, ListComplianceItemsErrorKind::InvalidFilter(_))
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            ListComplianceItemsErrorKind::InvalidNextToken(_)
        )
    }
    pub fn is_invalid_resource_id(&self) -> bool {
        matches!(
            &self.kind,
            ListComplianceItemsErrorKind::InvalidResourceId(_)
        )
    }
    pub fn is_invalid_resource_type(&self) -> bool {
        matches!(
            &self.kind,
            ListComplianceItemsErrorKind::InvalidResourceType(_)
        )
    }
}
impl std::error::Error for ListComplianceItemsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListComplianceItemsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListComplianceItemsErrorKind::InvalidFilter(_inner) => Some(_inner),
            ListComplianceItemsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            ListComplianceItemsErrorKind::InvalidResourceId(_inner) => Some(_inner),
            ListComplianceItemsErrorKind::InvalidResourceType(_inner) => Some(_inner),
            ListComplianceItemsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListComplianceSummariesError {
    pub kind: ListComplianceSummariesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListComplianceSummariesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidFilter(crate::error::InvalidFilter),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListComplianceSummariesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListComplianceSummariesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListComplianceSummariesErrorKind::InvalidFilter(_inner) => _inner.fmt(f),
            ListComplianceSummariesErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            ListComplianceSummariesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListComplianceSummariesError {
    fn code(&self) -> Option<&str> {
        ListComplianceSummariesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListComplianceSummariesError {
    pub fn new(kind: ListComplianceSummariesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListComplianceSummariesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListComplianceSummariesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListComplianceSummariesErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_filter(&self) -> bool {
        matches!(
            &self.kind,
            ListComplianceSummariesErrorKind::InvalidFilter(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            ListComplianceSummariesErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for ListComplianceSummariesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListComplianceSummariesErrorKind::InternalServerError(_inner) => Some(_inner),
            ListComplianceSummariesErrorKind::InvalidFilter(_inner) => Some(_inner),
            ListComplianceSummariesErrorKind::InvalidNextToken(_inner) => Some(_inner),
            ListComplianceSummariesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDocumentMetadataHistoryError {
    pub kind: ListDocumentMetadataHistoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDocumentMetadataHistoryErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidDocumentVersion(crate::error::InvalidDocumentVersion),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDocumentMetadataHistoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDocumentMetadataHistoryErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListDocumentMetadataHistoryErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            ListDocumentMetadataHistoryErrorKind::InvalidDocumentVersion(_inner) => _inner.fmt(f),
            ListDocumentMetadataHistoryErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            ListDocumentMetadataHistoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDocumentMetadataHistoryError {
    fn code(&self) -> Option<&str> {
        ListDocumentMetadataHistoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDocumentMetadataHistoryError {
    pub fn new(kind: ListDocumentMetadataHistoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDocumentMetadataHistoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDocumentMetadataHistoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListDocumentMetadataHistoryErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(
            &self.kind,
            ListDocumentMetadataHistoryErrorKind::InvalidDocument(_)
        )
    }
    pub fn is_invalid_document_version(&self) -> bool {
        matches!(
            &self.kind,
            ListDocumentMetadataHistoryErrorKind::InvalidDocumentVersion(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            ListDocumentMetadataHistoryErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for ListDocumentMetadataHistoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDocumentMetadataHistoryErrorKind::InternalServerError(_inner) => Some(_inner),
            ListDocumentMetadataHistoryErrorKind::InvalidDocument(_inner) => Some(_inner),
            ListDocumentMetadataHistoryErrorKind::InvalidDocumentVersion(_inner) => Some(_inner),
            ListDocumentMetadataHistoryErrorKind::InvalidNextToken(_inner) => Some(_inner),
            ListDocumentMetadataHistoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDocumentsError {
    pub kind: ListDocumentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDocumentsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidFilterKey(crate::error::InvalidFilterKey),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDocumentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDocumentsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListDocumentsErrorKind::InvalidFilterKey(_inner) => _inner.fmt(f),
            ListDocumentsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            ListDocumentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDocumentsError {
    fn code(&self) -> Option<&str> {
        ListDocumentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDocumentsError {
    pub fn new(kind: ListDocumentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDocumentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDocumentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListDocumentsErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_filter_key(&self) -> bool {
        matches!(&self.kind, ListDocumentsErrorKind::InvalidFilterKey(_))
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(&self.kind, ListDocumentsErrorKind::InvalidNextToken(_))
    }
}
impl std::error::Error for ListDocumentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDocumentsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListDocumentsErrorKind::InvalidFilterKey(_inner) => Some(_inner),
            ListDocumentsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            ListDocumentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDocumentVersionsError {
    pub kind: ListDocumentVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDocumentVersionsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDocumentVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDocumentVersionsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListDocumentVersionsErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            ListDocumentVersionsErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            ListDocumentVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDocumentVersionsError {
    fn code(&self) -> Option<&str> {
        ListDocumentVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDocumentVersionsError {
    pub fn new(kind: ListDocumentVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDocumentVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDocumentVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListDocumentVersionsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(
            &self.kind,
            ListDocumentVersionsErrorKind::InvalidDocument(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            ListDocumentVersionsErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for ListDocumentVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDocumentVersionsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListDocumentVersionsErrorKind::InvalidDocument(_inner) => Some(_inner),
            ListDocumentVersionsErrorKind::InvalidNextToken(_inner) => Some(_inner),
            ListDocumentVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInventoryEntriesError {
    pub kind: ListInventoryEntriesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInventoryEntriesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidFilter(crate::error::InvalidFilter),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    InvalidNextToken(crate::error::InvalidNextToken),
    InvalidTypeNameError(crate::error::InvalidTypeNameError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInventoryEntriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInventoryEntriesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListInventoryEntriesErrorKind::InvalidFilter(_inner) => _inner.fmt(f),
            ListInventoryEntriesErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            ListInventoryEntriesErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            ListInventoryEntriesErrorKind::InvalidTypeNameError(_inner) => _inner.fmt(f),
            ListInventoryEntriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInventoryEntriesError {
    fn code(&self) -> Option<&str> {
        ListInventoryEntriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInventoryEntriesError {
    pub fn new(kind: ListInventoryEntriesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInventoryEntriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInventoryEntriesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInventoryEntriesErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_filter(&self) -> bool {
        matches!(&self.kind, ListInventoryEntriesErrorKind::InvalidFilter(_))
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(
            &self.kind,
            ListInventoryEntriesErrorKind::InvalidInstanceId(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            ListInventoryEntriesErrorKind::InvalidNextToken(_)
        )
    }
    pub fn is_invalid_type_name_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInventoryEntriesErrorKind::InvalidTypeNameError(_)
        )
    }
}
impl std::error::Error for ListInventoryEntriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInventoryEntriesErrorKind::InternalServerError(_inner) => Some(_inner),
            ListInventoryEntriesErrorKind::InvalidFilter(_inner) => Some(_inner),
            ListInventoryEntriesErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            ListInventoryEntriesErrorKind::InvalidNextToken(_inner) => Some(_inner),
            ListInventoryEntriesErrorKind::InvalidTypeNameError(_inner) => Some(_inner),
            ListInventoryEntriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOpsItemEventsError {
    pub kind: ListOpsItemEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOpsItemEventsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    OpsItemInvalidParameterError(crate::error::OpsItemInvalidParameterError),
    OpsItemLimitExceededError(crate::error::OpsItemLimitExceededError),
    OpsItemNotFoundError(crate::error::OpsItemNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOpsItemEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOpsItemEventsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListOpsItemEventsErrorKind::OpsItemInvalidParameterError(_inner) => _inner.fmt(f),
            ListOpsItemEventsErrorKind::OpsItemLimitExceededError(_inner) => _inner.fmt(f),
            ListOpsItemEventsErrorKind::OpsItemNotFoundError(_inner) => _inner.fmt(f),
            ListOpsItemEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOpsItemEventsError {
    fn code(&self) -> Option<&str> {
        ListOpsItemEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOpsItemEventsError {
    pub fn new(kind: ListOpsItemEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOpsItemEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOpsItemEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOpsItemEventsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_ops_item_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOpsItemEventsErrorKind::OpsItemInvalidParameterError(_)
        )
    }
    pub fn is_ops_item_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOpsItemEventsErrorKind::OpsItemLimitExceededError(_)
        )
    }
    pub fn is_ops_item_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOpsItemEventsErrorKind::OpsItemNotFoundError(_)
        )
    }
}
impl std::error::Error for ListOpsItemEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOpsItemEventsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListOpsItemEventsErrorKind::OpsItemInvalidParameterError(_inner) => Some(_inner),
            ListOpsItemEventsErrorKind::OpsItemLimitExceededError(_inner) => Some(_inner),
            ListOpsItemEventsErrorKind::OpsItemNotFoundError(_inner) => Some(_inner),
            ListOpsItemEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOpsItemRelatedItemsError {
    pub kind: ListOpsItemRelatedItemsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOpsItemRelatedItemsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    OpsItemInvalidParameterError(crate::error::OpsItemInvalidParameterError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOpsItemRelatedItemsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOpsItemRelatedItemsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListOpsItemRelatedItemsErrorKind::OpsItemInvalidParameterError(_inner) => _inner.fmt(f),
            ListOpsItemRelatedItemsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOpsItemRelatedItemsError {
    fn code(&self) -> Option<&str> {
        ListOpsItemRelatedItemsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOpsItemRelatedItemsError {
    pub fn new(kind: ListOpsItemRelatedItemsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOpsItemRelatedItemsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOpsItemRelatedItemsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOpsItemRelatedItemsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_ops_item_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOpsItemRelatedItemsErrorKind::OpsItemInvalidParameterError(_)
        )
    }
}
impl std::error::Error for ListOpsItemRelatedItemsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOpsItemRelatedItemsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListOpsItemRelatedItemsErrorKind::OpsItemInvalidParameterError(_inner) => Some(_inner),
            ListOpsItemRelatedItemsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOpsMetadataError {
    pub kind: ListOpsMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOpsMetadataErrorKind {
    InternalServerError(crate::error::InternalServerError),
    OpsMetadataInvalidArgumentError(crate::error::OpsMetadataInvalidArgumentError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOpsMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOpsMetadataErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_inner) => _inner.fmt(f),
            ListOpsMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOpsMetadataError {
    fn code(&self) -> Option<&str> {
        ListOpsMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOpsMetadataError {
    pub fn new(kind: ListOpsMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOpsMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOpsMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListOpsMetadataErrorKind::InternalServerError(_))
    }
    pub fn is_ops_metadata_invalid_argument_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_)
        )
    }
}
impl std::error::Error for ListOpsMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOpsMetadataErrorKind::InternalServerError(_inner) => Some(_inner),
            ListOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_inner) => Some(_inner),
            ListOpsMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResourceComplianceSummariesError {
    pub kind: ListResourceComplianceSummariesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResourceComplianceSummariesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidFilter(crate::error::InvalidFilter),
    InvalidNextToken(crate::error::InvalidNextToken),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResourceComplianceSummariesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResourceComplianceSummariesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListResourceComplianceSummariesErrorKind::InvalidFilter(_inner) => _inner.fmt(f),
            ListResourceComplianceSummariesErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            ListResourceComplianceSummariesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResourceComplianceSummariesError {
    fn code(&self) -> Option<&str> {
        ListResourceComplianceSummariesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResourceComplianceSummariesError {
    pub fn new(kind: ListResourceComplianceSummariesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResourceComplianceSummariesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResourceComplianceSummariesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceComplianceSummariesErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_filter(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceComplianceSummariesErrorKind::InvalidFilter(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceComplianceSummariesErrorKind::InvalidNextToken(_)
        )
    }
}
impl std::error::Error for ListResourceComplianceSummariesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResourceComplianceSummariesErrorKind::InternalServerError(_inner) => Some(_inner),
            ListResourceComplianceSummariesErrorKind::InvalidFilter(_inner) => Some(_inner),
            ListResourceComplianceSummariesErrorKind::InvalidNextToken(_inner) => Some(_inner),
            ListResourceComplianceSummariesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResourceDataSyncError {
    pub kind: ListResourceDataSyncErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResourceDataSyncErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidNextToken(crate::error::InvalidNextToken),
    ResourceDataSyncInvalidConfigurationError(
        crate::error::ResourceDataSyncInvalidConfigurationError,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResourceDataSyncError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResourceDataSyncErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListResourceDataSyncErrorKind::InvalidNextToken(_inner) => _inner.fmt(f),
            ListResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(_inner) => {
                _inner.fmt(f)
            }
            ListResourceDataSyncErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResourceDataSyncError {
    fn code(&self) -> Option<&str> {
        ListResourceDataSyncError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResourceDataSyncError {
    pub fn new(kind: ListResourceDataSyncErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResourceDataSyncErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResourceDataSyncErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceDataSyncErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_next_token(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceDataSyncErrorKind::InvalidNextToken(_)
        )
    }
    pub fn is_resource_data_sync_invalid_configuration_error(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(_)
        )
    }
}
impl std::error::Error for ListResourceDataSyncError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResourceDataSyncErrorKind::InternalServerError(_inner) => Some(_inner),
            ListResourceDataSyncErrorKind::InvalidNextToken(_inner) => Some(_inner),
            ListResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(_inner) => {
                Some(_inner)
            }
            ListResourceDataSyncErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidResourceId(crate::error::InvalidResourceId),
    InvalidResourceType(crate::error::InvalidResourceType),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidResourceId(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidResourceType(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_resource_id(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidResourceId(_)
        )
    }
    pub fn is_invalid_resource_type(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidResourceType(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidResourceId(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidResourceType(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyDocumentPermissionError {
    pub kind: ModifyDocumentPermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDocumentPermissionErrorKind {
    DocumentLimitExceeded(crate::error::DocumentLimitExceeded),
    DocumentPermissionLimit(crate::error::DocumentPermissionLimit),
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidPermissionType(crate::error::InvalidPermissionType),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyDocumentPermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyDocumentPermissionErrorKind::DocumentLimitExceeded(_inner) => _inner.fmt(f),
            ModifyDocumentPermissionErrorKind::DocumentPermissionLimit(_inner) => _inner.fmt(f),
            ModifyDocumentPermissionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ModifyDocumentPermissionErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            ModifyDocumentPermissionErrorKind::InvalidPermissionType(_inner) => _inner.fmt(f),
            ModifyDocumentPermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyDocumentPermissionError {
    fn code(&self) -> Option<&str> {
        ModifyDocumentPermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDocumentPermissionError {
    pub fn new(kind: ModifyDocumentPermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyDocumentPermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyDocumentPermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_document_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDocumentPermissionErrorKind::DocumentLimitExceeded(_)
        )
    }
    pub fn is_document_permission_limit(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDocumentPermissionErrorKind::DocumentPermissionLimit(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDocumentPermissionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDocumentPermissionErrorKind::InvalidDocument(_)
        )
    }
    pub fn is_invalid_permission_type(&self) -> bool {
        matches!(
            &self.kind,
            ModifyDocumentPermissionErrorKind::InvalidPermissionType(_)
        )
    }
}
impl std::error::Error for ModifyDocumentPermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyDocumentPermissionErrorKind::DocumentLimitExceeded(_inner) => Some(_inner),
            ModifyDocumentPermissionErrorKind::DocumentPermissionLimit(_inner) => Some(_inner),
            ModifyDocumentPermissionErrorKind::InternalServerError(_inner) => Some(_inner),
            ModifyDocumentPermissionErrorKind::InvalidDocument(_inner) => Some(_inner),
            ModifyDocumentPermissionErrorKind::InvalidPermissionType(_inner) => Some(_inner),
            ModifyDocumentPermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutComplianceItemsError {
    pub kind: PutComplianceItemsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutComplianceItemsErrorKind {
    ComplianceTypeCountLimitExceededError(crate::error::ComplianceTypeCountLimitExceededError),
    InternalServerError(crate::error::InternalServerError),
    InvalidItemContentError(crate::error::InvalidItemContentError),
    InvalidResourceId(crate::error::InvalidResourceId),
    InvalidResourceType(crate::error::InvalidResourceType),
    ItemSizeLimitExceededError(crate::error::ItemSizeLimitExceededError),
    TotalSizeLimitExceededError(crate::error::TotalSizeLimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutComplianceItemsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutComplianceItemsErrorKind::ComplianceTypeCountLimitExceededError(_inner) => {
                _inner.fmt(f)
            }
            PutComplianceItemsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            PutComplianceItemsErrorKind::InvalidItemContentError(_inner) => _inner.fmt(f),
            PutComplianceItemsErrorKind::InvalidResourceId(_inner) => _inner.fmt(f),
            PutComplianceItemsErrorKind::InvalidResourceType(_inner) => _inner.fmt(f),
            PutComplianceItemsErrorKind::ItemSizeLimitExceededError(_inner) => _inner.fmt(f),
            PutComplianceItemsErrorKind::TotalSizeLimitExceededError(_inner) => _inner.fmt(f),
            PutComplianceItemsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutComplianceItemsError {
    fn code(&self) -> Option<&str> {
        PutComplianceItemsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutComplianceItemsError {
    pub fn new(kind: PutComplianceItemsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutComplianceItemsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutComplianceItemsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_compliance_type_count_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            PutComplianceItemsErrorKind::ComplianceTypeCountLimitExceededError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            PutComplianceItemsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_item_content_error(&self) -> bool {
        matches!(
            &self.kind,
            PutComplianceItemsErrorKind::InvalidItemContentError(_)
        )
    }
    pub fn is_invalid_resource_id(&self) -> bool {
        matches!(
            &self.kind,
            PutComplianceItemsErrorKind::InvalidResourceId(_)
        )
    }
    pub fn is_invalid_resource_type(&self) -> bool {
        matches!(
            &self.kind,
            PutComplianceItemsErrorKind::InvalidResourceType(_)
        )
    }
    pub fn is_item_size_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            PutComplianceItemsErrorKind::ItemSizeLimitExceededError(_)
        )
    }
    pub fn is_total_size_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            PutComplianceItemsErrorKind::TotalSizeLimitExceededError(_)
        )
    }
}
impl std::error::Error for PutComplianceItemsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutComplianceItemsErrorKind::ComplianceTypeCountLimitExceededError(_inner) => {
                Some(_inner)
            }
            PutComplianceItemsErrorKind::InternalServerError(_inner) => Some(_inner),
            PutComplianceItemsErrorKind::InvalidItemContentError(_inner) => Some(_inner),
            PutComplianceItemsErrorKind::InvalidResourceId(_inner) => Some(_inner),
            PutComplianceItemsErrorKind::InvalidResourceType(_inner) => Some(_inner),
            PutComplianceItemsErrorKind::ItemSizeLimitExceededError(_inner) => Some(_inner),
            PutComplianceItemsErrorKind::TotalSizeLimitExceededError(_inner) => Some(_inner),
            PutComplianceItemsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutInventoryError {
    pub kind: PutInventoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutInventoryErrorKind {
    CustomSchemaCountLimitExceededError(crate::error::CustomSchemaCountLimitExceededError),
    InternalServerError(crate::error::InternalServerError),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    InvalidInventoryItemContextError(crate::error::InvalidInventoryItemContextError),
    InvalidItemContentError(crate::error::InvalidItemContentError),
    InvalidTypeNameError(crate::error::InvalidTypeNameError),
    ItemContentMismatchError(crate::error::ItemContentMismatchError),
    ItemSizeLimitExceededError(crate::error::ItemSizeLimitExceededError),
    SubTypeCountLimitExceededError(crate::error::SubTypeCountLimitExceededError),
    TotalSizeLimitExceededError(crate::error::TotalSizeLimitExceededError),
    UnsupportedInventoryItemContextError(crate::error::UnsupportedInventoryItemContextError),
    UnsupportedInventorySchemaVersionError(crate::error::UnsupportedInventorySchemaVersionError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutInventoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutInventoryErrorKind::CustomSchemaCountLimitExceededError(_inner) => _inner.fmt(f),
            PutInventoryErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            PutInventoryErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            PutInventoryErrorKind::InvalidInventoryItemContextError(_inner) => _inner.fmt(f),
            PutInventoryErrorKind::InvalidItemContentError(_inner) => _inner.fmt(f),
            PutInventoryErrorKind::InvalidTypeNameError(_inner) => _inner.fmt(f),
            PutInventoryErrorKind::ItemContentMismatchError(_inner) => _inner.fmt(f),
            PutInventoryErrorKind::ItemSizeLimitExceededError(_inner) => _inner.fmt(f),
            PutInventoryErrorKind::SubTypeCountLimitExceededError(_inner) => _inner.fmt(f),
            PutInventoryErrorKind::TotalSizeLimitExceededError(_inner) => _inner.fmt(f),
            PutInventoryErrorKind::UnsupportedInventoryItemContextError(_inner) => _inner.fmt(f),
            PutInventoryErrorKind::UnsupportedInventorySchemaVersionError(_inner) => _inner.fmt(f),
            PutInventoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutInventoryError {
    fn code(&self) -> Option<&str> {
        PutInventoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutInventoryError {
    pub fn new(kind: PutInventoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutInventoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutInventoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_schema_count_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            PutInventoryErrorKind::CustomSchemaCountLimitExceededError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, PutInventoryErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(&self.kind, PutInventoryErrorKind::InvalidInstanceId(_))
    }
    pub fn is_invalid_inventory_item_context_error(&self) -> bool {
        matches!(
            &self.kind,
            PutInventoryErrorKind::InvalidInventoryItemContextError(_)
        )
    }
    pub fn is_invalid_item_content_error(&self) -> bool {
        matches!(
            &self.kind,
            PutInventoryErrorKind::InvalidItemContentError(_)
        )
    }
    pub fn is_invalid_type_name_error(&self) -> bool {
        matches!(&self.kind, PutInventoryErrorKind::InvalidTypeNameError(_))
    }
    pub fn is_item_content_mismatch_error(&self) -> bool {
        matches!(
            &self.kind,
            PutInventoryErrorKind::ItemContentMismatchError(_)
        )
    }
    pub fn is_item_size_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            PutInventoryErrorKind::ItemSizeLimitExceededError(_)
        )
    }
    pub fn is_sub_type_count_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            PutInventoryErrorKind::SubTypeCountLimitExceededError(_)
        )
    }
    pub fn is_total_size_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            PutInventoryErrorKind::TotalSizeLimitExceededError(_)
        )
    }
    pub fn is_unsupported_inventory_item_context_error(&self) -> bool {
        matches!(
            &self.kind,
            PutInventoryErrorKind::UnsupportedInventoryItemContextError(_)
        )
    }
    pub fn is_unsupported_inventory_schema_version_error(&self) -> bool {
        matches!(
            &self.kind,
            PutInventoryErrorKind::UnsupportedInventorySchemaVersionError(_)
        )
    }
}
impl std::error::Error for PutInventoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutInventoryErrorKind::CustomSchemaCountLimitExceededError(_inner) => Some(_inner),
            PutInventoryErrorKind::InternalServerError(_inner) => Some(_inner),
            PutInventoryErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            PutInventoryErrorKind::InvalidInventoryItemContextError(_inner) => Some(_inner),
            PutInventoryErrorKind::InvalidItemContentError(_inner) => Some(_inner),
            PutInventoryErrorKind::InvalidTypeNameError(_inner) => Some(_inner),
            PutInventoryErrorKind::ItemContentMismatchError(_inner) => Some(_inner),
            PutInventoryErrorKind::ItemSizeLimitExceededError(_inner) => Some(_inner),
            PutInventoryErrorKind::SubTypeCountLimitExceededError(_inner) => Some(_inner),
            PutInventoryErrorKind::TotalSizeLimitExceededError(_inner) => Some(_inner),
            PutInventoryErrorKind::UnsupportedInventoryItemContextError(_inner) => Some(_inner),
            PutInventoryErrorKind::UnsupportedInventorySchemaVersionError(_inner) => Some(_inner),
            PutInventoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutParameterError {
    pub kind: PutParameterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutParameterErrorKind {
    HierarchyLevelLimitExceededError(crate::error::HierarchyLevelLimitExceededError),
    HierarchyTypeMismatchError(crate::error::HierarchyTypeMismatchError),
    IncompatiblePolicyError(crate::error::IncompatiblePolicyError),
    InternalServerError(crate::error::InternalServerError),
    InvalidAllowedPatternError(crate::error::InvalidAllowedPatternError),
    InvalidKeyId(crate::error::InvalidKeyId),
    InvalidPolicyAttributeError(crate::error::InvalidPolicyAttributeError),
    InvalidPolicyTypeError(crate::error::InvalidPolicyTypeError),
    ParameterAlreadyExists(crate::error::ParameterAlreadyExists),
    ParameterLimitExceeded(crate::error::ParameterLimitExceeded),
    ParameterMaxVersionLimitExceeded(crate::error::ParameterMaxVersionLimitExceeded),
    ParameterPatternMismatchError(crate::error::ParameterPatternMismatchError),
    PoliciesLimitExceededError(crate::error::PoliciesLimitExceededError),
    TooManyUpdates(crate::error::TooManyUpdates),
    UnsupportedParameterType(crate::error::UnsupportedParameterType),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutParameterErrorKind::HierarchyLevelLimitExceededError(_inner) => _inner.fmt(f),
            PutParameterErrorKind::HierarchyTypeMismatchError(_inner) => _inner.fmt(f),
            PutParameterErrorKind::IncompatiblePolicyError(_inner) => _inner.fmt(f),
            PutParameterErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            PutParameterErrorKind::InvalidAllowedPatternError(_inner) => _inner.fmt(f),
            PutParameterErrorKind::InvalidKeyId(_inner) => _inner.fmt(f),
            PutParameterErrorKind::InvalidPolicyAttributeError(_inner) => _inner.fmt(f),
            PutParameterErrorKind::InvalidPolicyTypeError(_inner) => _inner.fmt(f),
            PutParameterErrorKind::ParameterAlreadyExists(_inner) => _inner.fmt(f),
            PutParameterErrorKind::ParameterLimitExceeded(_inner) => _inner.fmt(f),
            PutParameterErrorKind::ParameterMaxVersionLimitExceeded(_inner) => _inner.fmt(f),
            PutParameterErrorKind::ParameterPatternMismatchError(_inner) => _inner.fmt(f),
            PutParameterErrorKind::PoliciesLimitExceededError(_inner) => _inner.fmt(f),
            PutParameterErrorKind::TooManyUpdates(_inner) => _inner.fmt(f),
            PutParameterErrorKind::UnsupportedParameterType(_inner) => _inner.fmt(f),
            PutParameterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutParameterError {
    fn code(&self) -> Option<&str> {
        PutParameterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutParameterError {
    pub fn new(kind: PutParameterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutParameterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutParameterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_hierarchy_level_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            PutParameterErrorKind::HierarchyLevelLimitExceededError(_)
        )
    }
    pub fn is_hierarchy_type_mismatch_error(&self) -> bool {
        matches!(
            &self.kind,
            PutParameterErrorKind::HierarchyTypeMismatchError(_)
        )
    }
    pub fn is_incompatible_policy_error(&self) -> bool {
        matches!(
            &self.kind,
            PutParameterErrorKind::IncompatiblePolicyError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, PutParameterErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_allowed_pattern_error(&self) -> bool {
        matches!(
            &self.kind,
            PutParameterErrorKind::InvalidAllowedPatternError(_)
        )
    }
    pub fn is_invalid_key_id(&self) -> bool {
        matches!(&self.kind, PutParameterErrorKind::InvalidKeyId(_))
    }
    pub fn is_invalid_policy_attribute_error(&self) -> bool {
        matches!(
            &self.kind,
            PutParameterErrorKind::InvalidPolicyAttributeError(_)
        )
    }
    pub fn is_invalid_policy_type_error(&self) -> bool {
        matches!(&self.kind, PutParameterErrorKind::InvalidPolicyTypeError(_))
    }
    pub fn is_parameter_already_exists(&self) -> bool {
        matches!(&self.kind, PutParameterErrorKind::ParameterAlreadyExists(_))
    }
    pub fn is_parameter_limit_exceeded(&self) -> bool {
        matches!(&self.kind, PutParameterErrorKind::ParameterLimitExceeded(_))
    }
    pub fn is_parameter_max_version_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            PutParameterErrorKind::ParameterMaxVersionLimitExceeded(_)
        )
    }
    pub fn is_parameter_pattern_mismatch_error(&self) -> bool {
        matches!(
            &self.kind,
            PutParameterErrorKind::ParameterPatternMismatchError(_)
        )
    }
    pub fn is_policies_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            PutParameterErrorKind::PoliciesLimitExceededError(_)
        )
    }
    pub fn is_too_many_updates(&self) -> bool {
        matches!(&self.kind, PutParameterErrorKind::TooManyUpdates(_))
    }
    pub fn is_unsupported_parameter_type(&self) -> bool {
        matches!(
            &self.kind,
            PutParameterErrorKind::UnsupportedParameterType(_)
        )
    }
}
impl std::error::Error for PutParameterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutParameterErrorKind::HierarchyLevelLimitExceededError(_inner) => Some(_inner),
            PutParameterErrorKind::HierarchyTypeMismatchError(_inner) => Some(_inner),
            PutParameterErrorKind::IncompatiblePolicyError(_inner) => Some(_inner),
            PutParameterErrorKind::InternalServerError(_inner) => Some(_inner),
            PutParameterErrorKind::InvalidAllowedPatternError(_inner) => Some(_inner),
            PutParameterErrorKind::InvalidKeyId(_inner) => Some(_inner),
            PutParameterErrorKind::InvalidPolicyAttributeError(_inner) => Some(_inner),
            PutParameterErrorKind::InvalidPolicyTypeError(_inner) => Some(_inner),
            PutParameterErrorKind::ParameterAlreadyExists(_inner) => Some(_inner),
            PutParameterErrorKind::ParameterLimitExceeded(_inner) => Some(_inner),
            PutParameterErrorKind::ParameterMaxVersionLimitExceeded(_inner) => Some(_inner),
            PutParameterErrorKind::ParameterPatternMismatchError(_inner) => Some(_inner),
            PutParameterErrorKind::PoliciesLimitExceededError(_inner) => Some(_inner),
            PutParameterErrorKind::TooManyUpdates(_inner) => Some(_inner),
            PutParameterErrorKind::UnsupportedParameterType(_inner) => Some(_inner),
            PutParameterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterDefaultPatchBaselineError {
    pub kind: RegisterDefaultPatchBaselineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterDefaultPatchBaselineErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    InvalidResourceId(crate::error::InvalidResourceId),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterDefaultPatchBaselineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterDefaultPatchBaselineErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            RegisterDefaultPatchBaselineErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            RegisterDefaultPatchBaselineErrorKind::InvalidResourceId(_inner) => _inner.fmt(f),
            RegisterDefaultPatchBaselineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterDefaultPatchBaselineError {
    fn code(&self) -> Option<&str> {
        RegisterDefaultPatchBaselineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterDefaultPatchBaselineError {
    pub fn new(kind: RegisterDefaultPatchBaselineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterDefaultPatchBaselineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterDefaultPatchBaselineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDefaultPatchBaselineErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDefaultPatchBaselineErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_resource_id(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDefaultPatchBaselineErrorKind::InvalidResourceId(_)
        )
    }
}
impl std::error::Error for RegisterDefaultPatchBaselineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterDefaultPatchBaselineErrorKind::DoesNotExistError(_inner) => Some(_inner),
            RegisterDefaultPatchBaselineErrorKind::InternalServerError(_inner) => Some(_inner),
            RegisterDefaultPatchBaselineErrorKind::InvalidResourceId(_inner) => Some(_inner),
            RegisterDefaultPatchBaselineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterPatchBaselineForPatchGroupError {
    pub kind: RegisterPatchBaselineForPatchGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterPatchBaselineForPatchGroupErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    InvalidResourceId(crate::error::InvalidResourceId),
    ResourceLimitExceededError(crate::error::ResourceLimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterPatchBaselineForPatchGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterPatchBaselineForPatchGroupErrorKind::AlreadyExistsError(_inner) => {
                _inner.fmt(f)
            }
            RegisterPatchBaselineForPatchGroupErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            RegisterPatchBaselineForPatchGroupErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            RegisterPatchBaselineForPatchGroupErrorKind::InvalidResourceId(_inner) => _inner.fmt(f),
            RegisterPatchBaselineForPatchGroupErrorKind::ResourceLimitExceededError(_inner) => {
                _inner.fmt(f)
            }
            RegisterPatchBaselineForPatchGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterPatchBaselineForPatchGroupError {
    fn code(&self) -> Option<&str> {
        RegisterPatchBaselineForPatchGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterPatchBaselineForPatchGroupError {
    pub fn new(
        kind: RegisterPatchBaselineForPatchGroupErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterPatchBaselineForPatchGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterPatchBaselineForPatchGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterPatchBaselineForPatchGroupErrorKind::AlreadyExistsError(_)
        )
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterPatchBaselineForPatchGroupErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterPatchBaselineForPatchGroupErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_resource_id(&self) -> bool {
        matches!(
            &self.kind,
            RegisterPatchBaselineForPatchGroupErrorKind::InvalidResourceId(_)
        )
    }
    pub fn is_resource_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterPatchBaselineForPatchGroupErrorKind::ResourceLimitExceededError(_)
        )
    }
}
impl std::error::Error for RegisterPatchBaselineForPatchGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterPatchBaselineForPatchGroupErrorKind::AlreadyExistsError(_inner) => Some(_inner),
            RegisterPatchBaselineForPatchGroupErrorKind::DoesNotExistError(_inner) => Some(_inner),
            RegisterPatchBaselineForPatchGroupErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            RegisterPatchBaselineForPatchGroupErrorKind::InvalidResourceId(_inner) => Some(_inner),
            RegisterPatchBaselineForPatchGroupErrorKind::ResourceLimitExceededError(_inner) => {
                Some(_inner)
            }
            RegisterPatchBaselineForPatchGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterTargetWithMaintenanceWindowError {
    pub kind: RegisterTargetWithMaintenanceWindowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterTargetWithMaintenanceWindowErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    IdempotentParameterMismatch(crate::error::IdempotentParameterMismatch),
    InternalServerError(crate::error::InternalServerError),
    ResourceLimitExceededError(crate::error::ResourceLimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterTargetWithMaintenanceWindowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterTargetWithMaintenanceWindowErrorKind::DoesNotExistError(_inner) => {
                _inner.fmt(f)
            }
            RegisterTargetWithMaintenanceWindowErrorKind::IdempotentParameterMismatch(_inner) => {
                _inner.fmt(f)
            }
            RegisterTargetWithMaintenanceWindowErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            RegisterTargetWithMaintenanceWindowErrorKind::ResourceLimitExceededError(_inner) => {
                _inner.fmt(f)
            }
            RegisterTargetWithMaintenanceWindowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterTargetWithMaintenanceWindowError {
    fn code(&self) -> Option<&str> {
        RegisterTargetWithMaintenanceWindowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterTargetWithMaintenanceWindowError {
    pub fn new(
        kind: RegisterTargetWithMaintenanceWindowErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterTargetWithMaintenanceWindowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterTargetWithMaintenanceWindowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterTargetWithMaintenanceWindowErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch(&self) -> bool {
        matches!(
            &self.kind,
            RegisterTargetWithMaintenanceWindowErrorKind::IdempotentParameterMismatch(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterTargetWithMaintenanceWindowErrorKind::InternalServerError(_)
        )
    }
    pub fn is_resource_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterTargetWithMaintenanceWindowErrorKind::ResourceLimitExceededError(_)
        )
    }
}
impl std::error::Error for RegisterTargetWithMaintenanceWindowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterTargetWithMaintenanceWindowErrorKind::DoesNotExistError(_inner) => Some(_inner),
            RegisterTargetWithMaintenanceWindowErrorKind::IdempotentParameterMismatch(_inner) => {
                Some(_inner)
            }
            RegisterTargetWithMaintenanceWindowErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            RegisterTargetWithMaintenanceWindowErrorKind::ResourceLimitExceededError(_inner) => {
                Some(_inner)
            }
            RegisterTargetWithMaintenanceWindowErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterTaskWithMaintenanceWindowError {
    pub kind: RegisterTaskWithMaintenanceWindowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterTaskWithMaintenanceWindowErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    FeatureNotAvailableError(crate::error::FeatureNotAvailableError),
    IdempotentParameterMismatch(crate::error::IdempotentParameterMismatch),
    InternalServerError(crate::error::InternalServerError),
    ResourceLimitExceededError(crate::error::ResourceLimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterTaskWithMaintenanceWindowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterTaskWithMaintenanceWindowErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            RegisterTaskWithMaintenanceWindowErrorKind::FeatureNotAvailableError(_inner) => {
                _inner.fmt(f)
            }
            RegisterTaskWithMaintenanceWindowErrorKind::IdempotentParameterMismatch(_inner) => {
                _inner.fmt(f)
            }
            RegisterTaskWithMaintenanceWindowErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            RegisterTaskWithMaintenanceWindowErrorKind::ResourceLimitExceededError(_inner) => {
                _inner.fmt(f)
            }
            RegisterTaskWithMaintenanceWindowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterTaskWithMaintenanceWindowError {
    fn code(&self) -> Option<&str> {
        RegisterTaskWithMaintenanceWindowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterTaskWithMaintenanceWindowError {
    pub fn new(
        kind: RegisterTaskWithMaintenanceWindowErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterTaskWithMaintenanceWindowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterTaskWithMaintenanceWindowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterTaskWithMaintenanceWindowErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_feature_not_available_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterTaskWithMaintenanceWindowErrorKind::FeatureNotAvailableError(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch(&self) -> bool {
        matches!(
            &self.kind,
            RegisterTaskWithMaintenanceWindowErrorKind::IdempotentParameterMismatch(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterTaskWithMaintenanceWindowErrorKind::InternalServerError(_)
        )
    }
    pub fn is_resource_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterTaskWithMaintenanceWindowErrorKind::ResourceLimitExceededError(_)
        )
    }
}
impl std::error::Error for RegisterTaskWithMaintenanceWindowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterTaskWithMaintenanceWindowErrorKind::DoesNotExistError(_inner) => Some(_inner),
            RegisterTaskWithMaintenanceWindowErrorKind::FeatureNotAvailableError(_inner) => {
                Some(_inner)
            }
            RegisterTaskWithMaintenanceWindowErrorKind::IdempotentParameterMismatch(_inner) => {
                Some(_inner)
            }
            RegisterTaskWithMaintenanceWindowErrorKind::InternalServerError(_inner) => Some(_inner),
            RegisterTaskWithMaintenanceWindowErrorKind::ResourceLimitExceededError(_inner) => {
                Some(_inner)
            }
            RegisterTaskWithMaintenanceWindowErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveTagsFromResourceError {
    pub kind: RemoveTagsFromResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveTagsFromResourceErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidResourceId(crate::error::InvalidResourceId),
    InvalidResourceType(crate::error::InvalidResourceType),
    TooManyUpdates(crate::error::TooManyUpdates),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveTagsFromResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveTagsFromResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::InvalidResourceId(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::InvalidResourceType(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::TooManyUpdates(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveTagsFromResourceError {
    fn code(&self) -> Option<&str> {
        RemoveTagsFromResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveTagsFromResourceError {
    pub fn new(kind: RemoveTagsFromResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveTagsFromResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveTagsFromResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_resource_id(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::InvalidResourceId(_)
        )
    }
    pub fn is_invalid_resource_type(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::InvalidResourceType(_)
        )
    }
    pub fn is_too_many_updates(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::TooManyUpdates(_)
        )
    }
}
impl std::error::Error for RemoveTagsFromResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveTagsFromResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::InvalidResourceId(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::InvalidResourceType(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::TooManyUpdates(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetServiceSettingError {
    pub kind: ResetServiceSettingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetServiceSettingErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ServiceSettingNotFound(crate::error::ServiceSettingNotFound),
    TooManyUpdates(crate::error::TooManyUpdates),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetServiceSettingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetServiceSettingErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ResetServiceSettingErrorKind::ServiceSettingNotFound(_inner) => _inner.fmt(f),
            ResetServiceSettingErrorKind::TooManyUpdates(_inner) => _inner.fmt(f),
            ResetServiceSettingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetServiceSettingError {
    fn code(&self) -> Option<&str> {
        ResetServiceSettingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetServiceSettingError {
    pub fn new(kind: ResetServiceSettingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetServiceSettingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetServiceSettingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ResetServiceSettingErrorKind::InternalServerError(_)
        )
    }
    pub fn is_service_setting_not_found(&self) -> bool {
        matches!(
            &self.kind,
            ResetServiceSettingErrorKind::ServiceSettingNotFound(_)
        )
    }
    pub fn is_too_many_updates(&self) -> bool {
        matches!(&self.kind, ResetServiceSettingErrorKind::TooManyUpdates(_))
    }
}
impl std::error::Error for ResetServiceSettingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetServiceSettingErrorKind::InternalServerError(_inner) => Some(_inner),
            ResetServiceSettingErrorKind::ServiceSettingNotFound(_inner) => Some(_inner),
            ResetServiceSettingErrorKind::TooManyUpdates(_inner) => Some(_inner),
            ResetServiceSettingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResumeSessionError {
    pub kind: ResumeSessionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResumeSessionErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResumeSessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResumeSessionErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            ResumeSessionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ResumeSessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResumeSessionError {
    fn code(&self) -> Option<&str> {
        ResumeSessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResumeSessionError {
    pub fn new(kind: ResumeSessionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResumeSessionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResumeSessionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(&self.kind, ResumeSessionErrorKind::DoesNotExistError(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ResumeSessionErrorKind::InternalServerError(_))
    }
}
impl std::error::Error for ResumeSessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResumeSessionErrorKind::DoesNotExistError(_inner) => Some(_inner),
            ResumeSessionErrorKind::InternalServerError(_inner) => Some(_inner),
            ResumeSessionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendAutomationSignalError {
    pub kind: SendAutomationSignalErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendAutomationSignalErrorKind {
    AutomationExecutionNotFoundError(crate::error::AutomationExecutionNotFoundError),
    AutomationStepNotFoundError(crate::error::AutomationStepNotFoundError),
    InternalServerError(crate::error::InternalServerError),
    InvalidAutomationSignalError(crate::error::InvalidAutomationSignalError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendAutomationSignalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendAutomationSignalErrorKind::AutomationExecutionNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            SendAutomationSignalErrorKind::AutomationStepNotFoundError(_inner) => _inner.fmt(f),
            SendAutomationSignalErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            SendAutomationSignalErrorKind::InvalidAutomationSignalError(_inner) => _inner.fmt(f),
            SendAutomationSignalErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendAutomationSignalError {
    fn code(&self) -> Option<&str> {
        SendAutomationSignalError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendAutomationSignalError {
    pub fn new(kind: SendAutomationSignalErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendAutomationSignalErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendAutomationSignalErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_automation_execution_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            SendAutomationSignalErrorKind::AutomationExecutionNotFoundError(_)
        )
    }
    pub fn is_automation_step_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            SendAutomationSignalErrorKind::AutomationStepNotFoundError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            SendAutomationSignalErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_automation_signal_error(&self) -> bool {
        matches!(
            &self.kind,
            SendAutomationSignalErrorKind::InvalidAutomationSignalError(_)
        )
    }
}
impl std::error::Error for SendAutomationSignalError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendAutomationSignalErrorKind::AutomationExecutionNotFoundError(_inner) => Some(_inner),
            SendAutomationSignalErrorKind::AutomationStepNotFoundError(_inner) => Some(_inner),
            SendAutomationSignalErrorKind::InternalServerError(_inner) => Some(_inner),
            SendAutomationSignalErrorKind::InvalidAutomationSignalError(_inner) => Some(_inner),
            SendAutomationSignalErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendCommandError {
    pub kind: SendCommandErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendCommandErrorKind {
    DuplicateInstanceId(crate::error::DuplicateInstanceId),
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidDocumentVersion(crate::error::InvalidDocumentVersion),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    InvalidNotificationConfig(crate::error::InvalidNotificationConfig),
    InvalidOutputFolder(crate::error::InvalidOutputFolder),
    InvalidParameters(crate::error::InvalidParameters),
    InvalidRole(crate::error::InvalidRole),
    MaxDocumentSizeExceeded(crate::error::MaxDocumentSizeExceeded),
    UnsupportedPlatformType(crate::error::UnsupportedPlatformType),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendCommandError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendCommandErrorKind::DuplicateInstanceId(_inner) => _inner.fmt(f),
            SendCommandErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            SendCommandErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            SendCommandErrorKind::InvalidDocumentVersion(_inner) => _inner.fmt(f),
            SendCommandErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            SendCommandErrorKind::InvalidNotificationConfig(_inner) => _inner.fmt(f),
            SendCommandErrorKind::InvalidOutputFolder(_inner) => _inner.fmt(f),
            SendCommandErrorKind::InvalidParameters(_inner) => _inner.fmt(f),
            SendCommandErrorKind::InvalidRole(_inner) => _inner.fmt(f),
            SendCommandErrorKind::MaxDocumentSizeExceeded(_inner) => _inner.fmt(f),
            SendCommandErrorKind::UnsupportedPlatformType(_inner) => _inner.fmt(f),
            SendCommandErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendCommandError {
    fn code(&self) -> Option<&str> {
        SendCommandError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendCommandError {
    pub fn new(kind: SendCommandErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendCommandErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendCommandErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_instance_id(&self) -> bool {
        matches!(&self.kind, SendCommandErrorKind::DuplicateInstanceId(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, SendCommandErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(&self.kind, SendCommandErrorKind::InvalidDocument(_))
    }
    pub fn is_invalid_document_version(&self) -> bool {
        matches!(&self.kind, SendCommandErrorKind::InvalidDocumentVersion(_))
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(&self.kind, SendCommandErrorKind::InvalidInstanceId(_))
    }
    pub fn is_invalid_notification_config(&self) -> bool {
        matches!(
            &self.kind,
            SendCommandErrorKind::InvalidNotificationConfig(_)
        )
    }
    pub fn is_invalid_output_folder(&self) -> bool {
        matches!(&self.kind, SendCommandErrorKind::InvalidOutputFolder(_))
    }
    pub fn is_invalid_parameters(&self) -> bool {
        matches!(&self.kind, SendCommandErrorKind::InvalidParameters(_))
    }
    pub fn is_invalid_role(&self) -> bool {
        matches!(&self.kind, SendCommandErrorKind::InvalidRole(_))
    }
    pub fn is_max_document_size_exceeded(&self) -> bool {
        matches!(&self.kind, SendCommandErrorKind::MaxDocumentSizeExceeded(_))
    }
    pub fn is_unsupported_platform_type(&self) -> bool {
        matches!(&self.kind, SendCommandErrorKind::UnsupportedPlatformType(_))
    }
}
impl std::error::Error for SendCommandError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendCommandErrorKind::DuplicateInstanceId(_inner) => Some(_inner),
            SendCommandErrorKind::InternalServerError(_inner) => Some(_inner),
            SendCommandErrorKind::InvalidDocument(_inner) => Some(_inner),
            SendCommandErrorKind::InvalidDocumentVersion(_inner) => Some(_inner),
            SendCommandErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            SendCommandErrorKind::InvalidNotificationConfig(_inner) => Some(_inner),
            SendCommandErrorKind::InvalidOutputFolder(_inner) => Some(_inner),
            SendCommandErrorKind::InvalidParameters(_inner) => Some(_inner),
            SendCommandErrorKind::InvalidRole(_inner) => Some(_inner),
            SendCommandErrorKind::MaxDocumentSizeExceeded(_inner) => Some(_inner),
            SendCommandErrorKind::UnsupportedPlatformType(_inner) => Some(_inner),
            SendCommandErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartAssociationsOnceError {
    pub kind: StartAssociationsOnceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartAssociationsOnceErrorKind {
    AssociationDoesNotExist(crate::error::AssociationDoesNotExist),
    InvalidAssociation(crate::error::InvalidAssociation),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartAssociationsOnceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartAssociationsOnceErrorKind::AssociationDoesNotExist(_inner) => _inner.fmt(f),
            StartAssociationsOnceErrorKind::InvalidAssociation(_inner) => _inner.fmt(f),
            StartAssociationsOnceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartAssociationsOnceError {
    fn code(&self) -> Option<&str> {
        StartAssociationsOnceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartAssociationsOnceError {
    pub fn new(kind: StartAssociationsOnceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartAssociationsOnceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartAssociationsOnceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_association_does_not_exist(&self) -> bool {
        matches!(
            &self.kind,
            StartAssociationsOnceErrorKind::AssociationDoesNotExist(_)
        )
    }
    pub fn is_invalid_association(&self) -> bool {
        matches!(
            &self.kind,
            StartAssociationsOnceErrorKind::InvalidAssociation(_)
        )
    }
}
impl std::error::Error for StartAssociationsOnceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartAssociationsOnceErrorKind::AssociationDoesNotExist(_inner) => Some(_inner),
            StartAssociationsOnceErrorKind::InvalidAssociation(_inner) => Some(_inner),
            StartAssociationsOnceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartAutomationExecutionError {
    pub kind: StartAutomationExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartAutomationExecutionErrorKind {
    AutomationDefinitionNotFoundError(crate::error::AutomationDefinitionNotFoundError),
    AutomationDefinitionVersionNotFoundError(
        crate::error::AutomationDefinitionVersionNotFoundError,
    ),
    AutomationExecutionLimitExceededError(crate::error::AutomationExecutionLimitExceededError),
    IdempotentParameterMismatch(crate::error::IdempotentParameterMismatch),
    InternalServerError(crate::error::InternalServerError),
    InvalidAutomationExecutionParametersError(
        crate::error::InvalidAutomationExecutionParametersError,
    ),
    InvalidTarget(crate::error::InvalidTarget),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartAutomationExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartAutomationExecutionErrorKind::AutomationDefinitionNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            StartAutomationExecutionErrorKind::AutomationDefinitionVersionNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            StartAutomationExecutionErrorKind::AutomationExecutionLimitExceededError(_inner) => {
                _inner.fmt(f)
            }
            StartAutomationExecutionErrorKind::IdempotentParameterMismatch(_inner) => _inner.fmt(f),
            StartAutomationExecutionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartAutomationExecutionErrorKind::InvalidAutomationExecutionParametersError(
                _inner,
            ) => _inner.fmt(f),
            StartAutomationExecutionErrorKind::InvalidTarget(_inner) => _inner.fmt(f),
            StartAutomationExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartAutomationExecutionError {
    fn code(&self) -> Option<&str> {
        StartAutomationExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartAutomationExecutionError {
    pub fn new(kind: StartAutomationExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartAutomationExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartAutomationExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_automation_definition_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            StartAutomationExecutionErrorKind::AutomationDefinitionNotFoundError(_)
        )
    }
    pub fn is_automation_definition_version_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            StartAutomationExecutionErrorKind::AutomationDefinitionVersionNotFoundError(_)
        )
    }
    pub fn is_automation_execution_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            StartAutomationExecutionErrorKind::AutomationExecutionLimitExceededError(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch(&self) -> bool {
        matches!(
            &self.kind,
            StartAutomationExecutionErrorKind::IdempotentParameterMismatch(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartAutomationExecutionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_automation_execution_parameters_error(&self) -> bool {
        matches!(
            &self.kind,
            StartAutomationExecutionErrorKind::InvalidAutomationExecutionParametersError(_)
        )
    }
    pub fn is_invalid_target(&self) -> bool {
        matches!(
            &self.kind,
            StartAutomationExecutionErrorKind::InvalidTarget(_)
        )
    }
}
impl std::error::Error for StartAutomationExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartAutomationExecutionErrorKind::AutomationDefinitionNotFoundError(_inner) => {
                Some(_inner)
            }
            StartAutomationExecutionErrorKind::AutomationDefinitionVersionNotFoundError(_inner) => {
                Some(_inner)
            }
            StartAutomationExecutionErrorKind::AutomationExecutionLimitExceededError(_inner) => {
                Some(_inner)
            }
            StartAutomationExecutionErrorKind::IdempotentParameterMismatch(_inner) => Some(_inner),
            StartAutomationExecutionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartAutomationExecutionErrorKind::InvalidAutomationExecutionParametersError(
                _inner,
            ) => Some(_inner),
            StartAutomationExecutionErrorKind::InvalidTarget(_inner) => Some(_inner),
            StartAutomationExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartChangeRequestExecutionError {
    pub kind: StartChangeRequestExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartChangeRequestExecutionErrorKind {
    AutomationDefinitionNotApprovedError(crate::error::AutomationDefinitionNotApprovedError),
    AutomationDefinitionNotFoundError(crate::error::AutomationDefinitionNotFoundError),
    AutomationDefinitionVersionNotFoundError(
        crate::error::AutomationDefinitionVersionNotFoundError,
    ),
    AutomationExecutionLimitExceededError(crate::error::AutomationExecutionLimitExceededError),
    IdempotentParameterMismatch(crate::error::IdempotentParameterMismatch),
    InternalServerError(crate::error::InternalServerError),
    InvalidAutomationExecutionParametersError(
        crate::error::InvalidAutomationExecutionParametersError,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartChangeRequestExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartChangeRequestExecutionErrorKind::AutomationDefinitionNotApprovedError(_inner) => {
                _inner.fmt(f)
            }
            StartChangeRequestExecutionErrorKind::AutomationDefinitionNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            StartChangeRequestExecutionErrorKind::AutomationDefinitionVersionNotFoundError(
                _inner,
            ) => _inner.fmt(f),
            StartChangeRequestExecutionErrorKind::AutomationExecutionLimitExceededError(_inner) => {
                _inner.fmt(f)
            }
            StartChangeRequestExecutionErrorKind::IdempotentParameterMismatch(_inner) => {
                _inner.fmt(f)
            }
            StartChangeRequestExecutionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartChangeRequestExecutionErrorKind::InvalidAutomationExecutionParametersError(
                _inner,
            ) => _inner.fmt(f),
            StartChangeRequestExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartChangeRequestExecutionError {
    fn code(&self) -> Option<&str> {
        StartChangeRequestExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartChangeRequestExecutionError {
    pub fn new(kind: StartChangeRequestExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartChangeRequestExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartChangeRequestExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_automation_definition_not_approved_error(&self) -> bool {
        matches!(
            &self.kind,
            StartChangeRequestExecutionErrorKind::AutomationDefinitionNotApprovedError(_)
        )
    }
    pub fn is_automation_definition_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            StartChangeRequestExecutionErrorKind::AutomationDefinitionNotFoundError(_)
        )
    }
    pub fn is_automation_definition_version_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            StartChangeRequestExecutionErrorKind::AutomationDefinitionVersionNotFoundError(_)
        )
    }
    pub fn is_automation_execution_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            StartChangeRequestExecutionErrorKind::AutomationExecutionLimitExceededError(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch(&self) -> bool {
        matches!(
            &self.kind,
            StartChangeRequestExecutionErrorKind::IdempotentParameterMismatch(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartChangeRequestExecutionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_automation_execution_parameters_error(&self) -> bool {
        matches!(
            &self.kind,
            StartChangeRequestExecutionErrorKind::InvalidAutomationExecutionParametersError(_)
        )
    }
}
impl std::error::Error for StartChangeRequestExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartChangeRequestExecutionErrorKind::AutomationDefinitionNotApprovedError(_inner) => {
                Some(_inner)
            }
            StartChangeRequestExecutionErrorKind::AutomationDefinitionNotFoundError(_inner) => {
                Some(_inner)
            }
            StartChangeRequestExecutionErrorKind::AutomationDefinitionVersionNotFoundError(
                _inner,
            ) => Some(_inner),
            StartChangeRequestExecutionErrorKind::AutomationExecutionLimitExceededError(_inner) => {
                Some(_inner)
            }
            StartChangeRequestExecutionErrorKind::IdempotentParameterMismatch(_inner) => {
                Some(_inner)
            }
            StartChangeRequestExecutionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartChangeRequestExecutionErrorKind::InvalidAutomationExecutionParametersError(
                _inner,
            ) => Some(_inner),
            StartChangeRequestExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartSessionError {
    pub kind: StartSessionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartSessionErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    TargetNotConnected(crate::error::TargetNotConnected),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartSessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartSessionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartSessionErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            StartSessionErrorKind::TargetNotConnected(_inner) => _inner.fmt(f),
            StartSessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartSessionError {
    fn code(&self) -> Option<&str> {
        StartSessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartSessionError {
    pub fn new(kind: StartSessionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartSessionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartSessionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, StartSessionErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(&self.kind, StartSessionErrorKind::InvalidDocument(_))
    }
    pub fn is_target_not_connected(&self) -> bool {
        matches!(&self.kind, StartSessionErrorKind::TargetNotConnected(_))
    }
}
impl std::error::Error for StartSessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartSessionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartSessionErrorKind::InvalidDocument(_inner) => Some(_inner),
            StartSessionErrorKind::TargetNotConnected(_inner) => Some(_inner),
            StartSessionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopAutomationExecutionError {
    pub kind: StopAutomationExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopAutomationExecutionErrorKind {
    AutomationExecutionNotFoundError(crate::error::AutomationExecutionNotFoundError),
    InternalServerError(crate::error::InternalServerError),
    InvalidAutomationStatusUpdateError(crate::error::InvalidAutomationStatusUpdateError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopAutomationExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopAutomationExecutionErrorKind::AutomationExecutionNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            StopAutomationExecutionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StopAutomationExecutionErrorKind::InvalidAutomationStatusUpdateError(_inner) => {
                _inner.fmt(f)
            }
            StopAutomationExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopAutomationExecutionError {
    fn code(&self) -> Option<&str> {
        StopAutomationExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopAutomationExecutionError {
    pub fn new(kind: StopAutomationExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopAutomationExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopAutomationExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_automation_execution_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            StopAutomationExecutionErrorKind::AutomationExecutionNotFoundError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StopAutomationExecutionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_automation_status_update_error(&self) -> bool {
        matches!(
            &self.kind,
            StopAutomationExecutionErrorKind::InvalidAutomationStatusUpdateError(_)
        )
    }
}
impl std::error::Error for StopAutomationExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopAutomationExecutionErrorKind::AutomationExecutionNotFoundError(_inner) => {
                Some(_inner)
            }
            StopAutomationExecutionErrorKind::InternalServerError(_inner) => Some(_inner),
            StopAutomationExecutionErrorKind::InvalidAutomationStatusUpdateError(_inner) => {
                Some(_inner)
            }
            StopAutomationExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TerminateSessionError {
    pub kind: TerminateSessionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TerminateSessionErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TerminateSessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TerminateSessionErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            TerminateSessionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            TerminateSessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TerminateSessionError {
    fn code(&self) -> Option<&str> {
        TerminateSessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TerminateSessionError {
    pub fn new(kind: TerminateSessionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TerminateSessionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TerminateSessionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(&self.kind, TerminateSessionErrorKind::DoesNotExistError(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            TerminateSessionErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for TerminateSessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TerminateSessionErrorKind::DoesNotExistError(_inner) => Some(_inner),
            TerminateSessionErrorKind::InternalServerError(_inner) => Some(_inner),
            TerminateSessionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UnlabelParameterVersionError {
    pub kind: UnlabelParameterVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UnlabelParameterVersionErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ParameterNotFound(crate::error::ParameterNotFound),
    ParameterVersionNotFound(crate::error::ParameterVersionNotFound),
    TooManyUpdates(crate::error::TooManyUpdates),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UnlabelParameterVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UnlabelParameterVersionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UnlabelParameterVersionErrorKind::ParameterNotFound(_inner) => _inner.fmt(f),
            UnlabelParameterVersionErrorKind::ParameterVersionNotFound(_inner) => _inner.fmt(f),
            UnlabelParameterVersionErrorKind::TooManyUpdates(_inner) => _inner.fmt(f),
            UnlabelParameterVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UnlabelParameterVersionError {
    fn code(&self) -> Option<&str> {
        UnlabelParameterVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UnlabelParameterVersionError {
    pub fn new(kind: UnlabelParameterVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UnlabelParameterVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UnlabelParameterVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UnlabelParameterVersionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_parameter_not_found(&self) -> bool {
        matches!(
            &self.kind,
            UnlabelParameterVersionErrorKind::ParameterNotFound(_)
        )
    }
    pub fn is_parameter_version_not_found(&self) -> bool {
        matches!(
            &self.kind,
            UnlabelParameterVersionErrorKind::ParameterVersionNotFound(_)
        )
    }
    pub fn is_too_many_updates(&self) -> bool {
        matches!(
            &self.kind,
            UnlabelParameterVersionErrorKind::TooManyUpdates(_)
        )
    }
}
impl std::error::Error for UnlabelParameterVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UnlabelParameterVersionErrorKind::InternalServerError(_inner) => Some(_inner),
            UnlabelParameterVersionErrorKind::ParameterNotFound(_inner) => Some(_inner),
            UnlabelParameterVersionErrorKind::ParameterVersionNotFound(_inner) => Some(_inner),
            UnlabelParameterVersionErrorKind::TooManyUpdates(_inner) => Some(_inner),
            UnlabelParameterVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAssociationError {
    pub kind: UpdateAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAssociationErrorKind {
    AssociationDoesNotExist(crate::error::AssociationDoesNotExist),
    AssociationVersionLimitExceeded(crate::error::AssociationVersionLimitExceeded),
    InternalServerError(crate::error::InternalServerError),
    InvalidAssociationVersion(crate::error::InvalidAssociationVersion),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidDocumentVersion(crate::error::InvalidDocumentVersion),
    InvalidOutputLocation(crate::error::InvalidOutputLocation),
    InvalidParameters(crate::error::InvalidParameters),
    InvalidSchedule(crate::error::InvalidSchedule),
    InvalidTarget(crate::error::InvalidTarget),
    InvalidUpdate(crate::error::InvalidUpdate),
    TooManyUpdates(crate::error::TooManyUpdates),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAssociationErrorKind::AssociationDoesNotExist(_inner) => _inner.fmt(f),
            UpdateAssociationErrorKind::AssociationVersionLimitExceeded(_inner) => _inner.fmt(f),
            UpdateAssociationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateAssociationErrorKind::InvalidAssociationVersion(_inner) => _inner.fmt(f),
            UpdateAssociationErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            UpdateAssociationErrorKind::InvalidDocumentVersion(_inner) => _inner.fmt(f),
            UpdateAssociationErrorKind::InvalidOutputLocation(_inner) => _inner.fmt(f),
            UpdateAssociationErrorKind::InvalidParameters(_inner) => _inner.fmt(f),
            UpdateAssociationErrorKind::InvalidSchedule(_inner) => _inner.fmt(f),
            UpdateAssociationErrorKind::InvalidTarget(_inner) => _inner.fmt(f),
            UpdateAssociationErrorKind::InvalidUpdate(_inner) => _inner.fmt(f),
            UpdateAssociationErrorKind::TooManyUpdates(_inner) => _inner.fmt(f),
            UpdateAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAssociationError {
    fn code(&self) -> Option<&str> {
        UpdateAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAssociationError {
    pub fn new(kind: UpdateAssociationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_association_does_not_exist(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssociationErrorKind::AssociationDoesNotExist(_)
        )
    }
    pub fn is_association_version_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssociationErrorKind::AssociationVersionLimitExceeded(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssociationErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_association_version(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssociationErrorKind::InvalidAssociationVersion(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(&self.kind, UpdateAssociationErrorKind::InvalidDocument(_))
    }
    pub fn is_invalid_document_version(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssociationErrorKind::InvalidDocumentVersion(_)
        )
    }
    pub fn is_invalid_output_location(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssociationErrorKind::InvalidOutputLocation(_)
        )
    }
    pub fn is_invalid_parameters(&self) -> bool {
        matches!(&self.kind, UpdateAssociationErrorKind::InvalidParameters(_))
    }
    pub fn is_invalid_schedule(&self) -> bool {
        matches!(&self.kind, UpdateAssociationErrorKind::InvalidSchedule(_))
    }
    pub fn is_invalid_target(&self) -> bool {
        matches!(&self.kind, UpdateAssociationErrorKind::InvalidTarget(_))
    }
    pub fn is_invalid_update(&self) -> bool {
        matches!(&self.kind, UpdateAssociationErrorKind::InvalidUpdate(_))
    }
    pub fn is_too_many_updates(&self) -> bool {
        matches!(&self.kind, UpdateAssociationErrorKind::TooManyUpdates(_))
    }
}
impl std::error::Error for UpdateAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAssociationErrorKind::AssociationDoesNotExist(_inner) => Some(_inner),
            UpdateAssociationErrorKind::AssociationVersionLimitExceeded(_inner) => Some(_inner),
            UpdateAssociationErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateAssociationErrorKind::InvalidAssociationVersion(_inner) => Some(_inner),
            UpdateAssociationErrorKind::InvalidDocument(_inner) => Some(_inner),
            UpdateAssociationErrorKind::InvalidDocumentVersion(_inner) => Some(_inner),
            UpdateAssociationErrorKind::InvalidOutputLocation(_inner) => Some(_inner),
            UpdateAssociationErrorKind::InvalidParameters(_inner) => Some(_inner),
            UpdateAssociationErrorKind::InvalidSchedule(_inner) => Some(_inner),
            UpdateAssociationErrorKind::InvalidTarget(_inner) => Some(_inner),
            UpdateAssociationErrorKind::InvalidUpdate(_inner) => Some(_inner),
            UpdateAssociationErrorKind::TooManyUpdates(_inner) => Some(_inner),
            UpdateAssociationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAssociationStatusError {
    pub kind: UpdateAssociationStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAssociationStatusErrorKind {
    AssociationDoesNotExist(crate::error::AssociationDoesNotExist),
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    StatusUnchanged(crate::error::StatusUnchanged),
    TooManyUpdates(crate::error::TooManyUpdates),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAssociationStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAssociationStatusErrorKind::AssociationDoesNotExist(_inner) => _inner.fmt(f),
            UpdateAssociationStatusErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateAssociationStatusErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            UpdateAssociationStatusErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            UpdateAssociationStatusErrorKind::StatusUnchanged(_inner) => _inner.fmt(f),
            UpdateAssociationStatusErrorKind::TooManyUpdates(_inner) => _inner.fmt(f),
            UpdateAssociationStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAssociationStatusError {
    fn code(&self) -> Option<&str> {
        UpdateAssociationStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAssociationStatusError {
    pub fn new(kind: UpdateAssociationStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAssociationStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAssociationStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_association_does_not_exist(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssociationStatusErrorKind::AssociationDoesNotExist(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssociationStatusErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssociationStatusErrorKind::InvalidDocument(_)
        )
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssociationStatusErrorKind::InvalidInstanceId(_)
        )
    }
    pub fn is_status_unchanged(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssociationStatusErrorKind::StatusUnchanged(_)
        )
    }
    pub fn is_too_many_updates(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssociationStatusErrorKind::TooManyUpdates(_)
        )
    }
}
impl std::error::Error for UpdateAssociationStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAssociationStatusErrorKind::AssociationDoesNotExist(_inner) => Some(_inner),
            UpdateAssociationStatusErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateAssociationStatusErrorKind::InvalidDocument(_inner) => Some(_inner),
            UpdateAssociationStatusErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            UpdateAssociationStatusErrorKind::StatusUnchanged(_inner) => Some(_inner),
            UpdateAssociationStatusErrorKind::TooManyUpdates(_inner) => Some(_inner),
            UpdateAssociationStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDocumentError {
    pub kind: UpdateDocumentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDocumentErrorKind {
    DocumentVersionLimitExceeded(crate::error::DocumentVersionLimitExceeded),
    DuplicateDocumentContent(crate::error::DuplicateDocumentContent),
    DuplicateDocumentVersionName(crate::error::DuplicateDocumentVersionName),
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidDocumentContent(crate::error::InvalidDocumentContent),
    InvalidDocumentOperation(crate::error::InvalidDocumentOperation),
    InvalidDocumentSchemaVersion(crate::error::InvalidDocumentSchemaVersion),
    InvalidDocumentVersion(crate::error::InvalidDocumentVersion),
    MaxDocumentSizeExceeded(crate::error::MaxDocumentSizeExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDocumentErrorKind::DocumentVersionLimitExceeded(_inner) => _inner.fmt(f),
            UpdateDocumentErrorKind::DuplicateDocumentContent(_inner) => _inner.fmt(f),
            UpdateDocumentErrorKind::DuplicateDocumentVersionName(_inner) => _inner.fmt(f),
            UpdateDocumentErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateDocumentErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            UpdateDocumentErrorKind::InvalidDocumentContent(_inner) => _inner.fmt(f),
            UpdateDocumentErrorKind::InvalidDocumentOperation(_inner) => _inner.fmt(f),
            UpdateDocumentErrorKind::InvalidDocumentSchemaVersion(_inner) => _inner.fmt(f),
            UpdateDocumentErrorKind::InvalidDocumentVersion(_inner) => _inner.fmt(f),
            UpdateDocumentErrorKind::MaxDocumentSizeExceeded(_inner) => _inner.fmt(f),
            UpdateDocumentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDocumentError {
    fn code(&self) -> Option<&str> {
        UpdateDocumentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDocumentError {
    pub fn new(kind: UpdateDocumentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDocumentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDocumentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_document_version_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentErrorKind::DocumentVersionLimitExceeded(_)
        )
    }
    pub fn is_duplicate_document_content(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentErrorKind::DuplicateDocumentContent(_)
        )
    }
    pub fn is_duplicate_document_version_name(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentErrorKind::DuplicateDocumentVersionName(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, UpdateDocumentErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(&self.kind, UpdateDocumentErrorKind::InvalidDocument(_))
    }
    pub fn is_invalid_document_content(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentErrorKind::InvalidDocumentContent(_)
        )
    }
    pub fn is_invalid_document_operation(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentErrorKind::InvalidDocumentOperation(_)
        )
    }
    pub fn is_invalid_document_schema_version(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentErrorKind::InvalidDocumentSchemaVersion(_)
        )
    }
    pub fn is_invalid_document_version(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentErrorKind::InvalidDocumentVersion(_)
        )
    }
    pub fn is_max_document_size_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentErrorKind::MaxDocumentSizeExceeded(_)
        )
    }
}
impl std::error::Error for UpdateDocumentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDocumentErrorKind::DocumentVersionLimitExceeded(_inner) => Some(_inner),
            UpdateDocumentErrorKind::DuplicateDocumentContent(_inner) => Some(_inner),
            UpdateDocumentErrorKind::DuplicateDocumentVersionName(_inner) => Some(_inner),
            UpdateDocumentErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateDocumentErrorKind::InvalidDocument(_inner) => Some(_inner),
            UpdateDocumentErrorKind::InvalidDocumentContent(_inner) => Some(_inner),
            UpdateDocumentErrorKind::InvalidDocumentOperation(_inner) => Some(_inner),
            UpdateDocumentErrorKind::InvalidDocumentSchemaVersion(_inner) => Some(_inner),
            UpdateDocumentErrorKind::InvalidDocumentVersion(_inner) => Some(_inner),
            UpdateDocumentErrorKind::MaxDocumentSizeExceeded(_inner) => Some(_inner),
            UpdateDocumentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDocumentDefaultVersionError {
    pub kind: UpdateDocumentDefaultVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDocumentDefaultVersionErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidDocumentSchemaVersion(crate::error::InvalidDocumentSchemaVersion),
    InvalidDocumentVersion(crate::error::InvalidDocumentVersion),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDocumentDefaultVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDocumentDefaultVersionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateDocumentDefaultVersionErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            UpdateDocumentDefaultVersionErrorKind::InvalidDocumentSchemaVersion(_inner) => {
                _inner.fmt(f)
            }
            UpdateDocumentDefaultVersionErrorKind::InvalidDocumentVersion(_inner) => _inner.fmt(f),
            UpdateDocumentDefaultVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDocumentDefaultVersionError {
    fn code(&self) -> Option<&str> {
        UpdateDocumentDefaultVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDocumentDefaultVersionError {
    pub fn new(kind: UpdateDocumentDefaultVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDocumentDefaultVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDocumentDefaultVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentDefaultVersionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentDefaultVersionErrorKind::InvalidDocument(_)
        )
    }
    pub fn is_invalid_document_schema_version(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentDefaultVersionErrorKind::InvalidDocumentSchemaVersion(_)
        )
    }
    pub fn is_invalid_document_version(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentDefaultVersionErrorKind::InvalidDocumentVersion(_)
        )
    }
}
impl std::error::Error for UpdateDocumentDefaultVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDocumentDefaultVersionErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateDocumentDefaultVersionErrorKind::InvalidDocument(_inner) => Some(_inner),
            UpdateDocumentDefaultVersionErrorKind::InvalidDocumentSchemaVersion(_inner) => {
                Some(_inner)
            }
            UpdateDocumentDefaultVersionErrorKind::InvalidDocumentVersion(_inner) => Some(_inner),
            UpdateDocumentDefaultVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDocumentMetadataError {
    pub kind: UpdateDocumentMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDocumentMetadataErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidDocument(crate::error::InvalidDocument),
    InvalidDocumentOperation(crate::error::InvalidDocumentOperation),
    InvalidDocumentVersion(crate::error::InvalidDocumentVersion),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDocumentMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDocumentMetadataErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateDocumentMetadataErrorKind::InvalidDocument(_inner) => _inner.fmt(f),
            UpdateDocumentMetadataErrorKind::InvalidDocumentOperation(_inner) => _inner.fmt(f),
            UpdateDocumentMetadataErrorKind::InvalidDocumentVersion(_inner) => _inner.fmt(f),
            UpdateDocumentMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDocumentMetadataError {
    fn code(&self) -> Option<&str> {
        UpdateDocumentMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDocumentMetadataError {
    pub fn new(kind: UpdateDocumentMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDocumentMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDocumentMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentMetadataErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_document(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentMetadataErrorKind::InvalidDocument(_)
        )
    }
    pub fn is_invalid_document_operation(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentMetadataErrorKind::InvalidDocumentOperation(_)
        )
    }
    pub fn is_invalid_document_version(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentMetadataErrorKind::InvalidDocumentVersion(_)
        )
    }
}
impl std::error::Error for UpdateDocumentMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDocumentMetadataErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateDocumentMetadataErrorKind::InvalidDocument(_inner) => Some(_inner),
            UpdateDocumentMetadataErrorKind::InvalidDocumentOperation(_inner) => Some(_inner),
            UpdateDocumentMetadataErrorKind::InvalidDocumentVersion(_inner) => Some(_inner),
            UpdateDocumentMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMaintenanceWindowError {
    pub kind: UpdateMaintenanceWindowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMaintenanceWindowErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMaintenanceWindowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMaintenanceWindowErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            UpdateMaintenanceWindowErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateMaintenanceWindowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMaintenanceWindowError {
    fn code(&self) -> Option<&str> {
        UpdateMaintenanceWindowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMaintenanceWindowError {
    pub fn new(kind: UpdateMaintenanceWindowErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMaintenanceWindowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMaintenanceWindowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMaintenanceWindowErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMaintenanceWindowErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for UpdateMaintenanceWindowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMaintenanceWindowErrorKind::DoesNotExistError(_inner) => Some(_inner),
            UpdateMaintenanceWindowErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateMaintenanceWindowErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMaintenanceWindowTargetError {
    pub kind: UpdateMaintenanceWindowTargetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMaintenanceWindowTargetErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMaintenanceWindowTargetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMaintenanceWindowTargetErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            UpdateMaintenanceWindowTargetErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateMaintenanceWindowTargetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMaintenanceWindowTargetError {
    fn code(&self) -> Option<&str> {
        UpdateMaintenanceWindowTargetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMaintenanceWindowTargetError {
    pub fn new(kind: UpdateMaintenanceWindowTargetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMaintenanceWindowTargetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMaintenanceWindowTargetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMaintenanceWindowTargetErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMaintenanceWindowTargetErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for UpdateMaintenanceWindowTargetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMaintenanceWindowTargetErrorKind::DoesNotExistError(_inner) => Some(_inner),
            UpdateMaintenanceWindowTargetErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateMaintenanceWindowTargetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMaintenanceWindowTaskError {
    pub kind: UpdateMaintenanceWindowTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMaintenanceWindowTaskErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMaintenanceWindowTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMaintenanceWindowTaskErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            UpdateMaintenanceWindowTaskErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateMaintenanceWindowTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMaintenanceWindowTaskError {
    fn code(&self) -> Option<&str> {
        UpdateMaintenanceWindowTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMaintenanceWindowTaskError {
    pub fn new(kind: UpdateMaintenanceWindowTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMaintenanceWindowTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMaintenanceWindowTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMaintenanceWindowTaskErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMaintenanceWindowTaskErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for UpdateMaintenanceWindowTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMaintenanceWindowTaskErrorKind::DoesNotExistError(_inner) => Some(_inner),
            UpdateMaintenanceWindowTaskErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateMaintenanceWindowTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateManagedInstanceRoleError {
    pub kind: UpdateManagedInstanceRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateManagedInstanceRoleErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidInstanceId(crate::error::InvalidInstanceId),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateManagedInstanceRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateManagedInstanceRoleErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateManagedInstanceRoleErrorKind::InvalidInstanceId(_inner) => _inner.fmt(f),
            UpdateManagedInstanceRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateManagedInstanceRoleError {
    fn code(&self) -> Option<&str> {
        UpdateManagedInstanceRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateManagedInstanceRoleError {
    pub fn new(kind: UpdateManagedInstanceRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateManagedInstanceRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateManagedInstanceRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateManagedInstanceRoleErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_instance_id(&self) -> bool {
        matches!(
            &self.kind,
            UpdateManagedInstanceRoleErrorKind::InvalidInstanceId(_)
        )
    }
}
impl std::error::Error for UpdateManagedInstanceRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateManagedInstanceRoleErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateManagedInstanceRoleErrorKind::InvalidInstanceId(_inner) => Some(_inner),
            UpdateManagedInstanceRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateOpsItemError {
    pub kind: UpdateOpsItemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateOpsItemErrorKind {
    InternalServerError(crate::error::InternalServerError),
    OpsItemAlreadyExistsError(crate::error::OpsItemAlreadyExistsError),
    OpsItemInvalidParameterError(crate::error::OpsItemInvalidParameterError),
    OpsItemLimitExceededError(crate::error::OpsItemLimitExceededError),
    OpsItemNotFoundError(crate::error::OpsItemNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateOpsItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateOpsItemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateOpsItemErrorKind::OpsItemAlreadyExistsError(_inner) => _inner.fmt(f),
            UpdateOpsItemErrorKind::OpsItemInvalidParameterError(_inner) => _inner.fmt(f),
            UpdateOpsItemErrorKind::OpsItemLimitExceededError(_inner) => _inner.fmt(f),
            UpdateOpsItemErrorKind::OpsItemNotFoundError(_inner) => _inner.fmt(f),
            UpdateOpsItemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateOpsItemError {
    fn code(&self) -> Option<&str> {
        UpdateOpsItemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateOpsItemError {
    pub fn new(kind: UpdateOpsItemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateOpsItemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateOpsItemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, UpdateOpsItemErrorKind::InternalServerError(_))
    }
    pub fn is_ops_item_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpsItemErrorKind::OpsItemAlreadyExistsError(_)
        )
    }
    pub fn is_ops_item_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpsItemErrorKind::OpsItemInvalidParameterError(_)
        )
    }
    pub fn is_ops_item_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpsItemErrorKind::OpsItemLimitExceededError(_)
        )
    }
    pub fn is_ops_item_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateOpsItemErrorKind::OpsItemNotFoundError(_))
    }
}
impl std::error::Error for UpdateOpsItemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateOpsItemErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateOpsItemErrorKind::OpsItemAlreadyExistsError(_inner) => Some(_inner),
            UpdateOpsItemErrorKind::OpsItemInvalidParameterError(_inner) => Some(_inner),
            UpdateOpsItemErrorKind::OpsItemLimitExceededError(_inner) => Some(_inner),
            UpdateOpsItemErrorKind::OpsItemNotFoundError(_inner) => Some(_inner),
            UpdateOpsItemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateOpsMetadataError {
    pub kind: UpdateOpsMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateOpsMetadataErrorKind {
    InternalServerError(crate::error::InternalServerError),
    OpsMetadataInvalidArgumentError(crate::error::OpsMetadataInvalidArgumentError),
    OpsMetadataKeyLimitExceededError(crate::error::OpsMetadataKeyLimitExceededError),
    OpsMetadataNotFoundError(crate::error::OpsMetadataNotFoundError),
    OpsMetadataTooManyUpdatesError(crate::error::OpsMetadataTooManyUpdatesError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateOpsMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateOpsMetadataErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_inner) => _inner.fmt(f),
            UpdateOpsMetadataErrorKind::OpsMetadataKeyLimitExceededError(_inner) => _inner.fmt(f),
            UpdateOpsMetadataErrorKind::OpsMetadataNotFoundError(_inner) => _inner.fmt(f),
            UpdateOpsMetadataErrorKind::OpsMetadataTooManyUpdatesError(_inner) => _inner.fmt(f),
            UpdateOpsMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateOpsMetadataError {
    fn code(&self) -> Option<&str> {
        UpdateOpsMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateOpsMetadataError {
    pub fn new(kind: UpdateOpsMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateOpsMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateOpsMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpsMetadataErrorKind::InternalServerError(_)
        )
    }
    pub fn is_ops_metadata_invalid_argument_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_)
        )
    }
    pub fn is_ops_metadata_key_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpsMetadataErrorKind::OpsMetadataKeyLimitExceededError(_)
        )
    }
    pub fn is_ops_metadata_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpsMetadataErrorKind::OpsMetadataNotFoundError(_)
        )
    }
    pub fn is_ops_metadata_too_many_updates_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpsMetadataErrorKind::OpsMetadataTooManyUpdatesError(_)
        )
    }
}
impl std::error::Error for UpdateOpsMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateOpsMetadataErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(_inner) => Some(_inner),
            UpdateOpsMetadataErrorKind::OpsMetadataKeyLimitExceededError(_inner) => Some(_inner),
            UpdateOpsMetadataErrorKind::OpsMetadataNotFoundError(_inner) => Some(_inner),
            UpdateOpsMetadataErrorKind::OpsMetadataTooManyUpdatesError(_inner) => Some(_inner),
            UpdateOpsMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePatchBaselineError {
    pub kind: UpdatePatchBaselineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePatchBaselineErrorKind {
    DoesNotExistError(crate::error::DoesNotExistError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePatchBaselineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePatchBaselineErrorKind::DoesNotExistError(_inner) => _inner.fmt(f),
            UpdatePatchBaselineErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdatePatchBaselineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdatePatchBaselineError {
    fn code(&self) -> Option<&str> {
        UpdatePatchBaselineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePatchBaselineError {
    pub fn new(kind: UpdatePatchBaselineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePatchBaselineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePatchBaselineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_does_not_exist_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePatchBaselineErrorKind::DoesNotExistError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePatchBaselineErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for UpdatePatchBaselineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePatchBaselineErrorKind::DoesNotExistError(_inner) => Some(_inner),
            UpdatePatchBaselineErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdatePatchBaselineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateResourceDataSyncError {
    pub kind: UpdateResourceDataSyncErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateResourceDataSyncErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ResourceDataSyncConflictError(crate::error::ResourceDataSyncConflictError),
    ResourceDataSyncInvalidConfigurationError(
        crate::error::ResourceDataSyncInvalidConfigurationError,
    ),
    ResourceDataSyncNotFoundError(crate::error::ResourceDataSyncNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateResourceDataSyncError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateResourceDataSyncErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateResourceDataSyncErrorKind::ResourceDataSyncConflictError(_inner) => _inner.fmt(f),
            UpdateResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(_inner) => {
                _inner.fmt(f)
            }
            UpdateResourceDataSyncErrorKind::ResourceDataSyncNotFoundError(_inner) => _inner.fmt(f),
            UpdateResourceDataSyncErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateResourceDataSyncError {
    fn code(&self) -> Option<&str> {
        UpdateResourceDataSyncError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateResourceDataSyncError {
    pub fn new(kind: UpdateResourceDataSyncErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateResourceDataSyncErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateResourceDataSyncErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourceDataSyncErrorKind::InternalServerError(_)
        )
    }
    pub fn is_resource_data_sync_conflict_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourceDataSyncErrorKind::ResourceDataSyncConflictError(_)
        )
    }
    pub fn is_resource_data_sync_invalid_configuration_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(_)
        )
    }
    pub fn is_resource_data_sync_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourceDataSyncErrorKind::ResourceDataSyncNotFoundError(_)
        )
    }
}
impl std::error::Error for UpdateResourceDataSyncError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateResourceDataSyncErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateResourceDataSyncErrorKind::ResourceDataSyncConflictError(_inner) => Some(_inner),
            UpdateResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(_inner) => {
                Some(_inner)
            }
            UpdateResourceDataSyncErrorKind::ResourceDataSyncNotFoundError(_inner) => Some(_inner),
            UpdateResourceDataSyncErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServiceSettingError {
    pub kind: UpdateServiceSettingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServiceSettingErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ServiceSettingNotFound(crate::error::ServiceSettingNotFound),
    TooManyUpdates(crate::error::TooManyUpdates),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServiceSettingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServiceSettingErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateServiceSettingErrorKind::ServiceSettingNotFound(_inner) => _inner.fmt(f),
            UpdateServiceSettingErrorKind::TooManyUpdates(_inner) => _inner.fmt(f),
            UpdateServiceSettingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServiceSettingError {
    fn code(&self) -> Option<&str> {
        UpdateServiceSettingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateServiceSettingError {
    pub fn new(kind: UpdateServiceSettingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServiceSettingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServiceSettingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceSettingErrorKind::InternalServerError(_)
        )
    }
    pub fn is_service_setting_not_found(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceSettingErrorKind::ServiceSettingNotFound(_)
        )
    }
    pub fn is_too_many_updates(&self) -> bool {
        matches!(&self.kind, UpdateServiceSettingErrorKind::TooManyUpdates(_))
    }
}
impl std::error::Error for UpdateServiceSettingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServiceSettingErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateServiceSettingErrorKind::ServiceSettingNotFound(_inner) => Some(_inner),
            UpdateServiceSettingErrorKind::TooManyUpdates(_inner) => Some(_inner),
            UpdateServiceSettingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>There are concurrent updates for a resource that supports one update at a time.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyUpdates {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyUpdates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyUpdates");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyUpdates {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyUpdates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyUpdates")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyUpdates {}
/// See [`TooManyUpdates`](crate::error::TooManyUpdates)
pub mod too_many_updates {
    /// A builder for [`TooManyUpdates`](crate::error::TooManyUpdates)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyUpdates`](crate::error::TooManyUpdates)
        pub fn build(self) -> crate::error::TooManyUpdates {
            crate::error::TooManyUpdates {
                message: self.message,
            }
        }
    }
}
impl TooManyUpdates {
    /// Creates a new builder-style object to manufacture [`TooManyUpdates`](crate::error::TooManyUpdates)
    pub fn builder() -> crate::error::too_many_updates::Builder {
        crate::error::too_many_updates::Builder::default()
    }
}

/// <p>The specified service setting was not found. Either the service name or the setting has not
/// been provisioned by the AWS service team.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceSettingNotFound {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceSettingNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceSettingNotFound");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceSettingNotFound {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceSettingNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceSettingNotFound")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceSettingNotFound {}
/// See [`ServiceSettingNotFound`](crate::error::ServiceSettingNotFound)
pub mod service_setting_not_found {
    /// A builder for [`ServiceSettingNotFound`](crate::error::ServiceSettingNotFound)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceSettingNotFound`](crate::error::ServiceSettingNotFound)
        pub fn build(self) -> crate::error::ServiceSettingNotFound {
            crate::error::ServiceSettingNotFound {
                message: self.message,
            }
        }
    }
}
impl ServiceSettingNotFound {
    /// Creates a new builder-style object to manufacture [`ServiceSettingNotFound`](crate::error::ServiceSettingNotFound)
    pub fn builder() -> crate::error::service_setting_not_found::Builder {
        crate::error::service_setting_not_found::Builder::default()
    }
}

/// <p>An error occurred on the server side.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerError")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerError {}
/// See [`InternalServerError`](crate::error::InternalServerError)
pub mod internal_server_error {
    /// A builder for [`InternalServerError`](crate::error::InternalServerError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerError`](crate::error::InternalServerError)
        pub fn build(self) -> crate::error::InternalServerError {
            crate::error::InternalServerError {
                message: self.message,
            }
        }
    }
}
impl InternalServerError {
    /// Creates a new builder-style object to manufacture [`InternalServerError`](crate::error::InternalServerError)
    pub fn builder() -> crate::error::internal_server_error::Builder {
        crate::error::internal_server_error::Builder::default()
    }
}

/// <p>The specified sync name was not found.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDataSyncNotFoundError {
    #[serde(rename = "SyncName")]
    #[serde(default)]
    pub sync_name: std::option::Option<std::string::String>,
    #[serde(rename = "SyncType")]
    #[serde(default)]
    pub sync_type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceDataSyncNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDataSyncNotFoundError");
        formatter.field("sync_name", &self.sync_name);
        formatter.field("sync_type", &self.sync_type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceDataSyncNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceDataSyncNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ResourceDataSyncNotFoundError [ResourceDataSyncNotFoundException]"
        )?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceDataSyncNotFoundError {}
/// See [`ResourceDataSyncNotFoundError`](crate::error::ResourceDataSyncNotFoundError)
pub mod resource_data_sync_not_found_error {
    /// A builder for [`ResourceDataSyncNotFoundError`](crate::error::ResourceDataSyncNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sync_name: std::option::Option<std::string::String>,
        pub(crate) sync_type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn sync_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.sync_name = Some(input.into());
            self
        }
        pub fn set_sync_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sync_name = input;
            self
        }
        pub fn sync_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.sync_type = Some(input.into());
            self
        }
        pub fn set_sync_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sync_type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDataSyncNotFoundError`](crate::error::ResourceDataSyncNotFoundError)
        pub fn build(self) -> crate::error::ResourceDataSyncNotFoundError {
            crate::error::ResourceDataSyncNotFoundError {
                sync_name: self.sync_name,
                sync_type: self.sync_type,
                message: self.message,
            }
        }
    }
}
impl ResourceDataSyncNotFoundError {
    /// Creates a new builder-style object to manufacture [`ResourceDataSyncNotFoundError`](crate::error::ResourceDataSyncNotFoundError)
    pub fn builder() -> crate::error::resource_data_sync_not_found_error::Builder {
        crate::error::resource_data_sync_not_found_error::Builder::default()
    }
}

/// <p>The specified sync configuration is invalid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDataSyncInvalidConfigurationError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceDataSyncInvalidConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDataSyncInvalidConfigurationError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceDataSyncInvalidConfigurationError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceDataSyncInvalidConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceDataSyncInvalidConfigurationError [ResourceDataSyncInvalidConfigurationException]")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceDataSyncInvalidConfigurationError {}
/// See [`ResourceDataSyncInvalidConfigurationError`](crate::error::ResourceDataSyncInvalidConfigurationError)
pub mod resource_data_sync_invalid_configuration_error {
    /// A builder for [`ResourceDataSyncInvalidConfigurationError`](crate::error::ResourceDataSyncInvalidConfigurationError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDataSyncInvalidConfigurationError`](crate::error::ResourceDataSyncInvalidConfigurationError)
        pub fn build(self) -> crate::error::ResourceDataSyncInvalidConfigurationError {
            crate::error::ResourceDataSyncInvalidConfigurationError {
                message: self.message,
            }
        }
    }
}
impl ResourceDataSyncInvalidConfigurationError {
    /// Creates a new builder-style object to manufacture [`ResourceDataSyncInvalidConfigurationError`](crate::error::ResourceDataSyncInvalidConfigurationError)
    pub fn builder() -> crate::error::resource_data_sync_invalid_configuration_error::Builder {
        crate::error::resource_data_sync_invalid_configuration_error::Builder::default()
    }
}

/// <p>Another <code>UpdateResourceDataSync</code> request is being processed. Wait a few minutes
/// and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDataSyncConflictError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceDataSyncConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDataSyncConflictError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceDataSyncConflictError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceDataSyncConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ResourceDataSyncConflictError [ResourceDataSyncConflictException]"
        )?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceDataSyncConflictError {}
/// See [`ResourceDataSyncConflictError`](crate::error::ResourceDataSyncConflictError)
pub mod resource_data_sync_conflict_error {
    /// A builder for [`ResourceDataSyncConflictError`](crate::error::ResourceDataSyncConflictError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDataSyncConflictError`](crate::error::ResourceDataSyncConflictError)
        pub fn build(self) -> crate::error::ResourceDataSyncConflictError {
            crate::error::ResourceDataSyncConflictError {
                message: self.message,
            }
        }
    }
}
impl ResourceDataSyncConflictError {
    /// Creates a new builder-style object to manufacture [`ResourceDataSyncConflictError`](crate::error::ResourceDataSyncConflictError)
    pub fn builder() -> crate::error::resource_data_sync_conflict_error::Builder {
        crate::error::resource_data_sync_conflict_error::Builder::default()
    }
}

/// <p>Error returned when the ID specified for a resource, such as a maintenance window or Patch
/// baseline, doesn't exist.</p>
/// <p>For information about resource quotas in Systems Manager, see <a href="http://docs.aws.amazon.com/general/latest/gr/ssm.html#limits_ssm">Systems Manager service quotas</a> in the
/// <i>AWS General Reference</i>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DoesNotExistError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DoesNotExistError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DoesNotExistError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DoesNotExistError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DoesNotExistError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DoesNotExistError [DoesNotExistException]")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for DoesNotExistError {}
/// See [`DoesNotExistError`](crate::error::DoesNotExistError)
pub mod does_not_exist_error {
    /// A builder for [`DoesNotExistError`](crate::error::DoesNotExistError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DoesNotExistError`](crate::error::DoesNotExistError)
        pub fn build(self) -> crate::error::DoesNotExistError {
            crate::error::DoesNotExistError {
                message: self.message,
            }
        }
    }
}
impl DoesNotExistError {
    /// Creates a new builder-style object to manufacture [`DoesNotExistError`](crate::error::DoesNotExistError)
    pub fn builder() -> crate::error::does_not_exist_error::Builder {
        crate::error::does_not_exist_error::Builder::default()
    }
}

/// <p>The system is processing too many concurrent updates. Wait a few moments and try
/// again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsMetadataTooManyUpdatesError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsMetadataTooManyUpdatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsMetadataTooManyUpdatesError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OpsMetadataTooManyUpdatesError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OpsMetadataTooManyUpdatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "OpsMetadataTooManyUpdatesError [OpsMetadataTooManyUpdatesException]"
        )?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for OpsMetadataTooManyUpdatesError {}
/// See [`OpsMetadataTooManyUpdatesError`](crate::error::OpsMetadataTooManyUpdatesError)
pub mod ops_metadata_too_many_updates_error {
    /// A builder for [`OpsMetadataTooManyUpdatesError`](crate::error::OpsMetadataTooManyUpdatesError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsMetadataTooManyUpdatesError`](crate::error::OpsMetadataTooManyUpdatesError)
        pub fn build(self) -> crate::error::OpsMetadataTooManyUpdatesError {
            crate::error::OpsMetadataTooManyUpdatesError {
                message: self.message,
            }
        }
    }
}
impl OpsMetadataTooManyUpdatesError {
    /// Creates a new builder-style object to manufacture [`OpsMetadataTooManyUpdatesError`](crate::error::OpsMetadataTooManyUpdatesError)
    pub fn builder() -> crate::error::ops_metadata_too_many_updates_error::Builder {
        crate::error::ops_metadata_too_many_updates_error::Builder::default()
    }
}

/// <p>The OpsMetadata object does not exist. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsMetadataNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsMetadataNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsMetadataNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OpsMetadataNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OpsMetadataNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OpsMetadataNotFoundError [OpsMetadataNotFoundException]")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for OpsMetadataNotFoundError {}
/// See [`OpsMetadataNotFoundError`](crate::error::OpsMetadataNotFoundError)
pub mod ops_metadata_not_found_error {
    /// A builder for [`OpsMetadataNotFoundError`](crate::error::OpsMetadataNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsMetadataNotFoundError`](crate::error::OpsMetadataNotFoundError)
        pub fn build(self) -> crate::error::OpsMetadataNotFoundError {
            crate::error::OpsMetadataNotFoundError {
                message: self.message,
            }
        }
    }
}
impl OpsMetadataNotFoundError {
    /// Creates a new builder-style object to manufacture [`OpsMetadataNotFoundError`](crate::error::OpsMetadataNotFoundError)
    pub fn builder() -> crate::error::ops_metadata_not_found_error::Builder {
        crate::error::ops_metadata_not_found_error::Builder::default()
    }
}

/// <p>The OpsMetadata object exceeds the maximum number of OpsMetadata keys that you can assign to
/// an application in Application Manager.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsMetadataKeyLimitExceededError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsMetadataKeyLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsMetadataKeyLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OpsMetadataKeyLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OpsMetadataKeyLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "OpsMetadataKeyLimitExceededError [OpsMetadataKeyLimitExceededException]"
        )?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for OpsMetadataKeyLimitExceededError {}
/// See [`OpsMetadataKeyLimitExceededError`](crate::error::OpsMetadataKeyLimitExceededError)
pub mod ops_metadata_key_limit_exceeded_error {
    /// A builder for [`OpsMetadataKeyLimitExceededError`](crate::error::OpsMetadataKeyLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsMetadataKeyLimitExceededError`](crate::error::OpsMetadataKeyLimitExceededError)
        pub fn build(self) -> crate::error::OpsMetadataKeyLimitExceededError {
            crate::error::OpsMetadataKeyLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl OpsMetadataKeyLimitExceededError {
    /// Creates a new builder-style object to manufacture [`OpsMetadataKeyLimitExceededError`](crate::error::OpsMetadataKeyLimitExceededError)
    pub fn builder() -> crate::error::ops_metadata_key_limit_exceeded_error::Builder {
        crate::error::ops_metadata_key_limit_exceeded_error::Builder::default()
    }
}

/// <p>One of the arguments passed is invalid. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsMetadataInvalidArgumentError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsMetadataInvalidArgumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsMetadataInvalidArgumentError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OpsMetadataInvalidArgumentError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OpsMetadataInvalidArgumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "OpsMetadataInvalidArgumentError [OpsMetadataInvalidArgumentException]"
        )?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for OpsMetadataInvalidArgumentError {}
/// See [`OpsMetadataInvalidArgumentError`](crate::error::OpsMetadataInvalidArgumentError)
pub mod ops_metadata_invalid_argument_error {
    /// A builder for [`OpsMetadataInvalidArgumentError`](crate::error::OpsMetadataInvalidArgumentError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsMetadataInvalidArgumentError`](crate::error::OpsMetadataInvalidArgumentError)
        pub fn build(self) -> crate::error::OpsMetadataInvalidArgumentError {
            crate::error::OpsMetadataInvalidArgumentError {
                message: self.message,
            }
        }
    }
}
impl OpsMetadataInvalidArgumentError {
    /// Creates a new builder-style object to manufacture [`OpsMetadataInvalidArgumentError`](crate::error::OpsMetadataInvalidArgumentError)
    pub fn builder() -> crate::error::ops_metadata_invalid_argument_error::Builder {
        crate::error::ops_metadata_invalid_argument_error::Builder::default()
    }
}

/// <p>The specified OpsItem ID doesn't exist. Verify the ID and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemNotFoundError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsItemNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OpsItemNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OpsItemNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OpsItemNotFoundError [OpsItemNotFoundException]")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for OpsItemNotFoundError {}
/// See [`OpsItemNotFoundError`](crate::error::OpsItemNotFoundError)
pub mod ops_item_not_found_error {
    /// A builder for [`OpsItemNotFoundError`](crate::error::OpsItemNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemNotFoundError`](crate::error::OpsItemNotFoundError)
        pub fn build(self) -> crate::error::OpsItemNotFoundError {
            crate::error::OpsItemNotFoundError {
                message: self.message,
            }
        }
    }
}
impl OpsItemNotFoundError {
    /// Creates a new builder-style object to manufacture [`OpsItemNotFoundError`](crate::error::OpsItemNotFoundError)
    pub fn builder() -> crate::error::ops_item_not_found_error::Builder {
        crate::error::ops_item_not_found_error::Builder::default()
    }
}

/// <p>The request caused OpsItems to exceed one or more quotas. For information about OpsItem
/// quotas, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-learn-more.html#OpsCenter-learn-more-limits">What are the resource limits for OpsCenter?</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemLimitExceededError {
    #[serde(rename = "ResourceTypes")]
    #[serde(default)]
    pub resource_types: std::option::Option<std::vec::Vec<std::string::String>>,
    #[serde(rename = "Limit")]
    #[serde(default)]
    pub limit: i32,
    #[serde(rename = "LimitType")]
    #[serde(default)]
    pub limit_type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsItemLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemLimitExceededError");
        formatter.field("resource_types", &self.resource_types);
        formatter.field("limit", &self.limit);
        formatter.field("limit_type", &self.limit_type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OpsItemLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OpsItemLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "OpsItemLimitExceededError [OpsItemLimitExceededException]"
        )?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for OpsItemLimitExceededError {}
/// See [`OpsItemLimitExceededError`](crate::error::OpsItemLimitExceededError)
pub mod ops_item_limit_exceeded_error {
    /// A builder for [`OpsItemLimitExceededError`](crate::error::OpsItemLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) limit: std::option::Option<i32>,
        pub(crate) limit_type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn resource_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_types.unwrap_or_default();
            v.push(input.into());
            self.resource_types = Some(v);
            self
        }
        pub fn set_resource_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_types = input;
            self
        }
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        pub fn limit_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.limit_type = Some(input.into());
            self
        }
        pub fn set_limit_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.limit_type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemLimitExceededError`](crate::error::OpsItemLimitExceededError)
        pub fn build(self) -> crate::error::OpsItemLimitExceededError {
            crate::error::OpsItemLimitExceededError {
                resource_types: self.resource_types,
                limit: self.limit.unwrap_or_default(),
                limit_type: self.limit_type,
                message: self.message,
            }
        }
    }
}
impl OpsItemLimitExceededError {
    /// Creates a new builder-style object to manufacture [`OpsItemLimitExceededError`](crate::error::OpsItemLimitExceededError)
    pub fn builder() -> crate::error::ops_item_limit_exceeded_error::Builder {
        crate::error::ops_item_limit_exceeded_error::Builder::default()
    }
}

/// <p>A specified parameter argument isn't valid. Verify the available arguments and try
/// again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemInvalidParameterError {
    #[serde(rename = "ParameterNames")]
    #[serde(default)]
    pub parameter_names: std::option::Option<std::vec::Vec<std::string::String>>,
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsItemInvalidParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemInvalidParameterError");
        formatter.field("parameter_names", &self.parameter_names);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OpsItemInvalidParameterError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OpsItemInvalidParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "OpsItemInvalidParameterError [OpsItemInvalidParameterException]"
        )?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for OpsItemInvalidParameterError {}
/// See [`OpsItemInvalidParameterError`](crate::error::OpsItemInvalidParameterError)
pub mod ops_item_invalid_parameter_error {
    /// A builder for [`OpsItemInvalidParameterError`](crate::error::OpsItemInvalidParameterError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn parameter_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.parameter_names.unwrap_or_default();
            v.push(input.into());
            self.parameter_names = Some(v);
            self
        }
        pub fn set_parameter_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.parameter_names = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemInvalidParameterError`](crate::error::OpsItemInvalidParameterError)
        pub fn build(self) -> crate::error::OpsItemInvalidParameterError {
            crate::error::OpsItemInvalidParameterError {
                parameter_names: self.parameter_names,
                message: self.message,
            }
        }
    }
}
impl OpsItemInvalidParameterError {
    /// Creates a new builder-style object to manufacture [`OpsItemInvalidParameterError`](crate::error::OpsItemInvalidParameterError)
    pub fn builder() -> crate::error::ops_item_invalid_parameter_error::Builder {
        crate::error::ops_item_invalid_parameter_error::Builder::default()
    }
}

/// <p>The OpsItem already exists.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemAlreadyExistsError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
    #[serde(rename = "OpsItemId")]
    #[serde(default)]
    pub ops_item_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsItemAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemAlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.finish()
    }
}
impl OpsItemAlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OpsItemAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "OpsItemAlreadyExistsError [OpsItemAlreadyExistsException]"
        )?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for OpsItemAlreadyExistsError {}
/// See [`OpsItemAlreadyExistsError`](crate::error::OpsItemAlreadyExistsError)
pub mod ops_item_already_exists_error {
    /// A builder for [`OpsItemAlreadyExistsError`](crate::error::OpsItemAlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) ops_item_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn ops_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ops_item_id = Some(input.into());
            self
        }
        pub fn set_ops_item_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ops_item_id = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemAlreadyExistsError`](crate::error::OpsItemAlreadyExistsError)
        pub fn build(self) -> crate::error::OpsItemAlreadyExistsError {
            crate::error::OpsItemAlreadyExistsError {
                message: self.message,
                ops_item_id: self.ops_item_id,
            }
        }
    }
}
impl OpsItemAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`OpsItemAlreadyExistsError`](crate::error::OpsItemAlreadyExistsError)
    pub fn builder() -> crate::error::ops_item_already_exists_error::Builder {
        crate::error::ops_item_already_exists_error::Builder::default()
    }
}

/// <p>The following problems can cause this exception:</p>
/// <p>You do not have permission to access the instance.</p>
/// <p>SSM Agent is not running. Verify that SSM Agent is running.</p>
/// <p>SSM Agent is not registered with the SSM endpoint. Try reinstalling SSM Agent.</p>
/// <p>The instance is not in valid state. Valid states are: Running, Pending, Stopped, Stopping.
/// Invalid states are: Shutting-down and Terminated.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInstanceId {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidInstanceId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInstanceId");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidInstanceId {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInstanceId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInstanceId")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInstanceId {}
/// See [`InvalidInstanceId`](crate::error::InvalidInstanceId)
pub mod invalid_instance_id {
    /// A builder for [`InvalidInstanceId`](crate::error::InvalidInstanceId)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInstanceId`](crate::error::InvalidInstanceId)
        pub fn build(self) -> crate::error::InvalidInstanceId {
            crate::error::InvalidInstanceId {
                message: self.message,
            }
        }
    }
}
impl InvalidInstanceId {
    /// Creates a new builder-style object to manufacture [`InvalidInstanceId`](crate::error::InvalidInstanceId)
    pub fn builder() -> crate::error::invalid_instance_id::Builder {
        crate::error::invalid_instance_id::Builder::default()
    }
}

/// <p>The document version is not valid or does not exist.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDocumentVersion {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDocumentVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDocumentVersion");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDocumentVersion {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDocumentVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDocumentVersion")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDocumentVersion {}
/// See [`InvalidDocumentVersion`](crate::error::InvalidDocumentVersion)
pub mod invalid_document_version {
    /// A builder for [`InvalidDocumentVersion`](crate::error::InvalidDocumentVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDocumentVersion`](crate::error::InvalidDocumentVersion)
        pub fn build(self) -> crate::error::InvalidDocumentVersion {
            crate::error::InvalidDocumentVersion {
                message: self.message,
            }
        }
    }
}
impl InvalidDocumentVersion {
    /// Creates a new builder-style object to manufacture [`InvalidDocumentVersion`](crate::error::InvalidDocumentVersion)
    pub fn builder() -> crate::error::invalid_document_version::Builder {
        crate::error::invalid_document_version::Builder::default()
    }
}

/// <p>You attempted to delete a document while it is still shared. You must stop sharing the
/// document before you can delete it.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDocumentOperation {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDocumentOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDocumentOperation");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDocumentOperation {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDocumentOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDocumentOperation")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDocumentOperation {}
/// See [`InvalidDocumentOperation`](crate::error::InvalidDocumentOperation)
pub mod invalid_document_operation {
    /// A builder for [`InvalidDocumentOperation`](crate::error::InvalidDocumentOperation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDocumentOperation`](crate::error::InvalidDocumentOperation)
        pub fn build(self) -> crate::error::InvalidDocumentOperation {
            crate::error::InvalidDocumentOperation {
                message: self.message,
            }
        }
    }
}
impl InvalidDocumentOperation {
    /// Creates a new builder-style object to manufacture [`InvalidDocumentOperation`](crate::error::InvalidDocumentOperation)
    pub fn builder() -> crate::error::invalid_document_operation::Builder {
        crate::error::invalid_document_operation::Builder::default()
    }
}

/// <p>The specified document does not exist.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDocument {
    /// <p>The document does not exist or the document is not available to the user. This exception can
    /// be issued by CreateAssociation, CreateAssociationBatch, DeleteAssociation, DeleteDocument,
    /// DescribeAssociation, DescribeDocument, GetDocument, SendCommand, or UpdateAssociationStatus.
    /// </p>
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDocument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDocument");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDocument {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDocument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDocument")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDocument {}
/// See [`InvalidDocument`](crate::error::InvalidDocument)
pub mod invalid_document {
    /// A builder for [`InvalidDocument`](crate::error::InvalidDocument)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The document does not exist or the document is not available to the user. This exception can
        /// be issued by CreateAssociation, CreateAssociationBatch, DeleteAssociation, DeleteDocument,
        /// DescribeAssociation, DescribeDocument, GetDocument, SendCommand, or UpdateAssociationStatus.
        /// </p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDocument`](crate::error::InvalidDocument)
        pub fn build(self) -> crate::error::InvalidDocument {
            crate::error::InvalidDocument {
                message: self.message,
            }
        }
    }
}
impl InvalidDocument {
    /// Creates a new builder-style object to manufacture [`InvalidDocument`](crate::error::InvalidDocument)
    pub fn builder() -> crate::error::invalid_document::Builder {
        crate::error::invalid_document::Builder::default()
    }
}

/// <p>The version of the document schema is not supported.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDocumentSchemaVersion {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDocumentSchemaVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDocumentSchemaVersion");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDocumentSchemaVersion {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDocumentSchemaVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDocumentSchemaVersion")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDocumentSchemaVersion {}
/// See [`InvalidDocumentSchemaVersion`](crate::error::InvalidDocumentSchemaVersion)
pub mod invalid_document_schema_version {
    /// A builder for [`InvalidDocumentSchemaVersion`](crate::error::InvalidDocumentSchemaVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDocumentSchemaVersion`](crate::error::InvalidDocumentSchemaVersion)
        pub fn build(self) -> crate::error::InvalidDocumentSchemaVersion {
            crate::error::InvalidDocumentSchemaVersion {
                message: self.message,
            }
        }
    }
}
impl InvalidDocumentSchemaVersion {
    /// Creates a new builder-style object to manufacture [`InvalidDocumentSchemaVersion`](crate::error::InvalidDocumentSchemaVersion)
    pub fn builder() -> crate::error::invalid_document_schema_version::Builder {
        crate::error::invalid_document_schema_version::Builder::default()
    }
}

/// <p>The size limit of a document is 64 KB.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaxDocumentSizeExceeded {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaxDocumentSizeExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaxDocumentSizeExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaxDocumentSizeExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaxDocumentSizeExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaxDocumentSizeExceeded")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaxDocumentSizeExceeded {}
/// See [`MaxDocumentSizeExceeded`](crate::error::MaxDocumentSizeExceeded)
pub mod max_document_size_exceeded {
    /// A builder for [`MaxDocumentSizeExceeded`](crate::error::MaxDocumentSizeExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaxDocumentSizeExceeded`](crate::error::MaxDocumentSizeExceeded)
        pub fn build(self) -> crate::error::MaxDocumentSizeExceeded {
            crate::error::MaxDocumentSizeExceeded {
                message: self.message,
            }
        }
    }
}
impl MaxDocumentSizeExceeded {
    /// Creates a new builder-style object to manufacture [`MaxDocumentSizeExceeded`](crate::error::MaxDocumentSizeExceeded)
    pub fn builder() -> crate::error::max_document_size_exceeded::Builder {
        crate::error::max_document_size_exceeded::Builder::default()
    }
}

/// <p>The content for the document is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDocumentContent {
    /// <p>A description of the validation error.</p>
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDocumentContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDocumentContent");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDocumentContent {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDocumentContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDocumentContent")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDocumentContent {}
/// See [`InvalidDocumentContent`](crate::error::InvalidDocumentContent)
pub mod invalid_document_content {
    /// A builder for [`InvalidDocumentContent`](crate::error::InvalidDocumentContent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description of the validation error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDocumentContent`](crate::error::InvalidDocumentContent)
        pub fn build(self) -> crate::error::InvalidDocumentContent {
            crate::error::InvalidDocumentContent {
                message: self.message,
            }
        }
    }
}
impl InvalidDocumentContent {
    /// Creates a new builder-style object to manufacture [`InvalidDocumentContent`](crate::error::InvalidDocumentContent)
    pub fn builder() -> crate::error::invalid_document_content::Builder {
        crate::error::invalid_document_content::Builder::default()
    }
}

/// <p>The version name has already been used in this document. Specify a different version name,
/// and then try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DuplicateDocumentVersionName {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DuplicateDocumentVersionName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DuplicateDocumentVersionName");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DuplicateDocumentVersionName {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateDocumentVersionName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateDocumentVersionName")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateDocumentVersionName {}
/// See [`DuplicateDocumentVersionName`](crate::error::DuplicateDocumentVersionName)
pub mod duplicate_document_version_name {
    /// A builder for [`DuplicateDocumentVersionName`](crate::error::DuplicateDocumentVersionName)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateDocumentVersionName`](crate::error::DuplicateDocumentVersionName)
        pub fn build(self) -> crate::error::DuplicateDocumentVersionName {
            crate::error::DuplicateDocumentVersionName {
                message: self.message,
            }
        }
    }
}
impl DuplicateDocumentVersionName {
    /// Creates a new builder-style object to manufacture [`DuplicateDocumentVersionName`](crate::error::DuplicateDocumentVersionName)
    pub fn builder() -> crate::error::duplicate_document_version_name::Builder {
        crate::error::duplicate_document_version_name::Builder::default()
    }
}

/// <p>The content of the association document matches another document. Change the content of the
/// document and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DuplicateDocumentContent {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DuplicateDocumentContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DuplicateDocumentContent");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DuplicateDocumentContent {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateDocumentContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateDocumentContent")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateDocumentContent {}
/// See [`DuplicateDocumentContent`](crate::error::DuplicateDocumentContent)
pub mod duplicate_document_content {
    /// A builder for [`DuplicateDocumentContent`](crate::error::DuplicateDocumentContent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateDocumentContent`](crate::error::DuplicateDocumentContent)
        pub fn build(self) -> crate::error::DuplicateDocumentContent {
            crate::error::DuplicateDocumentContent {
                message: self.message,
            }
        }
    }
}
impl DuplicateDocumentContent {
    /// Creates a new builder-style object to manufacture [`DuplicateDocumentContent`](crate::error::DuplicateDocumentContent)
    pub fn builder() -> crate::error::duplicate_document_content::Builder {
        crate::error::duplicate_document_content::Builder::default()
    }
}

/// <p>The document has too many versions. Delete one or more document versions and try
/// again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentVersionLimitExceeded {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DocumentVersionLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentVersionLimitExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DocumentVersionLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DocumentVersionLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DocumentVersionLimitExceeded")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for DocumentVersionLimitExceeded {}
/// See [`DocumentVersionLimitExceeded`](crate::error::DocumentVersionLimitExceeded)
pub mod document_version_limit_exceeded {
    /// A builder for [`DocumentVersionLimitExceeded`](crate::error::DocumentVersionLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentVersionLimitExceeded`](crate::error::DocumentVersionLimitExceeded)
        pub fn build(self) -> crate::error::DocumentVersionLimitExceeded {
            crate::error::DocumentVersionLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl DocumentVersionLimitExceeded {
    /// Creates a new builder-style object to manufacture [`DocumentVersionLimitExceeded`](crate::error::DocumentVersionLimitExceeded)
    pub fn builder() -> crate::error::document_version_limit_exceeded::Builder {
        crate::error::document_version_limit_exceeded::Builder::default()
    }
}

/// <p>The updated status is the same as the current status.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StatusUnchanged {}
impl std::fmt::Debug for StatusUnchanged {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StatusUnchanged");
        formatter.finish()
    }
}
impl StatusUnchanged {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for StatusUnchanged {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StatusUnchanged")?;
        Ok(())
    }
}
impl std::error::Error for StatusUnchanged {}
/// See [`StatusUnchanged`](crate::error::StatusUnchanged)
pub mod status_unchanged {
    /// A builder for [`StatusUnchanged`](crate::error::StatusUnchanged)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`StatusUnchanged`](crate::error::StatusUnchanged)
        pub fn build(self) -> crate::error::StatusUnchanged {
            crate::error::StatusUnchanged {}
        }
    }
}
impl StatusUnchanged {
    /// Creates a new builder-style object to manufacture [`StatusUnchanged`](crate::error::StatusUnchanged)
    pub fn builder() -> crate::error::status_unchanged::Builder {
        crate::error::status_unchanged::Builder::default()
    }
}

/// <p>The specified association does not exist.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationDoesNotExist {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociationDoesNotExist {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationDoesNotExist");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AssociationDoesNotExist {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AssociationDoesNotExist {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AssociationDoesNotExist")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for AssociationDoesNotExist {}
/// See [`AssociationDoesNotExist`](crate::error::AssociationDoesNotExist)
pub mod association_does_not_exist {
    /// A builder for [`AssociationDoesNotExist`](crate::error::AssociationDoesNotExist)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationDoesNotExist`](crate::error::AssociationDoesNotExist)
        pub fn build(self) -> crate::error::AssociationDoesNotExist {
            crate::error::AssociationDoesNotExist {
                message: self.message,
            }
        }
    }
}
impl AssociationDoesNotExist {
    /// Creates a new builder-style object to manufacture [`AssociationDoesNotExist`](crate::error::AssociationDoesNotExist)
    pub fn builder() -> crate::error::association_does_not_exist::Builder {
        crate::error::association_does_not_exist::Builder::default()
    }
}

/// <p>The update is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidUpdate {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidUpdate");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidUpdate {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidUpdate")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidUpdate {}
/// See [`InvalidUpdate`](crate::error::InvalidUpdate)
pub mod invalid_update {
    /// A builder for [`InvalidUpdate`](crate::error::InvalidUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidUpdate`](crate::error::InvalidUpdate)
        pub fn build(self) -> crate::error::InvalidUpdate {
            crate::error::InvalidUpdate {
                message: self.message,
            }
        }
    }
}
impl InvalidUpdate {
    /// Creates a new builder-style object to manufacture [`InvalidUpdate`](crate::error::InvalidUpdate)
    pub fn builder() -> crate::error::invalid_update::Builder {
        crate::error::invalid_update::Builder::default()
    }
}

/// <p>The target is not valid or does not exist. It might not be configured for Systems Manager or you might
/// not have permission to perform the operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTarget {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTarget");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTarget {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTarget")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTarget {}
/// See [`InvalidTarget`](crate::error::InvalidTarget)
pub mod invalid_target {
    /// A builder for [`InvalidTarget`](crate::error::InvalidTarget)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTarget`](crate::error::InvalidTarget)
        pub fn build(self) -> crate::error::InvalidTarget {
            crate::error::InvalidTarget {
                message: self.message,
            }
        }
    }
}
impl InvalidTarget {
    /// Creates a new builder-style object to manufacture [`InvalidTarget`](crate::error::InvalidTarget)
    pub fn builder() -> crate::error::invalid_target::Builder {
        crate::error::invalid_target::Builder::default()
    }
}

/// <p>The schedule is invalid. Verify your cron or rate expression and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSchedule {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSchedule");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSchedule {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSchedule")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSchedule {}
/// See [`InvalidSchedule`](crate::error::InvalidSchedule)
pub mod invalid_schedule {
    /// A builder for [`InvalidSchedule`](crate::error::InvalidSchedule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSchedule`](crate::error::InvalidSchedule)
        pub fn build(self) -> crate::error::InvalidSchedule {
            crate::error::InvalidSchedule {
                message: self.message,
            }
        }
    }
}
impl InvalidSchedule {
    /// Creates a new builder-style object to manufacture [`InvalidSchedule`](crate::error::InvalidSchedule)
    pub fn builder() -> crate::error::invalid_schedule::Builder {
        crate::error::invalid_schedule::Builder::default()
    }
}

/// <p>You must specify values for all required parameters in the Systems Manager document. You can only
/// supply values to parameters defined in the Systems Manager document.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameters {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameters");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameters {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameters")?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameters {}
/// See [`InvalidParameters`](crate::error::InvalidParameters)
pub mod invalid_parameters {
    /// A builder for [`InvalidParameters`](crate::error::InvalidParameters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameters`](crate::error::InvalidParameters)
        pub fn build(self) -> crate::error::InvalidParameters {
            crate::error::InvalidParameters {
                message: self.message,
            }
        }
    }
}
impl InvalidParameters {
    /// Creates a new builder-style object to manufacture [`InvalidParameters`](crate::error::InvalidParameters)
    pub fn builder() -> crate::error::invalid_parameters::Builder {
        crate::error::invalid_parameters::Builder::default()
    }
}

/// <p>The output location is not valid or does not exist.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOutputLocation {}
impl std::fmt::Debug for InvalidOutputLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOutputLocation");
        formatter.finish()
    }
}
impl InvalidOutputLocation {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for InvalidOutputLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOutputLocation")?;
        Ok(())
    }
}
impl std::error::Error for InvalidOutputLocation {}
/// See [`InvalidOutputLocation`](crate::error::InvalidOutputLocation)
pub mod invalid_output_location {
    /// A builder for [`InvalidOutputLocation`](crate::error::InvalidOutputLocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`InvalidOutputLocation`](crate::error::InvalidOutputLocation)
        pub fn build(self) -> crate::error::InvalidOutputLocation {
            crate::error::InvalidOutputLocation {}
        }
    }
}
impl InvalidOutputLocation {
    /// Creates a new builder-style object to manufacture [`InvalidOutputLocation`](crate::error::InvalidOutputLocation)
    pub fn builder() -> crate::error::invalid_output_location::Builder {
        crate::error::invalid_output_location::Builder::default()
    }
}

/// <p>The version you specified is not valid. Use ListAssociationVersions to view all versions of
/// an association according to the association ID. Or, use the <code>$LATEST</code> parameter to
/// view the latest version of the association.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAssociationVersion {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAssociationVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAssociationVersion");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAssociationVersion {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAssociationVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAssociationVersion")?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAssociationVersion {}
/// See [`InvalidAssociationVersion`](crate::error::InvalidAssociationVersion)
pub mod invalid_association_version {
    /// A builder for [`InvalidAssociationVersion`](crate::error::InvalidAssociationVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAssociationVersion`](crate::error::InvalidAssociationVersion)
        pub fn build(self) -> crate::error::InvalidAssociationVersion {
            crate::error::InvalidAssociationVersion {
                message: self.message,
            }
        }
    }
}
impl InvalidAssociationVersion {
    /// Creates a new builder-style object to manufacture [`InvalidAssociationVersion`](crate::error::InvalidAssociationVersion)
    pub fn builder() -> crate::error::invalid_association_version::Builder {
        crate::error::invalid_association_version::Builder::default()
    }
}

/// <p>You have reached the maximum number versions allowed for an association. Each association
/// has a limit of 1,000 versions. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationVersionLimitExceeded {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociationVersionLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationVersionLimitExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AssociationVersionLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AssociationVersionLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AssociationVersionLimitExceeded")?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl std::error::Error for AssociationVersionLimitExceeded {}
/// See [`AssociationVersionLimitExceeded`](crate::error::AssociationVersionLimitExceeded)
pub mod association_version_limit_exceeded {
    /// A builder for [`AssociationVersionLimitExceeded`](crate::error::AssociationVersionLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationVersionLimitExceeded`](crate::error::AssociationVersionLimitExceeded)
        pub fn build(self) -> crate::error::AssociationVersionLimitExceeded {
            crate::error::AssociationVersionLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl AssociationVersionLimitExceeded {
    /// Creates a new builder-style object to manufacture [`AssociationVersionLimitExceeded`](crate::error::AssociationVersionLimitExceeded)
    pub fn builder() -> crate::error::association_version_limit_exceeded::Builder {
        crate::error::association_version_limit_exceeded::Builder::default()
    }
}

/// <p>The specified parameter version was not found. Verify the parameter name and version, and
/// try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterVersionNotFound {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParameterVersionNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterVersionNotFound");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ParameterVersionNotFound {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParameterVersionNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParameterVersionNotFound")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl std::error::Error for ParameterVersionNotFound {}
/// See [`ParameterVersionNotFound`](crate::error::ParameterVersionNotFound)
pub mod parameter_version_not_found {
    /// A builder for [`ParameterVersionNotFound`](crate::error::ParameterVersionNotFound)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterVersionNotFound`](crate::error::ParameterVersionNotFound)
        pub fn build(self) -> crate::error::ParameterVersionNotFound {
            crate::error::ParameterVersionNotFound {
                message: self.message,
            }
        }
    }
}
impl ParameterVersionNotFound {
    /// Creates a new builder-style object to manufacture [`ParameterVersionNotFound`](crate::error::ParameterVersionNotFound)
    pub fn builder() -> crate::error::parameter_version_not_found::Builder {
        crate::error::parameter_version_not_found::Builder::default()
    }
}

/// <p>The parameter could not be found. Verify the name and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterNotFound {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParameterNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterNotFound");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ParameterNotFound {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParameterNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParameterNotFound")?;
        if let Some(inner_34) = &self.message {
            write!(f, ": {}", inner_34)?;
        }
        Ok(())
    }
}
impl std::error::Error for ParameterNotFound {}
/// See [`ParameterNotFound`](crate::error::ParameterNotFound)
pub mod parameter_not_found {
    /// A builder for [`ParameterNotFound`](crate::error::ParameterNotFound)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterNotFound`](crate::error::ParameterNotFound)
        pub fn build(self) -> crate::error::ParameterNotFound {
            crate::error::ParameterNotFound {
                message: self.message,
            }
        }
    }
}
impl ParameterNotFound {
    /// Creates a new builder-style object to manufacture [`ParameterNotFound`](crate::error::ParameterNotFound)
    pub fn builder() -> crate::error::parameter_not_found::Builder {
        crate::error::parameter_not_found::Builder::default()
    }
}

/// <p>The specified update status operation is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAutomationStatusUpdateError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAutomationStatusUpdateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAutomationStatusUpdateError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAutomationStatusUpdateError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAutomationStatusUpdateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidAutomationStatusUpdateError [InvalidAutomationStatusUpdateException]"
        )?;
        if let Some(inner_35) = &self.message {
            write!(f, ": {}", inner_35)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAutomationStatusUpdateError {}
/// See [`InvalidAutomationStatusUpdateError`](crate::error::InvalidAutomationStatusUpdateError)
pub mod invalid_automation_status_update_error {
    /// A builder for [`InvalidAutomationStatusUpdateError`](crate::error::InvalidAutomationStatusUpdateError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAutomationStatusUpdateError`](crate::error::InvalidAutomationStatusUpdateError)
        pub fn build(self) -> crate::error::InvalidAutomationStatusUpdateError {
            crate::error::InvalidAutomationStatusUpdateError {
                message: self.message,
            }
        }
    }
}
impl InvalidAutomationStatusUpdateError {
    /// Creates a new builder-style object to manufacture [`InvalidAutomationStatusUpdateError`](crate::error::InvalidAutomationStatusUpdateError)
    pub fn builder() -> crate::error::invalid_automation_status_update_error::Builder {
        crate::error::invalid_automation_status_update_error::Builder::default()
    }
}

/// <p>There is no automation execution information for the requested automation execution
/// ID.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutomationExecutionNotFoundError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutomationExecutionNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutomationExecutionNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AutomationExecutionNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AutomationExecutionNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "AutomationExecutionNotFoundError [AutomationExecutionNotFoundException]"
        )?;
        if let Some(inner_36) = &self.message {
            write!(f, ": {}", inner_36)?;
        }
        Ok(())
    }
}
impl std::error::Error for AutomationExecutionNotFoundError {}
/// See [`AutomationExecutionNotFoundError`](crate::error::AutomationExecutionNotFoundError)
pub mod automation_execution_not_found_error {
    /// A builder for [`AutomationExecutionNotFoundError`](crate::error::AutomationExecutionNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AutomationExecutionNotFoundError`](crate::error::AutomationExecutionNotFoundError)
        pub fn build(self) -> crate::error::AutomationExecutionNotFoundError {
            crate::error::AutomationExecutionNotFoundError {
                message: self.message,
            }
        }
    }
}
impl AutomationExecutionNotFoundError {
    /// Creates a new builder-style object to manufacture [`AutomationExecutionNotFoundError`](crate::error::AutomationExecutionNotFoundError)
    pub fn builder() -> crate::error::automation_execution_not_found_error::Builder {
        crate::error::automation_execution_not_found_error::Builder::default()
    }
}

/// <p>The specified target instance for the session is not fully configured for use with Session Manager.
/// For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-getting-started.html">Getting started with
/// Session Manager</a> in the <i>AWS Systems Manager User Guide</i>. This error is also returned if you
/// attempt to start a session on an instance that is located in a different account or Region</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetNotConnected {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetNotConnected {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetNotConnected");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TargetNotConnected {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TargetNotConnected {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TargetNotConnected")?;
        if let Some(inner_37) = &self.message {
            write!(f, ": {}", inner_37)?;
        }
        Ok(())
    }
}
impl std::error::Error for TargetNotConnected {}
/// See [`TargetNotConnected`](crate::error::TargetNotConnected)
pub mod target_not_connected {
    /// A builder for [`TargetNotConnected`](crate::error::TargetNotConnected)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetNotConnected`](crate::error::TargetNotConnected)
        pub fn build(self) -> crate::error::TargetNotConnected {
            crate::error::TargetNotConnected {
                message: self.message,
            }
        }
    }
}
impl TargetNotConnected {
    /// Creates a new builder-style object to manufacture [`TargetNotConnected`](crate::error::TargetNotConnected)
    pub fn builder() -> crate::error::target_not_connected::Builder {
        crate::error::target_not_connected::Builder::default()
    }
}

/// <p>The supplied parameters for invoking the specified Automation document are incorrect. For
/// example, they may not match the set of parameters permitted for the specified Automation
/// document.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAutomationExecutionParametersError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAutomationExecutionParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAutomationExecutionParametersError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAutomationExecutionParametersError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAutomationExecutionParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAutomationExecutionParametersError [InvalidAutomationExecutionParametersException]")?;
        if let Some(inner_38) = &self.message {
            write!(f, ": {}", inner_38)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAutomationExecutionParametersError {}
/// See [`InvalidAutomationExecutionParametersError`](crate::error::InvalidAutomationExecutionParametersError)
pub mod invalid_automation_execution_parameters_error {
    /// A builder for [`InvalidAutomationExecutionParametersError`](crate::error::InvalidAutomationExecutionParametersError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAutomationExecutionParametersError`](crate::error::InvalidAutomationExecutionParametersError)
        pub fn build(self) -> crate::error::InvalidAutomationExecutionParametersError {
            crate::error::InvalidAutomationExecutionParametersError {
                message: self.message,
            }
        }
    }
}
impl InvalidAutomationExecutionParametersError {
    /// Creates a new builder-style object to manufacture [`InvalidAutomationExecutionParametersError`](crate::error::InvalidAutomationExecutionParametersError)
    pub fn builder() -> crate::error::invalid_automation_execution_parameters_error::Builder {
        crate::error::invalid_automation_execution_parameters_error::Builder::default()
    }
}

/// <p>Error returned when an idempotent operation is retried and the parameters don't match the
/// original call to the API with the same idempotency token. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct IdempotentParameterMismatch {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IdempotentParameterMismatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IdempotentParameterMismatch");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IdempotentParameterMismatch {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IdempotentParameterMismatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IdempotentParameterMismatch")?;
        if let Some(inner_39) = &self.message {
            write!(f, ": {}", inner_39)?;
        }
        Ok(())
    }
}
impl std::error::Error for IdempotentParameterMismatch {}
/// See [`IdempotentParameterMismatch`](crate::error::IdempotentParameterMismatch)
pub mod idempotent_parameter_mismatch {
    /// A builder for [`IdempotentParameterMismatch`](crate::error::IdempotentParameterMismatch)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IdempotentParameterMismatch`](crate::error::IdempotentParameterMismatch)
        pub fn build(self) -> crate::error::IdempotentParameterMismatch {
            crate::error::IdempotentParameterMismatch {
                message: self.message,
            }
        }
    }
}
impl IdempotentParameterMismatch {
    /// Creates a new builder-style object to manufacture [`IdempotentParameterMismatch`](crate::error::IdempotentParameterMismatch)
    pub fn builder() -> crate::error::idempotent_parameter_mismatch::Builder {
        crate::error::idempotent_parameter_mismatch::Builder::default()
    }
}

/// <p>The number of simultaneously running Automation executions exceeded the allowable
/// limit.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutomationExecutionLimitExceededError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutomationExecutionLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutomationExecutionLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AutomationExecutionLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AutomationExecutionLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "AutomationExecutionLimitExceededError [AutomationExecutionLimitExceededException]"
        )?;
        if let Some(inner_40) = &self.message {
            write!(f, ": {}", inner_40)?;
        }
        Ok(())
    }
}
impl std::error::Error for AutomationExecutionLimitExceededError {}
/// See [`AutomationExecutionLimitExceededError`](crate::error::AutomationExecutionLimitExceededError)
pub mod automation_execution_limit_exceeded_error {
    /// A builder for [`AutomationExecutionLimitExceededError`](crate::error::AutomationExecutionLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AutomationExecutionLimitExceededError`](crate::error::AutomationExecutionLimitExceededError)
        pub fn build(self) -> crate::error::AutomationExecutionLimitExceededError {
            crate::error::AutomationExecutionLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl AutomationExecutionLimitExceededError {
    /// Creates a new builder-style object to manufacture [`AutomationExecutionLimitExceededError`](crate::error::AutomationExecutionLimitExceededError)
    pub fn builder() -> crate::error::automation_execution_limit_exceeded_error::Builder {
        crate::error::automation_execution_limit_exceeded_error::Builder::default()
    }
}

/// <p>An Automation document with the specified name and version could not be found.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutomationDefinitionVersionNotFoundError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutomationDefinitionVersionNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutomationDefinitionVersionNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AutomationDefinitionVersionNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AutomationDefinitionVersionNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AutomationDefinitionVersionNotFoundError [AutomationDefinitionVersionNotFoundException]")?;
        if let Some(inner_41) = &self.message {
            write!(f, ": {}", inner_41)?;
        }
        Ok(())
    }
}
impl std::error::Error for AutomationDefinitionVersionNotFoundError {}
/// See [`AutomationDefinitionVersionNotFoundError`](crate::error::AutomationDefinitionVersionNotFoundError)
pub mod automation_definition_version_not_found_error {
    /// A builder for [`AutomationDefinitionVersionNotFoundError`](crate::error::AutomationDefinitionVersionNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AutomationDefinitionVersionNotFoundError`](crate::error::AutomationDefinitionVersionNotFoundError)
        pub fn build(self) -> crate::error::AutomationDefinitionVersionNotFoundError {
            crate::error::AutomationDefinitionVersionNotFoundError {
                message: self.message,
            }
        }
    }
}
impl AutomationDefinitionVersionNotFoundError {
    /// Creates a new builder-style object to manufacture [`AutomationDefinitionVersionNotFoundError`](crate::error::AutomationDefinitionVersionNotFoundError)
    pub fn builder() -> crate::error::automation_definition_version_not_found_error::Builder {
        crate::error::automation_definition_version_not_found_error::Builder::default()
    }
}

/// <p>An Automation document with the specified name could not be found.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutomationDefinitionNotFoundError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutomationDefinitionNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutomationDefinitionNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AutomationDefinitionNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AutomationDefinitionNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "AutomationDefinitionNotFoundError [AutomationDefinitionNotFoundException]"
        )?;
        if let Some(inner_42) = &self.message {
            write!(f, ": {}", inner_42)?;
        }
        Ok(())
    }
}
impl std::error::Error for AutomationDefinitionNotFoundError {}
/// See [`AutomationDefinitionNotFoundError`](crate::error::AutomationDefinitionNotFoundError)
pub mod automation_definition_not_found_error {
    /// A builder for [`AutomationDefinitionNotFoundError`](crate::error::AutomationDefinitionNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AutomationDefinitionNotFoundError`](crate::error::AutomationDefinitionNotFoundError)
        pub fn build(self) -> crate::error::AutomationDefinitionNotFoundError {
            crate::error::AutomationDefinitionNotFoundError {
                message: self.message,
            }
        }
    }
}
impl AutomationDefinitionNotFoundError {
    /// Creates a new builder-style object to manufacture [`AutomationDefinitionNotFoundError`](crate::error::AutomationDefinitionNotFoundError)
    pub fn builder() -> crate::error::automation_definition_not_found_error::Builder {
        crate::error::automation_definition_not_found_error::Builder::default()
    }
}

/// <p>Indicates that the Change Manager change template used in the change request was rejected or is
/// still in a pending state.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutomationDefinitionNotApprovedError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutomationDefinitionNotApprovedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutomationDefinitionNotApprovedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AutomationDefinitionNotApprovedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AutomationDefinitionNotApprovedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "AutomationDefinitionNotApprovedError [AutomationDefinitionNotApprovedException]"
        )?;
        if let Some(inner_43) = &self.message {
            write!(f, ": {}", inner_43)?;
        }
        Ok(())
    }
}
impl std::error::Error for AutomationDefinitionNotApprovedError {}
/// See [`AutomationDefinitionNotApprovedError`](crate::error::AutomationDefinitionNotApprovedError)
pub mod automation_definition_not_approved_error {
    /// A builder for [`AutomationDefinitionNotApprovedError`](crate::error::AutomationDefinitionNotApprovedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AutomationDefinitionNotApprovedError`](crate::error::AutomationDefinitionNotApprovedError)
        pub fn build(self) -> crate::error::AutomationDefinitionNotApprovedError {
            crate::error::AutomationDefinitionNotApprovedError {
                message: self.message,
            }
        }
    }
}
impl AutomationDefinitionNotApprovedError {
    /// Creates a new builder-style object to manufacture [`AutomationDefinitionNotApprovedError`](crate::error::AutomationDefinitionNotApprovedError)
    pub fn builder() -> crate::error::automation_definition_not_approved_error::Builder {
        crate::error::automation_definition_not_approved_error::Builder::default()
    }
}

/// <p>The association is not valid or does not exist. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAssociation {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAssociation");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAssociation {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAssociation")?;
        if let Some(inner_44) = &self.message {
            write!(f, ": {}", inner_44)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAssociation {}
/// See [`InvalidAssociation`](crate::error::InvalidAssociation)
pub mod invalid_association {
    /// A builder for [`InvalidAssociation`](crate::error::InvalidAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAssociation`](crate::error::InvalidAssociation)
        pub fn build(self) -> crate::error::InvalidAssociation {
            crate::error::InvalidAssociation {
                message: self.message,
            }
        }
    }
}
impl InvalidAssociation {
    /// Creates a new builder-style object to manufacture [`InvalidAssociation`](crate::error::InvalidAssociation)
    pub fn builder() -> crate::error::invalid_association::Builder {
        crate::error::invalid_association::Builder::default()
    }
}

/// <p>The document does not support the platform type of the given instance ID(s). For example,
/// you sent an document for a Windows instance to a Linux instance.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedPlatformType {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedPlatformType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedPlatformType");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedPlatformType {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedPlatformType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedPlatformType")?;
        if let Some(inner_45) = &self.message {
            write!(f, ": {}", inner_45)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedPlatformType {}
/// See [`UnsupportedPlatformType`](crate::error::UnsupportedPlatformType)
pub mod unsupported_platform_type {
    /// A builder for [`UnsupportedPlatformType`](crate::error::UnsupportedPlatformType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedPlatformType`](crate::error::UnsupportedPlatformType)
        pub fn build(self) -> crate::error::UnsupportedPlatformType {
            crate::error::UnsupportedPlatformType {
                message: self.message,
            }
        }
    }
}
impl UnsupportedPlatformType {
    /// Creates a new builder-style object to manufacture [`UnsupportedPlatformType`](crate::error::UnsupportedPlatformType)
    pub fn builder() -> crate::error::unsupported_platform_type::Builder {
        crate::error::unsupported_platform_type::Builder::default()
    }
}

/// <p>The role name can't contain invalid characters. Also verify that you specified an IAM role
/// for notifications that includes the required trust policy. For information about configuring the
/// IAM role for Run Command notifications, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/rc-sns-notifications.html">Configuring Amazon SNS
/// Notifications for Run Command</a> in the <i>AWS Systems Manager User Guide</i>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRole {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRole");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRole {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRole")?;
        if let Some(inner_46) = &self.message {
            write!(f, ": {}", inner_46)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRole {}
/// See [`InvalidRole`](crate::error::InvalidRole)
pub mod invalid_role {
    /// A builder for [`InvalidRole`](crate::error::InvalidRole)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRole`](crate::error::InvalidRole)
        pub fn build(self) -> crate::error::InvalidRole {
            crate::error::InvalidRole {
                message: self.message,
            }
        }
    }
}
impl InvalidRole {
    /// Creates a new builder-style object to manufacture [`InvalidRole`](crate::error::InvalidRole)
    pub fn builder() -> crate::error::invalid_role::Builder {
        crate::error::invalid_role::Builder::default()
    }
}

/// <p>The S3 bucket does not exist.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOutputFolder {}
impl std::fmt::Debug for InvalidOutputFolder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOutputFolder");
        formatter.finish()
    }
}
impl InvalidOutputFolder {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for InvalidOutputFolder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOutputFolder")?;
        Ok(())
    }
}
impl std::error::Error for InvalidOutputFolder {}
/// See [`InvalidOutputFolder`](crate::error::InvalidOutputFolder)
pub mod invalid_output_folder {
    /// A builder for [`InvalidOutputFolder`](crate::error::InvalidOutputFolder)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`InvalidOutputFolder`](crate::error::InvalidOutputFolder)
        pub fn build(self) -> crate::error::InvalidOutputFolder {
            crate::error::InvalidOutputFolder {}
        }
    }
}
impl InvalidOutputFolder {
    /// Creates a new builder-style object to manufacture [`InvalidOutputFolder`](crate::error::InvalidOutputFolder)
    pub fn builder() -> crate::error::invalid_output_folder::Builder {
        crate::error::invalid_output_folder::Builder::default()
    }
}

/// <p>One or more configuration items is not valid. Verify that a valid Amazon Resource Name (ARN)
/// was provided for an Amazon SNS topic.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNotificationConfig {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNotificationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNotificationConfig");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidNotificationConfig {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNotificationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNotificationConfig")?;
        if let Some(inner_47) = &self.message {
            write!(f, ": {}", inner_47)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNotificationConfig {}
/// See [`InvalidNotificationConfig`](crate::error::InvalidNotificationConfig)
pub mod invalid_notification_config {
    /// A builder for [`InvalidNotificationConfig`](crate::error::InvalidNotificationConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNotificationConfig`](crate::error::InvalidNotificationConfig)
        pub fn build(self) -> crate::error::InvalidNotificationConfig {
            crate::error::InvalidNotificationConfig {
                message: self.message,
            }
        }
    }
}
impl InvalidNotificationConfig {
    /// Creates a new builder-style object to manufacture [`InvalidNotificationConfig`](crate::error::InvalidNotificationConfig)
    pub fn builder() -> crate::error::invalid_notification_config::Builder {
        crate::error::invalid_notification_config::Builder::default()
    }
}

/// <p>You cannot specify an instance ID in more than one association.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DuplicateInstanceId {}
impl std::fmt::Debug for DuplicateInstanceId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DuplicateInstanceId");
        formatter.finish()
    }
}
impl DuplicateInstanceId {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for DuplicateInstanceId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateInstanceId")?;
        Ok(())
    }
}
impl std::error::Error for DuplicateInstanceId {}
/// See [`DuplicateInstanceId`](crate::error::DuplicateInstanceId)
pub mod duplicate_instance_id {
    /// A builder for [`DuplicateInstanceId`](crate::error::DuplicateInstanceId)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DuplicateInstanceId`](crate::error::DuplicateInstanceId)
        pub fn build(self) -> crate::error::DuplicateInstanceId {
            crate::error::DuplicateInstanceId {}
        }
    }
}
impl DuplicateInstanceId {
    /// Creates a new builder-style object to manufacture [`DuplicateInstanceId`](crate::error::DuplicateInstanceId)
    pub fn builder() -> crate::error::duplicate_instance_id::Builder {
        crate::error::duplicate_instance_id::Builder::default()
    }
}

/// <p>The signal is not valid for the current Automation execution.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAutomationSignalError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAutomationSignalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAutomationSignalError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAutomationSignalError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAutomationSignalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidAutomationSignalError [InvalidAutomationSignalException]"
        )?;
        if let Some(inner_48) = &self.message {
            write!(f, ": {}", inner_48)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAutomationSignalError {}
/// See [`InvalidAutomationSignalError`](crate::error::InvalidAutomationSignalError)
pub mod invalid_automation_signal_error {
    /// A builder for [`InvalidAutomationSignalError`](crate::error::InvalidAutomationSignalError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAutomationSignalError`](crate::error::InvalidAutomationSignalError)
        pub fn build(self) -> crate::error::InvalidAutomationSignalError {
            crate::error::InvalidAutomationSignalError {
                message: self.message,
            }
        }
    }
}
impl InvalidAutomationSignalError {
    /// Creates a new builder-style object to manufacture [`InvalidAutomationSignalError`](crate::error::InvalidAutomationSignalError)
    pub fn builder() -> crate::error::invalid_automation_signal_error::Builder {
        crate::error::invalid_automation_signal_error::Builder::default()
    }
}

/// <p>The specified step name and execution ID don't exist. Verify the information and try
/// again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutomationStepNotFoundError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutomationStepNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutomationStepNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AutomationStepNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AutomationStepNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "AutomationStepNotFoundError [AutomationStepNotFoundException]"
        )?;
        if let Some(inner_49) = &self.message {
            write!(f, ": {}", inner_49)?;
        }
        Ok(())
    }
}
impl std::error::Error for AutomationStepNotFoundError {}
/// See [`AutomationStepNotFoundError`](crate::error::AutomationStepNotFoundError)
pub mod automation_step_not_found_error {
    /// A builder for [`AutomationStepNotFoundError`](crate::error::AutomationStepNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AutomationStepNotFoundError`](crate::error::AutomationStepNotFoundError)
        pub fn build(self) -> crate::error::AutomationStepNotFoundError {
            crate::error::AutomationStepNotFoundError {
                message: self.message,
            }
        }
    }
}
impl AutomationStepNotFoundError {
    /// Creates a new builder-style object to manufacture [`AutomationStepNotFoundError`](crate::error::AutomationStepNotFoundError)
    pub fn builder() -> crate::error::automation_step_not_found_error::Builder {
        crate::error::automation_step_not_found_error::Builder::default()
    }
}

/// <p>The resource type is not valid. For example, if you are attempting to tag an instance, the
/// instance must be a registered, managed instance.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidResourceType {}
impl std::fmt::Debug for InvalidResourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidResourceType");
        formatter.finish()
    }
}
impl InvalidResourceType {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for InvalidResourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResourceType")?;
        Ok(())
    }
}
impl std::error::Error for InvalidResourceType {}
/// See [`InvalidResourceType`](crate::error::InvalidResourceType)
pub mod invalid_resource_type {
    /// A builder for [`InvalidResourceType`](crate::error::InvalidResourceType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`InvalidResourceType`](crate::error::InvalidResourceType)
        pub fn build(self) -> crate::error::InvalidResourceType {
            crate::error::InvalidResourceType {}
        }
    }
}
impl InvalidResourceType {
    /// Creates a new builder-style object to manufacture [`InvalidResourceType`](crate::error::InvalidResourceType)
    pub fn builder() -> crate::error::invalid_resource_type::Builder {
        crate::error::invalid_resource_type::Builder::default()
    }
}

/// <p>The resource ID is not valid. Verify that you entered the correct ID and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidResourceId {}
impl std::fmt::Debug for InvalidResourceId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidResourceId");
        formatter.finish()
    }
}
impl InvalidResourceId {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for InvalidResourceId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResourceId")?;
        Ok(())
    }
}
impl std::error::Error for InvalidResourceId {}
/// See [`InvalidResourceId`](crate::error::InvalidResourceId)
pub mod invalid_resource_id {
    /// A builder for [`InvalidResourceId`](crate::error::InvalidResourceId)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`InvalidResourceId`](crate::error::InvalidResourceId)
        pub fn build(self) -> crate::error::InvalidResourceId {
            crate::error::InvalidResourceId {}
        }
    }
}
impl InvalidResourceId {
    /// Creates a new builder-style object to manufacture [`InvalidResourceId`](crate::error::InvalidResourceId)
    pub fn builder() -> crate::error::invalid_resource_id::Builder {
        crate::error::invalid_resource_id::Builder::default()
    }
}

/// <p>Error returned when the caller has exceeded the default resource quotas. For example, too
/// many maintenance windows or patch baselines have been created.</p>
/// <p>For information about resource quotas in Systems Manager, see <a href="http://docs.aws.amazon.com/general/latest/gr/ssm.html#limits_ssm">Systems Manager service quotas</a> in the
/// <i>AWS General Reference</i>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceLimitExceededError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ResourceLimitExceededError [ResourceLimitExceededException]"
        )?;
        if let Some(inner_50) = &self.message {
            write!(f, ": {}", inner_50)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceLimitExceededError {}
/// See [`ResourceLimitExceededError`](crate::error::ResourceLimitExceededError)
pub mod resource_limit_exceeded_error {
    /// A builder for [`ResourceLimitExceededError`](crate::error::ResourceLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceLimitExceededError`](crate::error::ResourceLimitExceededError)
        pub fn build(self) -> crate::error::ResourceLimitExceededError {
            crate::error::ResourceLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl ResourceLimitExceededError {
    /// Creates a new builder-style object to manufacture [`ResourceLimitExceededError`](crate::error::ResourceLimitExceededError)
    pub fn builder() -> crate::error::resource_limit_exceeded_error::Builder {
        crate::error::resource_limit_exceeded_error::Builder::default()
    }
}

/// <p>You attempted to register a LAMBDA or STEP_FUNCTIONS task in a region where the
/// corresponding service is not available. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct FeatureNotAvailableError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FeatureNotAvailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FeatureNotAvailableError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FeatureNotAvailableError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FeatureNotAvailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FeatureNotAvailableError [FeatureNotAvailableException]")?;
        if let Some(inner_51) = &self.message {
            write!(f, ": {}", inner_51)?;
        }
        Ok(())
    }
}
impl std::error::Error for FeatureNotAvailableError {}
/// See [`FeatureNotAvailableError`](crate::error::FeatureNotAvailableError)
pub mod feature_not_available_error {
    /// A builder for [`FeatureNotAvailableError`](crate::error::FeatureNotAvailableError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FeatureNotAvailableError`](crate::error::FeatureNotAvailableError)
        pub fn build(self) -> crate::error::FeatureNotAvailableError {
            crate::error::FeatureNotAvailableError {
                message: self.message,
            }
        }
    }
}
impl FeatureNotAvailableError {
    /// Creates a new builder-style object to manufacture [`FeatureNotAvailableError`](crate::error::FeatureNotAvailableError)
    pub fn builder() -> crate::error::feature_not_available_error::Builder {
        crate::error::feature_not_available_error::Builder::default()
    }
}

/// <p>Error returned if an attempt is made to register a patch group with a patch baseline that is
/// already registered with a different patch baseline.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AlreadyExistsError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AlreadyExistsError [AlreadyExistsException]")?;
        if let Some(inner_52) = &self.message {
            write!(f, ": {}", inner_52)?;
        }
        Ok(())
    }
}
impl std::error::Error for AlreadyExistsError {}
/// See [`AlreadyExistsError`](crate::error::AlreadyExistsError)
pub mod already_exists_error {
    /// A builder for [`AlreadyExistsError`](crate::error::AlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AlreadyExistsError`](crate::error::AlreadyExistsError)
        pub fn build(self) -> crate::error::AlreadyExistsError {
            crate::error::AlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl AlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`AlreadyExistsError`](crate::error::AlreadyExistsError)
    pub fn builder() -> crate::error::already_exists_error::Builder {
        crate::error::already_exists_error::Builder::default()
    }
}

/// <p>The parameter type is not supported.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedParameterType {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedParameterType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedParameterType");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedParameterType {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedParameterType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedParameterType")?;
        if let Some(inner_53) = &self.message {
            write!(f, ": {}", inner_53)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedParameterType {}
/// See [`UnsupportedParameterType`](crate::error::UnsupportedParameterType)
pub mod unsupported_parameter_type {
    /// A builder for [`UnsupportedParameterType`](crate::error::UnsupportedParameterType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedParameterType`](crate::error::UnsupportedParameterType)
        pub fn build(self) -> crate::error::UnsupportedParameterType {
            crate::error::UnsupportedParameterType {
                message: self.message,
            }
        }
    }
}
impl UnsupportedParameterType {
    /// Creates a new builder-style object to manufacture [`UnsupportedParameterType`](crate::error::UnsupportedParameterType)
    pub fn builder() -> crate::error::unsupported_parameter_type::Builder {
        crate::error::unsupported_parameter_type::Builder::default()
    }
}

/// <p>You specified more than the maximum number of allowed policies for the parameter. The
/// maximum is 10.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PoliciesLimitExceededError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PoliciesLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PoliciesLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PoliciesLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PoliciesLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PoliciesLimitExceededError [PoliciesLimitExceededException]"
        )?;
        if let Some(inner_54) = &self.message {
            write!(f, ": {}", inner_54)?;
        }
        Ok(())
    }
}
impl std::error::Error for PoliciesLimitExceededError {}
/// See [`PoliciesLimitExceededError`](crate::error::PoliciesLimitExceededError)
pub mod policies_limit_exceeded_error {
    /// A builder for [`PoliciesLimitExceededError`](crate::error::PoliciesLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PoliciesLimitExceededError`](crate::error::PoliciesLimitExceededError)
        pub fn build(self) -> crate::error::PoliciesLimitExceededError {
            crate::error::PoliciesLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl PoliciesLimitExceededError {
    /// Creates a new builder-style object to manufacture [`PoliciesLimitExceededError`](crate::error::PoliciesLimitExceededError)
    pub fn builder() -> crate::error::policies_limit_exceeded_error::Builder {
        crate::error::policies_limit_exceeded_error::Builder::default()
    }
}

/// <p>The parameter name is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterPatternMismatchError {
    /// <p>The parameter name is not valid.</p>
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParameterPatternMismatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterPatternMismatchError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ParameterPatternMismatchError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParameterPatternMismatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ParameterPatternMismatchError [ParameterPatternMismatchException]"
        )?;
        if let Some(inner_55) = &self.message {
            write!(f, ": {}", inner_55)?;
        }
        Ok(())
    }
}
impl std::error::Error for ParameterPatternMismatchError {}
/// See [`ParameterPatternMismatchError`](crate::error::ParameterPatternMismatchError)
pub mod parameter_pattern_mismatch_error {
    /// A builder for [`ParameterPatternMismatchError`](crate::error::ParameterPatternMismatchError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The parameter name is not valid.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterPatternMismatchError`](crate::error::ParameterPatternMismatchError)
        pub fn build(self) -> crate::error::ParameterPatternMismatchError {
            crate::error::ParameterPatternMismatchError {
                message: self.message,
            }
        }
    }
}
impl ParameterPatternMismatchError {
    /// Creates a new builder-style object to manufacture [`ParameterPatternMismatchError`](crate::error::ParameterPatternMismatchError)
    pub fn builder() -> crate::error::parameter_pattern_mismatch_error::Builder {
        crate::error::parameter_pattern_mismatch_error::Builder::default()
    }
}

/// <p>Parameter Store retains the 100 most recently created versions of a parameter. After this
/// number of versions has been created, Parameter Store deletes the oldest version when a new one is
/// created. However, if the oldest version has a <i>label</i> attached to it,
/// Parameter Store will not delete the version and instead presents this error message:</p>
/// <p>
/// <code>An error occurred (ParameterMaxVersionLimitExceeded) when calling the PutParameter
/// operation: You attempted to create a new version of <i>parameter-name</i> by
/// calling the PutParameter API with the overwrite flag. Version
/// <i>version-number</i>, the oldest version, can't be deleted because it has a
/// label associated with it. Move the label to another version of the parameter, and try
/// again.</code>
/// </p>
/// <p>This safeguard is to prevent parameter versions with mission critical labels assigned to
/// them from being deleted. To continue creating new parameters, first move the label from the
/// oldest version of the parameter to a newer one for use in your operations. For information about
/// moving parameter labels, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html#sysman-paramstore-labels-console-move">Move a
/// parameter label (console)</a> or <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html#sysman-paramstore-labels-cli-move">Move a
/// parameter label (CLI)</a> in the <i>AWS Systems Manager User Guide</i>. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterMaxVersionLimitExceeded {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParameterMaxVersionLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterMaxVersionLimitExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ParameterMaxVersionLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParameterMaxVersionLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParameterMaxVersionLimitExceeded")?;
        if let Some(inner_56) = &self.message {
            write!(f, ": {}", inner_56)?;
        }
        Ok(())
    }
}
impl std::error::Error for ParameterMaxVersionLimitExceeded {}
/// See [`ParameterMaxVersionLimitExceeded`](crate::error::ParameterMaxVersionLimitExceeded)
pub mod parameter_max_version_limit_exceeded {
    /// A builder for [`ParameterMaxVersionLimitExceeded`](crate::error::ParameterMaxVersionLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterMaxVersionLimitExceeded`](crate::error::ParameterMaxVersionLimitExceeded)
        pub fn build(self) -> crate::error::ParameterMaxVersionLimitExceeded {
            crate::error::ParameterMaxVersionLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl ParameterMaxVersionLimitExceeded {
    /// Creates a new builder-style object to manufacture [`ParameterMaxVersionLimitExceeded`](crate::error::ParameterMaxVersionLimitExceeded)
    pub fn builder() -> crate::error::parameter_max_version_limit_exceeded::Builder {
        crate::error::parameter_max_version_limit_exceeded::Builder::default()
    }
}

/// <p>You have exceeded the number of parameters for this AWS account. Delete one or more
/// parameters and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterLimitExceeded {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParameterLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterLimitExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ParameterLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParameterLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParameterLimitExceeded")?;
        if let Some(inner_57) = &self.message {
            write!(f, ": {}", inner_57)?;
        }
        Ok(())
    }
}
impl std::error::Error for ParameterLimitExceeded {}
/// See [`ParameterLimitExceeded`](crate::error::ParameterLimitExceeded)
pub mod parameter_limit_exceeded {
    /// A builder for [`ParameterLimitExceeded`](crate::error::ParameterLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterLimitExceeded`](crate::error::ParameterLimitExceeded)
        pub fn build(self) -> crate::error::ParameterLimitExceeded {
            crate::error::ParameterLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl ParameterLimitExceeded {
    /// Creates a new builder-style object to manufacture [`ParameterLimitExceeded`](crate::error::ParameterLimitExceeded)
    pub fn builder() -> crate::error::parameter_limit_exceeded::Builder {
        crate::error::parameter_limit_exceeded::Builder::default()
    }
}

/// <p>The parameter already exists. You can't create duplicate parameters.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterAlreadyExists {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParameterAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterAlreadyExists");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ParameterAlreadyExists {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParameterAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParameterAlreadyExists")?;
        if let Some(inner_58) = &self.message {
            write!(f, ": {}", inner_58)?;
        }
        Ok(())
    }
}
impl std::error::Error for ParameterAlreadyExists {}
/// See [`ParameterAlreadyExists`](crate::error::ParameterAlreadyExists)
pub mod parameter_already_exists {
    /// A builder for [`ParameterAlreadyExists`](crate::error::ParameterAlreadyExists)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterAlreadyExists`](crate::error::ParameterAlreadyExists)
        pub fn build(self) -> crate::error::ParameterAlreadyExists {
            crate::error::ParameterAlreadyExists {
                message: self.message,
            }
        }
    }
}
impl ParameterAlreadyExists {
    /// Creates a new builder-style object to manufacture [`ParameterAlreadyExists`](crate::error::ParameterAlreadyExists)
    pub fn builder() -> crate::error::parameter_already_exists::Builder {
        crate::error::parameter_already_exists::Builder::default()
    }
}

/// <p>The policy type is not supported. Parameter Store supports the following policy types:
/// Expiration, ExpirationNotification, and NoChangeNotification.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPolicyTypeError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPolicyTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPolicyTypeError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPolicyTypeError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPolicyTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPolicyTypeError [InvalidPolicyTypeException]")?;
        if let Some(inner_59) = &self.message {
            write!(f, ": {}", inner_59)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPolicyTypeError {}
/// See [`InvalidPolicyTypeError`](crate::error::InvalidPolicyTypeError)
pub mod invalid_policy_type_error {
    /// A builder for [`InvalidPolicyTypeError`](crate::error::InvalidPolicyTypeError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPolicyTypeError`](crate::error::InvalidPolicyTypeError)
        pub fn build(self) -> crate::error::InvalidPolicyTypeError {
            crate::error::InvalidPolicyTypeError {
                message: self.message,
            }
        }
    }
}
impl InvalidPolicyTypeError {
    /// Creates a new builder-style object to manufacture [`InvalidPolicyTypeError`](crate::error::InvalidPolicyTypeError)
    pub fn builder() -> crate::error::invalid_policy_type_error::Builder {
        crate::error::invalid_policy_type_error::Builder::default()
    }
}

/// <p>A policy attribute or its value is invalid. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPolicyAttributeError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPolicyAttributeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPolicyAttributeError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPolicyAttributeError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPolicyAttributeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidPolicyAttributeError [InvalidPolicyAttributeException]"
        )?;
        if let Some(inner_60) = &self.message {
            write!(f, ": {}", inner_60)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPolicyAttributeError {}
/// See [`InvalidPolicyAttributeError`](crate::error::InvalidPolicyAttributeError)
pub mod invalid_policy_attribute_error {
    /// A builder for [`InvalidPolicyAttributeError`](crate::error::InvalidPolicyAttributeError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPolicyAttributeError`](crate::error::InvalidPolicyAttributeError)
        pub fn build(self) -> crate::error::InvalidPolicyAttributeError {
            crate::error::InvalidPolicyAttributeError {
                message: self.message,
            }
        }
    }
}
impl InvalidPolicyAttributeError {
    /// Creates a new builder-style object to manufacture [`InvalidPolicyAttributeError`](crate::error::InvalidPolicyAttributeError)
    pub fn builder() -> crate::error::invalid_policy_attribute_error::Builder {
        crate::error::invalid_policy_attribute_error::Builder::default()
    }
}

/// <p>The query key ID is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidKeyId {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidKeyId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidKeyId");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidKeyId {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidKeyId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidKeyId")?;
        if let Some(inner_61) = &self.message {
            write!(f, ": {}", inner_61)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidKeyId {}
/// See [`InvalidKeyId`](crate::error::InvalidKeyId)
pub mod invalid_key_id {
    /// A builder for [`InvalidKeyId`](crate::error::InvalidKeyId)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidKeyId`](crate::error::InvalidKeyId)
        pub fn build(self) -> crate::error::InvalidKeyId {
            crate::error::InvalidKeyId {
                message: self.message,
            }
        }
    }
}
impl InvalidKeyId {
    /// Creates a new builder-style object to manufacture [`InvalidKeyId`](crate::error::InvalidKeyId)
    pub fn builder() -> crate::error::invalid_key_id::Builder {
        crate::error::invalid_key_id::Builder::default()
    }
}

/// <p>The request does not meet the regular expression requirement.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAllowedPatternError {
    /// <p>The request does not meet the regular expression requirement.</p>
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAllowedPatternError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAllowedPatternError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAllowedPatternError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAllowedPatternError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidAllowedPatternError [InvalidAllowedPatternException]"
        )?;
        if let Some(inner_62) = &self.message {
            write!(f, ": {}", inner_62)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAllowedPatternError {}
/// See [`InvalidAllowedPatternError`](crate::error::InvalidAllowedPatternError)
pub mod invalid_allowed_pattern_error {
    /// A builder for [`InvalidAllowedPatternError`](crate::error::InvalidAllowedPatternError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The request does not meet the regular expression requirement.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAllowedPatternError`](crate::error::InvalidAllowedPatternError)
        pub fn build(self) -> crate::error::InvalidAllowedPatternError {
            crate::error::InvalidAllowedPatternError {
                message: self.message,
            }
        }
    }
}
impl InvalidAllowedPatternError {
    /// Creates a new builder-style object to manufacture [`InvalidAllowedPatternError`](crate::error::InvalidAllowedPatternError)
    pub fn builder() -> crate::error::invalid_allowed_pattern_error::Builder {
        crate::error::invalid_allowed_pattern_error::Builder::default()
    }
}

/// <p>There is a conflict in the policies specified for this parameter. You can't, for example,
/// specify two Expiration policies for a parameter. Review your policies, and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct IncompatiblePolicyError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IncompatiblePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IncompatiblePolicyError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IncompatiblePolicyError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IncompatiblePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IncompatiblePolicyError [IncompatiblePolicyException]")?;
        if let Some(inner_63) = &self.message {
            write!(f, ": {}", inner_63)?;
        }
        Ok(())
    }
}
impl std::error::Error for IncompatiblePolicyError {}
/// See [`IncompatiblePolicyError`](crate::error::IncompatiblePolicyError)
pub mod incompatible_policy_error {
    /// A builder for [`IncompatiblePolicyError`](crate::error::IncompatiblePolicyError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IncompatiblePolicyError`](crate::error::IncompatiblePolicyError)
        pub fn build(self) -> crate::error::IncompatiblePolicyError {
            crate::error::IncompatiblePolicyError {
                message: self.message,
            }
        }
    }
}
impl IncompatiblePolicyError {
    /// Creates a new builder-style object to manufacture [`IncompatiblePolicyError`](crate::error::IncompatiblePolicyError)
    pub fn builder() -> crate::error::incompatible_policy_error::Builder {
        crate::error::incompatible_policy_error::Builder::default()
    }
}

/// <p>Parameter Store does not support changing a parameter type in a hierarchy. For example, you
/// can't change a parameter from a <code>String</code> type to a <code>SecureString</code> type. You
/// must create a new, unique parameter.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct HierarchyTypeMismatchError {
    /// <p>Parameter Store does not support changing a parameter type in a hierarchy. For example, you
    /// can't change a parameter from a <code>String</code> type to a <code>SecureString</code> type. You
    /// must create a new, unique parameter.</p>
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HierarchyTypeMismatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HierarchyTypeMismatchError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl HierarchyTypeMismatchError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for HierarchyTypeMismatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "HierarchyTypeMismatchError [HierarchyTypeMismatchException]"
        )?;
        if let Some(inner_64) = &self.message {
            write!(f, ": {}", inner_64)?;
        }
        Ok(())
    }
}
impl std::error::Error for HierarchyTypeMismatchError {}
/// See [`HierarchyTypeMismatchError`](crate::error::HierarchyTypeMismatchError)
pub mod hierarchy_type_mismatch_error {
    /// A builder for [`HierarchyTypeMismatchError`](crate::error::HierarchyTypeMismatchError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Parameter Store does not support changing a parameter type in a hierarchy. For example, you
        /// can't change a parameter from a <code>String</code> type to a <code>SecureString</code> type. You
        /// must create a new, unique parameter.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyTypeMismatchError`](crate::error::HierarchyTypeMismatchError)
        pub fn build(self) -> crate::error::HierarchyTypeMismatchError {
            crate::error::HierarchyTypeMismatchError {
                message: self.message,
            }
        }
    }
}
impl HierarchyTypeMismatchError {
    /// Creates a new builder-style object to manufacture [`HierarchyTypeMismatchError`](crate::error::HierarchyTypeMismatchError)
    pub fn builder() -> crate::error::hierarchy_type_mismatch_error::Builder {
        crate::error::hierarchy_type_mismatch_error::Builder::default()
    }
}

/// <p>A hierarchy can have a maximum of 15 levels. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-parameter-name-constraints.html">Requirements and
/// constraints for parameter names</a> in the <i>AWS Systems Manager User Guide</i>. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct HierarchyLevelLimitExceededError {
    /// <p>A hierarchy can have a maximum of 15 levels. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-parameter-name-constraints.html">Requirements and
    /// constraints for parameter names</a> in the <i>AWS Systems Manager User Guide</i>. </p>
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HierarchyLevelLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HierarchyLevelLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl HierarchyLevelLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for HierarchyLevelLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "HierarchyLevelLimitExceededError [HierarchyLevelLimitExceededException]"
        )?;
        if let Some(inner_65) = &self.message {
            write!(f, ": {}", inner_65)?;
        }
        Ok(())
    }
}
impl std::error::Error for HierarchyLevelLimitExceededError {}
/// See [`HierarchyLevelLimitExceededError`](crate::error::HierarchyLevelLimitExceededError)
pub mod hierarchy_level_limit_exceeded_error {
    /// A builder for [`HierarchyLevelLimitExceededError`](crate::error::HierarchyLevelLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A hierarchy can have a maximum of 15 levels. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-parameter-name-constraints.html">Requirements and
        /// constraints for parameter names</a> in the <i>AWS Systems Manager User Guide</i>. </p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyLevelLimitExceededError`](crate::error::HierarchyLevelLimitExceededError)
        pub fn build(self) -> crate::error::HierarchyLevelLimitExceededError {
            crate::error::HierarchyLevelLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl HierarchyLevelLimitExceededError {
    /// Creates a new builder-style object to manufacture [`HierarchyLevelLimitExceededError`](crate::error::HierarchyLevelLimitExceededError)
    pub fn builder() -> crate::error::hierarchy_level_limit_exceeded_error::Builder {
        crate::error::hierarchy_level_limit_exceeded_error::Builder::default()
    }
}

/// <p>Inventory item type schema version has to match supported versions in the service. Check
/// output of GetInventorySchema to see the available schema version for each type.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedInventorySchemaVersionError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedInventorySchemaVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedInventorySchemaVersionError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedInventorySchemaVersionError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedInventorySchemaVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "UnsupportedInventorySchemaVersionError [UnsupportedInventorySchemaVersionException]"
        )?;
        if let Some(inner_66) = &self.message {
            write!(f, ": {}", inner_66)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedInventorySchemaVersionError {}
/// See [`UnsupportedInventorySchemaVersionError`](crate::error::UnsupportedInventorySchemaVersionError)
pub mod unsupported_inventory_schema_version_error {
    /// A builder for [`UnsupportedInventorySchemaVersionError`](crate::error::UnsupportedInventorySchemaVersionError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedInventorySchemaVersionError`](crate::error::UnsupportedInventorySchemaVersionError)
        pub fn build(self) -> crate::error::UnsupportedInventorySchemaVersionError {
            crate::error::UnsupportedInventorySchemaVersionError {
                message: self.message,
            }
        }
    }
}
impl UnsupportedInventorySchemaVersionError {
    /// Creates a new builder-style object to manufacture [`UnsupportedInventorySchemaVersionError`](crate::error::UnsupportedInventorySchemaVersionError)
    pub fn builder() -> crate::error::unsupported_inventory_schema_version_error::Builder {
        crate::error::unsupported_inventory_schema_version_error::Builder::default()
    }
}

/// <p>The <code>Context</code> attribute that you specified for the <code>InventoryItem</code> is
/// not allowed for this inventory type. You can only use the <code>Context</code> attribute with
/// inventory types like <code>AWS:ComplianceItem</code>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedInventoryItemContextError {
    #[serde(rename = "TypeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedInventoryItemContextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedInventoryItemContextError");
        formatter.field("type_name", &self.type_name);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedInventoryItemContextError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedInventoryItemContextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "UnsupportedInventoryItemContextError [UnsupportedInventoryItemContextException]"
        )?;
        if let Some(inner_67) = &self.message {
            write!(f, ": {}", inner_67)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedInventoryItemContextError {}
/// See [`UnsupportedInventoryItemContextError`](crate::error::UnsupportedInventoryItemContextError)
pub mod unsupported_inventory_item_context_error {
    /// A builder for [`UnsupportedInventoryItemContextError`](crate::error::UnsupportedInventoryItemContextError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.type_name = Some(input.into());
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.type_name = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedInventoryItemContextError`](crate::error::UnsupportedInventoryItemContextError)
        pub fn build(self) -> crate::error::UnsupportedInventoryItemContextError {
            crate::error::UnsupportedInventoryItemContextError {
                type_name: self.type_name,
                message: self.message,
            }
        }
    }
}
impl UnsupportedInventoryItemContextError {
    /// Creates a new builder-style object to manufacture [`UnsupportedInventoryItemContextError`](crate::error::UnsupportedInventoryItemContextError)
    pub fn builder() -> crate::error::unsupported_inventory_item_context_error::Builder {
        crate::error::unsupported_inventory_item_context_error::Builder::default()
    }
}

/// <p>The size of inventory data has exceeded the total size limit for the resource.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TotalSizeLimitExceededError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TotalSizeLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TotalSizeLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TotalSizeLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TotalSizeLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "TotalSizeLimitExceededError [TotalSizeLimitExceededException]"
        )?;
        if let Some(inner_68) = &self.message {
            write!(f, ": {}", inner_68)?;
        }
        Ok(())
    }
}
impl std::error::Error for TotalSizeLimitExceededError {}
/// See [`TotalSizeLimitExceededError`](crate::error::TotalSizeLimitExceededError)
pub mod total_size_limit_exceeded_error {
    /// A builder for [`TotalSizeLimitExceededError`](crate::error::TotalSizeLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TotalSizeLimitExceededError`](crate::error::TotalSizeLimitExceededError)
        pub fn build(self) -> crate::error::TotalSizeLimitExceededError {
            crate::error::TotalSizeLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl TotalSizeLimitExceededError {
    /// Creates a new builder-style object to manufacture [`TotalSizeLimitExceededError`](crate::error::TotalSizeLimitExceededError)
    pub fn builder() -> crate::error::total_size_limit_exceeded_error::Builder {
        crate::error::total_size_limit_exceeded_error::Builder::default()
    }
}

/// <p>The sub-type count exceeded the limit for the inventory type.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SubTypeCountLimitExceededError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubTypeCountLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubTypeCountLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubTypeCountLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubTypeCountLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SubTypeCountLimitExceededError [SubTypeCountLimitExceededException]"
        )?;
        if let Some(inner_69) = &self.message {
            write!(f, ": {}", inner_69)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubTypeCountLimitExceededError {}
/// See [`SubTypeCountLimitExceededError`](crate::error::SubTypeCountLimitExceededError)
pub mod sub_type_count_limit_exceeded_error {
    /// A builder for [`SubTypeCountLimitExceededError`](crate::error::SubTypeCountLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SubTypeCountLimitExceededError`](crate::error::SubTypeCountLimitExceededError)
        pub fn build(self) -> crate::error::SubTypeCountLimitExceededError {
            crate::error::SubTypeCountLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl SubTypeCountLimitExceededError {
    /// Creates a new builder-style object to manufacture [`SubTypeCountLimitExceededError`](crate::error::SubTypeCountLimitExceededError)
    pub fn builder() -> crate::error::sub_type_count_limit_exceeded_error::Builder {
        crate::error::sub_type_count_limit_exceeded_error::Builder::default()
    }
}

/// <p>The inventory item size has exceeded the size limit.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ItemSizeLimitExceededError {
    #[serde(rename = "TypeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ItemSizeLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ItemSizeLimitExceededError");
        formatter.field("type_name", &self.type_name);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ItemSizeLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ItemSizeLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ItemSizeLimitExceededError [ItemSizeLimitExceededException]"
        )?;
        if let Some(inner_70) = &self.message {
            write!(f, ": {}", inner_70)?;
        }
        Ok(())
    }
}
impl std::error::Error for ItemSizeLimitExceededError {}
/// See [`ItemSizeLimitExceededError`](crate::error::ItemSizeLimitExceededError)
pub mod item_size_limit_exceeded_error {
    /// A builder for [`ItemSizeLimitExceededError`](crate::error::ItemSizeLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.type_name = Some(input.into());
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.type_name = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ItemSizeLimitExceededError`](crate::error::ItemSizeLimitExceededError)
        pub fn build(self) -> crate::error::ItemSizeLimitExceededError {
            crate::error::ItemSizeLimitExceededError {
                type_name: self.type_name,
                message: self.message,
            }
        }
    }
}
impl ItemSizeLimitExceededError {
    /// Creates a new builder-style object to manufacture [`ItemSizeLimitExceededError`](crate::error::ItemSizeLimitExceededError)
    pub fn builder() -> crate::error::item_size_limit_exceeded_error::Builder {
        crate::error::item_size_limit_exceeded_error::Builder::default()
    }
}

/// <p>The inventory item has invalid content. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ItemContentMismatchError {
    #[serde(rename = "TypeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ItemContentMismatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ItemContentMismatchError");
        formatter.field("type_name", &self.type_name);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ItemContentMismatchError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ItemContentMismatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ItemContentMismatchError [ItemContentMismatchException]")?;
        if let Some(inner_71) = &self.message {
            write!(f, ": {}", inner_71)?;
        }
        Ok(())
    }
}
impl std::error::Error for ItemContentMismatchError {}
/// See [`ItemContentMismatchError`](crate::error::ItemContentMismatchError)
pub mod item_content_mismatch_error {
    /// A builder for [`ItemContentMismatchError`](crate::error::ItemContentMismatchError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.type_name = Some(input.into());
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.type_name = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ItemContentMismatchError`](crate::error::ItemContentMismatchError)
        pub fn build(self) -> crate::error::ItemContentMismatchError {
            crate::error::ItemContentMismatchError {
                type_name: self.type_name,
                message: self.message,
            }
        }
    }
}
impl ItemContentMismatchError {
    /// Creates a new builder-style object to manufacture [`ItemContentMismatchError`](crate::error::ItemContentMismatchError)
    pub fn builder() -> crate::error::item_content_mismatch_error::Builder {
        crate::error::item_content_mismatch_error::Builder::default()
    }
}

/// <p>The parameter type name is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTypeNameError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTypeNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTypeNameError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTypeNameError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTypeNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTypeNameError [InvalidTypeNameException]")?;
        if let Some(inner_72) = &self.message {
            write!(f, ": {}", inner_72)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTypeNameError {}
/// See [`InvalidTypeNameError`](crate::error::InvalidTypeNameError)
pub mod invalid_type_name_error {
    /// A builder for [`InvalidTypeNameError`](crate::error::InvalidTypeNameError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTypeNameError`](crate::error::InvalidTypeNameError)
        pub fn build(self) -> crate::error::InvalidTypeNameError {
            crate::error::InvalidTypeNameError {
                message: self.message,
            }
        }
    }
}
impl InvalidTypeNameError {
    /// Creates a new builder-style object to manufacture [`InvalidTypeNameError`](crate::error::InvalidTypeNameError)
    pub fn builder() -> crate::error::invalid_type_name_error::Builder {
        crate::error::invalid_type_name_error::Builder::default()
    }
}

/// <p>One or more content items is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidItemContentError {
    #[serde(rename = "TypeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidItemContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidItemContentError");
        formatter.field("type_name", &self.type_name);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidItemContentError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidItemContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidItemContentError [InvalidItemContentException]")?;
        if let Some(inner_73) = &self.message {
            write!(f, ": {}", inner_73)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidItemContentError {}
/// See [`InvalidItemContentError`](crate::error::InvalidItemContentError)
pub mod invalid_item_content_error {
    /// A builder for [`InvalidItemContentError`](crate::error::InvalidItemContentError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.type_name = Some(input.into());
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.type_name = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidItemContentError`](crate::error::InvalidItemContentError)
        pub fn build(self) -> crate::error::InvalidItemContentError {
            crate::error::InvalidItemContentError {
                type_name: self.type_name,
                message: self.message,
            }
        }
    }
}
impl InvalidItemContentError {
    /// Creates a new builder-style object to manufacture [`InvalidItemContentError`](crate::error::InvalidItemContentError)
    pub fn builder() -> crate::error::invalid_item_content_error::Builder {
        crate::error::invalid_item_content_error::Builder::default()
    }
}

/// <p>You specified invalid keys or values in the <code>Context</code> attribute for
/// <code>InventoryItem</code>. Verify the keys and values, and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInventoryItemContextError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidInventoryItemContextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInventoryItemContextError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidInventoryItemContextError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInventoryItemContextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidInventoryItemContextError [InvalidInventoryItemContextException]"
        )?;
        if let Some(inner_74) = &self.message {
            write!(f, ": {}", inner_74)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInventoryItemContextError {}
/// See [`InvalidInventoryItemContextError`](crate::error::InvalidInventoryItemContextError)
pub mod invalid_inventory_item_context_error {
    /// A builder for [`InvalidInventoryItemContextError`](crate::error::InvalidInventoryItemContextError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInventoryItemContextError`](crate::error::InvalidInventoryItemContextError)
        pub fn build(self) -> crate::error::InvalidInventoryItemContextError {
            crate::error::InvalidInventoryItemContextError {
                message: self.message,
            }
        }
    }
}
impl InvalidInventoryItemContextError {
    /// Creates a new builder-style object to manufacture [`InvalidInventoryItemContextError`](crate::error::InvalidInventoryItemContextError)
    pub fn builder() -> crate::error::invalid_inventory_item_context_error::Builder {
        crate::error::invalid_inventory_item_context_error::Builder::default()
    }
}

/// <p>You have exceeded the limit for custom schemas. Delete one or more custom schemas and try
/// again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomSchemaCountLimitExceededError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomSchemaCountLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomSchemaCountLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomSchemaCountLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomSchemaCountLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CustomSchemaCountLimitExceededError [CustomSchemaCountLimitExceededException]"
        )?;
        if let Some(inner_75) = &self.message {
            write!(f, ": {}", inner_75)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomSchemaCountLimitExceededError {}
/// See [`CustomSchemaCountLimitExceededError`](crate::error::CustomSchemaCountLimitExceededError)
pub mod custom_schema_count_limit_exceeded_error {
    /// A builder for [`CustomSchemaCountLimitExceededError`](crate::error::CustomSchemaCountLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomSchemaCountLimitExceededError`](crate::error::CustomSchemaCountLimitExceededError)
        pub fn build(self) -> crate::error::CustomSchemaCountLimitExceededError {
            crate::error::CustomSchemaCountLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl CustomSchemaCountLimitExceededError {
    /// Creates a new builder-style object to manufacture [`CustomSchemaCountLimitExceededError`](crate::error::CustomSchemaCountLimitExceededError)
    pub fn builder() -> crate::error::custom_schema_count_limit_exceeded_error::Builder {
        crate::error::custom_schema_count_limit_exceeded_error::Builder::default()
    }
}

/// <p>You specified too many custom compliance types. You can specify a maximum of 10 different
/// types. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ComplianceTypeCountLimitExceededError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ComplianceTypeCountLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ComplianceTypeCountLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ComplianceTypeCountLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ComplianceTypeCountLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ComplianceTypeCountLimitExceededError [ComplianceTypeCountLimitExceededException]"
        )?;
        if let Some(inner_76) = &self.message {
            write!(f, ": {}", inner_76)?;
        }
        Ok(())
    }
}
impl std::error::Error for ComplianceTypeCountLimitExceededError {}
/// See [`ComplianceTypeCountLimitExceededError`](crate::error::ComplianceTypeCountLimitExceededError)
pub mod compliance_type_count_limit_exceeded_error {
    /// A builder for [`ComplianceTypeCountLimitExceededError`](crate::error::ComplianceTypeCountLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ComplianceTypeCountLimitExceededError`](crate::error::ComplianceTypeCountLimitExceededError)
        pub fn build(self) -> crate::error::ComplianceTypeCountLimitExceededError {
            crate::error::ComplianceTypeCountLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl ComplianceTypeCountLimitExceededError {
    /// Creates a new builder-style object to manufacture [`ComplianceTypeCountLimitExceededError`](crate::error::ComplianceTypeCountLimitExceededError)
    pub fn builder() -> crate::error::compliance_type_count_limit_exceeded_error::Builder {
        crate::error::compliance_type_count_limit_exceeded_error::Builder::default()
    }
}

/// <p>The permission type is not supported. <i>Share</i> is the only supported
/// permission type.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPermissionType {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPermissionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPermissionType");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPermissionType {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPermissionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPermissionType")?;
        if let Some(inner_77) = &self.message {
            write!(f, ": {}", inner_77)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPermissionType {}
/// See [`InvalidPermissionType`](crate::error::InvalidPermissionType)
pub mod invalid_permission_type {
    /// A builder for [`InvalidPermissionType`](crate::error::InvalidPermissionType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPermissionType`](crate::error::InvalidPermissionType)
        pub fn build(self) -> crate::error::InvalidPermissionType {
            crate::error::InvalidPermissionType {
                message: self.message,
            }
        }
    }
}
impl InvalidPermissionType {
    /// Creates a new builder-style object to manufacture [`InvalidPermissionType`](crate::error::InvalidPermissionType)
    pub fn builder() -> crate::error::invalid_permission_type::Builder {
        crate::error::invalid_permission_type::Builder::default()
    }
}

/// <p>The document cannot be shared with more AWS user accounts. You can share a document with a
/// maximum of 20 accounts. You can publicly share up to five documents. If you need to increase this
/// limit, contact AWS Support.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentPermissionLimit {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DocumentPermissionLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentPermissionLimit");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DocumentPermissionLimit {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DocumentPermissionLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DocumentPermissionLimit")?;
        if let Some(inner_78) = &self.message {
            write!(f, ": {}", inner_78)?;
        }
        Ok(())
    }
}
impl std::error::Error for DocumentPermissionLimit {}
/// See [`DocumentPermissionLimit`](crate::error::DocumentPermissionLimit)
pub mod document_permission_limit {
    /// A builder for [`DocumentPermissionLimit`](crate::error::DocumentPermissionLimit)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentPermissionLimit`](crate::error::DocumentPermissionLimit)
        pub fn build(self) -> crate::error::DocumentPermissionLimit {
            crate::error::DocumentPermissionLimit {
                message: self.message,
            }
        }
    }
}
impl DocumentPermissionLimit {
    /// Creates a new builder-style object to manufacture [`DocumentPermissionLimit`](crate::error::DocumentPermissionLimit)
    pub fn builder() -> crate::error::document_permission_limit::Builder {
        crate::error::document_permission_limit::Builder::default()
    }
}

/// <p>You can have at most 500 active Systems Manager documents.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentLimitExceeded {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DocumentLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentLimitExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DocumentLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DocumentLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DocumentLimitExceeded")?;
        if let Some(inner_79) = &self.message {
            write!(f, ": {}", inner_79)?;
        }
        Ok(())
    }
}
impl std::error::Error for DocumentLimitExceeded {}
/// See [`DocumentLimitExceeded`](crate::error::DocumentLimitExceeded)
pub mod document_limit_exceeded {
    /// A builder for [`DocumentLimitExceeded`](crate::error::DocumentLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentLimitExceeded`](crate::error::DocumentLimitExceeded)
        pub fn build(self) -> crate::error::DocumentLimitExceeded {
            crate::error::DocumentLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl DocumentLimitExceeded {
    /// Creates a new builder-style object to manufacture [`DocumentLimitExceeded`](crate::error::DocumentLimitExceeded)
    pub fn builder() -> crate::error::document_limit_exceeded::Builder {
        crate::error::document_limit_exceeded::Builder::default()
    }
}

/// <p>The specified token is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNextToken {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNextToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNextToken");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidNextToken {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextToken")?;
        if let Some(inner_80) = &self.message {
            write!(f, ": {}", inner_80)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextToken {}
/// See [`InvalidNextToken`](crate::error::InvalidNextToken)
pub mod invalid_next_token {
    /// A builder for [`InvalidNextToken`](crate::error::InvalidNextToken)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextToken`](crate::error::InvalidNextToken)
        pub fn build(self) -> crate::error::InvalidNextToken {
            crate::error::InvalidNextToken {
                message: self.message,
            }
        }
    }
}
impl InvalidNextToken {
    /// Creates a new builder-style object to manufacture [`InvalidNextToken`](crate::error::InvalidNextToken)
    pub fn builder() -> crate::error::invalid_next_token::Builder {
        crate::error::invalid_next_token::Builder::default()
    }
}

/// <p>The filter name is not valid. Verify the you entered the correct name and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidFilter {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidFilter");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidFilter {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFilter")?;
        if let Some(inner_81) = &self.message {
            write!(f, ": {}", inner_81)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFilter {}
/// See [`InvalidFilter`](crate::error::InvalidFilter)
pub mod invalid_filter {
    /// A builder for [`InvalidFilter`](crate::error::InvalidFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFilter`](crate::error::InvalidFilter)
        pub fn build(self) -> crate::error::InvalidFilter {
            crate::error::InvalidFilter {
                message: self.message,
            }
        }
    }
}
impl InvalidFilter {
    /// Creates a new builder-style object to manufacture [`InvalidFilter`](crate::error::InvalidFilter)
    pub fn builder() -> crate::error::invalid_filter::Builder {
        crate::error::invalid_filter::Builder::default()
    }
}

/// <p>The specified key is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidFilterKey {}
impl std::fmt::Debug for InvalidFilterKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidFilterKey");
        formatter.finish()
    }
}
impl InvalidFilterKey {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for InvalidFilterKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFilterKey")?;
        Ok(())
    }
}
impl std::error::Error for InvalidFilterKey {}
/// See [`InvalidFilterKey`](crate::error::InvalidFilterKey)
pub mod invalid_filter_key {
    /// A builder for [`InvalidFilterKey`](crate::error::InvalidFilterKey)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`InvalidFilterKey`](crate::error::InvalidFilterKey)
        pub fn build(self) -> crate::error::InvalidFilterKey {
            crate::error::InvalidFilterKey {}
        }
    }
}
impl InvalidFilterKey {
    /// Creates a new builder-style object to manufacture [`InvalidFilterKey`](crate::error::InvalidFilterKey)
    pub fn builder() -> crate::error::invalid_filter_key::Builder {
        crate::error::invalid_filter_key::Builder::default()
    }
}

/// <p>The specified command ID is not valid. Verify the ID and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCommandId {}
impl std::fmt::Debug for InvalidCommandId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCommandId");
        formatter.finish()
    }
}
impl InvalidCommandId {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for InvalidCommandId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCommandId")?;
        Ok(())
    }
}
impl std::error::Error for InvalidCommandId {}
/// See [`InvalidCommandId`](crate::error::InvalidCommandId)
pub mod invalid_command_id {
    /// A builder for [`InvalidCommandId`](crate::error::InvalidCommandId)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`InvalidCommandId`](crate::error::InvalidCommandId)
        pub fn build(self) -> crate::error::InvalidCommandId {
            crate::error::InvalidCommandId {}
        }
    }
}
impl InvalidCommandId {
    /// Creates a new builder-style object to manufacture [`InvalidCommandId`](crate::error::InvalidCommandId)
    pub fn builder() -> crate::error::invalid_command_id::Builder {
        crate::error::invalid_command_id::Builder::default()
    }
}

/// <p>A parameter version can have a maximum of ten labels.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterVersionLabelLimitExceeded {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParameterVersionLabelLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterVersionLabelLimitExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ParameterVersionLabelLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParameterVersionLabelLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParameterVersionLabelLimitExceeded")?;
        if let Some(inner_82) = &self.message {
            write!(f, ": {}", inner_82)?;
        }
        Ok(())
    }
}
impl std::error::Error for ParameterVersionLabelLimitExceeded {}
/// See [`ParameterVersionLabelLimitExceeded`](crate::error::ParameterVersionLabelLimitExceeded)
pub mod parameter_version_label_limit_exceeded {
    /// A builder for [`ParameterVersionLabelLimitExceeded`](crate::error::ParameterVersionLabelLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterVersionLabelLimitExceeded`](crate::error::ParameterVersionLabelLimitExceeded)
        pub fn build(self) -> crate::error::ParameterVersionLabelLimitExceeded {
            crate::error::ParameterVersionLabelLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl ParameterVersionLabelLimitExceeded {
    /// Creates a new builder-style object to manufacture [`ParameterVersionLabelLimitExceeded`](crate::error::ParameterVersionLabelLimitExceeded)
    pub fn builder() -> crate::error::parameter_version_label_limit_exceeded::Builder {
        crate::error::parameter_version_label_limit_exceeded::Builder::default()
    }
}

/// <p>The filter value is not valid. Verify the value and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidFilterValue {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidFilterValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidFilterValue");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidFilterValue {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFilterValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFilterValue")?;
        if let Some(inner_83) = &self.message {
            write!(f, ": {}", inner_83)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFilterValue {}
/// See [`InvalidFilterValue`](crate::error::InvalidFilterValue)
pub mod invalid_filter_value {
    /// A builder for [`InvalidFilterValue`](crate::error::InvalidFilterValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFilterValue`](crate::error::InvalidFilterValue)
        pub fn build(self) -> crate::error::InvalidFilterValue {
            crate::error::InvalidFilterValue {
                message: self.message,
            }
        }
    }
}
impl InvalidFilterValue {
    /// Creates a new builder-style object to manufacture [`InvalidFilterValue`](crate::error::InvalidFilterValue)
    pub fn builder() -> crate::error::invalid_filter_value::Builder {
        crate::error::invalid_filter_value::Builder::default()
    }
}

/// <p>The specified filter option is not valid. Valid options are Equals and BeginsWith. For Path
/// filter, valid options are Recursive and OneLevel.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidFilterOption {
    /// <p>The specified filter option is not valid. Valid options are Equals and BeginsWith. For Path
    /// filter, valid options are Recursive and OneLevel.</p>
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidFilterOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidFilterOption");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidFilterOption {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFilterOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFilterOption")?;
        if let Some(inner_84) = &self.message {
            write!(f, ": {}", inner_84)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFilterOption {}
/// See [`InvalidFilterOption`](crate::error::InvalidFilterOption)
pub mod invalid_filter_option {
    /// A builder for [`InvalidFilterOption`](crate::error::InvalidFilterOption)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The specified filter option is not valid. Valid options are Equals and BeginsWith. For Path
        /// filter, valid options are Recursive and OneLevel.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFilterOption`](crate::error::InvalidFilterOption)
        pub fn build(self) -> crate::error::InvalidFilterOption {
            crate::error::InvalidFilterOption {
                message: self.message,
            }
        }
    }
}
impl InvalidFilterOption {
    /// Creates a new builder-style object to manufacture [`InvalidFilterOption`](crate::error::InvalidFilterOption)
    pub fn builder() -> crate::error::invalid_filter_option::Builder {
        crate::error::invalid_filter_option::Builder::default()
    }
}

/// <p>The specified aggregator is not valid for inventory groups. Verify that the aggregator uses
/// a valid inventory type such as <code>AWS:Application</code> or
/// <code>AWS:InstanceInformation</code>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAggregatorError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAggregatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAggregatorError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAggregatorError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAggregatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAggregatorError [InvalidAggregatorException]")?;
        if let Some(inner_85) = &self.message {
            write!(f, ": {}", inner_85)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAggregatorError {}
/// See [`InvalidAggregatorError`](crate::error::InvalidAggregatorError)
pub mod invalid_aggregator_error {
    /// A builder for [`InvalidAggregatorError`](crate::error::InvalidAggregatorError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAggregatorError`](crate::error::InvalidAggregatorError)
        pub fn build(self) -> crate::error::InvalidAggregatorError {
            crate::error::InvalidAggregatorError {
                message: self.message,
            }
        }
    }
}
impl InvalidAggregatorError {
    /// Creates a new builder-style object to manufacture [`InvalidAggregatorError`](crate::error::InvalidAggregatorError)
    pub fn builder() -> crate::error::invalid_aggregator_error::Builder {
        crate::error::invalid_aggregator_error::Builder::default()
    }
}

/// <p>The specified inventory item result attribute is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidResultAttributeError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidResultAttributeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidResultAttributeError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidResultAttributeError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidResultAttributeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidResultAttributeError [InvalidResultAttributeException]"
        )?;
        if let Some(inner_86) = &self.message {
            write!(f, ": {}", inner_86)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidResultAttributeError {}
/// See [`InvalidResultAttributeError`](crate::error::InvalidResultAttributeError)
pub mod invalid_result_attribute_error {
    /// A builder for [`InvalidResultAttributeError`](crate::error::InvalidResultAttributeError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidResultAttributeError`](crate::error::InvalidResultAttributeError)
        pub fn build(self) -> crate::error::InvalidResultAttributeError {
            crate::error::InvalidResultAttributeError {
                message: self.message,
            }
        }
    }
}
impl InvalidResultAttributeError {
    /// Creates a new builder-style object to manufacture [`InvalidResultAttributeError`](crate::error::InvalidResultAttributeError)
    pub fn builder() -> crate::error::invalid_result_attribute_error::Builder {
        crate::error::invalid_result_attribute_error::Builder::default()
    }
}

/// <p>The specified inventory group is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInventoryGroupError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidInventoryGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInventoryGroupError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidInventoryGroupError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInventoryGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidInventoryGroupError [InvalidInventoryGroupException]"
        )?;
        if let Some(inner_87) = &self.message {
            write!(f, ": {}", inner_87)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInventoryGroupError {}
/// See [`InvalidInventoryGroupError`](crate::error::InvalidInventoryGroupError)
pub mod invalid_inventory_group_error {
    /// A builder for [`InvalidInventoryGroupError`](crate::error::InvalidInventoryGroupError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInventoryGroupError`](crate::error::InvalidInventoryGroupError)
        pub fn build(self) -> crate::error::InvalidInventoryGroupError {
            crate::error::InvalidInventoryGroupError {
                message: self.message,
            }
        }
    }
}
impl InvalidInventoryGroupError {
    /// Creates a new builder-style object to manufacture [`InvalidInventoryGroupError`](crate::error::InvalidInventoryGroupError)
    pub fn builder() -> crate::error::invalid_inventory_group_error::Builder {
        crate::error::invalid_inventory_group_error::Builder::default()
    }
}

/// <p>The operating systems you specified is not supported, or the operation is not supported for
/// the operating system.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedOperatingSystem {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedOperatingSystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedOperatingSystem");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedOperatingSystem {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedOperatingSystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedOperatingSystem")?;
        if let Some(inner_88) = &self.message {
            write!(f, ": {}", inner_88)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedOperatingSystem {}
/// See [`UnsupportedOperatingSystem`](crate::error::UnsupportedOperatingSystem)
pub mod unsupported_operating_system {
    /// A builder for [`UnsupportedOperatingSystem`](crate::error::UnsupportedOperatingSystem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedOperatingSystem`](crate::error::UnsupportedOperatingSystem)
        pub fn build(self) -> crate::error::UnsupportedOperatingSystem {
            crate::error::UnsupportedOperatingSystem {
                message: self.message,
            }
        }
    }
}
impl UnsupportedOperatingSystem {
    /// Creates a new builder-style object to manufacture [`UnsupportedOperatingSystem`](crate::error::UnsupportedOperatingSystem)
    pub fn builder() -> crate::error::unsupported_operating_system::Builder {
        crate::error::unsupported_operating_system::Builder::default()
    }
}

/// <p>Microsoft application patching is only available on EC2 instances and advanced instances. To
/// patch Microsoft applications on on-premises servers and VMs, you must enable advanced instances.
/// For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-managedinstances-advanced.html">Using the
/// advanced-instances tier</a> in the <i>AWS Systems Manager User Guide</i>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedFeatureRequiredError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedFeatureRequiredError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedFeatureRequiredError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedFeatureRequiredError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedFeatureRequiredError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "UnsupportedFeatureRequiredError [UnsupportedFeatureRequiredException]"
        )?;
        if let Some(inner_89) = &self.message {
            write!(f, ": {}", inner_89)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedFeatureRequiredError {}
/// See [`UnsupportedFeatureRequiredError`](crate::error::UnsupportedFeatureRequiredError)
pub mod unsupported_feature_required_error {
    /// A builder for [`UnsupportedFeatureRequiredError`](crate::error::UnsupportedFeatureRequiredError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedFeatureRequiredError`](crate::error::UnsupportedFeatureRequiredError)
        pub fn build(self) -> crate::error::UnsupportedFeatureRequiredError {
            crate::error::UnsupportedFeatureRequiredError {
                message: self.message,
            }
        }
    }
}
impl UnsupportedFeatureRequiredError {
    /// Creates a new builder-style object to manufacture [`UnsupportedFeatureRequiredError`](crate::error::UnsupportedFeatureRequiredError)
    pub fn builder() -> crate::error::unsupported_feature_required_error::Builder {
        crate::error::unsupported_feature_required_error::Builder::default()
    }
}

/// <p>The command ID and instance ID you specified did not match any invocations. Verify the
/// command ID and the instance ID and try again. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvocationDoesNotExist {}
impl std::fmt::Debug for InvocationDoesNotExist {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvocationDoesNotExist");
        formatter.finish()
    }
}
impl InvocationDoesNotExist {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for InvocationDoesNotExist {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvocationDoesNotExist")?;
        Ok(())
    }
}
impl std::error::Error for InvocationDoesNotExist {}
/// See [`InvocationDoesNotExist`](crate::error::InvocationDoesNotExist)
pub mod invocation_does_not_exist {
    /// A builder for [`InvocationDoesNotExist`](crate::error::InvocationDoesNotExist)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`InvocationDoesNotExist`](crate::error::InvocationDoesNotExist)
        pub fn build(self) -> crate::error::InvocationDoesNotExist {
            crate::error::InvocationDoesNotExist {}
        }
    }
}
impl InvocationDoesNotExist {
    /// Creates a new builder-style object to manufacture [`InvocationDoesNotExist`](crate::error::InvocationDoesNotExist)
    pub fn builder() -> crate::error::invocation_does_not_exist::Builder {
        crate::error::invocation_does_not_exist::Builder::default()
    }
}

/// <p>The plugin name is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPluginName {}
impl std::fmt::Debug for InvalidPluginName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPluginName");
        formatter.finish()
    }
}
impl InvalidPluginName {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for InvalidPluginName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPluginName")?;
        Ok(())
    }
}
impl std::error::Error for InvalidPluginName {}
/// See [`InvalidPluginName`](crate::error::InvalidPluginName)
pub mod invalid_plugin_name {
    /// A builder for [`InvalidPluginName`](crate::error::InvalidPluginName)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`InvalidPluginName`](crate::error::InvalidPluginName)
        pub fn build(self) -> crate::error::InvalidPluginName {
            crate::error::InvalidPluginName {}
        }
    }
}
impl InvalidPluginName {
    /// Creates a new builder-style object to manufacture [`InvalidPluginName`](crate::error::InvalidPluginName)
    pub fn builder() -> crate::error::invalid_plugin_name::Builder {
        crate::error::invalid_plugin_name::Builder::default()
    }
}

/// <p>The calendar entry contained in the specified Systems Manager document is not supported.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedCalendarError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedCalendarError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedCalendarError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedCalendarError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedCalendarError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedCalendarError [UnsupportedCalendarException]")?;
        if let Some(inner_90) = &self.message {
            write!(f, ": {}", inner_90)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedCalendarError {}
/// See [`UnsupportedCalendarError`](crate::error::UnsupportedCalendarError)
pub mod unsupported_calendar_error {
    /// A builder for [`UnsupportedCalendarError`](crate::error::UnsupportedCalendarError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedCalendarError`](crate::error::UnsupportedCalendarError)
        pub fn build(self) -> crate::error::UnsupportedCalendarError {
            crate::error::UnsupportedCalendarError {
                message: self.message,
            }
        }
    }
}
impl UnsupportedCalendarError {
    /// Creates a new builder-style object to manufacture [`UnsupportedCalendarError`](crate::error::UnsupportedCalendarError)
    pub fn builder() -> crate::error::unsupported_calendar_error::Builder {
        crate::error::unsupported_calendar_error::Builder::default()
    }
}

/// <p>The document type is not valid. Valid document types are described in the
/// <code>DocumentType</code> property.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDocumentType {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDocumentType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDocumentType");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDocumentType {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDocumentType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDocumentType")?;
        if let Some(inner_91) = &self.message {
            write!(f, ": {}", inner_91)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDocumentType {}
/// See [`InvalidDocumentType`](crate::error::InvalidDocumentType)
pub mod invalid_document_type {
    /// A builder for [`InvalidDocumentType`](crate::error::InvalidDocumentType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDocumentType`](crate::error::InvalidDocumentType)
        pub fn build(self) -> crate::error::InvalidDocumentType {
            crate::error::InvalidDocumentType {
                message: self.message,
            }
        }
    }
}
impl InvalidDocumentType {
    /// Creates a new builder-style object to manufacture [`InvalidDocumentType`](crate::error::InvalidDocumentType)
    pub fn builder() -> crate::error::invalid_document_type::Builder {
        crate::error::invalid_document_type::Builder::default()
    }
}

/// <p>The association was not found using the parameters you specified in the call. Verify the
/// information and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemRelatedItemAssociationNotFoundError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsItemRelatedItemAssociationNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemRelatedItemAssociationNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OpsItemRelatedItemAssociationNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OpsItemRelatedItemAssociationNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OpsItemRelatedItemAssociationNotFoundError [OpsItemRelatedItemAssociationNotFoundException]")?;
        if let Some(inner_92) = &self.message {
            write!(f, ": {}", inner_92)?;
        }
        Ok(())
    }
}
impl std::error::Error for OpsItemRelatedItemAssociationNotFoundError {}
/// See [`OpsItemRelatedItemAssociationNotFoundError`](crate::error::OpsItemRelatedItemAssociationNotFoundError)
pub mod ops_item_related_item_association_not_found_error {
    /// A builder for [`OpsItemRelatedItemAssociationNotFoundError`](crate::error::OpsItemRelatedItemAssociationNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemRelatedItemAssociationNotFoundError`](crate::error::OpsItemRelatedItemAssociationNotFoundError)
        pub fn build(self) -> crate::error::OpsItemRelatedItemAssociationNotFoundError {
            crate::error::OpsItemRelatedItemAssociationNotFoundError {
                message: self.message,
            }
        }
    }
}
impl OpsItemRelatedItemAssociationNotFoundError {
    /// Creates a new builder-style object to manufacture [`OpsItemRelatedItemAssociationNotFoundError`](crate::error::OpsItemRelatedItemAssociationNotFoundError)
    pub fn builder() -> crate::error::ops_item_related_item_association_not_found_error::Builder {
        crate::error::ops_item_related_item_association_not_found_error::Builder::default()
    }
}

/// <p>The ID specified for the delete operation does not exist or is not valid. Verify the ID and
/// try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDeletionIdError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDeletionIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDeletionIdError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDeletionIdError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeletionIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeletionIdError [InvalidDeletionIdException]")?;
        if let Some(inner_93) = &self.message {
            write!(f, ": {}", inner_93)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeletionIdError {}
/// See [`InvalidDeletionIdError`](crate::error::InvalidDeletionIdError)
pub mod invalid_deletion_id_error {
    /// A builder for [`InvalidDeletionIdError`](crate::error::InvalidDeletionIdError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeletionIdError`](crate::error::InvalidDeletionIdError)
        pub fn build(self) -> crate::error::InvalidDeletionIdError {
            crate::error::InvalidDeletionIdError {
                message: self.message,
            }
        }
    }
}
impl InvalidDeletionIdError {
    /// Creates a new builder-style object to manufacture [`InvalidDeletionIdError`](crate::error::InvalidDeletionIdError)
    pub fn builder() -> crate::error::invalid_deletion_id_error::Builder {
        crate::error::invalid_deletion_id_error::Builder::default()
    }
}

/// <p>The specified filter value is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInstanceInformationFilterValue {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidInstanceInformationFilterValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInstanceInformationFilterValue");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidInstanceInformationFilterValue {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInstanceInformationFilterValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInstanceInformationFilterValue")?;
        if let Some(inner_94) = &self.message {
            write!(f, ": {}", inner_94)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInstanceInformationFilterValue {}
/// See [`InvalidInstanceInformationFilterValue`](crate::error::InvalidInstanceInformationFilterValue)
pub mod invalid_instance_information_filter_value {
    /// A builder for [`InvalidInstanceInformationFilterValue`](crate::error::InvalidInstanceInformationFilterValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInstanceInformationFilterValue`](crate::error::InvalidInstanceInformationFilterValue)
        pub fn build(self) -> crate::error::InvalidInstanceInformationFilterValue {
            crate::error::InvalidInstanceInformationFilterValue {
                message: self.message,
            }
        }
    }
}
impl InvalidInstanceInformationFilterValue {
    /// Creates a new builder-style object to manufacture [`InvalidInstanceInformationFilterValue`](crate::error::InvalidInstanceInformationFilterValue)
    pub fn builder() -> crate::error::invalid_instance_information_filter_value::Builder {
        crate::error::invalid_instance_information_filter_value::Builder::default()
    }
}

/// <p>The specified execution ID does not exist. Verify the ID number and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationExecutionDoesNotExist {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociationExecutionDoesNotExist {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationExecutionDoesNotExist");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AssociationExecutionDoesNotExist {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AssociationExecutionDoesNotExist {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AssociationExecutionDoesNotExist")?;
        if let Some(inner_95) = &self.message {
            write!(f, ": {}", inner_95)?;
        }
        Ok(())
    }
}
impl std::error::Error for AssociationExecutionDoesNotExist {}
/// See [`AssociationExecutionDoesNotExist`](crate::error::AssociationExecutionDoesNotExist)
pub mod association_execution_does_not_exist {
    /// A builder for [`AssociationExecutionDoesNotExist`](crate::error::AssociationExecutionDoesNotExist)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationExecutionDoesNotExist`](crate::error::AssociationExecutionDoesNotExist)
        pub fn build(self) -> crate::error::AssociationExecutionDoesNotExist {
            crate::error::AssociationExecutionDoesNotExist {
                message: self.message,
            }
        }
    }
}
impl AssociationExecutionDoesNotExist {
    /// Creates a new builder-style object to manufacture [`AssociationExecutionDoesNotExist`](crate::error::AssociationExecutionDoesNotExist)
    pub fn builder() -> crate::error::association_execution_does_not_exist::Builder {
        crate::error::association_execution_does_not_exist::Builder::default()
    }
}

/// <p>You specified the <code>Safe</code> option for the DeregisterTargetFromMaintenanceWindow
/// operation, but the target is still referenced in a task.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetInUseError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetInUseError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TargetInUseError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TargetInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TargetInUseError [TargetInUseException]")?;
        if let Some(inner_96) = &self.message {
            write!(f, ": {}", inner_96)?;
        }
        Ok(())
    }
}
impl std::error::Error for TargetInUseError {}
/// See [`TargetInUseError`](crate::error::TargetInUseError)
pub mod target_in_use_error {
    /// A builder for [`TargetInUseError`](crate::error::TargetInUseError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetInUseError`](crate::error::TargetInUseError)
        pub fn build(self) -> crate::error::TargetInUseError {
            crate::error::TargetInUseError {
                message: self.message,
            }
        }
    }
}
impl TargetInUseError {
    /// Creates a new builder-style object to manufacture [`TargetInUseError`](crate::error::TargetInUseError)
    pub fn builder() -> crate::error::target_in_use_error::Builder {
        crate::error::target_in_use_error::Builder::default()
    }
}

/// <p>Error returned if an attempt is made to delete a patch baseline that is registered for a
/// patch group.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceInUseError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseError [ResourceInUseException]")?;
        if let Some(inner_97) = &self.message {
            write!(f, ": {}", inner_97)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseError {}
/// See [`ResourceInUseError`](crate::error::ResourceInUseError)
pub mod resource_in_use_error {
    /// A builder for [`ResourceInUseError`](crate::error::ResourceInUseError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseError`](crate::error::ResourceInUseError)
        pub fn build(self) -> crate::error::ResourceInUseError {
            crate::error::ResourceInUseError {
                message: self.message,
            }
        }
    }
}
impl ResourceInUseError {
    /// Creates a new builder-style object to manufacture [`ResourceInUseError`](crate::error::ResourceInUseError)
    pub fn builder() -> crate::error::resource_in_use_error::Builder {
        crate::error::resource_in_use_error::Builder::default()
    }
}

/// <p>The delete inventory option specified is not valid. Verify the option and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOptionError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidOptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOptionError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidOptionError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOptionError [InvalidOptionException]")?;
        if let Some(inner_98) = &self.message {
            write!(f, ": {}", inner_98)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOptionError {}
/// See [`InvalidOptionError`](crate::error::InvalidOptionError)
pub mod invalid_option_error {
    /// A builder for [`InvalidOptionError`](crate::error::InvalidOptionError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOptionError`](crate::error::InvalidOptionError)
        pub fn build(self) -> crate::error::InvalidOptionError {
            crate::error::InvalidOptionError {
                message: self.message,
            }
        }
    }
}
impl InvalidOptionError {
    /// Creates a new builder-style object to manufacture [`InvalidOptionError`](crate::error::InvalidOptionError)
    pub fn builder() -> crate::error::invalid_option_error::Builder {
        crate::error::invalid_option_error::Builder::default()
    }
}

/// <p>The request is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInventoryRequestError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidInventoryRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInventoryRequestError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidInventoryRequestError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInventoryRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidInventoryRequestError [InvalidInventoryRequestException]"
        )?;
        if let Some(inner_99) = &self.message {
            write!(f, ": {}", inner_99)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInventoryRequestError {}
/// See [`InvalidInventoryRequestError`](crate::error::InvalidInventoryRequestError)
pub mod invalid_inventory_request_error {
    /// A builder for [`InvalidInventoryRequestError`](crate::error::InvalidInventoryRequestError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInventoryRequestError`](crate::error::InvalidInventoryRequestError)
        pub fn build(self) -> crate::error::InvalidInventoryRequestError {
            crate::error::InvalidInventoryRequestError {
                message: self.message,
            }
        }
    }
}
impl InvalidInventoryRequestError {
    /// Creates a new builder-style object to manufacture [`InvalidInventoryRequestError`](crate::error::InvalidInventoryRequestError)
    pub fn builder() -> crate::error::invalid_inventory_request_error::Builder {
        crate::error::invalid_inventory_request_error::Builder::default()
    }
}

/// <p>One or more of the parameters specified for the delete operation is not valid. Verify all
/// parameters and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDeleteInventoryParametersError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDeleteInventoryParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDeleteInventoryParametersError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDeleteInventoryParametersError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeleteInventoryParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDeleteInventoryParametersError [InvalidDeleteInventoryParametersException]"
        )?;
        if let Some(inner_100) = &self.message {
            write!(f, ": {}", inner_100)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeleteInventoryParametersError {}
/// See [`InvalidDeleteInventoryParametersError`](crate::error::InvalidDeleteInventoryParametersError)
pub mod invalid_delete_inventory_parameters_error {
    /// A builder for [`InvalidDeleteInventoryParametersError`](crate::error::InvalidDeleteInventoryParametersError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeleteInventoryParametersError`](crate::error::InvalidDeleteInventoryParametersError)
        pub fn build(self) -> crate::error::InvalidDeleteInventoryParametersError {
            crate::error::InvalidDeleteInventoryParametersError {
                message: self.message,
            }
        }
    }
}
impl InvalidDeleteInventoryParametersError {
    /// Creates a new builder-style object to manufacture [`InvalidDeleteInventoryParametersError`](crate::error::InvalidDeleteInventoryParametersError)
    pub fn builder() -> crate::error::invalid_delete_inventory_parameters_error::Builder {
        crate::error::invalid_delete_inventory_parameters_error::Builder::default()
    }
}

/// <p>You must disassociate a document from all instances before you can delete it.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociatedInstances {}
impl std::fmt::Debug for AssociatedInstances {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociatedInstances");
        formatter.finish()
    }
}
impl AssociatedInstances {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for AssociatedInstances {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AssociatedInstances")?;
        Ok(())
    }
}
impl std::error::Error for AssociatedInstances {}
/// See [`AssociatedInstances`](crate::error::AssociatedInstances)
pub mod associated_instances {
    /// A builder for [`AssociatedInstances`](crate::error::AssociatedInstances)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`AssociatedInstances`](crate::error::AssociatedInstances)
        pub fn build(self) -> crate::error::AssociatedInstances {
            crate::error::AssociatedInstances {}
        }
    }
}
impl AssociatedInstances {
    /// Creates a new builder-style object to manufacture [`AssociatedInstances`](crate::error::AssociatedInstances)
    pub fn builder() -> crate::error::associated_instances::Builder {
        crate::error::associated_instances::Builder::default()
    }
}

/// <p>The activation ID is not valid. Verify the you entered the correct ActivationId or
/// ActivationCode and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidActivationId {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidActivationId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidActivationId");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidActivationId {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidActivationId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidActivationId")?;
        if let Some(inner_101) = &self.message {
            write!(f, ": {}", inner_101)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidActivationId {}
/// See [`InvalidActivationId`](crate::error::InvalidActivationId)
pub mod invalid_activation_id {
    /// A builder for [`InvalidActivationId`](crate::error::InvalidActivationId)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidActivationId`](crate::error::InvalidActivationId)
        pub fn build(self) -> crate::error::InvalidActivationId {
            crate::error::InvalidActivationId {
                message: self.message,
            }
        }
    }
}
impl InvalidActivationId {
    /// Creates a new builder-style object to manufacture [`InvalidActivationId`](crate::error::InvalidActivationId)
    pub fn builder() -> crate::error::invalid_activation_id::Builder {
        crate::error::invalid_activation_id::Builder::default()
    }
}

/// <p>The activation is not valid. The activation might have been deleted, or the ActivationId and
/// the ActivationCode do not match.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidActivation {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidActivation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidActivation");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidActivation {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidActivation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidActivation")?;
        if let Some(inner_102) = &self.message {
            write!(f, ": {}", inner_102)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidActivation {}
/// See [`InvalidActivation`](crate::error::InvalidActivation)
pub mod invalid_activation {
    /// A builder for [`InvalidActivation`](crate::error::InvalidActivation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidActivation`](crate::error::InvalidActivation)
        pub fn build(self) -> crate::error::InvalidActivation {
            crate::error::InvalidActivation {
                message: self.message,
            }
        }
    }
}
impl InvalidActivation {
    /// Creates a new builder-style object to manufacture [`InvalidActivation`](crate::error::InvalidActivation)
    pub fn builder() -> crate::error::invalid_activation::Builder {
        crate::error::invalid_activation::Builder::default()
    }
}

/// <p>You have exceeded the allowed maximum sync configurations.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDataSyncCountExceededError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceDataSyncCountExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDataSyncCountExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceDataSyncCountExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceDataSyncCountExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ResourceDataSyncCountExceededError [ResourceDataSyncCountExceededException]"
        )?;
        if let Some(inner_103) = &self.message {
            write!(f, ": {}", inner_103)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceDataSyncCountExceededError {}
/// See [`ResourceDataSyncCountExceededError`](crate::error::ResourceDataSyncCountExceededError)
pub mod resource_data_sync_count_exceeded_error {
    /// A builder for [`ResourceDataSyncCountExceededError`](crate::error::ResourceDataSyncCountExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDataSyncCountExceededError`](crate::error::ResourceDataSyncCountExceededError)
        pub fn build(self) -> crate::error::ResourceDataSyncCountExceededError {
            crate::error::ResourceDataSyncCountExceededError {
                message: self.message,
            }
        }
    }
}
impl ResourceDataSyncCountExceededError {
    /// Creates a new builder-style object to manufacture [`ResourceDataSyncCountExceededError`](crate::error::ResourceDataSyncCountExceededError)
    pub fn builder() -> crate::error::resource_data_sync_count_exceeded_error::Builder {
        crate::error::resource_data_sync_count_exceeded_error::Builder::default()
    }
}

/// <p>A sync configuration with the same name already exists.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDataSyncAlreadyExistsError {
    #[serde(rename = "SyncName")]
    #[serde(default)]
    pub sync_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceDataSyncAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDataSyncAlreadyExistsError");
        formatter.field("sync_name", &self.sync_name);
        formatter.finish()
    }
}
impl ResourceDataSyncAlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for ResourceDataSyncAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ResourceDataSyncAlreadyExistsError [ResourceDataSyncAlreadyExistsException]"
        )?;
        Ok(())
    }
}
impl std::error::Error for ResourceDataSyncAlreadyExistsError {}
/// See [`ResourceDataSyncAlreadyExistsError`](crate::error::ResourceDataSyncAlreadyExistsError)
pub mod resource_data_sync_already_exists_error {
    /// A builder for [`ResourceDataSyncAlreadyExistsError`](crate::error::ResourceDataSyncAlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sync_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn sync_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.sync_name = Some(input.into());
            self
        }
        pub fn set_sync_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sync_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDataSyncAlreadyExistsError`](crate::error::ResourceDataSyncAlreadyExistsError)
        pub fn build(self) -> crate::error::ResourceDataSyncAlreadyExistsError {
            crate::error::ResourceDataSyncAlreadyExistsError {
                sync_name: self.sync_name,
            }
        }
    }
}
impl ResourceDataSyncAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`ResourceDataSyncAlreadyExistsError`](crate::error::ResourceDataSyncAlreadyExistsError)
    pub fn builder() -> crate::error::resource_data_sync_already_exists_error::Builder {
        crate::error::resource_data_sync_already_exists_error::Builder::default()
    }
}

/// <p>Your account reached the maximum number of OpsMetadata objects allowed by Application Manager. The
/// maximum is 200 OpsMetadata objects. Delete one or more OpsMetadata object and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsMetadataLimitExceededError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsMetadataLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsMetadataLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OpsMetadataLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OpsMetadataLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "OpsMetadataLimitExceededError [OpsMetadataLimitExceededException]"
        )?;
        if let Some(inner_104) = &self.message {
            write!(f, ": {}", inner_104)?;
        }
        Ok(())
    }
}
impl std::error::Error for OpsMetadataLimitExceededError {}
/// See [`OpsMetadataLimitExceededError`](crate::error::OpsMetadataLimitExceededError)
pub mod ops_metadata_limit_exceeded_error {
    /// A builder for [`OpsMetadataLimitExceededError`](crate::error::OpsMetadataLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsMetadataLimitExceededError`](crate::error::OpsMetadataLimitExceededError)
        pub fn build(self) -> crate::error::OpsMetadataLimitExceededError {
            crate::error::OpsMetadataLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl OpsMetadataLimitExceededError {
    /// Creates a new builder-style object to manufacture [`OpsMetadataLimitExceededError`](crate::error::OpsMetadataLimitExceededError)
    pub fn builder() -> crate::error::ops_metadata_limit_exceeded_error::Builder {
        crate::error::ops_metadata_limit_exceeded_error::Builder::default()
    }
}

/// <p>An OpsMetadata object already exists for the selected resource.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsMetadataAlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsMetadataAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsMetadataAlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OpsMetadataAlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OpsMetadataAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "OpsMetadataAlreadyExistsError [OpsMetadataAlreadyExistsException]"
        )?;
        if let Some(inner_105) = &self.message {
            write!(f, ": {}", inner_105)?;
        }
        Ok(())
    }
}
impl std::error::Error for OpsMetadataAlreadyExistsError {}
/// See [`OpsMetadataAlreadyExistsError`](crate::error::OpsMetadataAlreadyExistsError)
pub mod ops_metadata_already_exists_error {
    /// A builder for [`OpsMetadataAlreadyExistsError`](crate::error::OpsMetadataAlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsMetadataAlreadyExistsError`](crate::error::OpsMetadataAlreadyExistsError)
        pub fn build(self) -> crate::error::OpsMetadataAlreadyExistsError {
            crate::error::OpsMetadataAlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl OpsMetadataAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`OpsMetadataAlreadyExistsError`](crate::error::OpsMetadataAlreadyExistsError)
    pub fn builder() -> crate::error::ops_metadata_already_exists_error::Builder {
        crate::error::ops_metadata_already_exists_error::Builder::default()
    }
}

/// <p>The specified document already exists.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentAlreadyExists {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DocumentAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentAlreadyExists");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DocumentAlreadyExists {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DocumentAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DocumentAlreadyExists")?;
        if let Some(inner_106) = &self.message {
            write!(f, ": {}", inner_106)?;
        }
        Ok(())
    }
}
impl std::error::Error for DocumentAlreadyExists {}
/// See [`DocumentAlreadyExists`](crate::error::DocumentAlreadyExists)
pub mod document_already_exists {
    /// A builder for [`DocumentAlreadyExists`](crate::error::DocumentAlreadyExists)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentAlreadyExists`](crate::error::DocumentAlreadyExists)
        pub fn build(self) -> crate::error::DocumentAlreadyExists {
            crate::error::DocumentAlreadyExists {
                message: self.message,
            }
        }
    }
}
impl DocumentAlreadyExists {
    /// Creates a new builder-style object to manufacture [`DocumentAlreadyExists`](crate::error::DocumentAlreadyExists)
    pub fn builder() -> crate::error::document_already_exists::Builder {
        crate::error::document_already_exists::Builder::default()
    }
}

/// <p>You can have at most 2,000 active associations.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationLimitExceeded {}
impl std::fmt::Debug for AssociationLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationLimitExceeded");
        formatter.finish()
    }
}
impl AssociationLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for AssociationLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AssociationLimitExceeded")?;
        Ok(())
    }
}
impl std::error::Error for AssociationLimitExceeded {}
/// See [`AssociationLimitExceeded`](crate::error::AssociationLimitExceeded)
pub mod association_limit_exceeded {
    /// A builder for [`AssociationLimitExceeded`](crate::error::AssociationLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`AssociationLimitExceeded`](crate::error::AssociationLimitExceeded)
        pub fn build(self) -> crate::error::AssociationLimitExceeded {
            crate::error::AssociationLimitExceeded {}
        }
    }
}
impl AssociationLimitExceeded {
    /// Creates a new builder-style object to manufacture [`AssociationLimitExceeded`](crate::error::AssociationLimitExceeded)
    pub fn builder() -> crate::error::association_limit_exceeded::Builder {
        crate::error::association_limit_exceeded::Builder::default()
    }
}

/// <p>The specified association already exists.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationAlreadyExists {}
impl std::fmt::Debug for AssociationAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationAlreadyExists");
        formatter.finish()
    }
}
impl AssociationAlreadyExists {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for AssociationAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AssociationAlreadyExists")?;
        Ok(())
    }
}
impl std::error::Error for AssociationAlreadyExists {}
/// See [`AssociationAlreadyExists`](crate::error::AssociationAlreadyExists)
pub mod association_already_exists {
    /// A builder for [`AssociationAlreadyExists`](crate::error::AssociationAlreadyExists)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`AssociationAlreadyExists`](crate::error::AssociationAlreadyExists)
        pub fn build(self) -> crate::error::AssociationAlreadyExists {
            crate::error::AssociationAlreadyExists {}
        }
    }
}
impl AssociationAlreadyExists {
    /// Creates a new builder-style object to manufacture [`AssociationAlreadyExists`](crate::error::AssociationAlreadyExists)
    pub fn builder() -> crate::error::association_already_exists::Builder {
        crate::error::association_already_exists::Builder::default()
    }
}

/// <p>The Amazon Resource Name (ARN) is already associated with the OpsItem.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemRelatedItemAlreadyExistsError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
    #[serde(rename = "ResourceUri")]
    #[serde(default)]
    pub resource_uri: std::option::Option<std::string::String>,
    #[serde(rename = "OpsItemId")]
    #[serde(default)]
    pub ops_item_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsItemRelatedItemAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemRelatedItemAlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.field("resource_uri", &self.resource_uri);
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.finish()
    }
}
impl OpsItemRelatedItemAlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OpsItemRelatedItemAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "OpsItemRelatedItemAlreadyExistsError [OpsItemRelatedItemAlreadyExistsException]"
        )?;
        if let Some(inner_107) = &self.message {
            write!(f, ": {}", inner_107)?;
        }
        Ok(())
    }
}
impl std::error::Error for OpsItemRelatedItemAlreadyExistsError {}
/// See [`OpsItemRelatedItemAlreadyExistsError`](crate::error::OpsItemRelatedItemAlreadyExistsError)
pub mod ops_item_related_item_already_exists_error {
    /// A builder for [`OpsItemRelatedItemAlreadyExistsError`](crate::error::OpsItemRelatedItemAlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_uri: std::option::Option<std::string::String>,
        pub(crate) ops_item_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn resource_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_uri = Some(input.into());
            self
        }
        pub fn set_resource_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_uri = input;
            self
        }
        pub fn ops_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ops_item_id = Some(input.into());
            self
        }
        pub fn set_ops_item_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ops_item_id = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemRelatedItemAlreadyExistsError`](crate::error::OpsItemRelatedItemAlreadyExistsError)
        pub fn build(self) -> crate::error::OpsItemRelatedItemAlreadyExistsError {
            crate::error::OpsItemRelatedItemAlreadyExistsError {
                message: self.message,
                resource_uri: self.resource_uri,
                ops_item_id: self.ops_item_id,
            }
        }
    }
}
impl OpsItemRelatedItemAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`OpsItemRelatedItemAlreadyExistsError`](crate::error::OpsItemRelatedItemAlreadyExistsError)
    pub fn builder() -> crate::error::ops_item_related_item_already_exists_error::Builder {
        crate::error::ops_item_related_item_already_exists_error::Builder::default()
    }
}

/// <p>The <code>Targets</code> parameter includes too many tags. Remove one or more tags and try
/// the command again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyTagsError {}
impl std::fmt::Debug for TooManyTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyTagsError");
        formatter.finish()
    }
}
impl TooManyTagsError {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for TooManyTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTagsError")?;
        Ok(())
    }
}
impl std::error::Error for TooManyTagsError {}
/// See [`TooManyTagsError`](crate::error::TooManyTagsError)
pub mod too_many_tags_error {
    /// A builder for [`TooManyTagsError`](crate::error::TooManyTagsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`TooManyTagsError`](crate::error::TooManyTagsError)
        pub fn build(self) -> crate::error::TooManyTagsError {
            crate::error::TooManyTagsError {}
        }
    }
}
impl TooManyTagsError {
    /// Creates a new builder-style object to manufacture [`TooManyTagsError`](crate::error::TooManyTagsError)
    pub fn builder() -> crate::error::too_many_tags_error::Builder {
        crate::error::too_many_tags_error::Builder::default()
    }
}
