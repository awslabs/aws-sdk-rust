// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

#[derive(std::fmt::Debug)]
pub(crate) struct Handle {
    client: aws_hyper::Client<aws_hyper::conn::Standard>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client {
    handle: std::sync::Arc<Handle>,
}

impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf_conn(
            crate::Config::builder().build(),
            aws_hyper::conn::Standard::https(),
        )
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        Self::from_conf_conn(conf, aws_hyper::conn::Standard::https())
    }

    pub fn from_conf_conn(conf: crate::Config, conn: aws_hyper::conn::Standard) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }

    pub fn add_tags_to_resource(&self) -> fluent_builders::AddTagsToResource {
        fluent_builders::AddTagsToResource::new(self.handle.clone())
    }

    pub fn associate_ops_item_related_item(&self) -> fluent_builders::AssociateOpsItemRelatedItem {
        fluent_builders::AssociateOpsItemRelatedItem::new(self.handle.clone())
    }

    pub fn cancel_command(&self) -> fluent_builders::CancelCommand {
        fluent_builders::CancelCommand::new(self.handle.clone())
    }

    pub fn cancel_maintenance_window_execution(
        &self,
    ) -> fluent_builders::CancelMaintenanceWindowExecution {
        fluent_builders::CancelMaintenanceWindowExecution::new(self.handle.clone())
    }

    pub fn create_activation(&self) -> fluent_builders::CreateActivation {
        fluent_builders::CreateActivation::new(self.handle.clone())
    }

    pub fn create_association(&self) -> fluent_builders::CreateAssociation {
        fluent_builders::CreateAssociation::new(self.handle.clone())
    }

    pub fn create_association_batch(&self) -> fluent_builders::CreateAssociationBatch {
        fluent_builders::CreateAssociationBatch::new(self.handle.clone())
    }

    pub fn create_document(&self) -> fluent_builders::CreateDocument {
        fluent_builders::CreateDocument::new(self.handle.clone())
    }

    pub fn create_maintenance_window(&self) -> fluent_builders::CreateMaintenanceWindow {
        fluent_builders::CreateMaintenanceWindow::new(self.handle.clone())
    }

    pub fn create_ops_item(&self) -> fluent_builders::CreateOpsItem {
        fluent_builders::CreateOpsItem::new(self.handle.clone())
    }

    pub fn create_ops_metadata(&self) -> fluent_builders::CreateOpsMetadata {
        fluent_builders::CreateOpsMetadata::new(self.handle.clone())
    }

    pub fn create_patch_baseline(&self) -> fluent_builders::CreatePatchBaseline {
        fluent_builders::CreatePatchBaseline::new(self.handle.clone())
    }

    pub fn create_resource_data_sync(&self) -> fluent_builders::CreateResourceDataSync {
        fluent_builders::CreateResourceDataSync::new(self.handle.clone())
    }

    pub fn delete_activation(&self) -> fluent_builders::DeleteActivation {
        fluent_builders::DeleteActivation::new(self.handle.clone())
    }

    pub fn delete_association(&self) -> fluent_builders::DeleteAssociation {
        fluent_builders::DeleteAssociation::new(self.handle.clone())
    }

    pub fn delete_document(&self) -> fluent_builders::DeleteDocument {
        fluent_builders::DeleteDocument::new(self.handle.clone())
    }

    pub fn delete_inventory(&self) -> fluent_builders::DeleteInventory {
        fluent_builders::DeleteInventory::new(self.handle.clone())
    }

    pub fn delete_maintenance_window(&self) -> fluent_builders::DeleteMaintenanceWindow {
        fluent_builders::DeleteMaintenanceWindow::new(self.handle.clone())
    }

    pub fn delete_ops_metadata(&self) -> fluent_builders::DeleteOpsMetadata {
        fluent_builders::DeleteOpsMetadata::new(self.handle.clone())
    }

    pub fn delete_parameter(&self) -> fluent_builders::DeleteParameter {
        fluent_builders::DeleteParameter::new(self.handle.clone())
    }

    pub fn delete_parameters(&self) -> fluent_builders::DeleteParameters {
        fluent_builders::DeleteParameters::new(self.handle.clone())
    }

    pub fn delete_patch_baseline(&self) -> fluent_builders::DeletePatchBaseline {
        fluent_builders::DeletePatchBaseline::new(self.handle.clone())
    }

    pub fn delete_resource_data_sync(&self) -> fluent_builders::DeleteResourceDataSync {
        fluent_builders::DeleteResourceDataSync::new(self.handle.clone())
    }

    pub fn deregister_managed_instance(&self) -> fluent_builders::DeregisterManagedInstance {
        fluent_builders::DeregisterManagedInstance::new(self.handle.clone())
    }

    pub fn deregister_patch_baseline_for_patch_group(
        &self,
    ) -> fluent_builders::DeregisterPatchBaselineForPatchGroup {
        fluent_builders::DeregisterPatchBaselineForPatchGroup::new(self.handle.clone())
    }

    pub fn deregister_target_from_maintenance_window(
        &self,
    ) -> fluent_builders::DeregisterTargetFromMaintenanceWindow {
        fluent_builders::DeregisterTargetFromMaintenanceWindow::new(self.handle.clone())
    }

    pub fn deregister_task_from_maintenance_window(
        &self,
    ) -> fluent_builders::DeregisterTaskFromMaintenanceWindow {
        fluent_builders::DeregisterTaskFromMaintenanceWindow::new(self.handle.clone())
    }

    pub fn describe_activations(&self) -> fluent_builders::DescribeActivations {
        fluent_builders::DescribeActivations::new(self.handle.clone())
    }

    pub fn describe_association(&self) -> fluent_builders::DescribeAssociation {
        fluent_builders::DescribeAssociation::new(self.handle.clone())
    }

    pub fn describe_association_executions(
        &self,
    ) -> fluent_builders::DescribeAssociationExecutions {
        fluent_builders::DescribeAssociationExecutions::new(self.handle.clone())
    }

    pub fn describe_association_execution_targets(
        &self,
    ) -> fluent_builders::DescribeAssociationExecutionTargets {
        fluent_builders::DescribeAssociationExecutionTargets::new(self.handle.clone())
    }

    pub fn describe_automation_executions(&self) -> fluent_builders::DescribeAutomationExecutions {
        fluent_builders::DescribeAutomationExecutions::new(self.handle.clone())
    }

    pub fn describe_automation_step_executions(
        &self,
    ) -> fluent_builders::DescribeAutomationStepExecutions {
        fluent_builders::DescribeAutomationStepExecutions::new(self.handle.clone())
    }

    pub fn describe_available_patches(&self) -> fluent_builders::DescribeAvailablePatches {
        fluent_builders::DescribeAvailablePatches::new(self.handle.clone())
    }

    pub fn describe_document(&self) -> fluent_builders::DescribeDocument {
        fluent_builders::DescribeDocument::new(self.handle.clone())
    }

    pub fn describe_document_permission(&self) -> fluent_builders::DescribeDocumentPermission {
        fluent_builders::DescribeDocumentPermission::new(self.handle.clone())
    }

    pub fn describe_effective_instance_associations(
        &self,
    ) -> fluent_builders::DescribeEffectiveInstanceAssociations {
        fluent_builders::DescribeEffectiveInstanceAssociations::new(self.handle.clone())
    }

    pub fn describe_effective_patches_for_patch_baseline(
        &self,
    ) -> fluent_builders::DescribeEffectivePatchesForPatchBaseline {
        fluent_builders::DescribeEffectivePatchesForPatchBaseline::new(self.handle.clone())
    }

    pub fn describe_instance_associations_status(
        &self,
    ) -> fluent_builders::DescribeInstanceAssociationsStatus {
        fluent_builders::DescribeInstanceAssociationsStatus::new(self.handle.clone())
    }

    pub fn describe_instance_information(&self) -> fluent_builders::DescribeInstanceInformation {
        fluent_builders::DescribeInstanceInformation::new(self.handle.clone())
    }

    pub fn describe_instance_patches(&self) -> fluent_builders::DescribeInstancePatches {
        fluent_builders::DescribeInstancePatches::new(self.handle.clone())
    }

    pub fn describe_instance_patch_states(&self) -> fluent_builders::DescribeInstancePatchStates {
        fluent_builders::DescribeInstancePatchStates::new(self.handle.clone())
    }

    pub fn describe_instance_patch_states_for_patch_group(
        &self,
    ) -> fluent_builders::DescribeInstancePatchStatesForPatchGroup {
        fluent_builders::DescribeInstancePatchStatesForPatchGroup::new(self.handle.clone())
    }

    pub fn describe_inventory_deletions(&self) -> fluent_builders::DescribeInventoryDeletions {
        fluent_builders::DescribeInventoryDeletions::new(self.handle.clone())
    }

    pub fn describe_maintenance_window_executions(
        &self,
    ) -> fluent_builders::DescribeMaintenanceWindowExecutions {
        fluent_builders::DescribeMaintenanceWindowExecutions::new(self.handle.clone())
    }

    pub fn describe_maintenance_window_execution_task_invocations(
        &self,
    ) -> fluent_builders::DescribeMaintenanceWindowExecutionTaskInvocations {
        fluent_builders::DescribeMaintenanceWindowExecutionTaskInvocations::new(self.handle.clone())
    }

    pub fn describe_maintenance_window_execution_tasks(
        &self,
    ) -> fluent_builders::DescribeMaintenanceWindowExecutionTasks {
        fluent_builders::DescribeMaintenanceWindowExecutionTasks::new(self.handle.clone())
    }

    pub fn describe_maintenance_windows(&self) -> fluent_builders::DescribeMaintenanceWindows {
        fluent_builders::DescribeMaintenanceWindows::new(self.handle.clone())
    }

    pub fn describe_maintenance_window_schedule(
        &self,
    ) -> fluent_builders::DescribeMaintenanceWindowSchedule {
        fluent_builders::DescribeMaintenanceWindowSchedule::new(self.handle.clone())
    }

    pub fn describe_maintenance_windows_for_target(
        &self,
    ) -> fluent_builders::DescribeMaintenanceWindowsForTarget {
        fluent_builders::DescribeMaintenanceWindowsForTarget::new(self.handle.clone())
    }

    pub fn describe_maintenance_window_targets(
        &self,
    ) -> fluent_builders::DescribeMaintenanceWindowTargets {
        fluent_builders::DescribeMaintenanceWindowTargets::new(self.handle.clone())
    }

    pub fn describe_maintenance_window_tasks(
        &self,
    ) -> fluent_builders::DescribeMaintenanceWindowTasks {
        fluent_builders::DescribeMaintenanceWindowTasks::new(self.handle.clone())
    }

    pub fn describe_ops_items(&self) -> fluent_builders::DescribeOpsItems {
        fluent_builders::DescribeOpsItems::new(self.handle.clone())
    }

    pub fn describe_parameters(&self) -> fluent_builders::DescribeParameters {
        fluent_builders::DescribeParameters::new(self.handle.clone())
    }

    pub fn describe_patch_baselines(&self) -> fluent_builders::DescribePatchBaselines {
        fluent_builders::DescribePatchBaselines::new(self.handle.clone())
    }

    pub fn describe_patch_groups(&self) -> fluent_builders::DescribePatchGroups {
        fluent_builders::DescribePatchGroups::new(self.handle.clone())
    }

    pub fn describe_patch_group_state(&self) -> fluent_builders::DescribePatchGroupState {
        fluent_builders::DescribePatchGroupState::new(self.handle.clone())
    }

    pub fn describe_patch_properties(&self) -> fluent_builders::DescribePatchProperties {
        fluent_builders::DescribePatchProperties::new(self.handle.clone())
    }

    pub fn describe_sessions(&self) -> fluent_builders::DescribeSessions {
        fluent_builders::DescribeSessions::new(self.handle.clone())
    }

    pub fn disassociate_ops_item_related_item(
        &self,
    ) -> fluent_builders::DisassociateOpsItemRelatedItem {
        fluent_builders::DisassociateOpsItemRelatedItem::new(self.handle.clone())
    }

    pub fn get_automation_execution(&self) -> fluent_builders::GetAutomationExecution {
        fluent_builders::GetAutomationExecution::new(self.handle.clone())
    }

    pub fn get_calendar_state(&self) -> fluent_builders::GetCalendarState {
        fluent_builders::GetCalendarState::new(self.handle.clone())
    }

    pub fn get_command_invocation(&self) -> fluent_builders::GetCommandInvocation {
        fluent_builders::GetCommandInvocation::new(self.handle.clone())
    }

    pub fn get_connection_status(&self) -> fluent_builders::GetConnectionStatus {
        fluent_builders::GetConnectionStatus::new(self.handle.clone())
    }

    pub fn get_default_patch_baseline(&self) -> fluent_builders::GetDefaultPatchBaseline {
        fluent_builders::GetDefaultPatchBaseline::new(self.handle.clone())
    }

    pub fn get_deployable_patch_snapshot_for_instance(
        &self,
    ) -> fluent_builders::GetDeployablePatchSnapshotForInstance {
        fluent_builders::GetDeployablePatchSnapshotForInstance::new(self.handle.clone())
    }

    pub fn get_document(&self) -> fluent_builders::GetDocument {
        fluent_builders::GetDocument::new(self.handle.clone())
    }

    pub fn get_inventory(&self) -> fluent_builders::GetInventory {
        fluent_builders::GetInventory::new(self.handle.clone())
    }

    pub fn get_inventory_schema(&self) -> fluent_builders::GetInventorySchema {
        fluent_builders::GetInventorySchema::new(self.handle.clone())
    }

    pub fn get_maintenance_window(&self) -> fluent_builders::GetMaintenanceWindow {
        fluent_builders::GetMaintenanceWindow::new(self.handle.clone())
    }

    pub fn get_maintenance_window_execution(
        &self,
    ) -> fluent_builders::GetMaintenanceWindowExecution {
        fluent_builders::GetMaintenanceWindowExecution::new(self.handle.clone())
    }

    pub fn get_maintenance_window_execution_task(
        &self,
    ) -> fluent_builders::GetMaintenanceWindowExecutionTask {
        fluent_builders::GetMaintenanceWindowExecutionTask::new(self.handle.clone())
    }

    pub fn get_maintenance_window_execution_task_invocation(
        &self,
    ) -> fluent_builders::GetMaintenanceWindowExecutionTaskInvocation {
        fluent_builders::GetMaintenanceWindowExecutionTaskInvocation::new(self.handle.clone())
    }

    pub fn get_maintenance_window_task(&self) -> fluent_builders::GetMaintenanceWindowTask {
        fluent_builders::GetMaintenanceWindowTask::new(self.handle.clone())
    }

    pub fn get_ops_item(&self) -> fluent_builders::GetOpsItem {
        fluent_builders::GetOpsItem::new(self.handle.clone())
    }

    pub fn get_ops_metadata(&self) -> fluent_builders::GetOpsMetadata {
        fluent_builders::GetOpsMetadata::new(self.handle.clone())
    }

    pub fn get_ops_summary(&self) -> fluent_builders::GetOpsSummary {
        fluent_builders::GetOpsSummary::new(self.handle.clone())
    }

    pub fn get_parameter(&self) -> fluent_builders::GetParameter {
        fluent_builders::GetParameter::new(self.handle.clone())
    }

    pub fn get_parameter_history(&self) -> fluent_builders::GetParameterHistory {
        fluent_builders::GetParameterHistory::new(self.handle.clone())
    }

    pub fn get_parameters(&self) -> fluent_builders::GetParameters {
        fluent_builders::GetParameters::new(self.handle.clone())
    }

    pub fn get_parameters_by_path(&self) -> fluent_builders::GetParametersByPath {
        fluent_builders::GetParametersByPath::new(self.handle.clone())
    }

    pub fn get_patch_baseline(&self) -> fluent_builders::GetPatchBaseline {
        fluent_builders::GetPatchBaseline::new(self.handle.clone())
    }

    pub fn get_patch_baseline_for_patch_group(
        &self,
    ) -> fluent_builders::GetPatchBaselineForPatchGroup {
        fluent_builders::GetPatchBaselineForPatchGroup::new(self.handle.clone())
    }

    pub fn get_service_setting(&self) -> fluent_builders::GetServiceSetting {
        fluent_builders::GetServiceSetting::new(self.handle.clone())
    }

    pub fn label_parameter_version(&self) -> fluent_builders::LabelParameterVersion {
        fluent_builders::LabelParameterVersion::new(self.handle.clone())
    }

    pub fn list_associations(&self) -> fluent_builders::ListAssociations {
        fluent_builders::ListAssociations::new(self.handle.clone())
    }

    pub fn list_association_versions(&self) -> fluent_builders::ListAssociationVersions {
        fluent_builders::ListAssociationVersions::new(self.handle.clone())
    }

    pub fn list_command_invocations(&self) -> fluent_builders::ListCommandInvocations {
        fluent_builders::ListCommandInvocations::new(self.handle.clone())
    }

    pub fn list_commands(&self) -> fluent_builders::ListCommands {
        fluent_builders::ListCommands::new(self.handle.clone())
    }

    pub fn list_compliance_items(&self) -> fluent_builders::ListComplianceItems {
        fluent_builders::ListComplianceItems::new(self.handle.clone())
    }

    pub fn list_compliance_summaries(&self) -> fluent_builders::ListComplianceSummaries {
        fluent_builders::ListComplianceSummaries::new(self.handle.clone())
    }

    pub fn list_document_metadata_history(&self) -> fluent_builders::ListDocumentMetadataHistory {
        fluent_builders::ListDocumentMetadataHistory::new(self.handle.clone())
    }

    pub fn list_documents(&self) -> fluent_builders::ListDocuments {
        fluent_builders::ListDocuments::new(self.handle.clone())
    }

    pub fn list_document_versions(&self) -> fluent_builders::ListDocumentVersions {
        fluent_builders::ListDocumentVersions::new(self.handle.clone())
    }

    pub fn list_inventory_entries(&self) -> fluent_builders::ListInventoryEntries {
        fluent_builders::ListInventoryEntries::new(self.handle.clone())
    }

    pub fn list_ops_item_events(&self) -> fluent_builders::ListOpsItemEvents {
        fluent_builders::ListOpsItemEvents::new(self.handle.clone())
    }

    pub fn list_ops_item_related_items(&self) -> fluent_builders::ListOpsItemRelatedItems {
        fluent_builders::ListOpsItemRelatedItems::new(self.handle.clone())
    }

    pub fn list_ops_metadata(&self) -> fluent_builders::ListOpsMetadata {
        fluent_builders::ListOpsMetadata::new(self.handle.clone())
    }

    pub fn list_resource_compliance_summaries(
        &self,
    ) -> fluent_builders::ListResourceComplianceSummaries {
        fluent_builders::ListResourceComplianceSummaries::new(self.handle.clone())
    }

    pub fn list_resource_data_sync(&self) -> fluent_builders::ListResourceDataSync {
        fluent_builders::ListResourceDataSync::new(self.handle.clone())
    }

    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }

    pub fn modify_document_permission(&self) -> fluent_builders::ModifyDocumentPermission {
        fluent_builders::ModifyDocumentPermission::new(self.handle.clone())
    }

    pub fn put_compliance_items(&self) -> fluent_builders::PutComplianceItems {
        fluent_builders::PutComplianceItems::new(self.handle.clone())
    }

    pub fn put_inventory(&self) -> fluent_builders::PutInventory {
        fluent_builders::PutInventory::new(self.handle.clone())
    }

    pub fn put_parameter(&self) -> fluent_builders::PutParameter {
        fluent_builders::PutParameter::new(self.handle.clone())
    }

    pub fn register_default_patch_baseline(&self) -> fluent_builders::RegisterDefaultPatchBaseline {
        fluent_builders::RegisterDefaultPatchBaseline::new(self.handle.clone())
    }

    pub fn register_patch_baseline_for_patch_group(
        &self,
    ) -> fluent_builders::RegisterPatchBaselineForPatchGroup {
        fluent_builders::RegisterPatchBaselineForPatchGroup::new(self.handle.clone())
    }

    pub fn register_target_with_maintenance_window(
        &self,
    ) -> fluent_builders::RegisterTargetWithMaintenanceWindow {
        fluent_builders::RegisterTargetWithMaintenanceWindow::new(self.handle.clone())
    }

    pub fn register_task_with_maintenance_window(
        &self,
    ) -> fluent_builders::RegisterTaskWithMaintenanceWindow {
        fluent_builders::RegisterTaskWithMaintenanceWindow::new(self.handle.clone())
    }

    pub fn remove_tags_from_resource(&self) -> fluent_builders::RemoveTagsFromResource {
        fluent_builders::RemoveTagsFromResource::new(self.handle.clone())
    }

    pub fn reset_service_setting(&self) -> fluent_builders::ResetServiceSetting {
        fluent_builders::ResetServiceSetting::new(self.handle.clone())
    }

    pub fn resume_session(&self) -> fluent_builders::ResumeSession {
        fluent_builders::ResumeSession::new(self.handle.clone())
    }

    pub fn send_automation_signal(&self) -> fluent_builders::SendAutomationSignal {
        fluent_builders::SendAutomationSignal::new(self.handle.clone())
    }

    pub fn send_command(&self) -> fluent_builders::SendCommand {
        fluent_builders::SendCommand::new(self.handle.clone())
    }

    pub fn start_associations_once(&self) -> fluent_builders::StartAssociationsOnce {
        fluent_builders::StartAssociationsOnce::new(self.handle.clone())
    }

    pub fn start_automation_execution(&self) -> fluent_builders::StartAutomationExecution {
        fluent_builders::StartAutomationExecution::new(self.handle.clone())
    }

    pub fn start_change_request_execution(&self) -> fluent_builders::StartChangeRequestExecution {
        fluent_builders::StartChangeRequestExecution::new(self.handle.clone())
    }

    pub fn start_session(&self) -> fluent_builders::StartSession {
        fluent_builders::StartSession::new(self.handle.clone())
    }

    pub fn stop_automation_execution(&self) -> fluent_builders::StopAutomationExecution {
        fluent_builders::StopAutomationExecution::new(self.handle.clone())
    }

    pub fn terminate_session(&self) -> fluent_builders::TerminateSession {
        fluent_builders::TerminateSession::new(self.handle.clone())
    }

    pub fn unlabel_parameter_version(&self) -> fluent_builders::UnlabelParameterVersion {
        fluent_builders::UnlabelParameterVersion::new(self.handle.clone())
    }

    pub fn update_association(&self) -> fluent_builders::UpdateAssociation {
        fluent_builders::UpdateAssociation::new(self.handle.clone())
    }

    pub fn update_association_status(&self) -> fluent_builders::UpdateAssociationStatus {
        fluent_builders::UpdateAssociationStatus::new(self.handle.clone())
    }

    pub fn update_document(&self) -> fluent_builders::UpdateDocument {
        fluent_builders::UpdateDocument::new(self.handle.clone())
    }

    pub fn update_document_default_version(&self) -> fluent_builders::UpdateDocumentDefaultVersion {
        fluent_builders::UpdateDocumentDefaultVersion::new(self.handle.clone())
    }

    pub fn update_document_metadata(&self) -> fluent_builders::UpdateDocumentMetadata {
        fluent_builders::UpdateDocumentMetadata::new(self.handle.clone())
    }

    pub fn update_maintenance_window(&self) -> fluent_builders::UpdateMaintenanceWindow {
        fluent_builders::UpdateMaintenanceWindow::new(self.handle.clone())
    }

    pub fn update_maintenance_window_target(
        &self,
    ) -> fluent_builders::UpdateMaintenanceWindowTarget {
        fluent_builders::UpdateMaintenanceWindowTarget::new(self.handle.clone())
    }

    pub fn update_maintenance_window_task(&self) -> fluent_builders::UpdateMaintenanceWindowTask {
        fluent_builders::UpdateMaintenanceWindowTask::new(self.handle.clone())
    }

    pub fn update_managed_instance_role(&self) -> fluent_builders::UpdateManagedInstanceRole {
        fluent_builders::UpdateManagedInstanceRole::new(self.handle.clone())
    }

    pub fn update_ops_item(&self) -> fluent_builders::UpdateOpsItem {
        fluent_builders::UpdateOpsItem::new(self.handle.clone())
    }

    pub fn update_ops_metadata(&self) -> fluent_builders::UpdateOpsMetadata {
        fluent_builders::UpdateOpsMetadata::new(self.handle.clone())
    }

    pub fn update_patch_baseline(&self) -> fluent_builders::UpdatePatchBaseline {
        fluent_builders::UpdatePatchBaseline::new(self.handle.clone())
    }

    pub fn update_resource_data_sync(&self) -> fluent_builders::UpdateResourceDataSync {
        fluent_builders::UpdateResourceDataSync::new(self.handle.clone())
    }

    pub fn update_service_setting(&self) -> fluent_builders::UpdateServiceSetting {
        fluent_builders::UpdateServiceSetting::new(self.handle.clone())
    }
}
pub mod fluent_builders {

    #[derive(std::fmt::Debug)]
    pub struct AddTagsToResource {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::add_tags_to_resource_input::Builder,
    }
    impl AddTagsToResource {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AddTagsToResourceOutput,
            smithy_http::result::SdkError<crate::error::AddTagsToResourceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Specifies the type of resource you are tagging.</p>
        /// <note>
        /// <p>The ManagedInstance type for this API action is for on-premises managed instances. You must
        /// specify the name of the managed instance in the following format: mi-ID_number. For example,
        /// mi-1a2b3c4d5e6f.</p>
        /// </note>
        pub fn resource_type(mut self, inp: crate::model::ResourceTypeForTagging) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(
            mut self,
            inp: std::option::Option<crate::model::ResourceTypeForTagging>,
        ) -> Self {
            self.inner = self.inner.set_resource_type(inp);
            self
        }
        /// <p>The resource ID you want to tag.</p>
        /// <p>Use the ID of the resource. Here are some examples:</p>
        /// <p>ManagedInstance: mi-012345abcde</p>
        /// <p>MaintenanceWindow: mw-012345abcde</p>
        /// <p>PatchBaseline: pb-012345abcde</p>
        /// <p>OpsMetadata object: <code>ResourceID</code> for tagging is created from the Amazon Resource
        /// Name (ARN) for the object. Specifically, <code>ResourceID</code> is created from the strings that
        /// come after the word <code>opsmetadata</code> in the ARN. For example, an OpsMetadata object with
        /// an ARN of <code>arn:aws:ssm:us-east-2:1234567890:opsmetadata/aws/ssm/MyGroup/appmanager</code>
        /// has a <code>ResourceID</code> of either <code>aws/ssm/MyGroup/appmanager</code> or
        /// <code>/aws/ssm/MyGroup/appmanager</code>.</p>
        /// <p>For the Document and Parameter values, use the name of the resource.</p>
        /// <note>
        /// <p>The ManagedInstance type for this API action is only for on-premises managed instances. You
        /// must specify the name of the managed instance in the following format: mi-ID_number. For
        /// example, mi-1a2b3c4d5e6f.</p>
        /// </note>
        pub fn resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(inp);
            self
        }
        pub fn set_resource_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(inp);
            self
        }
        /// <p>One or more tags. The value parameter is required.</p>
        /// <important>
        /// <p>Do not enter personally identifiable information in this field.</p>
        /// </important>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct AssociateOpsItemRelatedItem {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::associate_ops_item_related_item_input::Builder,
    }
    impl AssociateOpsItemRelatedItem {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AssociateOpsItemRelatedItemOutput,
            smithy_http::result::SdkError<crate::error::AssociateOpsItemRelatedItemError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the OpsItem to which you want to associate a resource as a related item.</p>
        pub fn ops_item_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ops_item_id(inp);
            self
        }
        pub fn set_ops_item_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ops_item_id(inp);
            self
        }
        /// <p>The type of association that you want to create between an OpsItem and a resource. OpsCenter
        /// supports <code>IsParentOf</code> and <code>RelatesTo</code> association types.</p>
        pub fn association_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_type(inp);
            self
        }
        pub fn set_association_type(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_type(inp);
            self
        }
        /// <p>The type of resource that you want to associate with an OpsItem. OpsCenter supports the
        /// following types:</p>
        /// <p>
        /// <code>AWS::SSMIncidents::IncidentRecord</code>: an Incident Manager incident. Incident
        /// Manager is a capability of AWS Systems Manager.</p>
        /// <p>
        /// <code>AWS::SSM::Document</code>: a Systems Manager (SSM) document.</p>
        pub fn resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_type(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS resource that you want to associate with the
        /// OpsItem.</p>
        pub fn resource_uri(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_uri(inp);
            self
        }
        pub fn set_resource_uri(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_uri(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct CancelCommand {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::cancel_command_input::Builder,
    }
    impl CancelCommand {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CancelCommandOutput,
            smithy_http::result::SdkError<crate::error::CancelCommandError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the command you want to cancel.</p>
        pub fn command_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.command_id(inp);
            self
        }
        pub fn set_command_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_command_id(inp);
            self
        }
        /// <p>(Optional) A list of instance IDs on which you want to cancel the command. If not provided,
        /// the command is canceled on every instance on which it was requested.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct CancelMaintenanceWindowExecution {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::cancel_maintenance_window_execution_input::Builder,
    }
    impl CancelMaintenanceWindowExecution {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CancelMaintenanceWindowExecutionOutput,
            smithy_http::result::SdkError<crate::error::CancelMaintenanceWindowExecutionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window execution to stop.</p>
        pub fn window_execution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_execution_id(inp);
            self
        }
        pub fn set_window_execution_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_window_execution_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct CreateActivation {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_activation_input::Builder,
    }
    impl CreateActivation {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateActivationOutput,
            smithy_http::result::SdkError<crate::error::CreateActivationError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>A user-defined description of the resource that you want to register with Systems Manager. </p>
        /// <important>
        /// <p>Do not enter personally identifiable information in this field.</p>
        /// </important>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>The name of the registered, managed instance as it will appear in the Systems Manager console or when
        /// you use the AWS command line tools to list Systems Manager resources.</p>
        /// <important>
        /// <p>Do not enter personally identifiable information in this field.</p>
        /// </important>
        pub fn default_instance_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_instance_name(inp);
            self
        }
        pub fn set_default_instance_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_instance_name(inp);
            self
        }
        /// <p>The Amazon Identity and Access Management (IAM) role that you want to assign to the managed
        /// instance. This IAM role must provide AssumeRole permissions for the Systems Manager service principal
        /// <code>ssm.amazonaws.com</code>. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-service-role.html">Create an IAM service role for a
        /// hybrid environment</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn iam_role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.iam_role(inp);
            self
        }
        pub fn set_iam_role(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_iam_role(inp);
            self
        }
        /// <p>Specify the maximum number of managed instances you want to register. The default value is 1
        /// instance.</p>
        pub fn registration_limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.registration_limit(inp);
            self
        }
        pub fn set_registration_limit(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_registration_limit(inp);
            self
        }
        /// <p>The date by which this activation request should expire, in timestamp format, such as
        /// "2021-07-07T00:00:00". You can specify a date up to 30 days in advance. If you don't provide an
        /// expiration date, the activation code expires in 24 hours.</p>
        pub fn expiration_date(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.expiration_date(inp);
            self
        }
        pub fn set_expiration_date(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_expiration_date(inp);
            self
        }
        /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
        /// different ways, such as by purpose, owner, or environment. For example, you might want to tag an
        /// activation to identify which servers or virtual machines (VMs) in your on-premises environment
        /// you intend to activate. In this case, you could specify the following key name/value
        /// pairs:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Key=OS,Value=Windows</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Key=Environment,Value=Production</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <important>
        /// <p>When you install SSM Agent on your on-premises servers and VMs, you specify an activation
        /// ID and code. When you specify the activation ID and code, tags assigned to the activation are
        /// automatically applied to the on-premises servers or VMs.</p>
        /// </important>
        /// <p>You can't add tags to or delete tags from an existing activation. You can tag your
        /// on-premises servers and VMs after they connect to Systems Manager for the first time and are assigned a
        /// managed instance ID. This means they are listed in the AWS Systems Manager console with an ID that is
        /// prefixed with "mi-". For information about how to add tags to your managed instances, see <a>AddTagsToResource</a>. For information about how to remove tags from your managed
        /// instances, see <a>RemoveTagsFromResource</a>.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct CreateAssociation {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_association_input::Builder,
    }
    impl CreateAssociation {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateAssociationOutput,
            smithy_http::result::SdkError<crate::error::CreateAssociationError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the SSM document that contains the configuration information for the instance.
        /// You can specify Command or Automation documents.</p>
        /// <p>You can specify AWS-predefined documents, documents you created, or a document that is
        /// shared with you from another account.</p>
        /// <p>For SSM documents that are shared with you from other AWS accounts, you must specify the
        /// complete SSM document ARN, in the following format:</p>
        /// <p>
        /// <code>arn:<i>partition</i>:ssm:<i>region</i>:<i>account-id</i>:document/<i>document-name</i>
        /// </code>
        /// </p>
        /// <p>For example:</p>
        /// <p>
        /// <code>arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document</code>
        /// </p>
        /// <p>For AWS-predefined documents and SSM documents you created in your account, you only need to
        /// specify the document name. For example, <code>AWS-ApplyPatchBaseline</code> or
        /// <code>My-Document</code>.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The document version you want to associate with the target(s). Can be a specific version or
        /// the default version.</p>
        pub fn document_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_version(inp);
            self
        }
        pub fn set_document_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_version(inp);
            self
        }
        /// <p>The instance ID.</p>
        /// <note>
        /// <p>
        /// <code>InstanceId</code> has been deprecated. To specify an instance ID for an association,
        /// use the <code>Targets</code> parameter. Requests that include the
        /// parameter <code>InstanceID</code> with SSM documents that use schema version 2.0 or later will
        /// fail. In addition, if you use the parameter <code>InstanceId</code>, you
        /// cannot use the parameters <code>AssociationName</code>, <code>DocumentVersion</code>,
        /// <code>MaxErrors</code>, <code>MaxConcurrency</code>, <code>OutputLocation</code>, or
        /// <code>ScheduleExpression</code>. To use these parameters, you must use the <code>Targets</code>
        /// parameter.</p>
        /// </note>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>The parameters for the runtime configuration of the document.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.parameters(k, v);
            self
        }
        pub fn set_parameters(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.inner = self.inner.set_parameters(inp);
            self
        }
        /// <p>The targets for the association. You can target instances by using tags, AWS Resource
        /// Groups, all instances in an AWS account, or individual instance IDs. For more information about
        /// choosing targets for an association, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-state-manager-targets-and-rate-controls.html">Using targets and rate controls with State Manager associations</a> in the
        /// <i>AWS Systems Manager User Guide</i>.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::Target>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.inner = self.inner.set_targets(inp);
            self
        }
        /// <p>A cron expression when the association will be applied to the target(s).</p>
        pub fn schedule_expression(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schedule_expression(inp);
            self
        }
        pub fn set_schedule_expression(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_schedule_expression(inp);
            self
        }
        /// <p>An S3 bucket where you want to store the output details of the request.</p>
        pub fn output_location(
            mut self,
            inp: crate::model::InstanceAssociationOutputLocation,
        ) -> Self {
            self.inner = self.inner.output_location(inp);
            self
        }
        pub fn set_output_location(
            mut self,
            inp: std::option::Option<crate::model::InstanceAssociationOutputLocation>,
        ) -> Self {
            self.inner = self.inner.set_output_location(inp);
            self
        }
        /// <p>Specify a descriptive name for the association.</p>
        pub fn association_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_name(inp);
            self
        }
        pub fn set_association_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_name(inp);
            self
        }
        /// <p>Specify the target for the association. This target is required for associations that use an
        /// Automation document and target resources by using rate controls.</p>
        pub fn automation_target_parameter_name(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.automation_target_parameter_name(inp);
            self
        }
        pub fn set_automation_target_parameter_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_automation_target_parameter_name(inp);
            self
        }
        /// <p>The number of errors that are allowed before the system stops sending requests to run the
        /// association on additional targets. You can specify either an absolute number of errors, for
        /// example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
        /// the system stops sending requests when the fourth error is received. If you specify 0, then the
        /// system stops sending requests after the first error is returned. If you run an association on 50
        /// instances and set MaxError to 10%, then the system stops sending the request when the sixth error
        /// is received.</p>
        /// <p>Executions that are already running an association when MaxErrors is reached are allowed to
        /// complete, but some of these executions may fail as well. If you need to ensure that there won't
        /// be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
        /// at a time.</p>
        pub fn max_errors(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.max_errors(inp);
            self
        }
        pub fn set_max_errors(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_max_errors(inp);
            self
        }
        /// <p>The maximum number of targets allowed to run the association at the same time. You can
        /// specify a number, for example 10, or a percentage of the target set, for example 10%. The default
        /// value is 100%, which means all targets run the association at the same time.</p>
        /// <p>If a new instance starts and attempts to run an association while Systems Manager is running
        /// MaxConcurrency associations, the association is allowed to run. During the next association
        /// interval, the new instance will process its association within the limit specified for
        /// MaxConcurrency.</p>
        pub fn max_concurrency(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.max_concurrency(inp);
            self
        }
        pub fn set_max_concurrency(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_max_concurrency(inp);
            self
        }
        /// <p>The severity level to assign to the association.</p>
        pub fn compliance_severity(
            mut self,
            inp: crate::model::AssociationComplianceSeverity,
        ) -> Self {
            self.inner = self.inner.compliance_severity(inp);
            self
        }
        pub fn set_compliance_severity(
            mut self,
            inp: std::option::Option<crate::model::AssociationComplianceSeverity>,
        ) -> Self {
            self.inner = self.inner.set_compliance_severity(inp);
            self
        }
        /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
        /// <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
        /// execution to determine the compliance status. If the association execution runs successfully,
        /// then the association is <code>COMPLIANT</code>. If the association execution doesn't run
        /// successfully, the association is <code>NON-COMPLIANT</code>.</p>
        /// <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
        /// for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
        /// managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
        /// <p>By default, all associations use <code>AUTO</code> mode.</p>
        pub fn sync_compliance(mut self, inp: crate::model::AssociationSyncCompliance) -> Self {
            self.inner = self.inner.sync_compliance(inp);
            self
        }
        pub fn set_sync_compliance(
            mut self,
            inp: std::option::Option<crate::model::AssociationSyncCompliance>,
        ) -> Self {
            self.inner = self.inner.set_sync_compliance(inp);
            self
        }
        /// <p>By default, when you create a new association, the system runs it immediately after it is
        /// created and then according to the schedule you specified. Specify this option if you don't want
        /// an association to run immediately after you create it. This parameter is not supported for rate
        /// expressions.</p>
        pub fn apply_only_at_cron_interval(mut self, inp: bool) -> Self {
            self.inner = self.inner.apply_only_at_cron_interval(inp);
            self
        }
        pub fn set_apply_only_at_cron_interval(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_apply_only_at_cron_interval(inp);
            self
        }
        /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager Change Calendar type
        /// documents you want to gate your associations under. The associations only run when that Change
        /// Calendar is open. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar">AWS Systems Manager Change
        /// Calendar</a>.</p>
        pub fn calendar_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.calendar_names(inp);
            self
        }
        pub fn set_calendar_names(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_calendar_names(inp);
            self
        }
        /// <p>A location is a combination of AWS Regions and AWS accounts where you want to run the
        /// association. Use this action to create an association in multiple Regions and multiple
        /// accounts.</p>
        pub fn target_locations(mut self, inp: impl Into<crate::model::TargetLocation>) -> Self {
            self.inner = self.inner.target_locations(inp);
            self
        }
        pub fn set_target_locations(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
        ) -> Self {
            self.inner = self.inner.set_target_locations(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct CreateAssociationBatch {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_association_batch_input::Builder,
    }
    impl CreateAssociationBatch {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateAssociationBatchOutput,
            smithy_http::result::SdkError<crate::error::CreateAssociationBatchError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>One or more associations.</p>
        pub fn entries(
            mut self,
            inp: impl Into<crate::model::CreateAssociationBatchRequestEntry>,
        ) -> Self {
            self.inner = self.inner.entries(inp);
            self
        }
        pub fn set_entries(
            mut self,
            inp: std::option::Option<
                std::vec::Vec<crate::model::CreateAssociationBatchRequestEntry>,
            >,
        ) -> Self {
            self.inner = self.inner.set_entries(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct CreateDocument {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_document_input::Builder,
    }
    impl CreateDocument {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateDocumentOutput,
            smithy_http::result::SdkError<crate::error::CreateDocumentError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The content for the new SSM document in JSON or YAML format. We recommend storing the
        /// contents for your new document in an external JSON or YAML file and referencing the file in a
        /// command.</p>
        /// <p>For examples, see the following topics in the <i>AWS Systems Manager User Guide</i>.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-api.html">Create an SSM document
        /// (AWS API)</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-cli.html">Create an SSM document
        /// (AWS CLI)</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-api.html">Create an SSM document
        /// (API)</a>
        /// </p>
        /// </li>
        /// </ul>
        pub fn content(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content(inp);
            self
        }
        pub fn set_content(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content(inp);
            self
        }
        /// <p>A list of SSM documents required by a document. This parameter is used exclusively by AWS
        /// AppConfig. When a user creates an AppConfig configuration in an SSM document, the user must also
        /// specify a required document for validation purposes. In this case, an
        /// <code>ApplicationConfiguration</code> document requires an
        /// <code>ApplicationConfigurationSchema</code> document for validation purposes. For more
        /// information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/appconfig.html">AWS AppConfig</a> in the
        /// <i>AWS Systems Manager User Guide</i>.</p>
        pub fn requires(mut self, inp: impl Into<crate::model::DocumentRequires>) -> Self {
            self.inner = self.inner.requires(inp);
            self
        }
        pub fn set_requires(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::DocumentRequires>>,
        ) -> Self {
            self.inner = self.inner.set_requires(inp);
            self
        }
        /// <p>A list of key and value pairs that describe attachments to a version of a document.</p>
        pub fn attachments(mut self, inp: impl Into<crate::model::AttachmentsSource>) -> Self {
            self.inner = self.inner.attachments(inp);
            self
        }
        pub fn set_attachments(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::AttachmentsSource>>,
        ) -> Self {
            self.inner = self.inner.set_attachments(inp);
            self
        }
        /// <p>A name for the Systems Manager document.</p>
        /// <important>
        /// <p>You can't use the following strings as document name prefixes. These are reserved by AWS
        /// for use as document name prefixes:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>aws-</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>amazon</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>amzn</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </important>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>An optional field where you can specify a friendly name for the Systems Manager document. This value
        /// can differ for each version of the document. You can update this value at a later time using the
        /// <a>UpdateDocument</a> action.</p>
        pub fn display_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.display_name(inp);
            self
        }
        pub fn set_display_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_display_name(inp);
            self
        }
        /// <p>An optional field specifying the version of the artifact you are creating with the document.
        /// For example, "Release 12, Update 6". This value is unique across all versions of a document, and
        /// cannot be changed.</p>
        pub fn version_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_name(inp);
            self
        }
        pub fn set_version_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_name(inp);
            self
        }
        /// <p>The type of document to create.</p>
        pub fn document_type(mut self, inp: crate::model::DocumentType) -> Self {
            self.inner = self.inner.document_type(inp);
            self
        }
        pub fn set_document_type(
            mut self,
            inp: std::option::Option<crate::model::DocumentType>,
        ) -> Self {
            self.inner = self.inner.set_document_type(inp);
            self
        }
        /// <p>Specify the document format for the request. The document format can be JSON, YAML, or TEXT.
        /// JSON is the default format.</p>
        pub fn document_format(mut self, inp: crate::model::DocumentFormat) -> Self {
            self.inner = self.inner.document_format(inp);
            self
        }
        pub fn set_document_format(
            mut self,
            inp: std::option::Option<crate::model::DocumentFormat>,
        ) -> Self {
            self.inner = self.inner.set_document_format(inp);
            self
        }
        /// <p>Specify a target type to define the kinds of resources the document can run on. For example,
        /// to run a document on EC2 instances, specify the following value: /AWS::EC2::Instance. If you
        /// specify a value of '/' the document can run on all types of resources. If you don't specify a
        /// value, the document can't run on any resources. For a list of valid resource types, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS resource and property types
        /// reference</a> in the <i>AWS CloudFormation User Guide</i>. </p>
        pub fn target_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_type(inp);
            self
        }
        pub fn set_target_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_type(inp);
            self
        }
        /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
        /// different ways, such as by purpose, owner, or environment. For example, you might want to tag an
        /// SSM document to identify the types of targets or the environment where it will run. In this case,
        /// you could specify the following key name/value pairs:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Key=OS,Value=Windows</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Key=Environment,Value=Production</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>To add tags to an existing SSM document, use the <a>AddTagsToResource</a>
        /// action.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct CreateMaintenanceWindow {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_maintenance_window_input::Builder,
    }
    impl CreateMaintenanceWindow {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateMaintenanceWindowOutput,
            smithy_http::result::SdkError<crate::error::CreateMaintenanceWindowError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the maintenance window.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>An optional description for the maintenance window. We recommend specifying a description to
        /// help you organize your maintenance windows. </p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>The date and time, in ISO-8601 Extended format, for when you want the maintenance window to
        /// become active. StartDate allows you to delay activation of the maintenance window until the
        /// specified future date.</p>
        pub fn start_date(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.start_date(inp);
            self
        }
        pub fn set_start_date(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_start_date(inp);
            self
        }
        /// <p>The date and time, in ISO-8601 Extended format, for when you want the maintenance window to
        /// become inactive. EndDate allows you to set a date and time in the future when the maintenance
        /// window will no longer run.</p>
        pub fn end_date(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.end_date(inp);
            self
        }
        pub fn set_end_date(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_end_date(inp);
            self
        }
        /// <p>The schedule of the maintenance window in the form of a cron or rate expression.</p>
        pub fn schedule(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schedule(inp);
            self
        }
        pub fn set_schedule(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_schedule(inp);
            self
        }
        /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
        /// Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or
        /// "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time
        /// Zone Database</a> on the IANA website.</p>
        pub fn schedule_timezone(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schedule_timezone(inp);
            self
        }
        pub fn set_schedule_timezone(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_schedule_timezone(inp);
            self
        }
        /// <p>The number of days to wait after the date and time specified by a CRON expression before
        /// running the maintenance window.</p>
        /// <p>For example, the following cron expression schedules a maintenance window to run on the
        /// third Tuesday of every month at 11:30 PM.</p>
        /// <p>
        /// <code>cron(30 23 ? * TUE#3 *)</code>
        /// </p>
        /// <p>If the schedule offset is <code>2</code>, the maintenance window won't run until two days
        /// later.</p>
        pub fn schedule_offset(mut self, inp: i32) -> Self {
            self.inner = self.inner.schedule_offset(inp);
            self
        }
        pub fn set_schedule_offset(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_schedule_offset(inp);
            self
        }
        /// <p>The duration of the maintenance window in hours.</p>
        pub fn duration(mut self, inp: i32) -> Self {
            self.inner = self.inner.duration(inp);
            self
        }
        pub fn set_duration(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_duration(inp);
            self
        }
        /// <p>The number of hours before the end of the maintenance window that Systems Manager stops scheduling new
        /// tasks for execution.</p>
        pub fn cutoff(mut self, inp: i32) -> Self {
            self.inner = self.inner.cutoff(inp);
            self
        }
        pub fn set_cutoff(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_cutoff(inp);
            self
        }
        /// <p>Enables a maintenance window task to run on managed instances, even if you have not
        /// registered those instances as targets. If enabled, then you must specify the unregistered
        /// instances (by instance ID) when you register a task with the maintenance window.</p>
        /// <p>If you don't enable this option, then you must specify previously-registered targets when
        /// you register a task with the maintenance window.</p>
        pub fn allow_unassociated_targets(mut self, inp: bool) -> Self {
            self.inner = self.inner.allow_unassociated_targets(inp);
            self
        }
        pub fn set_allow_unassociated_targets(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_allow_unassociated_targets(inp);
            self
        }
        /// <p>User-provided idempotency token.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(inp);
            self
        }
        /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
        /// different ways, such as by purpose, owner, or environment. For example, you might want to tag a
        /// maintenance window to identify the type of tasks it will run, the types of targets, and the
        /// environment it will run in. In this case, you could specify the following key name/value
        /// pairs:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Key=TaskType,Value=AgentUpdate</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Key=OS,Value=Windows</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Key=Environment,Value=Production</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>To add tags to an existing maintenance window, use the <a>AddTagsToResource</a>
        /// action.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct CreateOpsItem {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_ops_item_input::Builder,
    }
    impl CreateOpsItem {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateOpsItemOutput,
            smithy_http::result::SdkError<crate::error::CreateOpsItemError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Information about the OpsItem. </p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>The type of OpsItem to create. Currently, the only valid values are
        /// <code>/aws/changerequest</code> and <code>/aws/issue</code>.</p>
        pub fn ops_item_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ops_item_type(inp);
            self
        }
        pub fn set_ops_item_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ops_item_type(inp);
            self
        }
        /// <p>Operational data is custom data that provides useful reference details about the OpsItem.
        /// For example, you can specify log files, error strings, license keys, troubleshooting tips, or
        /// other relevant data. You enter operational data as key-value pairs. The key has a maximum length
        /// of 128 characters. The value has a maximum size of 20 KB.</p>
        /// <important>
        /// <p>Operational data keys <i>can't</i> begin with the following: amazon, aws,
        /// amzn, ssm, /amazon, /aws, /amzn, /ssm.</p>
        /// </important>
        /// <p>You can choose to make the data searchable by other users in the account or you can restrict
        /// search access. Searchable data means that all users with access to the OpsItem Overview page (as
        /// provided by the <a>DescribeOpsItems</a> API action) can view and search on the
        /// specified data. Operational data that is not searchable is only viewable by users who have access
        /// to the OpsItem (as provided by the <a>GetOpsItem</a> API action).</p>
        /// <p>Use the <code>/aws/resources</code> key in OperationalData to specify a related resource in
        /// the request. Use the <code>/aws/automations</code> key in OperationalData to associate an
        /// Automation runbook with the OpsItem. To view AWS CLI example commands that use these keys, see
        /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems">Creating OpsItems manually</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn operational_data(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::OpsItemDataValue>,
        ) -> Self {
            self.inner = self.inner.operational_data(k, v);
            self
        }
        pub fn set_operational_data(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::OpsItemDataValue>,
            >,
        ) -> Self {
            self.inner = self.inner.set_operational_data(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this
        /// OpsItem is edited or changed.</p>
        pub fn notifications(mut self, inp: impl Into<crate::model::OpsItemNotification>) -> Self {
            self.inner = self.inner.notifications(inp);
            self
        }
        pub fn set_notifications(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::OpsItemNotification>>,
        ) -> Self {
            self.inner = self.inner.set_notifications(inp);
            self
        }
        /// <p>The importance of this OpsItem in relation to other OpsItems in the system.</p>
        pub fn priority(mut self, inp: i32) -> Self {
            self.inner = self.inner.priority(inp);
            self
        }
        pub fn set_priority(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(inp);
            self
        }
        /// <p>One or more OpsItems that share something in common with the current OpsItems. For example,
        /// related OpsItems can include OpsItems with similar error messages, impacted resources, or
        /// statuses for the impacted resource.</p>
        pub fn related_ops_items(mut self, inp: impl Into<crate::model::RelatedOpsItem>) -> Self {
            self.inner = self.inner.related_ops_items(inp);
            self
        }
        pub fn set_related_ops_items(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::RelatedOpsItem>>,
        ) -> Self {
            self.inner = self.inner.set_related_ops_items(inp);
            self
        }
        /// <p>The origin of the OpsItem, such as Amazon EC2 or Systems Manager.</p>
        /// <note>
        /// <p>The source name can't contain the following strings: aws, amazon, and amzn. </p>
        /// </note>
        pub fn source(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source(inp);
            self
        }
        pub fn set_source(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source(inp);
            self
        }
        /// <p>A short heading that describes the nature of the OpsItem and the impacted resource.</p>
        pub fn title(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.title(inp);
            self
        }
        pub fn set_title(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_title(inp);
            self
        }
        /// <p>Optional metadata that you assign to a resource. You can restrict access to OpsItems by
        /// using an inline IAM policy that specifies tags. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-getting-started.html#OpsCenter-getting-started-user-permissions">Getting started with OpsCenter</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        /// <p>Tags use a key-value pair. For example:</p>
        /// <p>
        /// <code>Key=Department,Value=Finance</code>
        /// </p>
        /// <note>
        /// <p>To add tags to an existing OpsItem, use the <a>AddTagsToResource</a>
        /// action.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// <p>Specify a category to assign to an OpsItem. </p>
        pub fn category(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.category(inp);
            self
        }
        pub fn set_category(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_category(inp);
            self
        }
        /// <p>Specify a severity to assign to an OpsItem.</p>
        pub fn severity(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.severity(inp);
            self
        }
        pub fn set_severity(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_severity(inp);
            self
        }
        /// <p>The time a runbook workflow started. Currently reported only for the OpsItem type
        /// <code>/aws/changerequest</code>.</p>
        pub fn actual_start_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.actual_start_time(inp);
            self
        }
        pub fn set_actual_start_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_actual_start_time(inp);
            self
        }
        /// <p>The time a runbook workflow ended. Currently reported only for the OpsItem type
        /// <code>/aws/changerequest</code>.</p>
        pub fn actual_end_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.actual_end_time(inp);
            self
        }
        pub fn set_actual_end_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_actual_end_time(inp);
            self
        }
        /// <p>The time specified in a change request for a runbook workflow to start. Currently supported
        /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
        pub fn planned_start_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.planned_start_time(inp);
            self
        }
        pub fn set_planned_start_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_planned_start_time(inp);
            self
        }
        /// <p>The time specified in a change request for a runbook workflow to end. Currently supported
        /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
        pub fn planned_end_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.planned_end_time(inp);
            self
        }
        pub fn set_planned_end_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_planned_end_time(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct CreateOpsMetadata {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_ops_metadata_input::Builder,
    }
    impl CreateOpsMetadata {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateOpsMetadataOutput,
            smithy_http::result::SdkError<crate::error::CreateOpsMetadataError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>A resource ID for a new Application Manager application.</p>
        pub fn resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(inp);
            self
        }
        pub fn set_resource_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(inp);
            self
        }
        /// <p>Metadata for a new Application Manager application. </p>
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::MetadataValue>,
        ) -> Self {
            self.inner = self.inner.metadata(k, v);
            self
        }
        pub fn set_metadata(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::MetadataValue>,
            >,
        ) -> Self {
            self.inner = self.inner.set_metadata(inp);
            self
        }
        /// <p>Optional metadata that you assign to a resource. You can specify a maximum of five tags for
        /// an OpsMetadata object. Tags enable you to categorize a resource in different ways, such as by
        /// purpose, owner, or environment. For example, you might want to tag an OpsMetadata object to
        /// identify an environment or target AWS Region. In this case, you could specify the following
        /// key-value pairs:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Key=Environment,Value=Production</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Key=Region,Value=us-east-2</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct CreatePatchBaseline {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_patch_baseline_input::Builder,
    }
    impl CreatePatchBaseline {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreatePatchBaselineOutput,
            smithy_http::result::SdkError<crate::error::CreatePatchBaselineError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Defines the operating system the patch baseline applies to. The Default value is
        /// WINDOWS.</p>
        pub fn operating_system(mut self, inp: crate::model::OperatingSystem) -> Self {
            self.inner = self.inner.operating_system(inp);
            self
        }
        pub fn set_operating_system(
            mut self,
            inp: std::option::Option<crate::model::OperatingSystem>,
        ) -> Self {
            self.inner = self.inner.set_operating_system(inp);
            self
        }
        /// <p>The name of the patch baseline.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>A set of global filters used to include patches in the baseline.</p>
        pub fn global_filters(mut self, inp: crate::model::PatchFilterGroup) -> Self {
            self.inner = self.inner.global_filters(inp);
            self
        }
        pub fn set_global_filters(
            mut self,
            inp: std::option::Option<crate::model::PatchFilterGroup>,
        ) -> Self {
            self.inner = self.inner.set_global_filters(inp);
            self
        }
        /// <p>A set of rules used to include patches in the baseline.</p>
        pub fn approval_rules(mut self, inp: crate::model::PatchRuleGroup) -> Self {
            self.inner = self.inner.approval_rules(inp);
            self
        }
        pub fn set_approval_rules(
            mut self,
            inp: std::option::Option<crate::model::PatchRuleGroup>,
        ) -> Self {
            self.inner = self.inner.set_approval_rules(inp);
            self
        }
        /// <p>A list of explicitly approved patches for the baseline.</p>
        /// <p>For information about accepted formats for lists of approved patches and rejected patches,
        /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
        /// package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn approved_patches(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.approved_patches(inp);
            self
        }
        pub fn set_approved_patches(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_approved_patches(inp);
            self
        }
        /// <p>Defines the compliance level for approved patches. When an approved patch is reported as
        /// missing, this value describes the severity of the compliance violation. The default value is
        /// UNSPECIFIED.</p>
        pub fn approved_patches_compliance_level(
            mut self,
            inp: crate::model::PatchComplianceLevel,
        ) -> Self {
            self.inner = self.inner.approved_patches_compliance_level(inp);
            self
        }
        pub fn set_approved_patches_compliance_level(
            mut self,
            inp: std::option::Option<crate::model::PatchComplianceLevel>,
        ) -> Self {
            self.inner = self.inner.set_approved_patches_compliance_level(inp);
            self
        }
        /// <p>Indicates whether the list of approved patches includes non-security updates that should be
        /// applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
        pub fn approved_patches_enable_non_security(mut self, inp: bool) -> Self {
            self.inner = self.inner.approved_patches_enable_non_security(inp);
            self
        }
        pub fn set_approved_patches_enable_non_security(
            mut self,
            inp: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_approved_patches_enable_non_security(inp);
            self
        }
        /// <p>A list of explicitly rejected patches for the baseline.</p>
        /// <p>For information about accepted formats for lists of approved patches and rejected patches,
        /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
        /// package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn rejected_patches(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rejected_patches(inp);
            self
        }
        pub fn set_rejected_patches(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_rejected_patches(inp);
            self
        }
        /// <p>The action for Patch Manager to take on patches included in the RejectedPackages
        /// list.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>ALLOW_AS_DEPENDENCY</b>: A package in the Rejected patches
        /// list is installed only if it is a dependency of another package. It is considered compliant
        /// with the patch baseline, and its status is reported as <i>InstalledOther</i>.
        /// This is the default action if no option is specified.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>BLOCK</b>: Packages in the RejectedPatches list, and packages
        /// that include them as dependencies, are not installed under any circumstances. If a package was
        /// installed before it was added to the Rejected patches list, it is considered non-compliant with
        /// the patch baseline, and its status is reported as
        /// <i>InstalledRejected</i>.</p>
        /// </li>
        /// </ul>
        pub fn rejected_patches_action(mut self, inp: crate::model::PatchAction) -> Self {
            self.inner = self.inner.rejected_patches_action(inp);
            self
        }
        pub fn set_rejected_patches_action(
            mut self,
            inp: std::option::Option<crate::model::PatchAction>,
        ) -> Self {
            self.inner = self.inner.set_rejected_patches_action(inp);
            self
        }
        /// <p>A description of the patch baseline.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>Information about the patches to use to update the instances, including target operating
        /// systems and source repositories. Applies to Linux instances only.</p>
        pub fn sources(mut self, inp: impl Into<crate::model::PatchSource>) -> Self {
            self.inner = self.inner.sources(inp);
            self
        }
        pub fn set_sources(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PatchSource>>,
        ) -> Self {
            self.inner = self.inner.set_sources(inp);
            self
        }
        /// <p>User-provided idempotency token.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(inp);
            self
        }
        /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
        /// different ways, such as by purpose, owner, or environment. For example, you might want to tag a
        /// patch baseline to identify the severity level of patches it specifies and the operating system
        /// family it applies to. In this case, you could specify the following key name/value pairs:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Key=PatchSeverity,Value=Critical</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Key=OS,Value=Windows</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>To add tags to an existing patch baseline, use the <a>AddTagsToResource</a>
        /// action.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct CreateResourceDataSync {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_resource_data_sync_input::Builder,
    }
    impl CreateResourceDataSync {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateResourceDataSyncOutput,
            smithy_http::result::SdkError<crate::error::CreateResourceDataSyncError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>A name for the configuration.</p>
        pub fn sync_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sync_name(inp);
            self
        }
        pub fn set_sync_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_sync_name(inp);
            self
        }
        /// <p>Amazon S3 configuration details for the sync. This parameter is required if the
        /// <code>SyncType</code> value is SyncToDestination.</p>
        pub fn s3_destination(mut self, inp: crate::model::ResourceDataSyncS3Destination) -> Self {
            self.inner = self.inner.s3_destination(inp);
            self
        }
        pub fn set_s3_destination(
            mut self,
            inp: std::option::Option<crate::model::ResourceDataSyncS3Destination>,
        ) -> Self {
            self.inner = self.inner.set_s3_destination(inp);
            self
        }
        /// <p>Specify <code>SyncToDestination</code> to create a resource data sync that synchronizes data
        /// to an S3 bucket for Inventory. If you specify <code>SyncToDestination</code>, you must provide a
        /// value for <code>S3Destination</code>. Specify <code>SyncFromSource</code> to synchronize data
        /// from a single account and multiple Regions, or multiple AWS accounts and Regions, as listed in
        /// AWS Organizations for Explorer. If you specify <code>SyncFromSource</code>, you must provide a value for
        /// <code>SyncSource</code>. The default value is <code>SyncToDestination</code>.</p>
        pub fn sync_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sync_type(inp);
            self
        }
        pub fn set_sync_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_sync_type(inp);
            self
        }
        /// <p>Specify information about the data sources to synchronize. This parameter is required if the
        /// <code>SyncType</code> value is SyncFromSource.</p>
        pub fn sync_source(mut self, inp: crate::model::ResourceDataSyncSource) -> Self {
            self.inner = self.inner.sync_source(inp);
            self
        }
        pub fn set_sync_source(
            mut self,
            inp: std::option::Option<crate::model::ResourceDataSyncSource>,
        ) -> Self {
            self.inner = self.inner.set_sync_source(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeleteActivation {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_activation_input::Builder,
    }
    impl DeleteActivation {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteActivationOutput,
            smithy_http::result::SdkError<crate::error::DeleteActivationError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the activation that you want to delete.</p>
        pub fn activation_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.activation_id(inp);
            self
        }
        pub fn set_activation_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_activation_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeleteAssociation {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_association_input::Builder,
    }
    impl DeleteAssociation {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteAssociationOutput,
            smithy_http::result::SdkError<crate::error::DeleteAssociationError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the Systems Manager document.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>The association ID that you want to delete.</p>
        pub fn association_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(inp);
            self
        }
        pub fn set_association_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_association_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeleteDocument {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_document_input::Builder,
    }
    impl DeleteDocument {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteDocumentOutput,
            smithy_http::result::SdkError<crate::error::DeleteDocumentError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the document.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The version of the document that you want to delete. If not provided, all versions of the
        /// document are deleted.</p>
        pub fn document_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_version(inp);
            self
        }
        pub fn set_document_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_version(inp);
            self
        }
        /// <p>The version name of the document that you want to delete. If not provided, all versions of
        /// the document are deleted.</p>
        pub fn version_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_name(inp);
            self
        }
        pub fn set_version_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_name(inp);
            self
        }
        /// <p>Some SSM document types require that you specify a <code>Force</code> flag before you can
        /// delete the document. For example, you must specify a <code>Force</code> flag to delete a document
        /// of type <code>ApplicationConfigurationSchema</code>. You can restrict access to the
        /// <code>Force</code> flag in an AWS Identity and Access Management (IAM) policy.</p>
        pub fn force(mut self, inp: bool) -> Self {
            self.inner = self.inner.force(inp);
            self
        }
        pub fn set_force(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_force(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeleteInventory {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_inventory_input::Builder,
    }
    impl DeleteInventory {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteInventoryOutput,
            smithy_http::result::SdkError<crate::error::DeleteInventoryError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the custom inventory type for which you want to delete either all previously
        /// collected data or the inventory type itself. </p>
        pub fn type_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.type_name(inp);
            self
        }
        pub fn set_type_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_type_name(inp);
            self
        }
        /// <p>Use the <code>SchemaDeleteOption</code> to delete a custom inventory type (schema). If you
        /// don't choose this option, the system only deletes existing inventory data associated with the
        /// custom inventory type. Choose one of the following options:</p>
        /// <p>DisableSchema: If you choose this option, the system ignores all inventory data for the
        /// specified version, and any earlier versions. To enable this schema again, you must call the
        /// <code>PutInventory</code> action for a version greater than the disabled version.</p>
        /// <p>DeleteSchema: This option deletes the specified custom type from the Inventory service. You
        /// can recreate the schema later, if you want.</p>
        pub fn schema_delete_option(
            mut self,
            inp: crate::model::InventorySchemaDeleteOption,
        ) -> Self {
            self.inner = self.inner.schema_delete_option(inp);
            self
        }
        pub fn set_schema_delete_option(
            mut self,
            inp: std::option::Option<crate::model::InventorySchemaDeleteOption>,
        ) -> Self {
            self.inner = self.inner.set_schema_delete_option(inp);
            self
        }
        /// <p>Use this option to view a summary of the deletion request without deleting any data or the
        /// data type. This option is useful when you only want to understand what will be deleted. Once you
        /// validate that the data to be deleted is what you intend to delete, you can run the same command
        /// without specifying the <code>DryRun</code> option.</p>
        pub fn dry_run(mut self, inp: bool) -> Self {
            self.inner = self.inner.dry_run(inp);
            self
        }
        pub fn set_dry_run(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_dry_run(inp);
            self
        }
        /// <p>User-provided idempotency token.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeleteMaintenanceWindow {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_maintenance_window_input::Builder,
    }
    impl DeleteMaintenanceWindow {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteMaintenanceWindowOutput,
            smithy_http::result::SdkError<crate::error::DeleteMaintenanceWindowError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window to delete.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeleteOpsMetadata {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_ops_metadata_input::Builder,
    }
    impl DeleteOpsMetadata {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteOpsMetadataOutput,
            smithy_http::result::SdkError<crate::error::DeleteOpsMetadataError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The Amazon Resource Name (ARN) of an OpsMetadata Object to delete.</p>
        pub fn ops_metadata_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ops_metadata_arn(inp);
            self
        }
        pub fn set_ops_metadata_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ops_metadata_arn(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeleteParameter {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_parameter_input::Builder,
    }
    impl DeleteParameter {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteParameterOutput,
            smithy_http::result::SdkError<crate::error::DeleteParameterError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the parameter to delete.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeleteParameters {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_parameters_input::Builder,
    }
    impl DeleteParameters {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteParametersOutput,
            smithy_http::result::SdkError<crate::error::DeleteParametersError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The names of the parameters to delete.</p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeletePatchBaseline {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_patch_baseline_input::Builder,
    }
    impl DeletePatchBaseline {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeletePatchBaselineOutput,
            smithy_http::result::SdkError<crate::error::DeletePatchBaselineError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the patch baseline to delete.</p>
        pub fn baseline_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.baseline_id(inp);
            self
        }
        pub fn set_baseline_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_baseline_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeleteResourceDataSync {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_resource_data_sync_input::Builder,
    }
    impl DeleteResourceDataSync {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteResourceDataSyncOutput,
            smithy_http::result::SdkError<crate::error::DeleteResourceDataSyncError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the configuration to delete.</p>
        pub fn sync_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sync_name(inp);
            self
        }
        pub fn set_sync_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_sync_name(inp);
            self
        }
        /// <p>Specify the type of resource data sync to delete.</p>
        pub fn sync_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sync_type(inp);
            self
        }
        pub fn set_sync_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_sync_type(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeregisterManagedInstance {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::deregister_managed_instance_input::Builder,
    }
    impl DeregisterManagedInstance {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeregisterManagedInstanceOutput,
            smithy_http::result::SdkError<crate::error::DeregisterManagedInstanceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID assigned to the managed instance when you registered it using the activation process.
        /// </p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeregisterPatchBaselineForPatchGroup {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::deregister_patch_baseline_for_patch_group_input::Builder,
    }
    impl DeregisterPatchBaselineForPatchGroup {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeregisterPatchBaselineForPatchGroupOutput,
            smithy_http::result::SdkError<crate::error::DeregisterPatchBaselineForPatchGroupError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the patch baseline to deregister the patch group from.</p>
        pub fn baseline_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.baseline_id(inp);
            self
        }
        pub fn set_baseline_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_baseline_id(inp);
            self
        }
        /// <p>The name of the patch group that should be deregistered from the patch baseline.</p>
        pub fn patch_group(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.patch_group(inp);
            self
        }
        pub fn set_patch_group(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_patch_group(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeregisterTargetFromMaintenanceWindow {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::deregister_target_from_maintenance_window_input::Builder,
    }
    impl DeregisterTargetFromMaintenanceWindow {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeregisterTargetFromMaintenanceWindowOutput,
            smithy_http::result::SdkError<crate::error::DeregisterTargetFromMaintenanceWindowError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window the target should be removed from.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
        /// <p>The ID of the target definition to remove.</p>
        pub fn window_target_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_target_id(inp);
            self
        }
        pub fn set_window_target_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_window_target_id(inp);
            self
        }
        /// <p>The system checks if the target is being referenced by a task. If the target is being
        /// referenced, the system returns an error and does not deregister the target from the maintenance
        /// window.</p>
        pub fn safe(mut self, inp: bool) -> Self {
            self.inner = self.inner.safe(inp);
            self
        }
        pub fn set_safe(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_safe(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeregisterTaskFromMaintenanceWindow {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::deregister_task_from_maintenance_window_input::Builder,
    }
    impl DeregisterTaskFromMaintenanceWindow {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeregisterTaskFromMaintenanceWindowOutput,
            smithy_http::result::SdkError<crate::error::DeregisterTaskFromMaintenanceWindowError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window the task should be removed from.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
        /// <p>The ID of the task to remove from the maintenance window.</p>
        pub fn window_task_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_task_id(inp);
            self
        }
        pub fn set_window_task_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_task_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeActivations {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_activations_input::Builder,
    }
    impl DescribeActivations {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeActivationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeActivationsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>A filter to view information about your activations.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::DescribeActivationsFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::DescribeActivationsFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeAssociation {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_association_input::Builder,
    }
    impl DescribeAssociation {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeAssociationOutput,
            smithy_http::result::SdkError<crate::error::DescribeAssociationError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the Systems Manager document.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The instance ID.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>The association ID for which you want information.</p>
        pub fn association_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(inp);
            self
        }
        pub fn set_association_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_association_id(inp);
            self
        }
        /// <p>Specify the association version to retrieve. To view the latest version, either specify
        /// <code>$LATEST</code> for this parameter, or omit this parameter. To view a list of all
        /// associations for an instance, use <a>ListAssociations</a>. To get a list of versions
        /// for a specific association, use <a>ListAssociationVersions</a>. </p>
        pub fn association_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_version(inp);
            self
        }
        pub fn set_association_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_version(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeAssociationExecutions {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_association_executions_input::Builder,
    }
    impl DescribeAssociationExecutions {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeAssociationExecutionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeAssociationExecutionsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The association ID for which you want to view execution history details.</p>
        pub fn association_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(inp);
            self
        }
        pub fn set_association_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_association_id(inp);
            self
        }
        /// <p>Filters for the request. You can specify the following filters and values.</p>
        /// <p>ExecutionId (EQUAL)</p>
        /// <p>Status (EQUAL)</p>
        /// <p>CreatedTime (EQUAL, GREATER_THAN, LESS_THAN)</p>
        pub fn filters(mut self, inp: impl Into<crate::model::AssociationExecutionFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::AssociationExecutionFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeAssociationExecutionTargets {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_association_execution_targets_input::Builder,
    }
    impl DescribeAssociationExecutionTargets {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeAssociationExecutionTargetsOutput,
            smithy_http::result::SdkError<crate::error::DescribeAssociationExecutionTargetsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The association ID that includes the execution for which you want to view details.</p>
        pub fn association_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(inp);
            self
        }
        pub fn set_association_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_association_id(inp);
            self
        }
        /// <p>The execution ID for which you want to view details.</p>
        pub fn execution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.execution_id(inp);
            self
        }
        pub fn set_execution_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_execution_id(inp);
            self
        }
        /// <p>Filters for the request. You can specify the following filters and values.</p>
        /// <p>Status (EQUAL)</p>
        /// <p>ResourceId (EQUAL)</p>
        /// <p>ResourceType (EQUAL)</p>
        pub fn filters(
            mut self,
            inp: impl Into<crate::model::AssociationExecutionTargetsFilter>,
        ) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<
                std::vec::Vec<crate::model::AssociationExecutionTargetsFilter>,
            >,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeAutomationExecutions {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_automation_executions_input::Builder,
    }
    impl DescribeAutomationExecutions {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeAutomationExecutionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeAutomationExecutionsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Filters used to limit the scope of executions that are requested.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::AutomationExecutionFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::AutomationExecutionFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeAutomationStepExecutions {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_automation_step_executions_input::Builder,
    }
    impl DescribeAutomationStepExecutions {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeAutomationStepExecutionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeAutomationStepExecutionsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The Automation execution ID for which you want step execution descriptions.</p>
        pub fn automation_execution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.automation_execution_id(inp);
            self
        }
        pub fn set_automation_execution_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_automation_execution_id(inp);
            self
        }
        /// <p>One or more filters to limit the number of step executions returned by the request.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::StepExecutionFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::StepExecutionFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>Indicates whether to list step executions in reverse order by start time. The default value
        /// is 'false'.</p>
        pub fn reverse_order(mut self, inp: bool) -> Self {
            self.inner = self.inner.reverse_order(inp);
            self
        }
        pub fn set_reverse_order(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeAvailablePatches {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_available_patches_input::Builder,
    }
    impl DescribeAvailablePatches {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeAvailablePatchesOutput,
            smithy_http::result::SdkError<crate::error::DescribeAvailablePatchesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Filters used to scope down the returned patches.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::PatchOrchestratorFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PatchOrchestratorFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of patches to return (per page).</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeDocument {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_document_input::Builder,
    }
    impl DescribeDocument {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeDocumentOutput,
            smithy_http::result::SdkError<crate::error::DescribeDocumentError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the Systems Manager document.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The document version for which you want information. Can be a specific version or the
        /// default version.</p>
        pub fn document_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_version(inp);
            self
        }
        pub fn set_document_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_version(inp);
            self
        }
        /// <p>An optional field specifying the version of the artifact associated with the document. For
        /// example, "Release 12, Update 6". This value is unique across all versions of a document, and
        /// cannot be changed.</p>
        pub fn version_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_name(inp);
            self
        }
        pub fn set_version_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeDocumentPermission {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_document_permission_input::Builder,
    }
    impl DescribeDocumentPermission {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeDocumentPermissionOutput,
            smithy_http::result::SdkError<crate::error::DescribeDocumentPermissionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the document for which you are the owner.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The permission type for the document. The permission type can be
        /// <i>Share</i>.</p>
        pub fn permission_type(mut self, inp: crate::model::DocumentPermissionType) -> Self {
            self.inner = self.inner.permission_type(inp);
            self
        }
        pub fn set_permission_type(
            mut self,
            inp: std::option::Option<crate::model::DocumentPermissionType>,
        ) -> Self {
            self.inner = self.inner.set_permission_type(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeEffectiveInstanceAssociations {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_effective_instance_associations_input::Builder,
    }
    impl DescribeEffectiveInstanceAssociations {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeEffectiveInstanceAssociationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeEffectiveInstanceAssociationsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The instance ID for which you want to view all associations.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeEffectivePatchesForPatchBaseline {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_effective_patches_for_patch_baseline_input::Builder,
    }
    impl DescribeEffectivePatchesForPatchBaseline {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeEffectivePatchesForPatchBaselineOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeEffectivePatchesForPatchBaselineError,
            >,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the patch baseline to retrieve the effective patches for.</p>
        pub fn baseline_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.baseline_id(inp);
            self
        }
        pub fn set_baseline_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_baseline_id(inp);
            self
        }
        /// <p>The maximum number of patches to return (per page).</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeInstanceAssociationsStatus {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_instance_associations_status_input::Builder,
    }
    impl DescribeInstanceAssociationsStatus {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeInstanceAssociationsStatusOutput,
            smithy_http::result::SdkError<crate::error::DescribeInstanceAssociationsStatusError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The instance IDs for which you want association status information.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeInstanceInformation {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_instance_information_input::Builder,
    }
    impl DescribeInstanceInformation {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeInstanceInformationOutput,
            smithy_http::result::SdkError<crate::error::DescribeInstanceInformationError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>This is a legacy method. We recommend that you don't use this method. Instead, use the
        /// <code>Filters</code> data type. <code>Filters</code> enables you to return instance information
        /// by filtering based on tags applied to managed instances.</p>
        /// <note>
        /// <p>Attempting to use <code>InstanceInformationFilterList</code> and <code>Filters</code> leads
        /// to an exception error. </p>
        /// </note>
        pub fn instance_information_filter_list(
            mut self,
            inp: impl Into<crate::model::InstanceInformationFilter>,
        ) -> Self {
            self.inner = self.inner.instance_information_filter_list(inp);
            self
        }
        pub fn set_instance_information_filter_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InstanceInformationFilter>>,
        ) -> Self {
            self.inner = self.inner.set_instance_information_filter_list(inp);
            self
        }
        /// <p>One or more filters. Use a filter to return a more specific list of instances. You can
        /// filter based on tags applied to EC2 instances. Use this <code>Filters</code> data type instead of
        /// <code>InstanceInformationFilterList</code>, which is deprecated.</p>
        pub fn filters(
            mut self,
            inp: impl Into<crate::model::InstanceInformationStringFilter>,
        ) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InstanceInformationStringFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results. </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeInstancePatches {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_instance_patches_input::Builder,
    }
    impl DescribeInstancePatches {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeInstancePatchesOutput,
            smithy_http::result::SdkError<crate::error::DescribeInstancePatchesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the instance whose patch state information should be retrieved.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>An array of structures. Each entry in the array is a structure containing a Key, Value
        /// combination. Valid values for Key are <code>Classification</code> | <code>KBId</code> |
        /// <code>Severity</code> | <code>State</code>.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::PatchOrchestratorFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PatchOrchestratorFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of patches to return (per page).</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeInstancePatchStates {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_instance_patch_states_input::Builder,
    }
    impl DescribeInstancePatchStates {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeInstancePatchStatesOutput,
            smithy_http::result::SdkError<crate::error::DescribeInstancePatchStatesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the instance whose patch state information should be retrieved.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of instances to return (per page).</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeInstancePatchStatesForPatchGroup {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_instance_patch_states_for_patch_group_input::Builder,
    }
    impl DescribeInstancePatchStatesForPatchGroup {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeInstancePatchStatesForPatchGroupOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeInstancePatchStatesForPatchGroupError,
            >,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the patch group for which the patch state information should be
        /// retrieved.</p>
        pub fn patch_group(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.patch_group(inp);
            self
        }
        pub fn set_patch_group(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_patch_group(inp);
            self
        }
        /// <p>Each entry in the array is a structure containing:</p>
        /// <p>Key (string between 1 and 200 characters)</p>
        /// <p> Values (array containing a single string)</p>
        /// <p> Type (string "Equal", "NotEqual", "LessThan", "GreaterThan")</p>
        pub fn filters(mut self, inp: impl Into<crate::model::InstancePatchStateFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InstancePatchStateFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of patches to return (per page).</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeInventoryDeletions {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_inventory_deletions_input::Builder,
    }
    impl DescribeInventoryDeletions {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeInventoryDeletionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeInventoryDeletionsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Specify the delete inventory ID for which you want information. This ID was returned by the
        /// <code>DeleteInventory</code> action.</p>
        pub fn deletion_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deletion_id(inp);
            self
        }
        pub fn set_deletion_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_deletion_id(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeMaintenanceWindowExecutions {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_maintenance_window_executions_input::Builder,
    }
    impl DescribeMaintenanceWindowExecutions {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeMaintenanceWindowExecutionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeMaintenanceWindowExecutionsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window whose executions should be retrieved.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
        /// <p>Each entry in the array is a structure containing:</p>
        /// <p>Key (string, between 1 and 128 characters)</p>
        /// <p>Values (array of strings, each string is between 1 and 256 characters)</p>
        /// <p>The supported Keys are ExecutedBefore and ExecutedAfter with the value being a date/time
        /// string such as 2016-11-04T05:00:00Z.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::MaintenanceWindowFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeMaintenanceWindowExecutionTaskInvocations {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_maintenance_window_execution_task_invocations_input::Builder,
    }
    impl DescribeMaintenanceWindowExecutionTaskInvocations {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeMaintenanceWindowExecutionTaskInvocationsOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError,
            >,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window execution the task is part of.</p>
        pub fn window_execution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_execution_id(inp);
            self
        }
        pub fn set_window_execution_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_window_execution_id(inp);
            self
        }
        /// <p>The ID of the specific task in the maintenance window task that should be retrieved.</p>
        pub fn task_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(inp);
            self
        }
        pub fn set_task_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(inp);
            self
        }
        /// <p>Optional filters used to scope down the returned task invocations. The supported filter key
        /// is STATUS with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT,
        /// CANCELLING, and CANCELLED.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::MaintenanceWindowFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeMaintenanceWindowExecutionTasks {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_maintenance_window_execution_tasks_input::Builder,
    }
    impl DescribeMaintenanceWindowExecutionTasks {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeMaintenanceWindowExecutionTasksOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeMaintenanceWindowExecutionTasksError,
            >,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window execution whose task executions should be retrieved.</p>
        pub fn window_execution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_execution_id(inp);
            self
        }
        pub fn set_window_execution_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_window_execution_id(inp);
            self
        }
        /// <p>Optional filters used to scope down the returned tasks. The supported filter key is STATUS
        /// with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT, CANCELLING, and
        /// CANCELLED. </p>
        pub fn filters(mut self, inp: impl Into<crate::model::MaintenanceWindowFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeMaintenanceWindows {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_maintenance_windows_input::Builder,
    }
    impl DescribeMaintenanceWindows {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeMaintenanceWindowsOutput,
            smithy_http::result::SdkError<crate::error::DescribeMaintenanceWindowsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Optional filters used to narrow down the scope of the returned maintenance windows.
        /// Supported filter keys are <b>Name</b> and <b>Enabled</b>.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::MaintenanceWindowFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeMaintenanceWindowSchedule {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_maintenance_window_schedule_input::Builder,
    }
    impl DescribeMaintenanceWindowSchedule {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeMaintenanceWindowScheduleOutput,
            smithy_http::result::SdkError<crate::error::DescribeMaintenanceWindowScheduleError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window to retrieve information about.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
        /// <p>The instance ID or key/value pair to retrieve information about.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::Target>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.inner = self.inner.set_targets(inp);
            self
        }
        /// <p>The type of resource you want to retrieve information about. For example, "INSTANCE".</p>
        pub fn resource_type(mut self, inp: crate::model::MaintenanceWindowResourceType) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(
            mut self,
            inp: std::option::Option<crate::model::MaintenanceWindowResourceType>,
        ) -> Self {
            self.inner = self.inner.set_resource_type(inp);
            self
        }
        /// <p>Filters used to limit the range of results. For example, you can limit maintenance window
        /// executions to only those scheduled before or after a certain date and time.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::PatchOrchestratorFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PatchOrchestratorFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeMaintenanceWindowsForTarget {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_maintenance_windows_for_target_input::Builder,
    }
    impl DescribeMaintenanceWindowsForTarget {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeMaintenanceWindowsForTargetOutput,
            smithy_http::result::SdkError<crate::error::DescribeMaintenanceWindowsForTargetError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The instance ID or key/value pair to retrieve information about.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::Target>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.inner = self.inner.set_targets(inp);
            self
        }
        /// <p>The type of resource you want to retrieve information about. For example, "INSTANCE".</p>
        pub fn resource_type(mut self, inp: crate::model::MaintenanceWindowResourceType) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(
            mut self,
            inp: std::option::Option<crate::model::MaintenanceWindowResourceType>,
        ) -> Self {
            self.inner = self.inner.set_resource_type(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeMaintenanceWindowTargets {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_maintenance_window_targets_input::Builder,
    }
    impl DescribeMaintenanceWindowTargets {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeMaintenanceWindowTargetsOutput,
            smithy_http::result::SdkError<crate::error::DescribeMaintenanceWindowTargetsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window whose targets should be retrieved.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
        /// <p>Optional filters that can be used to narrow down the scope of the returned window targets.
        /// The supported filter keys are Type, WindowTargetId and OwnerInformation.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::MaintenanceWindowFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeMaintenanceWindowTasks {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_maintenance_window_tasks_input::Builder,
    }
    impl DescribeMaintenanceWindowTasks {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeMaintenanceWindowTasksOutput,
            smithy_http::result::SdkError<crate::error::DescribeMaintenanceWindowTasksError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window whose tasks should be retrieved.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
        /// <p>Optional filters used to narrow down the scope of the returned tasks. The supported filter
        /// keys are WindowTaskId, TaskArn, Priority, and TaskType.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::MaintenanceWindowFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::MaintenanceWindowFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeOpsItems {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_ops_items_input::Builder,
    }
    impl DescribeOpsItems {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeOpsItemsOutput,
            smithy_http::result::SdkError<crate::error::DescribeOpsItemsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>One or more filters to limit the response.</p>
        /// <ul>
        /// <li>
        /// <p>Key: CreatedTime</p>
        /// <p>Operations: GreaterThan, LessThan</p>
        /// </li>
        /// <li>
        /// <p>Key: LastModifiedBy</p>
        /// <p>Operations: Contains, Equals</p>
        /// </li>
        /// <li>
        /// <p>Key: LastModifiedTime</p>
        /// <p>Operations: GreaterThan, LessThan</p>
        /// </li>
        /// <li>
        /// <p>Key: Priority</p>
        /// <p>Operations: Equals</p>
        /// </li>
        /// <li>
        /// <p>Key: Source</p>
        /// <p>Operations: Contains, Equals</p>
        /// </li>
        /// <li>
        /// <p>Key: Status</p>
        /// <p>Operations: Equals</p>
        /// </li>
        /// <li>
        /// <p>Key: Title</p>
        /// <p>Operations: Contains</p>
        /// </li>
        /// <li>
        /// <p>Key: OperationalData*</p>
        /// <p>Operations: Equals</p>
        /// </li>
        /// <li>
        /// <p>Key: OperationalDataKey</p>
        /// <p>Operations: Equals</p>
        /// </li>
        /// <li>
        /// <p>Key: OperationalDataValue</p>
        /// <p>Operations: Equals, Contains</p>
        /// </li>
        /// <li>
        /// <p>Key: OpsItemId</p>
        /// <p>Operations: Equals</p>
        /// </li>
        /// <li>
        /// <p>Key: ResourceId</p>
        /// <p>Operations: Contains</p>
        /// </li>
        /// <li>
        /// <p>Key: AutomationId</p>
        /// <p>Operations: Equals</p>
        /// </li>
        /// </ul>
        /// <p>*If you filter the response by using the OperationalData operator, specify a key-value pair
        /// by using the following JSON format: {"key":"key_name","value":"a_value"}</p>
        pub fn ops_item_filters(mut self, inp: impl Into<crate::model::OpsItemFilter>) -> Self {
            self.inner = self.inner.ops_item_filters(inp);
            self
        }
        pub fn set_ops_item_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::OpsItemFilter>>,
        ) -> Self {
            self.inner = self.inner.set_ops_item_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeParameters {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_parameters_input::Builder,
    }
    impl DescribeParameters {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeParametersOutput,
            smithy_http::result::SdkError<crate::error::DescribeParametersError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>This data type is deprecated. Instead, use <code>ParameterFilters</code>.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::ParametersFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ParametersFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>Filters to limit the request results.</p>
        pub fn parameter_filters(
            mut self,
            inp: impl Into<crate::model::ParameterStringFilter>,
        ) -> Self {
            self.inner = self.inner.parameter_filters(inp);
            self
        }
        pub fn set_parameter_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ParameterStringFilter>>,
        ) -> Self {
            self.inner = self.inner.set_parameter_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribePatchBaselines {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_patch_baselines_input::Builder,
    }
    impl DescribePatchBaselines {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribePatchBaselinesOutput,
            smithy_http::result::SdkError<crate::error::DescribePatchBaselinesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Each element in the array is a structure containing: </p>
        /// <p>Key: (string, "NAME_PREFIX" or "OWNER")</p>
        /// <p>Value: (array of strings, exactly 1 entry, between 1 and 255 characters)</p>
        pub fn filters(mut self, inp: impl Into<crate::model::PatchOrchestratorFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PatchOrchestratorFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of patch baselines to return (per page).</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribePatchGroups {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_patch_groups_input::Builder,
    }
    impl DescribePatchGroups {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribePatchGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribePatchGroupsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The maximum number of patch groups to return (per page).</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
        /// <p>For <code>DescribePatchGroups</code>,valid filter keys include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NAME_PREFIX</code>: The name of the patch group. Wildcards (*) are accepted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OPERATING_SYSTEM</code>: The supported operating system type to return results for.
        /// For valid operating system values, see <a>GetDefaultPatchBaselineRequest$OperatingSystem</a> in <a>CreatePatchBaseline</a>.</p>
        /// <p>Examples:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>--filters Key=NAME_PREFIX,Values=MyPatchGroup*</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>--filters Key=OPERATING_SYSTEM,Values=AMAZON_LINUX_2</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::PatchOrchestratorFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PatchOrchestratorFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribePatchGroupState {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_patch_group_state_input::Builder,
    }
    impl DescribePatchGroupState {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribePatchGroupStateOutput,
            smithy_http::result::SdkError<crate::error::DescribePatchGroupStateError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the patch group whose patch snapshot should be retrieved.</p>
        pub fn patch_group(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.patch_group(inp);
            self
        }
        pub fn set_patch_group(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_patch_group(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribePatchProperties {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_patch_properties_input::Builder,
    }
    impl DescribePatchProperties {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribePatchPropertiesOutput,
            smithy_http::result::SdkError<crate::error::DescribePatchPropertiesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The operating system type for which to list patches.</p>
        pub fn operating_system(mut self, inp: crate::model::OperatingSystem) -> Self {
            self.inner = self.inner.operating_system(inp);
            self
        }
        pub fn set_operating_system(
            mut self,
            inp: std::option::Option<crate::model::OperatingSystem>,
        ) -> Self {
            self.inner = self.inner.set_operating_system(inp);
            self
        }
        /// <p>The patch property for which you want to view patch details. </p>
        pub fn property(mut self, inp: crate::model::PatchProperty) -> Self {
            self.inner = self.inner.property(inp);
            self
        }
        pub fn set_property(
            mut self,
            inp: std::option::Option<crate::model::PatchProperty>,
        ) -> Self {
            self.inner = self.inner.set_property(inp);
            self
        }
        /// <p>Indicates whether to list patches for the Windows operating system or for Microsoft
        /// applications. Not applicable for the Linux or macOS operating systems.</p>
        pub fn patch_set(mut self, inp: crate::model::PatchSet) -> Self {
            self.inner = self.inner.patch_set(inp);
            self
        }
        pub fn set_patch_set(mut self, inp: std::option::Option<crate::model::PatchSet>) -> Self {
            self.inner = self.inner.set_patch_set(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeSessions {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_sessions_input::Builder,
    }
    impl DescribeSessions {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeSessionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeSessionsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The session status to retrieve a list of sessions for. For example, "Active".</p>
        pub fn state(mut self, inp: crate::model::SessionState) -> Self {
            self.inner = self.inner.state(inp);
            self
        }
        pub fn set_state(mut self, inp: std::option::Option<crate::model::SessionState>) -> Self {
            self.inner = self.inner.set_state(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>One or more filters to limit the type of sessions returned by the request.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::SessionFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::SessionFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DisassociateOpsItemRelatedItem {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::disassociate_ops_item_related_item_input::Builder,
    }
    impl DisassociateOpsItemRelatedItem {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DisassociateOpsItemRelatedItemOutput,
            smithy_http::result::SdkError<crate::error::DisassociateOpsItemRelatedItemError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the OpsItem for which you want to delete an association between the OpsItem and a
        /// related resource.</p>
        pub fn ops_item_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ops_item_id(inp);
            self
        }
        pub fn set_ops_item_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ops_item_id(inp);
            self
        }
        /// <p>The ID of the association for which you want to delete an association between the OpsItem
        /// and a related resource.</p>
        pub fn association_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(inp);
            self
        }
        pub fn set_association_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_association_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetAutomationExecution {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_automation_execution_input::Builder,
    }
    impl GetAutomationExecution {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetAutomationExecutionOutput,
            smithy_http::result::SdkError<crate::error::GetAutomationExecutionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The unique identifier for an existing automation execution to examine. The execution ID is
        /// returned by StartAutomationExecution when the execution of an Automation document is
        /// initiated.</p>
        pub fn automation_execution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.automation_execution_id(inp);
            self
        }
        pub fn set_automation_execution_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_automation_execution_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetCalendarState {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_calendar_state_input::Builder,
    }
    impl GetCalendarState {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetCalendarStateOutput,
            smithy_http::result::SdkError<crate::error::GetCalendarStateError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager documents that represent the calendar
        /// entries for which you want to get the state.</p>
        pub fn calendar_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.calendar_names(inp);
            self
        }
        pub fn set_calendar_names(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_calendar_names(inp);
            self
        }
        /// <p>(Optional) The specific time for which you want to get calendar state information, in <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format. If you do not add
        /// <code>AtTime</code>, the current time is assumed.</p>
        pub fn at_time(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.at_time(inp);
            self
        }
        pub fn set_at_time(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_at_time(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetCommandInvocation {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_command_invocation_input::Builder,
    }
    impl GetCommandInvocation {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetCommandInvocationOutput,
            smithy_http::result::SdkError<crate::error::GetCommandInvocationError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>(Required) The parent command ID of the invocation plugin.</p>
        pub fn command_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.command_id(inp);
            self
        }
        pub fn set_command_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_command_id(inp);
            self
        }
        /// <p>(Required) The ID of the managed instance targeted by the command. A managed instance can be
        /// an Amazon Elastic Compute Cloud (Amazon EC2) instance or an instance in your hybrid environment that is configured for
        /// AWS Systems Manager.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>The name of the plugin for which you want detailed results. If the document contains only
        /// one plugin, you can omit the name and details for that plugin. If the document contains more than
        /// one plugin, you must specify the name of the plugin for which you want to view details.</p>
        /// <p>Plugin names are also referred to as <i>step names</i> in Systems Manager documents. For
        /// example, <code>aws:RunShellScript</code> is a plugin.</p>
        /// <p>To find the <code>PluginName</code>, check the document content and find the name of the
        /// plugin. Alternatively, use <a>ListCommandInvocations</a> with the
        /// <code>CommandId</code> and <code>Details</code> parameters. The <code>PluginName</code> is the
        /// <code>Name</code> attribute of the <code>CommandPlugin</code> object in the
        /// <code>CommandPlugins</code> list.</p>
        pub fn plugin_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.plugin_name(inp);
            self
        }
        pub fn set_plugin_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_plugin_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetConnectionStatus {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_connection_status_input::Builder,
    }
    impl GetConnectionStatus {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetConnectionStatusOutput,
            smithy_http::result::SdkError<crate::error::GetConnectionStatusError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the instance.</p>
        pub fn target(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target(inp);
            self
        }
        pub fn set_target(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetDefaultPatchBaseline {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_default_patch_baseline_input::Builder,
    }
    impl GetDefaultPatchBaseline {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetDefaultPatchBaselineOutput,
            smithy_http::result::SdkError<crate::error::GetDefaultPatchBaselineError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Returns the default patch baseline for the specified operating system.</p>
        pub fn operating_system(mut self, inp: crate::model::OperatingSystem) -> Self {
            self.inner = self.inner.operating_system(inp);
            self
        }
        pub fn set_operating_system(
            mut self,
            inp: std::option::Option<crate::model::OperatingSystem>,
        ) -> Self {
            self.inner = self.inner.set_operating_system(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetDeployablePatchSnapshotForInstance {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_deployable_patch_snapshot_for_instance_input::Builder,
    }
    impl GetDeployablePatchSnapshotForInstance {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetDeployablePatchSnapshotForInstanceOutput,
            smithy_http::result::SdkError<crate::error::GetDeployablePatchSnapshotForInstanceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the instance for which the appropriate patch snapshot should be retrieved.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>The user-defined snapshot ID.</p>
        pub fn snapshot_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_id(inp);
            self
        }
        pub fn set_snapshot_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_snapshot_id(inp);
            self
        }
        /// <p>Defines the basic information about a patch baseline override.</p>
        pub fn baseline_override(mut self, inp: crate::model::BaselineOverride) -> Self {
            self.inner = self.inner.baseline_override(inp);
            self
        }
        pub fn set_baseline_override(
            mut self,
            inp: std::option::Option<crate::model::BaselineOverride>,
        ) -> Self {
            self.inner = self.inner.set_baseline_override(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetDocument {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_document_input::Builder,
    }
    impl GetDocument {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetDocumentOutput,
            smithy_http::result::SdkError<crate::error::GetDocumentError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the Systems Manager document.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>An optional field specifying the version of the artifact associated with the document. For
        /// example, "Release 12, Update 6". This value is unique across all versions of a document and can't
        /// be changed.</p>
        pub fn version_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_name(inp);
            self
        }
        pub fn set_version_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_name(inp);
            self
        }
        /// <p>The document version for which you want information.</p>
        pub fn document_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_version(inp);
            self
        }
        pub fn set_document_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_version(inp);
            self
        }
        /// <p>Returns the document in the specified format. The document format can be either JSON or
        /// YAML. JSON is the default format.</p>
        pub fn document_format(mut self, inp: crate::model::DocumentFormat) -> Self {
            self.inner = self.inner.document_format(inp);
            self
        }
        pub fn set_document_format(
            mut self,
            inp: std::option::Option<crate::model::DocumentFormat>,
        ) -> Self {
            self.inner = self.inner.set_document_format(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetInventory {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_inventory_input::Builder,
    }
    impl GetInventory {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetInventoryOutput,
            smithy_http::result::SdkError<crate::error::GetInventoryError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::InventoryFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InventoryFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>Returns counts of inventory types based on one or more expressions. For example, if you
        /// aggregate by using an expression that uses the <code>AWS:InstanceInformation.PlatformType</code>
        /// type, you can see a count of how many Windows and Linux instances exist in your inventoried
        /// fleet.</p>
        pub fn aggregators(mut self, inp: impl Into<crate::model::InventoryAggregator>) -> Self {
            self.inner = self.inner.aggregators(inp);
            self
        }
        pub fn set_aggregators(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InventoryAggregator>>,
        ) -> Self {
            self.inner = self.inner.set_aggregators(inp);
            self
        }
        /// <p>The list of inventory item types to return.</p>
        pub fn result_attributes(mut self, inp: impl Into<crate::model::ResultAttribute>) -> Self {
            self.inner = self.inner.result_attributes(inp);
            self
        }
        pub fn set_result_attributes(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ResultAttribute>>,
        ) -> Self {
            self.inner = self.inner.set_result_attributes(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetInventorySchema {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_inventory_schema_input::Builder,
    }
    impl GetInventorySchema {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetInventorySchemaOutput,
            smithy_http::result::SdkError<crate::error::GetInventorySchemaError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The type of inventory item to return.</p>
        pub fn type_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.type_name(inp);
            self
        }
        pub fn set_type_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_type_name(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>Returns inventory schemas that support aggregation. For example, this call returns the
        /// <code>AWS:InstanceInformation</code> type, because it supports aggregation based on the
        /// <code>PlatformName</code>, <code>PlatformType</code>, and <code>PlatformVersion</code>
        /// attributes.</p>
        pub fn aggregator(mut self, inp: bool) -> Self {
            self.inner = self.inner.aggregator(inp);
            self
        }
        pub fn set_aggregator(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_aggregator(inp);
            self
        }
        /// <p>Returns the sub-type schema for a specified inventory type.</p>
        pub fn sub_type(mut self, inp: bool) -> Self {
            self.inner = self.inner.sub_type(inp);
            self
        }
        pub fn set_sub_type(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_sub_type(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetMaintenanceWindow {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_maintenance_window_input::Builder,
    }
    impl GetMaintenanceWindow {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetMaintenanceWindowOutput,
            smithy_http::result::SdkError<crate::error::GetMaintenanceWindowError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window for which you want to retrieve information.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetMaintenanceWindowExecution {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_maintenance_window_execution_input::Builder,
    }
    impl GetMaintenanceWindowExecution {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetMaintenanceWindowExecutionOutput,
            smithy_http::result::SdkError<crate::error::GetMaintenanceWindowExecutionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window execution that includes the task.</p>
        pub fn window_execution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_execution_id(inp);
            self
        }
        pub fn set_window_execution_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_window_execution_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetMaintenanceWindowExecutionTask {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_maintenance_window_execution_task_input::Builder,
    }
    impl GetMaintenanceWindowExecutionTask {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetMaintenanceWindowExecutionTaskOutput,
            smithy_http::result::SdkError<crate::error::GetMaintenanceWindowExecutionTaskError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window execution that includes the task.</p>
        pub fn window_execution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_execution_id(inp);
            self
        }
        pub fn set_window_execution_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_window_execution_id(inp);
            self
        }
        /// <p>The ID of the specific task execution in the maintenance window task that should be
        /// retrieved.</p>
        pub fn task_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(inp);
            self
        }
        pub fn set_task_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetMaintenanceWindowExecutionTaskInvocation {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_maintenance_window_execution_task_invocation_input::Builder,
    }
    impl GetMaintenanceWindowExecutionTaskInvocation {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetMaintenanceWindowExecutionTaskInvocationOutput,
            smithy_http::result::SdkError<
                crate::error::GetMaintenanceWindowExecutionTaskInvocationError,
            >,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window execution for which the task is a part.</p>
        pub fn window_execution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_execution_id(inp);
            self
        }
        pub fn set_window_execution_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_window_execution_id(inp);
            self
        }
        /// <p>The ID of the specific task in the maintenance window task that should be retrieved. </p>
        pub fn task_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(inp);
            self
        }
        pub fn set_task_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(inp);
            self
        }
        /// <p>The invocation ID to retrieve.</p>
        pub fn invocation_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.invocation_id(inp);
            self
        }
        pub fn set_invocation_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_invocation_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetMaintenanceWindowTask {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_maintenance_window_task_input::Builder,
    }
    impl GetMaintenanceWindowTask {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetMaintenanceWindowTaskOutput,
            smithy_http::result::SdkError<crate::error::GetMaintenanceWindowTaskError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The maintenance window ID that includes the task to retrieve.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
        /// <p>The maintenance window task ID to retrieve.</p>
        pub fn window_task_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_task_id(inp);
            self
        }
        pub fn set_window_task_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_task_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetOpsItem {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_ops_item_input::Builder,
    }
    impl GetOpsItem {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetOpsItemOutput,
            smithy_http::result::SdkError<crate::error::GetOpsItemError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the OpsItem that you want to get.</p>
        pub fn ops_item_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ops_item_id(inp);
            self
        }
        pub fn set_ops_item_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ops_item_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetOpsMetadata {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_ops_metadata_input::Builder,
    }
    impl GetOpsMetadata {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetOpsMetadataOutput,
            smithy_http::result::SdkError<crate::error::GetOpsMetadataError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The Amazon Resource Name (ARN) of an OpsMetadata Object to view.</p>
        pub fn ops_metadata_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ops_metadata_arn(inp);
            self
        }
        pub fn set_ops_metadata_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ops_metadata_arn(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetOpsSummary {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_ops_summary_input::Builder,
    }
    impl GetOpsSummary {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetOpsSummaryOutput,
            smithy_http::result::SdkError<crate::error::GetOpsSummaryError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Specify the name of a resource data sync to get.</p>
        pub fn sync_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sync_name(inp);
            self
        }
        pub fn set_sync_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_sync_name(inp);
            self
        }
        /// <p>Optional filters used to scope down the returned OpsItems. </p>
        pub fn filters(mut self, inp: impl Into<crate::model::OpsFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::OpsFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>Optional aggregators that return counts of OpsItems based on one or more expressions.</p>
        pub fn aggregators(mut self, inp: impl Into<crate::model::OpsAggregator>) -> Self {
            self.inner = self.inner.aggregators(inp);
            self
        }
        pub fn set_aggregators(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::OpsAggregator>>,
        ) -> Self {
            self.inner = self.inner.set_aggregators(inp);
            self
        }
        /// <p>The OpsItem data type to return.</p>
        pub fn result_attributes(
            mut self,
            inp: impl Into<crate::model::OpsResultAttribute>,
        ) -> Self {
            self.inner = self.inner.result_attributes(inp);
            self
        }
        pub fn set_result_attributes(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::OpsResultAttribute>>,
        ) -> Self {
            self.inner = self.inner.set_result_attributes(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetParameter {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_parameter_input::Builder,
    }
    impl GetParameter {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetParameterOutput,
            smithy_http::result::SdkError<crate::error::GetParameterError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the parameter you want to query.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>Return decrypted values for secure string parameters. This flag is ignored for String and
        /// StringList parameter types.</p>
        pub fn with_decryption(mut self, inp: bool) -> Self {
            self.inner = self.inner.with_decryption(inp);
            self
        }
        pub fn set_with_decryption(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_with_decryption(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetParameterHistory {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_parameter_history_input::Builder,
    }
    impl GetParameterHistory {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetParameterHistoryOutput,
            smithy_http::result::SdkError<crate::error::GetParameterHistoryError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the parameter for which you want to review history.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>Return decrypted values for secure string parameters. This flag is ignored for String and
        /// StringList parameter types.</p>
        pub fn with_decryption(mut self, inp: bool) -> Self {
            self.inner = self.inner.with_decryption(inp);
            self
        }
        pub fn set_with_decryption(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_with_decryption(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetParameters {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_parameters_input::Builder,
    }
    impl GetParameters {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetParametersOutput,
            smithy_http::result::SdkError<crate::error::GetParametersError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Names of the parameters for which you want to query information.</p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(inp);
            self
        }
        /// <p>Return decrypted secure string value. Return decrypted values for secure string parameters.
        /// This flag is ignored for String and StringList parameter types.</p>
        pub fn with_decryption(mut self, inp: bool) -> Self {
            self.inner = self.inner.with_decryption(inp);
            self
        }
        pub fn set_with_decryption(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_with_decryption(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetParametersByPath {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_parameters_by_path_input::Builder,
    }
    impl GetParametersByPath {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetParametersByPathOutput,
            smithy_http::result::SdkError<crate::error::GetParametersByPathError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The hierarchy for the parameter. Hierarchies start with a forward slash (/). The hierachy is
        /// the parameter name except the last part of the parameter. For the API call to succeeed, the last
        /// part of the parameter name cannot be in the path. A parameter name hierarchy can have a maximum
        /// of 15 levels. Here is an example of a hierarchy: <code>/Finance/Prod/IAD/WinServ2016/license33
        /// </code>
        /// </p>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path(inp);
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path(inp);
            self
        }
        /// <p>Retrieve all parameters within a hierarchy.</p>
        /// <important>
        /// <p>If a user has access to a path, then the user can access all levels of that path. For
        /// example, if a user has permission to access path <code>/a</code>, then the user can also access
        /// <code>/a/b</code>. Even if a user has explicitly been denied access in IAM for parameter
        /// <code>/a/b</code>, they can still call the GetParametersByPath API action recursively for
        /// <code>/a</code> and view <code>/a/b</code>.</p>
        /// </important>
        pub fn recursive(mut self, inp: bool) -> Self {
            self.inner = self.inner.recursive(inp);
            self
        }
        pub fn set_recursive(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_recursive(inp);
            self
        }
        /// <p>Filters to limit the request results.</p>
        /// <note>
        /// <p>For <code>GetParametersByPath</code>, the following filter <code>Key</code> names are
        /// supported: <code>Type</code>, <code>KeyId</code>, <code>Label</code>, and
        /// <code>DataType</code>.</p>
        /// <p>The following <code>Key</code> values are not supported for
        /// <code>GetParametersByPath</code>: <code>tag</code>, <code>Name</code>, <code>Path</code>, and
        /// <code>Tier</code>.</p>
        /// </note>
        pub fn parameter_filters(
            mut self,
            inp: impl Into<crate::model::ParameterStringFilter>,
        ) -> Self {
            self.inner = self.inner.parameter_filters(inp);
            self
        }
        pub fn set_parameter_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ParameterStringFilter>>,
        ) -> Self {
            self.inner = self.inner.set_parameter_filters(inp);
            self
        }
        /// <p>Retrieve all parameters in a hierarchy with their value decrypted.</p>
        pub fn with_decryption(mut self, inp: bool) -> Self {
            self.inner = self.inner.with_decryption(inp);
            self
        }
        pub fn set_with_decryption(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_with_decryption(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetPatchBaseline {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_patch_baseline_input::Builder,
    }
    impl GetPatchBaseline {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetPatchBaselineOutput,
            smithy_http::result::SdkError<crate::error::GetPatchBaselineError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the patch baseline to retrieve.</p>
        pub fn baseline_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.baseline_id(inp);
            self
        }
        pub fn set_baseline_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_baseline_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetPatchBaselineForPatchGroup {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_patch_baseline_for_patch_group_input::Builder,
    }
    impl GetPatchBaselineForPatchGroup {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetPatchBaselineForPatchGroupOutput,
            smithy_http::result::SdkError<crate::error::GetPatchBaselineForPatchGroupError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the patch group whose patch baseline should be retrieved.</p>
        pub fn patch_group(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.patch_group(inp);
            self
        }
        pub fn set_patch_group(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_patch_group(inp);
            self
        }
        /// <p>Returns he operating system rule specified for patch groups using the patch baseline.</p>
        pub fn operating_system(mut self, inp: crate::model::OperatingSystem) -> Self {
            self.inner = self.inner.operating_system(inp);
            self
        }
        pub fn set_operating_system(
            mut self,
            inp: std::option::Option<crate::model::OperatingSystem>,
        ) -> Self {
            self.inner = self.inner.set_operating_system(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetServiceSetting {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_service_setting_input::Builder,
    }
    impl GetServiceSetting {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetServiceSettingOutput,
            smithy_http::result::SdkError<crate::error::GetServiceSettingError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the service setting to get. The setting ID can be
        /// <code>/ssm/automation/customer-script-log-destination</code>,
        /// <code>/ssm/automation/customer-script-log-group-name</code>,
        /// <code>/ssm/parameter-store/default-parameter-tier</code>,
        /// <code>/ssm/parameter-store/high-throughput-enabled</code>, or
        /// <code>/ssm/managed-instance/activation-tier</code>.</p>
        pub fn setting_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.setting_id(inp);
            self
        }
        pub fn set_setting_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_setting_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct LabelParameterVersion {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::label_parameter_version_input::Builder,
    }
    impl LabelParameterVersion {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::LabelParameterVersionOutput,
            smithy_http::result::SdkError<crate::error::LabelParameterVersionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The parameter name on which you want to attach one or more labels.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The specific version of the parameter on which you want to attach one or more labels. If no
        /// version is specified, the system attaches the label to the latest version.</p>
        pub fn parameter_version(mut self, inp: i64) -> Self {
            self.inner = self.inner.parameter_version(inp);
            self
        }
        pub fn set_parameter_version(mut self, inp: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_parameter_version(inp);
            self
        }
        /// <p>One or more labels to attach to the specified parameter version.</p>
        pub fn labels(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.labels(inp);
            self
        }
        pub fn set_labels(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_labels(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListAssociations {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_associations_input::Builder,
    }
    impl ListAssociations {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListAssociationsOutput,
            smithy_http::result::SdkError<crate::error::ListAssociationsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
        /// <note>
        /// <p>Filtering associations using the <code>InstanceID</code> attribute only returns legacy
        /// associations created using the <code>InstanceID</code> attribute. Associations targeting the
        /// instance that are part of the Target Attributes <code>ResourceGroup</code> or <code>Tags</code>
        /// are not returned.</p>
        /// </note>
        pub fn association_filter_list(
            mut self,
            inp: impl Into<crate::model::AssociationFilter>,
        ) -> Self {
            self.inner = self.inner.association_filter_list(inp);
            self
        }
        pub fn set_association_filter_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::AssociationFilter>>,
        ) -> Self {
            self.inner = self.inner.set_association_filter_list(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListAssociationVersions {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_association_versions_input::Builder,
    }
    impl ListAssociationVersions {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListAssociationVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListAssociationVersionsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The association ID for which you want to view all versions.</p>
        pub fn association_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(inp);
            self
        }
        pub fn set_association_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_association_id(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListCommandInvocations {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_command_invocations_input::Builder,
    }
    impl ListCommandInvocations {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListCommandInvocationsOutput,
            smithy_http::result::SdkError<crate::error::ListCommandInvocationsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>(Optional) The invocations for a specific command ID.</p>
        pub fn command_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.command_id(inp);
            self
        }
        pub fn set_command_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_command_id(inp);
            self
        }
        /// <p>(Optional) The command execution details for a specific instance ID.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>(Optional) The maximum number of items to return for this call. The call also returns a
        /// token that you can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>(Optional) The token for the next set of items to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>(Optional) One or more filters. Use a filter to return a more specific list of
        /// results.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::CommandFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::CommandFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>(Optional) If set this returns the response of the command executions and any command
        /// output. The default value is 'false'. </p>
        pub fn details(mut self, inp: bool) -> Self {
            self.inner = self.inner.details(inp);
            self
        }
        pub fn set_details(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_details(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListCommands {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_commands_input::Builder,
    }
    impl ListCommands {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListCommandsOutput,
            smithy_http::result::SdkError<crate::error::ListCommandsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>(Optional) If provided, lists only the specified command.</p>
        pub fn command_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.command_id(inp);
            self
        }
        pub fn set_command_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_command_id(inp);
            self
        }
        /// <p>(Optional) Lists commands issued against this instance ID.</p>
        /// <note>
        /// <p>You can't specify an instance ID in the same command that you specify <code>Status</code> =
        /// <code>Pending</code>. This is because the command has not reached the instance yet.</p>
        /// </note>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>(Optional) The maximum number of items to return for this call. The call also returns a
        /// token that you can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>(Optional) The token for the next set of items to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>(Optional) One or more filters. Use a filter to return a more specific list of results.
        /// </p>
        pub fn filters(mut self, inp: impl Into<crate::model::CommandFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::CommandFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListComplianceItems {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_compliance_items_input::Builder,
    }
    impl ListComplianceItems {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListComplianceItemsOutput,
            smithy_http::result::SdkError<crate::error::ListComplianceItemsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>One or more compliance filters. Use a filter to return a more specific list of
        /// results.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::ComplianceStringFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ComplianceStringFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The ID for the resources from which to get compliance information. Currently, you can only
        /// specify one resource ID.</p>
        pub fn resource_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_ids(inp);
            self
        }
        pub fn set_resource_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resource_ids(inp);
            self
        }
        /// <p>The type of resource from which to get compliance information. Currently, the only supported
        /// resource type is <code>ManagedInstance</code>.</p>
        pub fn resource_types(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_types(inp);
            self
        }
        pub fn set_resource_types(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resource_types(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListComplianceSummaries {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_compliance_summaries_input::Builder,
    }
    impl ListComplianceSummaries {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListComplianceSummariesOutput,
            smithy_http::result::SdkError<crate::error::ListComplianceSummariesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>One or more compliance or inventory filters. Use a filter to return a more specific list of
        /// results.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::ComplianceStringFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ComplianceStringFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. Currently, you can specify null or 50.
        /// The call also returns a token that you can specify in a subsequent call to get the next set of
        /// results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListDocumentMetadataHistory {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_document_metadata_history_input::Builder,
    }
    impl ListDocumentMetadataHistory {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListDocumentMetadataHistoryOutput,
            smithy_http::result::SdkError<crate::error::ListDocumentMetadataHistoryError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the document.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The version of the document.</p>
        pub fn document_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_version(inp);
            self
        }
        pub fn set_document_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_version(inp);
            self
        }
        /// <p>The type of data for which details are being requested. Currently, the only supported value
        /// is <code>DocumentReviews</code>.</p>
        pub fn metadata(mut self, inp: crate::model::DocumentMetadataEnum) -> Self {
            self.inner = self.inner.metadata(inp);
            self
        }
        pub fn set_metadata(
            mut self,
            inp: std::option::Option<crate::model::DocumentMetadataEnum>,
        ) -> Self {
            self.inner = self.inner.set_metadata(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListDocuments {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_documents_input::Builder,
    }
    impl ListDocuments {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListDocumentsOutput,
            smithy_http::result::SdkError<crate::error::ListDocumentsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>This data type is deprecated. Instead, use <code>Filters</code>.</p>
        pub fn document_filter_list(
            mut self,
            inp: impl Into<crate::model::DocumentFilter>,
        ) -> Self {
            self.inner = self.inner.document_filter_list(inp);
            self
        }
        pub fn set_document_filter_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::DocumentFilter>>,
        ) -> Self {
            self.inner = self.inner.set_document_filter_list(inp);
            self
        }
        /// <p>One or more <code>DocumentKeyValuesFilter</code> objects. Use a filter to return a more
        /// specific list of results. For keys, you can specify one or more key-value pair tags that have
        /// been applied to a document. Other valid keys include <code>Owner</code>, <code>Name</code>,
        /// <code>PlatformTypes</code>, <code>DocumentType</code>, and <code>TargetType</code>. For example,
        /// to return documents you own use <code>Key=Owner,Values=Self</code>. To specify a custom key-value
        /// pair, use the format <code>Key=tag:tagName,Values=valueName</code>.</p>
        /// <note>
        /// <p>This API action only supports filtering documents by using a single tag key and one or more
        /// tag values. For example: <code>Key=tag:tagName,Values=valueName1,valueName2</code>
        /// </p>
        /// </note>
        pub fn filters(mut self, inp: impl Into<crate::model::DocumentKeyValuesFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::DocumentKeyValuesFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListDocumentVersions {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_document_versions_input::Builder,
    }
    impl ListDocumentVersions {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListDocumentVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListDocumentVersionsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the document. You can specify an Amazon Resource Name (ARN).</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListInventoryEntries {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_inventory_entries_input::Builder,
    }
    impl ListInventoryEntries {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListInventoryEntriesOutput,
            smithy_http::result::SdkError<crate::error::ListInventoryEntriesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The instance ID for which you want inventory information.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>The type of inventory item for which you want information.</p>
        pub fn type_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.type_name(inp);
            self
        }
        pub fn set_type_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_type_name(inp);
            self
        }
        /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::InventoryFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InventoryFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListOpsItemEvents {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_ops_item_events_input::Builder,
    }
    impl ListOpsItemEvents {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListOpsItemEventsOutput,
            smithy_http::result::SdkError<crate::error::ListOpsItemEventsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>One or more OpsItem filters. Use a filter to return a more specific list of results. </p>
        pub fn filters(mut self, inp: impl Into<crate::model::OpsItemEventFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::OpsItemEventFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results. </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListOpsItemRelatedItems {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_ops_item_related_items_input::Builder,
    }
    impl ListOpsItemRelatedItems {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListOpsItemRelatedItemsOutput,
            smithy_http::result::SdkError<crate::error::ListOpsItemRelatedItemsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the OpsItem for which you want to list all related-item resources.</p>
        pub fn ops_item_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ops_item_id(inp);
            self
        }
        pub fn set_ops_item_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ops_item_id(inp);
            self
        }
        /// <p>One or more OpsItem filters. Use a filter to return a more specific list of results. </p>
        pub fn filters(mut self, inp: impl Into<crate::model::OpsItemRelatedItemsFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::OpsItemRelatedItemsFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous
        /// call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListOpsMetadata {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_ops_metadata_input::Builder,
    }
    impl ListOpsMetadata {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListOpsMetadataOutput,
            smithy_http::result::SdkError<crate::error::ListOpsMetadataError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>One or more filters to limit the number of OpsMetadata objects returned by the call.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::OpsMetadataFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::OpsMetadataFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListResourceComplianceSummaries {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_resource_compliance_summaries_input::Builder,
    }
    impl ListResourceComplianceSummaries {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListResourceComplianceSummariesOutput,
            smithy_http::result::SdkError<crate::error::ListResourceComplianceSummariesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::ComplianceStringFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ComplianceStringFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListResourceDataSync {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_resource_data_sync_input::Builder,
    }
    impl ListResourceDataSync {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListResourceDataSyncOutput,
            smithy_http::result::SdkError<crate::error::ListResourceDataSyncError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>View a list of resource data syncs according to the sync type. Specify
        /// <code>SyncToDestination</code> to view resource data syncs that synchronize data to an Amazon S3
        /// bucket. Specify <code>SyncFromSource</code> to view resource data syncs from AWS Organizations or from
        /// multiple AWS Regions.</p>
        pub fn sync_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sync_type(inp);
            self
        }
        pub fn set_sync_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_sync_type(inp);
            self
        }
        /// <p>A token to start the list. Use this token to get the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>The maximum number of items to return for this call. The call also returns a token that you
        /// can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl ListTagsForResource {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Returns a list of tags for a specific resource type.</p>
        pub fn resource_type(mut self, inp: crate::model::ResourceTypeForTagging) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(
            mut self,
            inp: std::option::Option<crate::model::ResourceTypeForTagging>,
        ) -> Self {
            self.inner = self.inner.set_resource_type(inp);
            self
        }
        /// <p>The resource ID for which you want to see a list of tags.</p>
        pub fn resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(inp);
            self
        }
        pub fn set_resource_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ModifyDocumentPermission {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::modify_document_permission_input::Builder,
    }
    impl ModifyDocumentPermission {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ModifyDocumentPermissionOutput,
            smithy_http::result::SdkError<crate::error::ModifyDocumentPermissionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the document that you want to share.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The permission type for the document. The permission type can be
        /// <i>Share</i>.</p>
        pub fn permission_type(mut self, inp: crate::model::DocumentPermissionType) -> Self {
            self.inner = self.inner.permission_type(inp);
            self
        }
        pub fn set_permission_type(
            mut self,
            inp: std::option::Option<crate::model::DocumentPermissionType>,
        ) -> Self {
            self.inner = self.inner.set_permission_type(inp);
            self
        }
        /// <p>The AWS user accounts that should have access to the document. The account IDs can either be
        /// a group of account IDs or <i>All</i>.</p>
        pub fn account_ids_to_add(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_ids_to_add(inp);
            self
        }
        pub fn set_account_ids_to_add(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_account_ids_to_add(inp);
            self
        }
        /// <p>The AWS user accounts that should no longer have access to the document. The AWS user
        /// account can either be a group of account IDs or <i>All</i>. This action has a
        /// higher priority than <i>AccountIdsToAdd</i>. If you specify an account ID to add
        /// and the same ID to remove, the system removes access to the document.</p>
        pub fn account_ids_to_remove(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_ids_to_remove(inp);
            self
        }
        pub fn set_account_ids_to_remove(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_account_ids_to_remove(inp);
            self
        }
        /// <p>(Optional) The version of the document to share. If it's not specified, the system choose
        /// the <code>Default</code> version to share.</p>
        pub fn shared_document_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.shared_document_version(inp);
            self
        }
        pub fn set_shared_document_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_shared_document_version(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct PutComplianceItems {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::put_compliance_items_input::Builder,
    }
    impl PutComplianceItems {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutComplianceItemsOutput,
            smithy_http::result::SdkError<crate::error::PutComplianceItemsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Specify an ID for this resource. For a managed instance, this is the instance ID.</p>
        pub fn resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(inp);
            self
        }
        pub fn set_resource_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(inp);
            self
        }
        /// <p>Specify the type of resource. <code>ManagedInstance</code> is currently the only supported
        /// resource type.</p>
        pub fn resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_type(inp);
            self
        }
        /// <p>Specify the compliance type. For example, specify Association (for a State Manager
        /// association), Patch, or Custom:<code>string</code>.</p>
        pub fn compliance_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.compliance_type(inp);
            self
        }
        pub fn set_compliance_type(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_compliance_type(inp);
            self
        }
        /// <p>A summary of the call execution that includes an execution ID, the type of execution (for
        /// example, <code>Command</code>), and the date/time of the execution using a datetime object that
        /// is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.</p>
        pub fn execution_summary(mut self, inp: crate::model::ComplianceExecutionSummary) -> Self {
            self.inner = self.inner.execution_summary(inp);
            self
        }
        pub fn set_execution_summary(
            mut self,
            inp: std::option::Option<crate::model::ComplianceExecutionSummary>,
        ) -> Self {
            self.inner = self.inner.set_execution_summary(inp);
            self
        }
        /// <p>Information about the compliance as defined by the resource type. For example, for a patch
        /// compliance type, <code>Items</code> includes information about the PatchSeverity, Classification,
        /// and so on.</p>
        pub fn items(mut self, inp: impl Into<crate::model::ComplianceItemEntry>) -> Self {
            self.inner = self.inner.items(inp);
            self
        }
        pub fn set_items(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ComplianceItemEntry>>,
        ) -> Self {
            self.inner = self.inner.set_items(inp);
            self
        }
        /// <p>MD5 or SHA-256 content hash. The content hash is used to determine if existing information
        /// should be overwritten or ignored. If the content hashes match, the request to put compliance
        /// information is ignored.</p>
        pub fn item_content_hash(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.item_content_hash(inp);
            self
        }
        pub fn set_item_content_hash(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_item_content_hash(inp);
            self
        }
        /// <p>The mode for uploading compliance items. You can specify <code>COMPLETE</code> or
        /// <code>PARTIAL</code>. In <code>COMPLETE</code> mode, the system overwrites all existing
        /// compliance information for the resource. You must provide a full list of compliance items each
        /// time you send the request.</p>
        /// <p>In <code>PARTIAL</code> mode, the system overwrites compliance information for a specific
        /// association. The association must be configured with <code>SyncCompliance</code> set to
        /// <code>MANUAL</code>. By default, all requests use <code>COMPLETE</code> mode.</p>
        /// <note>
        /// <p>This attribute is only valid for association compliance.</p>
        /// </note>
        pub fn upload_type(mut self, inp: crate::model::ComplianceUploadType) -> Self {
            self.inner = self.inner.upload_type(inp);
            self
        }
        pub fn set_upload_type(
            mut self,
            inp: std::option::Option<crate::model::ComplianceUploadType>,
        ) -> Self {
            self.inner = self.inner.set_upload_type(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct PutInventory {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::put_inventory_input::Builder,
    }
    impl PutInventory {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutInventoryOutput,
            smithy_http::result::SdkError<crate::error::PutInventoryError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>An instance ID where you want to add or update inventory items.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>The inventory items that you want to add or update on instances.</p>
        pub fn items(mut self, inp: impl Into<crate::model::InventoryItem>) -> Self {
            self.inner = self.inner.items(inp);
            self
        }
        pub fn set_items(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InventoryItem>>,
        ) -> Self {
            self.inner = self.inner.set_items(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct PutParameter {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::put_parameter_input::Builder,
    }
    impl PutParameter {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutParameterOutput,
            smithy_http::result::SdkError<crate::error::PutParameterError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The fully qualified name of the parameter that you want to add to the system. The fully
        /// qualified name includes the complete hierarchy of the parameter path and name. For parameters in
        /// a hierarchy, you must include a leading forward slash character (/) when you create or reference
        /// a parameter. For example: <code>/Dev/DBServer/MySQL/db-string13</code>
        /// </p>
        /// <p>Naming Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Parameter names are case sensitive.</p>
        /// </li>
        /// <li>
        /// <p>A parameter name must be unique within an AWS Region</p>
        /// </li>
        /// <li>
        /// <p>A parameter name can't be prefixed with "aws" or "ssm" (case-insensitive).</p>
        /// </li>
        /// <li>
        /// <p>Parameter names can include only the following symbols and letters:
        /// <code>a-zA-Z0-9_.-</code>
        /// </p>
        /// <p>In addition, the slash character ( / ) is used to delineate hierarchies in parameter
        /// names. For example: <code>/Dev/Production/East/Project-ABC/MyParameter</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>A parameter name can't include spaces.</p>
        /// </li>
        /// <li>
        /// <p>Parameter hierarchies are limited to a maximum depth of fifteen levels.</p>
        /// </li>
        /// </ul>
        /// <p>For additional information about valid values for parameter names, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-su-create.html">Creating Systems Manager parameters</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        /// <note>
        /// <p>The maximum length constraint listed below includes capacity for additional system
        /// attributes that are not part of the name. The maximum length for a parameter name, including the
        /// full length of the parameter ARN, is 1011 characters. For example, the length of the following
        /// parameter name is 65 characters, not 20 characters:</p>
        /// <p>
        /// <code>arn:aws:ssm:us-east-2:111122223333:parameter/ExampleParameterName</code>
        /// </p>
        /// </note>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>Information about the parameter that you want to add to the system. Optional but
        /// recommended.</p>
        /// <important>
        /// <p>Do not enter personally identifiable information in this field.</p>
        /// </important>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>The parameter value that you want to add to the system. Standard parameters have a value
        /// limit of 4 KB. Advanced parameters have a value limit of 8 KB.</p>
        /// <note>
        /// <p>Parameters can't be referenced or nested in the values of other parameters. You can't
        /// include <code>{{}}</code> or <code>{{ssm:<i>parameter-name</i>}}</code> in a
        /// parameter value.</p>
        /// </note>
        pub fn value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.value(inp);
            self
        }
        pub fn set_value(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_value(inp);
            self
        }
        /// <p>The type of parameter that you want to add to the system.</p>
        /// <note>
        /// <p>
        /// <code>SecureString</code> is not currently supported for AWS CloudFormation
        /// templates.</p>
        /// </note>
        /// <p>Items in a <code>StringList</code> must be separated by a comma (,). You can't
        /// use other punctuation or special character to escape items in the list. If you have a parameter
        /// value that requires a comma, then use the <code>String</code> data type.</p>
        /// <important>
        /// <p>Specifying a parameter type is not required when updating a parameter. You must specify a
        /// parameter type when creating a parameter.</p>
        /// </important>
        pub fn r#type(mut self, inp: crate::model::ParameterType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<crate::model::ParameterType>) -> Self {
            self.inner = self.inner.set_type(inp);
            self
        }
        /// <p>The KMS Key ID that you want to use to encrypt a parameter. Either the default AWS Key
        /// Management Service (AWS KMS) key automatically assigned to your AWS account or a custom key.
        /// Required for parameters that use the <code>SecureString</code> data type.</p>
        /// <p>If you don't specify a key ID, the system uses the default key associated with your AWS
        /// account.</p>
        /// <ul>
        /// <li>
        /// <p>To use your default AWS KMS key, choose the <code>SecureString</code> data
        /// type, and do <i>not</i> specify the <code>Key ID</code> when you
        /// create the parameter. The system automatically populates <code>Key ID</code> with
        /// your default KMS key.</p>
        /// </li>
        /// <li>
        /// <p>To use a custom KMS key, choose the <code>SecureString</code> data type with
        /// the <code>Key ID</code> parameter.</p>
        /// </li>
        /// </ul>
        pub fn key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_id(inp);
            self
        }
        pub fn set_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_id(inp);
            self
        }
        /// <p>Overwrite an existing parameter. The default value is 'false'.</p>
        pub fn overwrite(mut self, inp: bool) -> Self {
            self.inner = self.inner.overwrite(inp);
            self
        }
        pub fn set_overwrite(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_overwrite(inp);
            self
        }
        /// <p>A regular expression used to validate the parameter value. For example, for String types
        /// with values restricted to numbers, you can specify the following: AllowedPattern=^\d+$ </p>
        pub fn allowed_pattern(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.allowed_pattern(inp);
            self
        }
        pub fn set_allowed_pattern(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_allowed_pattern(inp);
            self
        }
        /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
        /// different ways, such as by purpose, owner, or environment. For example, you might want to tag a
        /// Systems Manager parameter to identify the type of resource to which it applies, the environment, or the
        /// type of configuration data referenced by the parameter. In this case, you could specify the
        /// following key name/value pairs:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Key=Resource,Value=S3bucket</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Key=OS,Value=Windows</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Key=ParameterType,Value=LicenseKey</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>To add tags to an existing Systems Manager parameter, use the <a>AddTagsToResource</a>
        /// action.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// <p>The parameter tier to assign to a parameter.</p>
        /// <p>Parameter Store offers a standard tier and an advanced tier for parameters. Standard
        /// parameters have a content size limit of 4 KB and can't be configured to use parameter policies.
        /// You can create a maximum of 10,000 standard parameters for each Region in an AWS account.
        /// Standard parameters are offered at no additional cost. </p>
        /// <p>Advanced parameters have a content size limit of 8 KB and can be configured to use parameter
        /// policies. You can create a maximum of 100,000 advanced parameters for each Region in an AWS
        /// account. Advanced parameters incur a charge. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-advanced-parameters.html">Standard and
        /// advanced parameter tiers</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        /// <p>You can change a standard parameter to an advanced parameter any time. But you can't revert
        /// an advanced parameter to a standard parameter. Reverting an advanced parameter to a standard
        /// parameter would result in data loss because the system would truncate the size of the parameter
        /// from 8 KB to 4 KB. Reverting would also remove any policies attached to the parameter. Lastly,
        /// advanced parameters use a different form of encryption than standard parameters. </p>
        /// <p>If you no longer need an advanced parameter, or if you no longer want to incur charges for
        /// an advanced parameter, you must delete it and recreate it as a new standard parameter. </p>
        /// <p>
        /// <b>Using the Default Tier Configuration</b>
        /// </p>
        /// <p>In <code>PutParameter</code> requests, you can specify the tier to create the parameter in.
        /// Whenever you specify a tier in the request, Parameter Store creates or updates the parameter
        /// according to that request. However, if you do not specify a tier in a request, Parameter Store
        /// assigns the tier based on the current Parameter Store default tier configuration.</p>
        /// <p>The default tier when you begin using Parameter Store is the standard-parameter tier. If you
        /// use the advanced-parameter tier, you can specify one of the following as the default:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Advanced</b>: With this option, Parameter Store evaluates all
        /// requests as advanced parameters. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Intelligent-Tiering</b>: With this option, Parameter Store
        /// evaluates each request to determine if the parameter is standard or advanced. </p>
        /// <p>If the request doesn't include any options that require an advanced parameter, the
        /// parameter is created in the standard-parameter tier. If one or more options requiring an
        /// advanced parameter are included in the request, Parameter Store create a parameter in the
        /// advanced-parameter tier.</p>
        /// <p>This approach helps control your parameter-related costs by always creating standard
        /// parameters unless an advanced parameter is necessary. </p>
        /// </li>
        /// </ul>
        /// <p>Options that require an advanced parameter include the following:</p>
        /// <ul>
        /// <li>
        /// <p>The content size of the parameter is more than 4 KB.</p>
        /// </li>
        /// <li>
        /// <p>The parameter uses a parameter policy.</p>
        /// </li>
        /// <li>
        /// <p>More than 10,000 parameters already exist in your AWS account in the current
        /// Region.</p>
        /// </li>
        /// </ul>
        /// <p>For more information about configuring the default tier option, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/ps-default-tier.html">Specifying a
        /// default parameter tier</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn tier(mut self, inp: crate::model::ParameterTier) -> Self {
            self.inner = self.inner.tier(inp);
            self
        }
        pub fn set_tier(mut self, inp: std::option::Option<crate::model::ParameterTier>) -> Self {
            self.inner = self.inner.set_tier(inp);
            self
        }
        /// <p>One or more policies to apply to a parameter. This action takes a JSON array. Parameter
        /// Store supports the following policy types:</p>
        /// <p>Expiration: This policy deletes the parameter after it expires. When you create the policy,
        /// you specify the expiration date. You can update the expiration date and time by updating the
        /// policy. Updating the <i>parameter</i> does not affect the expiration date and time.
        /// When the expiration time is reached, Parameter Store deletes the parameter.</p>
        /// <p>ExpirationNotification: This policy triggers an event in Amazon CloudWatch Events that
        /// notifies you about the expiration. By using this policy, you can receive notification before or
        /// after the expiration time is reached, in units of days or hours.</p>
        /// <p>NoChangeNotification: This policy triggers a CloudWatch event if a parameter has not been
        /// modified for a specified period of time. This policy type is useful when, for example, a secret
        /// needs to be changed within a period of time, but it has not been changed.</p>
        /// <p>All existing policies are preserved until you send new policies or an empty policy. For more
        /// information about parameter policies, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html">Assigning parameter
        /// policies</a>. </p>
        pub fn policies(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policies(inp);
            self
        }
        pub fn set_policies(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policies(inp);
            self
        }
        /// <p>The data type for a <code>String</code> parameter. Supported data types include plain text
        /// and Amazon Machine Image IDs.</p>
        /// <p>
        /// <b>The following data type values are supported.</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>text</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>aws:ec2:image</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>When you create a <code>String</code> parameter and specify <code>aws:ec2:image</code>,
        /// Systems Manager validates the parameter value is in the required format, such as
        /// <code>ami-12345abcdeEXAMPLE</code>, and that the specified AMI is available in your AWS account.
        /// For more information, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-ec2-aliases.html">Native
        /// parameter support for Amazon Machine Image IDs</a> in the
        /// <i>AWS Systems Manager User Guide</i>.</p>
        pub fn data_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.data_type(inp);
            self
        }
        pub fn set_data_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_data_type(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct RegisterDefaultPatchBaseline {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::register_default_patch_baseline_input::Builder,
    }
    impl RegisterDefaultPatchBaseline {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RegisterDefaultPatchBaselineOutput,
            smithy_http::result::SdkError<crate::error::RegisterDefaultPatchBaselineError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the patch baseline that should be the default patch baseline.</p>
        pub fn baseline_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.baseline_id(inp);
            self
        }
        pub fn set_baseline_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_baseline_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct RegisterPatchBaselineForPatchGroup {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::register_patch_baseline_for_patch_group_input::Builder,
    }
    impl RegisterPatchBaselineForPatchGroup {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RegisterPatchBaselineForPatchGroupOutput,
            smithy_http::result::SdkError<crate::error::RegisterPatchBaselineForPatchGroupError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the patch baseline to register the patch group with.</p>
        pub fn baseline_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.baseline_id(inp);
            self
        }
        pub fn set_baseline_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_baseline_id(inp);
            self
        }
        /// <p>The name of the patch group that should be registered with the patch baseline.</p>
        pub fn patch_group(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.patch_group(inp);
            self
        }
        pub fn set_patch_group(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_patch_group(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct RegisterTargetWithMaintenanceWindow {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::register_target_with_maintenance_window_input::Builder,
    }
    impl RegisterTargetWithMaintenanceWindow {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RegisterTargetWithMaintenanceWindowOutput,
            smithy_http::result::SdkError<crate::error::RegisterTargetWithMaintenanceWindowError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window the target should be registered with.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
        /// <p>The type of target being registered with the maintenance window.</p>
        pub fn resource_type(mut self, inp: crate::model::MaintenanceWindowResourceType) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(
            mut self,
            inp: std::option::Option<crate::model::MaintenanceWindowResourceType>,
        ) -> Self {
            self.inner = self.inner.set_resource_type(inp);
            self
        }
        /// <p>The targets to register with the maintenance window. In other words, the instances to run
        /// commands on when the maintenance window runs.</p>
        /// <note>
        /// <p>If a single maintenance window task is registered with multiple targets, its task
        /// invocations occur sequentially and not in parallel. If your task must run on multiple targets at
        /// the same time, register a task for each target individually and assign each task the same
        /// priority level.</p>
        /// </note>
        /// <p>You can specify targets using instance IDs, resource group names, or tags that have been
        /// applied to instances.</p>
        /// <p>
        /// <b>Example 1</b>: Specify instance IDs</p>
        /// <p>
        /// <code>Key=InstanceIds,Values=<i>instance-id-1</i>,<i>instance-id-2</i>,<i>instance-id-3</i>
        /// </code>
        /// </p>
        /// <p>
        /// <b>Example 2</b>: Use tag key-pairs applied to instances</p>
        /// <p>
        /// <code>Key=tag:<i>my-tag-key</i>,Values=<i>my-tag-value-1</i>,<i>my-tag-value-2</i>
        /// </code>
        /// </p>
        /// <p>
        /// <b>Example 3</b>: Use tag-keys applied to instances</p>
        /// <p>
        /// <code>Key=tag-key,Values=<i>my-tag-key-1</i>,<i>my-tag-key-2</i>
        /// </code>
        /// </p>
        /// <p>
        /// <b>Example 4</b>: Use resource group names</p>
        /// <p>
        /// <code>Key=resource-groups:Name,Values=<i>resource-group-name</i>
        /// </code>
        /// </p>
        /// <p>
        /// <b>Example 5</b>: Use filters for resource group types</p>
        /// <p>
        /// <code>Key=resource-groups:ResourceTypeFilters,Values=<i>resource-type-1</i>,<i>resource-type-2</i>
        /// </code>
        /// </p>
        /// <note>
        /// <p>For <code>Key=resource-groups:ResourceTypeFilters</code>, specify resource types in the
        /// following format</p>
        /// <p>
        /// <code>Key=resource-groups:ResourceTypeFilters,Values=<i>AWS::EC2::INSTANCE</i>,<i>AWS::EC2::VPC</i>
        /// </code>
        /// </p>
        /// </note>
        /// <p>For more information about these examples formats, including the best use case for each one,
        /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-tutorial-targets-examples.html">Examples: Register
        /// targets with a maintenance window</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::Target>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.inner = self.inner.set_targets(inp);
            self
        }
        /// <p>User-provided value that will be included in any CloudWatch events raised while running
        /// tasks for these targets in this maintenance window.</p>
        pub fn owner_information(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.owner_information(inp);
            self
        }
        pub fn set_owner_information(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_owner_information(inp);
            self
        }
        /// <p>An optional name for the target.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>An optional description for the target.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>User-provided idempotency token.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct RegisterTaskWithMaintenanceWindow {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::register_task_with_maintenance_window_input::Builder,
    }
    impl RegisterTaskWithMaintenanceWindow {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RegisterTaskWithMaintenanceWindowOutput,
            smithy_http::result::SdkError<crate::error::RegisterTaskWithMaintenanceWindowError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window the task should be added to.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
        /// <p>The targets (either instances or maintenance window targets).</p>
        /// <note>
        /// <p>One or more targets must be specified for maintenance window Run Command-type tasks.
        /// Depending on the task, targets are optional for other maintenance window task types (Automation,
        /// AWS Lambda, and AWS Step Functions). For more information about running tasks that do not
        /// specify targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html">Registering
        /// maintenance window tasks without targets</a> in the
        /// <i>AWS Systems Manager User Guide</i>.</p>
        /// </note>
        /// <p>Specify instances using the following format: </p>
        /// <p>
        /// <code>Key=InstanceIds,Values=<instance-id-1>,<instance-id-2></code>
        /// </p>
        /// <p>Specify maintenance window targets using the following format:</p>
        /// <p>
        /// <code>Key=WindowTargetIds,Values=<window-target-id-1>,<window-target-id-2></code>
        /// </p>
        pub fn targets(mut self, inp: impl Into<crate::model::Target>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.inner = self.inner.set_targets(inp);
            self
        }
        /// <p>The ARN of the task to run.</p>
        pub fn task_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_arn(inp);
            self
        }
        pub fn set_task_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_arn(inp);
            self
        }
        /// <p>The ARN of the IAM service role for Systems Manager to assume when running a
        /// maintenance window task. If you do not specify a service role ARN, Systems Manager uses your account's
        /// service-linked role.  If no service-linked role for Systems Manager exists in your account, it is created when you run
        /// <code>RegisterTaskWithMaintenanceWindow</code>.</p>
        /// <p>For more information, see the following topics in the in the <i>AWS Systems Manager User Guide</i>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/using-service-linked-roles.html#slr-permissions">Using
        /// service-linked roles for Systems Manager</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html#maintenance-window-tasks-service-role">Should I use a service-linked role or a custom service role to run maintenance window tasks?
        /// </a>
        /// </p>
        /// </li>
        /// </ul>
        pub fn service_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_role_arn(inp);
            self
        }
        pub fn set_service_role_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_role_arn(inp);
            self
        }
        /// <p>The type of task being registered.</p>
        pub fn task_type(mut self, inp: crate::model::MaintenanceWindowTaskType) -> Self {
            self.inner = self.inner.task_type(inp);
            self
        }
        pub fn set_task_type(
            mut self,
            inp: std::option::Option<crate::model::MaintenanceWindowTaskType>,
        ) -> Self {
            self.inner = self.inner.set_task_type(inp);
            self
        }
        /// <p>The parameters that should be passed to the task when it is run.</p>
        /// <note>
        /// <p>
        /// <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
        /// instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
        /// about how Systems Manager handles these options for the supported maintenance window task
        /// types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
        /// </note>
        pub fn task_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::MaintenanceWindowTaskParameterValueExpression>,
        ) -> Self {
            self.inner = self.inner.task_parameters(k, v);
            self
        }
        pub fn set_task_parameters(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::MaintenanceWindowTaskParameterValueExpression,
                >,
            >,
        ) -> Self {
            self.inner = self.inner.set_task_parameters(inp);
            self
        }
        /// <p>The parameters that the task should use during execution. Populate only the fields that
        /// match the task type. All other fields should be empty. </p>
        pub fn task_invocation_parameters(
            mut self,
            inp: crate::model::MaintenanceWindowTaskInvocationParameters,
        ) -> Self {
            self.inner = self.inner.task_invocation_parameters(inp);
            self
        }
        pub fn set_task_invocation_parameters(
            mut self,
            inp: std::option::Option<crate::model::MaintenanceWindowTaskInvocationParameters>,
        ) -> Self {
            self.inner = self.inner.set_task_invocation_parameters(inp);
            self
        }
        /// <p>The priority of the task in the maintenance window, the lower the number the higher the
        /// priority. Tasks in a maintenance window are scheduled in priority order with tasks that have the
        /// same priority scheduled in parallel.</p>
        pub fn priority(mut self, inp: i32) -> Self {
            self.inner = self.inner.priority(inp);
            self
        }
        pub fn set_priority(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(inp);
            self
        }
        /// <p>The maximum number of targets this task can be run for in parallel.</p>
        /// <note>
        /// <p>For maintenance window tasks without a target specified, you cannot supply a value for this
        /// option. Instead, the system inserts a placeholder value of <code>1</code>. This value does not
        /// affect the running of your task.</p>
        /// </note>
        pub fn max_concurrency(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.max_concurrency(inp);
            self
        }
        pub fn set_max_concurrency(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_max_concurrency(inp);
            self
        }
        /// <p>The maximum number of errors allowed before this task stops being scheduled.</p>
        /// <note>
        /// <p>For maintenance window tasks without a target specified, you cannot supply a value for this
        /// option. Instead, the system inserts a placeholder value of <code>1</code>. This value does not
        /// affect the running of your task.</p>
        /// </note>
        pub fn max_errors(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.max_errors(inp);
            self
        }
        pub fn set_max_errors(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_max_errors(inp);
            self
        }
        /// <p>A structure containing information about an S3 bucket to write instance-level logs to. </p>
        /// <note>
        /// <p>
        /// <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
        /// <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
        /// For information about how Systems Manager handles these options for the supported maintenance
        /// window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
        /// </note>
        pub fn logging_info(mut self, inp: crate::model::LoggingInfo) -> Self {
            self.inner = self.inner.logging_info(inp);
            self
        }
        pub fn set_logging_info(
            mut self,
            inp: std::option::Option<crate::model::LoggingInfo>,
        ) -> Self {
            self.inner = self.inner.set_logging_info(inp);
            self
        }
        /// <p>An optional name for the task.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>An optional description for the task.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>User-provided idempotency token.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct RemoveTagsFromResource {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::remove_tags_from_resource_input::Builder,
    }
    impl RemoveTagsFromResource {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RemoveTagsFromResourceOutput,
            smithy_http::result::SdkError<crate::error::RemoveTagsFromResourceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The type of resource from which you want to remove a tag.</p>
        /// <note>
        /// <p>The ManagedInstance type for this API action is only for on-premises managed instances.
        /// Specify the name of the managed instance in the following format: mi-ID_number. For example,
        /// mi-1a2b3c4d5e6f.</p>
        /// </note>
        pub fn resource_type(mut self, inp: crate::model::ResourceTypeForTagging) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(
            mut self,
            inp: std::option::Option<crate::model::ResourceTypeForTagging>,
        ) -> Self {
            self.inner = self.inner.set_resource_type(inp);
            self
        }
        /// <p>The ID of the resource from which you want to remove tags. For example:</p>
        /// <p>ManagedInstance: mi-012345abcde</p>
        /// <p>MaintenanceWindow: mw-012345abcde</p>
        /// <p>PatchBaseline: pb-012345abcde</p>
        /// <p>OpsMetadata object: <code>ResourceID</code> for tagging is created from the Amazon Resource
        /// Name (ARN) for the object. Specifically, <code>ResourceID</code> is created from the strings that
        /// come after the word <code>opsmetadata</code> in the ARN. For example, an OpsMetadata object with
        /// an ARN of <code>arn:aws:ssm:us-east-2:1234567890:opsmetadata/aws/ssm/MyGroup/appmanager</code>
        /// has a <code>ResourceID</code> of either <code>aws/ssm/MyGroup/appmanager</code> or
        /// <code>/aws/ssm/MyGroup/appmanager</code>.</p>
        /// <p>For the Document and Parameter values, use the name of the resource.</p>
        /// <note>
        /// <p>The ManagedInstance type for this API action is only for on-premises managed instances.
        /// Specify the name of the managed instance in the following format: mi-ID_number. For example,
        /// mi-1a2b3c4d5e6f.</p>
        /// </note>
        pub fn resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(inp);
            self
        }
        pub fn set_resource_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(inp);
            self
        }
        /// <p>Tag keys that you want to remove from the specified resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ResetServiceSetting {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::reset_service_setting_input::Builder,
    }
    impl ResetServiceSetting {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ResetServiceSettingOutput,
            smithy_http::result::SdkError<crate::error::ResetServiceSettingError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The Amazon Resource Name (ARN) of the service setting to reset. The setting ID can be
        /// <code>/ssm/automation/customer-script-log-destination</code>,
        /// <code>/ssm/automation/customer-script-log-group-name</code>,
        /// <code>/ssm/parameter-store/default-parameter-tier</code>,
        /// <code>/ssm/parameter-store/high-throughput-enabled</code>, or
        /// <code>/ssm/managed-instance/activation-tier</code>. For example,
        /// <code>arn:aws:ssm:us-east-1:111122223333:servicesetting/ssm/parameter-store/high-throughput-enabled</code>.</p>
        pub fn setting_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.setting_id(inp);
            self
        }
        pub fn set_setting_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_setting_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ResumeSession {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::resume_session_input::Builder,
    }
    impl ResumeSession {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ResumeSessionOutput,
            smithy_http::result::SdkError<crate::error::ResumeSessionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the disconnected session to resume.</p>
        pub fn session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_id(inp);
            self
        }
        pub fn set_session_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct SendAutomationSignal {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::send_automation_signal_input::Builder,
    }
    impl SendAutomationSignal {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::SendAutomationSignalOutput,
            smithy_http::result::SdkError<crate::error::SendAutomationSignalError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The unique identifier for an existing Automation execution that you want to send the signal
        /// to.</p>
        pub fn automation_execution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.automation_execution_id(inp);
            self
        }
        pub fn set_automation_execution_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_automation_execution_id(inp);
            self
        }
        /// <p>The type of signal to send to an Automation execution. </p>
        pub fn signal_type(mut self, inp: crate::model::SignalType) -> Self {
            self.inner = self.inner.signal_type(inp);
            self
        }
        pub fn set_signal_type(
            mut self,
            inp: std::option::Option<crate::model::SignalType>,
        ) -> Self {
            self.inner = self.inner.set_signal_type(inp);
            self
        }
        /// <p>The data sent with the signal. The data schema depends on the type of signal used in the
        /// request.</p>
        /// <p>For <code>Approve</code> and <code>Reject</code> signal types, the payload is an optional
        /// comment that you can send with the signal type. For example:</p>
        /// <p>
        /// <code>Comment="Looks good"</code>
        /// </p>
        /// <p>For <code>StartStep</code> and <code>Resume</code> signal types, you must send the name of
        /// the Automation step to start or resume as the payload. For example:</p>
        /// <p>
        /// <code>StepName="step1"</code>
        /// </p>
        /// <p>For the <code>StopStep</code> signal type, you must send the step execution ID as the
        /// payload. For example:</p>
        /// <p>
        /// <code>StepExecutionId="97fff367-fc5a-4299-aed8-0123456789ab"</code>
        /// </p>
        pub fn payload(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.payload(k, v);
            self
        }
        pub fn set_payload(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.inner = self.inner.set_payload(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct SendCommand {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::send_command_input::Builder,
    }
    impl SendCommand {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::SendCommandOutput,
            smithy_http::result::SdkError<crate::error::SendCommandError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The IDs of the instances where the command should run. Specifying instance IDs is most
        /// useful when you are targeting a limited number of instances, though you can specify up to 50
        /// IDs.</p>
        /// <p>To target a larger number of instances, or if you prefer not to list individual instance
        /// IDs, we recommend using the <code>Targets</code> option instead. Using <code>Targets</code>,
        /// which accepts tag key-value pairs to identify the instances to send commands to, you can a send
        /// command to tens, hundreds, or thousands of instances at once.</p>
        /// <p>For more information about how to use targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html">Using targets and rate
        /// controls to send commands to a fleet</a> in the
        /// <i>AWS Systems Manager User Guide</i>.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(inp);
            self
        }
        /// <p>An array of search criteria that targets instances using a <code>Key,Value</code>
        /// combination that you specify. Specifying targets is most useful when you want to send a command
        /// to a large number of instances at once. Using <code>Targets</code>, which accepts tag key-value
        /// pairs to identify instances, you can send a command to tens, hundreds, or thousands of instances
        /// at once.</p>
        /// <p>To send a command to a smaller number of instances, you can use the <code>InstanceIds</code>
        /// option instead.</p>
        /// <p>For more information about how to use targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html">Sending commands to a
        /// fleet</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::Target>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.inner = self.inner.set_targets(inp);
            self
        }
        /// <p>The name of the Systems Manager document to run. This can be a public document or a custom document.
        /// To run a shared document belonging to another account, specify the document ARN. For more
        /// information about how to use shared documents, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-using-shared.html">Using shared SSM documents</a>
        /// in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn document_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_name(inp);
            self
        }
        pub fn set_document_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_document_name(inp);
            self
        }
        /// <p>The SSM document version to use in the request. You can specify $DEFAULT, $LATEST, or a
        /// specific version number. If you run commands by using the AWS CLI, then you must escape the first
        /// two options by using a backslash. If you specify a version number, then you don't need to use the
        /// backslash. For example:</p>
        /// <p>--document-version "\$DEFAULT"</p>
        /// <p>--document-version "\$LATEST"</p>
        /// <p>--document-version "3"</p>
        pub fn document_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_version(inp);
            self
        }
        pub fn set_document_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_version(inp);
            self
        }
        /// <p>The Sha256 or Sha1 hash created by the system when the document was created. </p>
        /// <note>
        /// <p>Sha1 hashes have been deprecated.</p>
        /// </note>
        pub fn document_hash(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_hash(inp);
            self
        }
        pub fn set_document_hash(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_document_hash(inp);
            self
        }
        /// <p>Sha256 or Sha1.</p>
        /// <note>
        /// <p>Sha1 hashes have been deprecated.</p>
        /// </note>
        pub fn document_hash_type(mut self, inp: crate::model::DocumentHashType) -> Self {
            self.inner = self.inner.document_hash_type(inp);
            self
        }
        pub fn set_document_hash_type(
            mut self,
            inp: std::option::Option<crate::model::DocumentHashType>,
        ) -> Self {
            self.inner = self.inner.set_document_hash_type(inp);
            self
        }
        /// <p>If this time is reached and the command has not already started running, it will not
        /// run.</p>
        pub fn timeout_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.timeout_seconds(inp);
            self
        }
        pub fn set_timeout_seconds(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_timeout_seconds(inp);
            self
        }
        /// <p>User-specified information about the command, such as a brief description of what the
        /// command should do.</p>
        pub fn comment(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment(inp);
            self
        }
        pub fn set_comment(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment(inp);
            self
        }
        /// <p>The required and optional parameters specified in the document being run.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.parameters(k, v);
            self
        }
        pub fn set_parameters(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.inner = self.inner.set_parameters(inp);
            self
        }
        /// <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager
        /// automatically determines the Region of the S3 bucket.</p>
        pub fn output_s3_region(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_s3_region(inp);
            self
        }
        pub fn set_output_s3_region(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_output_s3_region(inp);
            self
        }
        /// <p>The name of the S3 bucket where command execution responses should be stored.</p>
        pub fn output_s3_bucket_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_s3_bucket_name(inp);
            self
        }
        pub fn set_output_s3_bucket_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_output_s3_bucket_name(inp);
            self
        }
        /// <p>The directory structure within the S3 bucket where the responses should be stored.</p>
        pub fn output_s3_key_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_s3_key_prefix(inp);
            self
        }
        pub fn set_output_s3_key_prefix(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_output_s3_key_prefix(inp);
            self
        }
        /// <p>(Optional) The maximum number of instances that are allowed to run the command at the same
        /// time. You can specify a number such as 10 or a percentage such as 10%. The default value is 50.
        /// For more information about how to use MaxConcurrency, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-velocity">Using
        /// concurrency controls</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn max_concurrency(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.max_concurrency(inp);
            self
        }
        pub fn set_max_concurrency(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_max_concurrency(inp);
            self
        }
        /// <p>The maximum number of errors allowed without the command failing. When the command fails one
        /// more time beyond the value of MaxErrors, the systems stops sending the command to additional
        /// targets. You can specify a number like 10 or a percentage like 10%. The default value is 0. For
        /// more information about how to use MaxErrors, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-maxerrors">Using
        /// error controls</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn max_errors(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.max_errors(inp);
            self
        }
        pub fn set_max_errors(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_max_errors(inp);
            self
        }
        /// <p>The ARN of the IAM service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for Run
        /// Command commands.</p>
        pub fn service_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_role_arn(inp);
            self
        }
        pub fn set_service_role_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_role_arn(inp);
            self
        }
        /// <p>Configurations for sending notifications.</p>
        pub fn notification_config(mut self, inp: crate::model::NotificationConfig) -> Self {
            self.inner = self.inner.notification_config(inp);
            self
        }
        pub fn set_notification_config(
            mut self,
            inp: std::option::Option<crate::model::NotificationConfig>,
        ) -> Self {
            self.inner = self.inner.set_notification_config(inp);
            self
        }
        /// <p>Enables Systems Manager to send Run Command output to Amazon CloudWatch Logs. </p>
        pub fn cloud_watch_output_config(
            mut self,
            inp: crate::model::CloudWatchOutputConfig,
        ) -> Self {
            self.inner = self.inner.cloud_watch_output_config(inp);
            self
        }
        pub fn set_cloud_watch_output_config(
            mut self,
            inp: std::option::Option<crate::model::CloudWatchOutputConfig>,
        ) -> Self {
            self.inner = self.inner.set_cloud_watch_output_config(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct StartAssociationsOnce {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::start_associations_once_input::Builder,
    }
    impl StartAssociationsOnce {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::StartAssociationsOnceOutput,
            smithy_http::result::SdkError<crate::error::StartAssociationsOnceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The association IDs that you want to run immediately and only one time.</p>
        pub fn association_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_ids(inp);
            self
        }
        pub fn set_association_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_association_ids(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct StartAutomationExecution {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::start_automation_execution_input::Builder,
    }
    impl StartAutomationExecution {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::StartAutomationExecutionOutput,
            smithy_http::result::SdkError<crate::error::StartAutomationExecutionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the Systems Manager document to run. This can be a public document or a custom document.
        /// To run a shared document belonging to another account, specify the document ARN. For more
        /// information about how to use shared documents, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-using-shared.html">Using shared SSM documents</a>
        /// in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn document_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_name(inp);
            self
        }
        pub fn set_document_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_document_name(inp);
            self
        }
        /// <p>The version of the Automation document to use for this execution.</p>
        pub fn document_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_version(inp);
            self
        }
        pub fn set_document_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_version(inp);
            self
        }
        /// <p>A key-value map of execution parameters, which match the declared parameters in the
        /// Automation document.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.parameters(k, v);
            self
        }
        pub fn set_parameters(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.inner = self.inner.set_parameters(inp);
            self
        }
        /// <p>User-provided idempotency token. The token must be unique, is case insensitive, enforces the
        /// UUID format, and can't be reused.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(inp);
            self
        }
        /// <p>The execution mode of the automation. Valid modes include the following: Auto and
        /// Interactive. The default mode is Auto.</p>
        pub fn mode(mut self, inp: crate::model::ExecutionMode) -> Self {
            self.inner = self.inner.mode(inp);
            self
        }
        pub fn set_mode(mut self, inp: std::option::Option<crate::model::ExecutionMode>) -> Self {
            self.inner = self.inner.set_mode(inp);
            self
        }
        /// <p>The name of the parameter used as the target resource for the rate-controlled execution.
        /// Required if you specify targets.</p>
        pub fn target_parameter_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_parameter_name(inp);
            self
        }
        pub fn set_target_parameter_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_parameter_name(inp);
            self
        }
        /// <p>A key-value mapping to target resources. Required if you specify TargetParameterName.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::Target>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.inner = self.inner.set_targets(inp);
            self
        }
        /// <p>A key-value mapping of document parameters to target resources. Both Targets and TargetMaps
        /// cannot be specified together.</p>
        pub fn target_maps(
            mut self,
            inp: impl Into<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.inner = self.inner.target_maps(inp);
            self
        }
        pub fn set_target_maps(
            mut self,
            inp: std::option::Option<
                std::vec::Vec<
                    std::collections::HashMap<
                        std::string::String,
                        std::vec::Vec<std::string::String>,
                    >,
                >,
            >,
        ) -> Self {
            self.inner = self.inner.set_target_maps(inp);
            self
        }
        /// <p>The maximum number of targets allowed to run this task in parallel. You can specify a
        /// number, such as 10, or a percentage, such as 10%. The default value is 10.</p>
        pub fn max_concurrency(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.max_concurrency(inp);
            self
        }
        pub fn set_max_concurrency(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_max_concurrency(inp);
            self
        }
        /// <p>The number of errors that are allowed before the system stops running the automation on
        /// additional targets. You can specify either an absolute number of errors, for example 10, or a
        /// percentage of the target set, for example 10%. If you specify 3, for example, the system stops
        /// running the automation when the fourth error is received. If you specify 0, then the system stops
        /// running the automation on additional targets after the first error result is returned. If you run
        /// an automation on 50 resources and set max-errors to 10%, then the system stops running the
        /// automation on additional targets when the sixth error is received.</p>
        /// <p>Executions that are already running an automation when max-errors is reached are allowed to
        /// complete, but some of these executions may fail as well. If you need to ensure that there won't
        /// be more than max-errors failed executions, set max-concurrency to 1 so the executions proceed one
        /// at a time.</p>
        pub fn max_errors(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.max_errors(inp);
            self
        }
        pub fn set_max_errors(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_max_errors(inp);
            self
        }
        /// <p>A location is a combination of AWS Regions and/or AWS accounts where you want to run the
        /// Automation. Use this action to start an Automation in multiple Regions and multiple accounts. For
        /// more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-automation-multiple-accounts-and-regions.html">Running Automation workflows in multiple AWS Regions and accounts</a> in the
        /// <i>AWS Systems Manager User Guide</i>. </p>
        pub fn target_locations(mut self, inp: impl Into<crate::model::TargetLocation>) -> Self {
            self.inner = self.inner.target_locations(inp);
            self
        }
        pub fn set_target_locations(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
        ) -> Self {
            self.inner = self.inner.set_target_locations(inp);
            self
        }
        /// <p>Optional metadata that you assign to a resource. You can specify a maximum of five tags for
        /// an automation. Tags enable you to categorize a resource in different ways, such as by purpose,
        /// owner, or environment. For example, you might want to tag an automation to identify an
        /// environment or operating system. In this case, you could specify the following key name/value
        /// pairs:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Key=environment,Value=test</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Key=OS,Value=Windows</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>To add tags to an existing patch baseline, use the <a>AddTagsToResource</a>
        /// action.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct StartChangeRequestExecution {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::start_change_request_execution_input::Builder,
    }
    impl StartChangeRequestExecution {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::StartChangeRequestExecutionOutput,
            smithy_http::result::SdkError<crate::error::StartChangeRequestExecutionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The date and time specified in the change request to run the Automation runbooks.</p>
        /// <note>
        /// <p>The Automation runbooks specified for the runbook workflow can't run until all required
        /// approvals for the change request have been received.</p>
        /// </note>
        pub fn scheduled_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.scheduled_time(inp);
            self
        }
        pub fn set_scheduled_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_time(inp);
            self
        }
        /// <p>The name of the change template document to run during the runbook workflow.</p>
        pub fn document_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_name(inp);
            self
        }
        pub fn set_document_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_document_name(inp);
            self
        }
        /// <p>The version of the change template document to run during the runbook workflow.</p>
        pub fn document_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_version(inp);
            self
        }
        pub fn set_document_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_version(inp);
            self
        }
        /// <p>A key-value map of parameters that match the declared parameters in the change template
        /// document.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.parameters(k, v);
            self
        }
        pub fn set_parameters(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.inner = self.inner.set_parameters(inp);
            self
        }
        /// <p>The name of the change request associated with the runbook workflow to be run.</p>
        pub fn change_request_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.change_request_name(inp);
            self
        }
        pub fn set_change_request_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_change_request_name(inp);
            self
        }
        /// <p>The user-provided idempotency token. The token must be unique, is case insensitive, enforces
        /// the UUID format, and can't be reused.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(inp);
            self
        }
        /// <p>Information about the Automation runbooks (Automation documents) that are run during the
        /// runbook workflow.</p>
        /// <note>
        /// <p>The Automation runbooks specified for the runbook workflow can't run until all required
        /// approvals for the change request have been received.</p>
        /// </note>
        pub fn runbooks(mut self, inp: impl Into<crate::model::Runbook>) -> Self {
            self.inner = self.inner.runbooks(inp);
            self
        }
        pub fn set_runbooks(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Runbook>>,
        ) -> Self {
            self.inner = self.inner.set_runbooks(inp);
            self
        }
        /// <p>Optional metadata that you assign to a resource. You can specify a maximum of five tags for
        /// a change request. Tags enable you to categorize a resource in different ways, such as by
        /// purpose, owner, or environment. For example, you might want to tag a change request to identify
        /// an environment or target AWS Region. In this case, you could specify the following key-value
        /// pairs:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Key=Environment,Value=Production</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Key=Region,Value=us-east-2</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// <p>The time that the requester expects the runbook workflow related to the change request to
        /// complete. The time is an estimate only that the requester provides for reviewers.</p>
        pub fn scheduled_end_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.scheduled_end_time(inp);
            self
        }
        pub fn set_scheduled_end_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_end_time(inp);
            self
        }
        /// <p>User-provided details about the change. If no details are provided, content specified in the
        /// <b>Template information</b> section of the associated change template
        /// is added.</p>
        pub fn change_details(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.change_details(inp);
            self
        }
        pub fn set_change_details(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_change_details(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct StartSession {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::start_session_input::Builder,
    }
    impl StartSession {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::StartSessionOutput,
            smithy_http::result::SdkError<crate::error::StartSessionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The instance to connect to for the session.</p>
        pub fn target(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target(inp);
            self
        }
        pub fn set_target(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target(inp);
            self
        }
        /// <p>The name of the SSM document to define the parameters and plugin settings for the session.
        /// For example, <code>SSM-SessionManagerRunShell</code>. You can call the <a>GetDocument</a> API to verify the document exists before attempting to start a session.
        /// If no document name is provided, a shell to the instance is launched by default.</p>
        pub fn document_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_name(inp);
            self
        }
        pub fn set_document_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_document_name(inp);
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.parameters(k, v);
            self
        }
        pub fn set_parameters(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.inner = self.inner.set_parameters(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct StopAutomationExecution {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::stop_automation_execution_input::Builder,
    }
    impl StopAutomationExecution {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::StopAutomationExecutionOutput,
            smithy_http::result::SdkError<crate::error::StopAutomationExecutionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The execution ID of the Automation to stop.</p>
        pub fn automation_execution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.automation_execution_id(inp);
            self
        }
        pub fn set_automation_execution_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_automation_execution_id(inp);
            self
        }
        /// <p>The stop request type. Valid types include the following: Cancel and Complete. The default
        /// type is Cancel.</p>
        pub fn r#type(mut self, inp: crate::model::StopType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<crate::model::StopType>) -> Self {
            self.inner = self.inner.set_type(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct TerminateSession {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::terminate_session_input::Builder,
    }
    impl TerminateSession {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TerminateSessionOutput,
            smithy_http::result::SdkError<crate::error::TerminateSessionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the session to terminate.</p>
        pub fn session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_id(inp);
            self
        }
        pub fn set_session_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UnlabelParameterVersion {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::unlabel_parameter_version_input::Builder,
    }
    impl UnlabelParameterVersion {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UnlabelParameterVersionOutput,
            smithy_http::result::SdkError<crate::error::UnlabelParameterVersionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The parameter name of which you want to delete one or more labels.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The specific version of the parameter which you want to delete one or more labels from. If
        /// it is not present, the call will fail.</p>
        pub fn parameter_version(mut self, inp: i64) -> Self {
            self.inner = self.inner.parameter_version(inp);
            self
        }
        pub fn set_parameter_version(mut self, inp: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_parameter_version(inp);
            self
        }
        /// <p>One or more labels to delete from the specified parameter version.</p>
        pub fn labels(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.labels(inp);
            self
        }
        pub fn set_labels(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_labels(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateAssociation {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_association_input::Builder,
    }
    impl UpdateAssociation {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateAssociationOutput,
            smithy_http::result::SdkError<crate::error::UpdateAssociationError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the association you want to update. </p>
        pub fn association_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(inp);
            self
        }
        pub fn set_association_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_association_id(inp);
            self
        }
        /// <p>The parameters you want to update for the association. If you create a parameter using
        /// Parameter Store, you can reference the parameter using {{ssm:parameter-name}}</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.parameters(k, v);
            self
        }
        pub fn set_parameters(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.inner = self.inner.set_parameters(inp);
            self
        }
        /// <p>The document version you want update for the association. </p>
        pub fn document_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_version(inp);
            self
        }
        pub fn set_document_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_version(inp);
            self
        }
        /// <p>The cron expression used to schedule the association that you want to update.</p>
        pub fn schedule_expression(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schedule_expression(inp);
            self
        }
        pub fn set_schedule_expression(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_schedule_expression(inp);
            self
        }
        /// <p>An S3 bucket where you want to store the results of this request.</p>
        pub fn output_location(
            mut self,
            inp: crate::model::InstanceAssociationOutputLocation,
        ) -> Self {
            self.inner = self.inner.output_location(inp);
            self
        }
        pub fn set_output_location(
            mut self,
            inp: std::option::Option<crate::model::InstanceAssociationOutputLocation>,
        ) -> Self {
            self.inner = self.inner.set_output_location(inp);
            self
        }
        /// <p>The name of the SSM document that contains the configuration information for the instance.
        /// You can specify Command or Automation documents.</p>
        /// <p>You can specify AWS-predefined documents, documents you created, or a document that is
        /// shared with you from another account.</p>
        /// <p>For SSM documents that are shared with you from other AWS accounts, you must specify the
        /// complete SSM document ARN, in the following format:</p>
        /// <p>
        /// <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:document/<i>document-name</i>
        /// </code>
        /// </p>
        /// <p>For example:</p>
        /// <p>
        /// <code>arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document</code>
        /// </p>
        /// <p>For AWS-predefined documents and SSM documents you created in your account, you only need to
        /// specify the document name. For example, <code>AWS-ApplyPatchBaseline</code> or
        /// <code>My-Document</code>.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The targets of the association.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::Target>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.inner = self.inner.set_targets(inp);
            self
        }
        /// <p>The name of the association that you want to update.</p>
        pub fn association_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_name(inp);
            self
        }
        pub fn set_association_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_name(inp);
            self
        }
        /// <p>This parameter is provided for concurrency control purposes. You must specify the latest
        /// association version in the service. If you want to ensure that this request succeeds, either
        /// specify <code>$LATEST</code>, or omit this parameter.</p>
        pub fn association_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_version(inp);
            self
        }
        pub fn set_association_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_version(inp);
            self
        }
        /// <p>Specify the target for the association. This target is required for associations that use an
        /// Automation document and target resources by using rate controls.</p>
        pub fn automation_target_parameter_name(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.automation_target_parameter_name(inp);
            self
        }
        pub fn set_automation_target_parameter_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_automation_target_parameter_name(inp);
            self
        }
        /// <p>The number of errors that are allowed before the system stops sending requests to run the
        /// association on additional targets. You can specify either an absolute number of errors, for
        /// example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
        /// the system stops sending requests when the fourth error is received. If you specify 0, then the
        /// system stops sending requests after the first error is returned. If you run an association on 50
        /// instances and set MaxError to 10%, then the system stops sending the request when the sixth error
        /// is received.</p>
        /// <p>Executions that are already running an association when MaxErrors is reached are allowed to
        /// complete, but some of these executions may fail as well. If you need to ensure that there won't
        /// be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
        /// at a time.</p>
        pub fn max_errors(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.max_errors(inp);
            self
        }
        pub fn set_max_errors(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_max_errors(inp);
            self
        }
        /// <p>The maximum number of targets allowed to run the association at the same time. You can
        /// specify a number, for example 10, or a percentage of the target set, for example 10%. The default
        /// value is 100%, which means all targets run the association at the same time.</p>
        /// <p>If a new instance starts and attempts to run an association while Systems Manager is running
        /// MaxConcurrency associations, the association is allowed to run. During the next association
        /// interval, the new instance will process its association within the limit specified for
        /// MaxConcurrency.</p>
        pub fn max_concurrency(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.max_concurrency(inp);
            self
        }
        pub fn set_max_concurrency(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_max_concurrency(inp);
            self
        }
        /// <p>The severity level to assign to the association.</p>
        pub fn compliance_severity(
            mut self,
            inp: crate::model::AssociationComplianceSeverity,
        ) -> Self {
            self.inner = self.inner.compliance_severity(inp);
            self
        }
        pub fn set_compliance_severity(
            mut self,
            inp: std::option::Option<crate::model::AssociationComplianceSeverity>,
        ) -> Self {
            self.inner = self.inner.set_compliance_severity(inp);
            self
        }
        /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
        /// <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
        /// execution to determine the compliance status. If the association execution runs successfully,
        /// then the association is <code>COMPLIANT</code>. If the association execution doesn't run
        /// successfully, the association is <code>NON-COMPLIANT</code>.</p>
        /// <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
        /// for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
        /// managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
        /// <p>By default, all associations use <code>AUTO</code> mode.</p>
        pub fn sync_compliance(mut self, inp: crate::model::AssociationSyncCompliance) -> Self {
            self.inner = self.inner.sync_compliance(inp);
            self
        }
        pub fn set_sync_compliance(
            mut self,
            inp: std::option::Option<crate::model::AssociationSyncCompliance>,
        ) -> Self {
            self.inner = self.inner.set_sync_compliance(inp);
            self
        }
        /// <p>By default, when you update an association, the system runs it immediately after it is
        /// updated and then according to the schedule you specified. Specify this option if you don't want
        /// an association to run immediately after you update it. This parameter is not supported for rate
        /// expressions.</p>
        /// <p>Also, if you specified this option when you created the association, you can reset it. To do
        /// so, specify the <code>no-apply-only-at-cron-interval</code> parameter when you update the
        /// association from the command line. This parameter forces the association to run immediately after
        /// updating it and according to the interval specified.</p>
        pub fn apply_only_at_cron_interval(mut self, inp: bool) -> Self {
            self.inner = self.inner.apply_only_at_cron_interval(inp);
            self
        }
        pub fn set_apply_only_at_cron_interval(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_apply_only_at_cron_interval(inp);
            self
        }
        /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager Change Calendar type
        /// documents you want to gate your associations under. The associations only run when that Change
        /// Calendar is open. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar">AWS Systems Manager Change
        /// Calendar</a>.</p>
        pub fn calendar_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.calendar_names(inp);
            self
        }
        pub fn set_calendar_names(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_calendar_names(inp);
            self
        }
        /// <p>A location is a combination of AWS Regions and AWS accounts where you want to run the
        /// association. Use this action to update an association in multiple Regions and multiple
        /// accounts.</p>
        pub fn target_locations(mut self, inp: impl Into<crate::model::TargetLocation>) -> Self {
            self.inner = self.inner.target_locations(inp);
            self
        }
        pub fn set_target_locations(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
        ) -> Self {
            self.inner = self.inner.set_target_locations(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateAssociationStatus {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_association_status_input::Builder,
    }
    impl UpdateAssociationStatus {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateAssociationStatusOutput,
            smithy_http::result::SdkError<crate::error::UpdateAssociationStatusError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the Systems Manager document.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>The association status.</p>
        pub fn association_status(mut self, inp: crate::model::AssociationStatus) -> Self {
            self.inner = self.inner.association_status(inp);
            self
        }
        pub fn set_association_status(
            mut self,
            inp: std::option::Option<crate::model::AssociationStatus>,
        ) -> Self {
            self.inner = self.inner.set_association_status(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateDocument {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_document_input::Builder,
    }
    impl UpdateDocument {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateDocumentOutput,
            smithy_http::result::SdkError<crate::error::UpdateDocumentError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>A valid JSON or YAML string.</p>
        pub fn content(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content(inp);
            self
        }
        pub fn set_content(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content(inp);
            self
        }
        /// <p>A list of key and value pairs that describe attachments to a version of a document.</p>
        pub fn attachments(mut self, inp: impl Into<crate::model::AttachmentsSource>) -> Self {
            self.inner = self.inner.attachments(inp);
            self
        }
        pub fn set_attachments(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::AttachmentsSource>>,
        ) -> Self {
            self.inner = self.inner.set_attachments(inp);
            self
        }
        /// <p>The name of the Systems Manager document that you want to update.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The friendly name of the Systems Manager document that you want to update. This value can differ for
        /// each version of the document. If you do not specify a value for this parameter in your request,
        /// the existing value is applied to the new document version.</p>
        pub fn display_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.display_name(inp);
            self
        }
        pub fn set_display_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_display_name(inp);
            self
        }
        /// <p>An optional field specifying the version of the artifact you are updating with the document.
        /// For example, "Release 12, Update 6". This value is unique across all versions of a document, and
        /// cannot be changed.</p>
        pub fn version_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_name(inp);
            self
        }
        pub fn set_version_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_name(inp);
            self
        }
        /// <p>The version of the document that you want to update. Currently, Systems Manager supports updating only
        /// the latest version of the document. You can specify the version number of the latest version or
        /// use the <code>$LATEST</code> variable.</p>
        pub fn document_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_version(inp);
            self
        }
        pub fn set_document_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_version(inp);
            self
        }
        /// <p>Specify the document format for the new document version. Systems Manager supports JSON and YAML
        /// documents. JSON is the default format.</p>
        pub fn document_format(mut self, inp: crate::model::DocumentFormat) -> Self {
            self.inner = self.inner.document_format(inp);
            self
        }
        pub fn set_document_format(
            mut self,
            inp: std::option::Option<crate::model::DocumentFormat>,
        ) -> Self {
            self.inner = self.inner.set_document_format(inp);
            self
        }
        /// <p>Specify a new target type for the document.</p>
        pub fn target_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_type(inp);
            self
        }
        pub fn set_target_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_type(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateDocumentDefaultVersion {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_document_default_version_input::Builder,
    }
    impl UpdateDocumentDefaultVersion {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateDocumentDefaultVersionOutput,
            smithy_http::result::SdkError<crate::error::UpdateDocumentDefaultVersionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of a custom document that you want to set as the default version.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The version of a custom document that you want to set as the default version.</p>
        pub fn document_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_version(inp);
            self
        }
        pub fn set_document_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_version(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateDocumentMetadata {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_document_metadata_input::Builder,
    }
    impl UpdateDocumentMetadata {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateDocumentMetadataOutput,
            smithy_http::result::SdkError<crate::error::UpdateDocumentMetadataError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the document for which a version is to be updated.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The version of a document to update.</p>
        pub fn document_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_version(inp);
            self
        }
        pub fn set_document_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_version(inp);
            self
        }
        /// <p>The document review details to update.</p>
        pub fn document_reviews(mut self, inp: crate::model::DocumentReviews) -> Self {
            self.inner = self.inner.document_reviews(inp);
            self
        }
        pub fn set_document_reviews(
            mut self,
            inp: std::option::Option<crate::model::DocumentReviews>,
        ) -> Self {
            self.inner = self.inner.set_document_reviews(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateMaintenanceWindow {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_maintenance_window_input::Builder,
    }
    impl UpdateMaintenanceWindow {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateMaintenanceWindowOutput,
            smithy_http::result::SdkError<crate::error::UpdateMaintenanceWindowError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the maintenance window to update.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
        /// <p>The name of the maintenance window.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>An optional description for the update request.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
        /// Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or
        /// "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time
        /// Zone Database</a> on the IANA website.</p>
        pub fn start_date(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.start_date(inp);
            self
        }
        pub fn set_start_date(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_start_date(inp);
            self
        }
        /// <p>The date and time, in ISO-8601 Extended format, for when you want the maintenance window to
        /// become inactive. EndDate allows you to set a date and time in the future when the maintenance
        /// window will no longer run.</p>
        pub fn end_date(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.end_date(inp);
            self
        }
        pub fn set_end_date(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_end_date(inp);
            self
        }
        /// <p>The schedule of the maintenance window in the form of a cron or rate expression.</p>
        pub fn schedule(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schedule(inp);
            self
        }
        pub fn set_schedule(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_schedule(inp);
            self
        }
        /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
        /// Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or
        /// "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time
        /// Zone Database</a> on the IANA website.</p>
        pub fn schedule_timezone(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schedule_timezone(inp);
            self
        }
        pub fn set_schedule_timezone(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_schedule_timezone(inp);
            self
        }
        /// <p>The number of days to wait after the date and time specified by a CRON expression before
        /// running the maintenance window.</p>
        /// <p>For example, the following cron expression schedules a maintenance window to run the third
        /// Tuesday of every month at 11:30 PM.</p>
        /// <p>
        /// <code>cron(30 23 ? * TUE#3 *)</code>
        /// </p>
        /// <p>If the schedule offset is <code>2</code>, the maintenance window won't run until two days
        /// later.</p>
        pub fn schedule_offset(mut self, inp: i32) -> Self {
            self.inner = self.inner.schedule_offset(inp);
            self
        }
        pub fn set_schedule_offset(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_schedule_offset(inp);
            self
        }
        /// <p>The duration of the maintenance window in hours.</p>
        pub fn duration(mut self, inp: i32) -> Self {
            self.inner = self.inner.duration(inp);
            self
        }
        pub fn set_duration(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration(inp);
            self
        }
        /// <p>The number of hours before the end of the maintenance window that Systems Manager stops scheduling new
        /// tasks for execution.</p>
        pub fn cutoff(mut self, inp: i32) -> Self {
            self.inner = self.inner.cutoff(inp);
            self
        }
        pub fn set_cutoff(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_cutoff(inp);
            self
        }
        /// <p>Whether targets must be registered with the maintenance window before tasks can be defined
        /// for those targets.</p>
        pub fn allow_unassociated_targets(mut self, inp: bool) -> Self {
            self.inner = self.inner.allow_unassociated_targets(inp);
            self
        }
        pub fn set_allow_unassociated_targets(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_allow_unassociated_targets(inp);
            self
        }
        /// <p>Whether the maintenance window is enabled.</p>
        pub fn enabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.enabled(inp);
            self
        }
        pub fn set_enabled(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enabled(inp);
            self
        }
        /// <p>If True, then all fields that are required by the CreateMaintenanceWindow action are also
        /// required for this API request. Optional fields that are not specified are set to null. </p>
        pub fn replace(mut self, inp: bool) -> Self {
            self.inner = self.inner.replace(inp);
            self
        }
        pub fn set_replace(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_replace(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateMaintenanceWindowTarget {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_maintenance_window_target_input::Builder,
    }
    impl UpdateMaintenanceWindowTarget {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateMaintenanceWindowTargetOutput,
            smithy_http::result::SdkError<crate::error::UpdateMaintenanceWindowTargetError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The maintenance window ID with which to modify the target.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
        /// <p>The target ID to modify.</p>
        pub fn window_target_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_target_id(inp);
            self
        }
        pub fn set_window_target_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_window_target_id(inp);
            self
        }
        /// <p>The targets to add or replace.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::Target>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.inner = self.inner.set_targets(inp);
            self
        }
        /// <p>User-provided value that will be included in any CloudWatch events raised while running
        /// tasks for these targets in this maintenance window.</p>
        pub fn owner_information(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.owner_information(inp);
            self
        }
        pub fn set_owner_information(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_owner_information(inp);
            self
        }
        /// <p>A name for the update.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>An optional description for the update.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>If True, then all fields that are required by the RegisterTargetWithMaintenanceWindow action
        /// are also required for this API request. Optional fields that are not specified are set to
        /// null.</p>
        pub fn replace(mut self, inp: bool) -> Self {
            self.inner = self.inner.replace(inp);
            self
        }
        pub fn set_replace(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_replace(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateMaintenanceWindowTask {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_maintenance_window_task_input::Builder,
    }
    impl UpdateMaintenanceWindowTask {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateMaintenanceWindowTaskOutput,
            smithy_http::result::SdkError<crate::error::UpdateMaintenanceWindowTaskError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The maintenance window ID that contains the task to modify.</p>
        pub fn window_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_id(inp);
            self
        }
        pub fn set_window_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_id(inp);
            self
        }
        /// <p>The task ID to modify.</p>
        pub fn window_task_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.window_task_id(inp);
            self
        }
        pub fn set_window_task_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_window_task_id(inp);
            self
        }
        /// <p>The targets (either instances or tags) to modify. Instances are specified using
        /// Key=instanceids,Values=instanceID_1,instanceID_2. Tags are specified using
        /// Key=tag_name,Values=tag_value. </p>
        /// <note>
        /// <p>One or more targets must be specified for maintenance window Run Command-type tasks.
        /// Depending on the task, targets are optional for other maintenance window task types (Automation,
        /// AWS Lambda, and AWS Step Functions). For more information about running tasks that do not
        /// specify targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html">Registering
        /// maintenance window tasks without targets</a> in the
        /// <i>AWS Systems Manager User Guide</i>.</p>
        /// </note>
        pub fn targets(mut self, inp: impl Into<crate::model::Target>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.inner = self.inner.set_targets(inp);
            self
        }
        /// <p>The task ARN to modify.</p>
        pub fn task_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_arn(inp);
            self
        }
        pub fn set_task_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_arn(inp);
            self
        }
        /// <p>The ARN of the IAM service role for Systems Manager to assume when running a
        /// maintenance window task. If you do not specify a service role ARN, Systems Manager uses your account's
        /// service-linked role.  If no service-linked role for Systems Manager exists in your account, it is created when you run
        /// <code>RegisterTaskWithMaintenanceWindow</code>.</p>
        /// <p>For more information, see the following topics in the in the <i>AWS Systems Manager User Guide</i>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/using-service-linked-roles.html#slr-permissions">Using
        /// service-linked roles for Systems Manager</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html#maintenance-window-tasks-service-role">Should I use a service-linked role or a custom service role to run maintenance window tasks?
        /// </a>
        /// </p>
        /// </li>
        /// </ul>
        pub fn service_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_role_arn(inp);
            self
        }
        pub fn set_service_role_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_role_arn(inp);
            self
        }
        /// <p>The parameters to modify.</p>
        /// <note>
        /// <p>
        /// <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
        /// instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
        /// about how Systems Manager handles these options for the supported maintenance window task
        /// types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
        /// </note>
        /// <p>The map has the following format:</p>
        /// <p>Key: string, between 1 and 255 characters</p>
        /// <p>Value: an array of strings, each string is between 1 and 255 characters</p>
        pub fn task_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::MaintenanceWindowTaskParameterValueExpression>,
        ) -> Self {
            self.inner = self.inner.task_parameters(k, v);
            self
        }
        pub fn set_task_parameters(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::MaintenanceWindowTaskParameterValueExpression,
                >,
            >,
        ) -> Self {
            self.inner = self.inner.set_task_parameters(inp);
            self
        }
        /// <p>The parameters that the task should use during execution. Populate only the fields that
        /// match the task type. All other fields should be empty.</p>
        /// <important>
        /// <p>When you update a maintenance window task that has options specified in
        /// <code>TaskInvocationParameters</code>, you must provide again all the
        /// <code>TaskInvocationParameters</code> values that you want to retain. The values you do not
        /// specify again are removed. For example, suppose that when you registered a Run Command task, you
        /// specified <code>TaskInvocationParameters</code> values for <code>Comment</code>,
        /// <code>NotificationConfig</code>, and <code>OutputS3BucketName</code>. If you update the
        /// maintenance window task and specify only a different <code>OutputS3BucketName</code> value, the
        /// values for <code>Comment</code> and <code>NotificationConfig</code> are removed.</p>
        /// </important>
        pub fn task_invocation_parameters(
            mut self,
            inp: crate::model::MaintenanceWindowTaskInvocationParameters,
        ) -> Self {
            self.inner = self.inner.task_invocation_parameters(inp);
            self
        }
        pub fn set_task_invocation_parameters(
            mut self,
            inp: std::option::Option<crate::model::MaintenanceWindowTaskInvocationParameters>,
        ) -> Self {
            self.inner = self.inner.set_task_invocation_parameters(inp);
            self
        }
        /// <p>The new task priority to specify. The lower the number, the higher the priority. Tasks that
        /// have the same priority are scheduled in parallel.</p>
        pub fn priority(mut self, inp: i32) -> Self {
            self.inner = self.inner.priority(inp);
            self
        }
        pub fn set_priority(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(inp);
            self
        }
        /// <p>The new <code>MaxConcurrency</code> value you want to specify. <code>MaxConcurrency</code>
        /// is the number of targets that are allowed to run this task in parallel.</p>
        /// <note>
        /// <p>For maintenance window tasks without a target specified, you cannot supply a value for this
        /// option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported
        /// in the response to this command. This value does not affect the running of your task and can be
        /// ignored.</p>
        /// </note>
        pub fn max_concurrency(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.max_concurrency(inp);
            self
        }
        pub fn set_max_concurrency(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_max_concurrency(inp);
            self
        }
        /// <p>The new <code>MaxErrors</code> value to specify. <code>MaxErrors</code> is the maximum
        /// number of errors that are allowed before the task stops being scheduled.</p>
        /// <note>
        /// <p>For maintenance window tasks without a target specified, you cannot supply a value for this
        /// option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported
        /// in the response to this command. This value does not affect the running of your task and can be
        /// ignored.</p>
        /// </note>
        pub fn max_errors(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.max_errors(inp);
            self
        }
        pub fn set_max_errors(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_max_errors(inp);
            self
        }
        /// <p>The new logging location in Amazon S3 to specify.</p>
        /// <note>
        /// <p>
        /// <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
        /// <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
        /// For information about how Systems Manager handles these options for the supported maintenance
        /// window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
        /// </note>
        pub fn logging_info(mut self, inp: crate::model::LoggingInfo) -> Self {
            self.inner = self.inner.logging_info(inp);
            self
        }
        pub fn set_logging_info(
            mut self,
            inp: std::option::Option<crate::model::LoggingInfo>,
        ) -> Self {
            self.inner = self.inner.set_logging_info(inp);
            self
        }
        /// <p>The new task name to specify.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The new task description to specify.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>If True, then all fields that are required by the RegisterTaskWithMaintenanceWindow action
        /// are also required for this API request. Optional fields that are not specified are set to
        /// null.</p>
        pub fn replace(mut self, inp: bool) -> Self {
            self.inner = self.inner.replace(inp);
            self
        }
        pub fn set_replace(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_replace(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateManagedInstanceRole {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_managed_instance_role_input::Builder,
    }
    impl UpdateManagedInstanceRole {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateManagedInstanceRoleOutput,
            smithy_http::result::SdkError<crate::error::UpdateManagedInstanceRoleError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the managed instance where you want to update the role.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(inp);
            self
        }
        /// <p>The IAM role you want to assign or change.</p>
        pub fn iam_role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.iam_role(inp);
            self
        }
        pub fn set_iam_role(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_iam_role(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateOpsItem {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_ops_item_input::Builder,
    }
    impl UpdateOpsItem {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateOpsItemOutput,
            smithy_http::result::SdkError<crate::error::UpdateOpsItemError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Update the information about the OpsItem. Provide enough information so that users reading
        /// this OpsItem for the first time understand the issue. </p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>Add new keys or edit existing key-value pairs of the OperationalData map in the OpsItem
        /// object.</p>
        /// <p>Operational data is custom data that provides useful reference details about the OpsItem.
        /// For example, you can specify log files, error strings, license keys, troubleshooting tips, or
        /// other relevant data. You enter operational data as key-value pairs. The key has a maximum length
        /// of 128 characters. The value has a maximum size of 20 KB.</p>
        /// <important>
        /// <p>Operational data keys <i>can't</i> begin with the following: amazon, aws,
        /// amzn, ssm, /amazon, /aws, /amzn, /ssm.</p>
        /// </important>
        /// <p>You can choose to make the data searchable by other users in the account or you can restrict
        /// search access. Searchable data means that all users with access to the OpsItem Overview page (as
        /// provided by the <a>DescribeOpsItems</a> API action) can view and search on the
        /// specified data. Operational data that is not searchable is only viewable by users who have access
        /// to the OpsItem (as provided by the <a>GetOpsItem</a> API action).</p>
        /// <p>Use the <code>/aws/resources</code> key in OperationalData to specify a related resource in
        /// the request. Use the <code>/aws/automations</code> key in OperationalData to associate an
        /// Automation runbook with the OpsItem. To view AWS CLI example commands that use these keys, see
        /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems">Creating OpsItems manually</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn operational_data(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::OpsItemDataValue>,
        ) -> Self {
            self.inner = self.inner.operational_data(k, v);
            self
        }
        pub fn set_operational_data(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::OpsItemDataValue>,
            >,
        ) -> Self {
            self.inner = self.inner.set_operational_data(inp);
            self
        }
        /// <p>Keys that you want to remove from the OperationalData map.</p>
        pub fn operational_data_to_delete(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.operational_data_to_delete(inp);
            self
        }
        pub fn set_operational_data_to_delete(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_operational_data_to_delete(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this
        /// OpsItem is edited or changed.</p>
        pub fn notifications(mut self, inp: impl Into<crate::model::OpsItemNotification>) -> Self {
            self.inner = self.inner.notifications(inp);
            self
        }
        pub fn set_notifications(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::OpsItemNotification>>,
        ) -> Self {
            self.inner = self.inner.set_notifications(inp);
            self
        }
        /// <p>The importance of this OpsItem in relation to other OpsItems in the system.</p>
        pub fn priority(mut self, inp: i32) -> Self {
            self.inner = self.inner.priority(inp);
            self
        }
        pub fn set_priority(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(inp);
            self
        }
        /// <p>One or more OpsItems that share something in common with the current OpsItems. For example,
        /// related OpsItems can include OpsItems with similar error messages, impacted resources, or
        /// statuses for the impacted resource.</p>
        pub fn related_ops_items(mut self, inp: impl Into<crate::model::RelatedOpsItem>) -> Self {
            self.inner = self.inner.related_ops_items(inp);
            self
        }
        pub fn set_related_ops_items(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::RelatedOpsItem>>,
        ) -> Self {
            self.inner = self.inner.set_related_ops_items(inp);
            self
        }
        /// <p>The OpsItem status. Status can be <code>Open</code>, <code>In Progress</code>, or
        /// <code>Resolved</code>. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-working-with-OpsItems.html#OpsCenter-working-with-OpsItems-editing-details">Editing OpsItem details</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn status(mut self, inp: crate::model::OpsItemStatus) -> Self {
            self.inner = self.inner.status(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<crate::model::OpsItemStatus>) -> Self {
            self.inner = self.inner.set_status(inp);
            self
        }
        /// <p>The ID of the OpsItem.</p>
        pub fn ops_item_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ops_item_id(inp);
            self
        }
        pub fn set_ops_item_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ops_item_id(inp);
            self
        }
        /// <p>A short heading that describes the nature of the OpsItem and the impacted resource.</p>
        pub fn title(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.title(inp);
            self
        }
        pub fn set_title(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_title(inp);
            self
        }
        /// <p>Specify a new category for an OpsItem.</p>
        pub fn category(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.category(inp);
            self
        }
        pub fn set_category(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_category(inp);
            self
        }
        /// <p>Specify a new severity for an OpsItem.</p>
        pub fn severity(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.severity(inp);
            self
        }
        pub fn set_severity(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_severity(inp);
            self
        }
        /// <p>The time a runbook workflow started. Currently reported only for the OpsItem type
        /// <code>/aws/changerequest</code>.</p>
        pub fn actual_start_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.actual_start_time(inp);
            self
        }
        pub fn set_actual_start_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_actual_start_time(inp);
            self
        }
        /// <p>The time a runbook workflow ended. Currently reported only for the OpsItem type
        /// <code>/aws/changerequest</code>.</p>
        pub fn actual_end_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.actual_end_time(inp);
            self
        }
        pub fn set_actual_end_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_actual_end_time(inp);
            self
        }
        /// <p>The time specified in a change request for a runbook workflow to start. Currently supported
        /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
        pub fn planned_start_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.planned_start_time(inp);
            self
        }
        pub fn set_planned_start_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_planned_start_time(inp);
            self
        }
        /// <p>The time specified in a change request for a runbook workflow to end. Currently supported
        /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
        pub fn planned_end_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.planned_end_time(inp);
            self
        }
        pub fn set_planned_end_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_planned_end_time(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateOpsMetadata {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_ops_metadata_input::Builder,
    }
    impl UpdateOpsMetadata {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateOpsMetadataOutput,
            smithy_http::result::SdkError<crate::error::UpdateOpsMetadataError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The Amazon Resoure Name (ARN) of the OpsMetadata Object to update.</p>
        pub fn ops_metadata_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ops_metadata_arn(inp);
            self
        }
        pub fn set_ops_metadata_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ops_metadata_arn(inp);
            self
        }
        /// <p>Metadata to add to an OpsMetadata object.</p>
        pub fn metadata_to_update(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::MetadataValue>,
        ) -> Self {
            self.inner = self.inner.metadata_to_update(k, v);
            self
        }
        pub fn set_metadata_to_update(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::MetadataValue>,
            >,
        ) -> Self {
            self.inner = self.inner.set_metadata_to_update(inp);
            self
        }
        /// <p>The metadata keys to delete from the OpsMetadata object. </p>
        pub fn keys_to_delete(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.keys_to_delete(inp);
            self
        }
        pub fn set_keys_to_delete(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_keys_to_delete(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdatePatchBaseline {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_patch_baseline_input::Builder,
    }
    impl UpdatePatchBaseline {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdatePatchBaselineOutput,
            smithy_http::result::SdkError<crate::error::UpdatePatchBaselineError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ID of the patch baseline to update.</p>
        pub fn baseline_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.baseline_id(inp);
            self
        }
        pub fn set_baseline_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_baseline_id(inp);
            self
        }
        /// <p>The name of the patch baseline.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>A set of global filters used to include patches in the baseline.</p>
        pub fn global_filters(mut self, inp: crate::model::PatchFilterGroup) -> Self {
            self.inner = self.inner.global_filters(inp);
            self
        }
        pub fn set_global_filters(
            mut self,
            inp: std::option::Option<crate::model::PatchFilterGroup>,
        ) -> Self {
            self.inner = self.inner.set_global_filters(inp);
            self
        }
        /// <p>A set of rules used to include patches in the baseline.</p>
        pub fn approval_rules(mut self, inp: crate::model::PatchRuleGroup) -> Self {
            self.inner = self.inner.approval_rules(inp);
            self
        }
        pub fn set_approval_rules(
            mut self,
            inp: std::option::Option<crate::model::PatchRuleGroup>,
        ) -> Self {
            self.inner = self.inner.set_approval_rules(inp);
            self
        }
        /// <p>A list of explicitly approved patches for the baseline.</p>
        /// <p>For information about accepted formats for lists of approved patches and rejected patches,
        /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
        /// package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn approved_patches(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.approved_patches(inp);
            self
        }
        pub fn set_approved_patches(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_approved_patches(inp);
            self
        }
        /// <p>Assigns a new compliance severity level to an existing patch baseline.</p>
        pub fn approved_patches_compliance_level(
            mut self,
            inp: crate::model::PatchComplianceLevel,
        ) -> Self {
            self.inner = self.inner.approved_patches_compliance_level(inp);
            self
        }
        pub fn set_approved_patches_compliance_level(
            mut self,
            inp: std::option::Option<crate::model::PatchComplianceLevel>,
        ) -> Self {
            self.inner = self.inner.set_approved_patches_compliance_level(inp);
            self
        }
        /// <p>Indicates whether the list of approved patches includes non-security updates that should be
        /// applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
        pub fn approved_patches_enable_non_security(mut self, inp: bool) -> Self {
            self.inner = self.inner.approved_patches_enable_non_security(inp);
            self
        }
        pub fn set_approved_patches_enable_non_security(
            mut self,
            inp: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_approved_patches_enable_non_security(inp);
            self
        }
        /// <p>A list of explicitly rejected patches for the baseline.</p>
        /// <p>For information about accepted formats for lists of approved patches and rejected patches,
        /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
        /// package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn rejected_patches(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rejected_patches(inp);
            self
        }
        pub fn set_rejected_patches(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_rejected_patches(inp);
            self
        }
        /// <p>The action for Patch Manager to take on patches included in the RejectedPackages
        /// list.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>ALLOW_AS_DEPENDENCY</b>: A package in the Rejected patches
        /// list is installed only if it is a dependency of another package. It is considered compliant
        /// with the patch baseline, and its status is reported as <i>InstalledOther</i>.
        /// This is the default action if no option is specified.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>BLOCK</b>: Packages in the RejectedPatches list, and packages
        /// that include them as dependencies, are not installed under any circumstances. If a package was
        /// installed before it was added to the Rejected patches list, it is considered non-compliant with
        /// the patch baseline, and its status is reported as
        /// <i>InstalledRejected</i>.</p>
        /// </li>
        /// </ul>
        pub fn rejected_patches_action(mut self, inp: crate::model::PatchAction) -> Self {
            self.inner = self.inner.rejected_patches_action(inp);
            self
        }
        pub fn set_rejected_patches_action(
            mut self,
            inp: std::option::Option<crate::model::PatchAction>,
        ) -> Self {
            self.inner = self.inner.set_rejected_patches_action(inp);
            self
        }
        /// <p>A description of the patch baseline.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>Information about the patches to use to update the instances, including target operating
        /// systems and source repositories. Applies to Linux instances only.</p>
        pub fn sources(mut self, inp: impl Into<crate::model::PatchSource>) -> Self {
            self.inner = self.inner.sources(inp);
            self
        }
        pub fn set_sources(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PatchSource>>,
        ) -> Self {
            self.inner = self.inner.set_sources(inp);
            self
        }
        /// <p>If True, then all fields that are required by the CreatePatchBaseline action are also
        /// required for this API request. Optional fields that are not specified are set to null.</p>
        pub fn replace(mut self, inp: bool) -> Self {
            self.inner = self.inner.replace(inp);
            self
        }
        pub fn set_replace(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_replace(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateResourceDataSync {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_resource_data_sync_input::Builder,
    }
    impl UpdateResourceDataSync {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateResourceDataSyncOutput,
            smithy_http::result::SdkError<crate::error::UpdateResourceDataSyncError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the resource data sync you want to update.</p>
        pub fn sync_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sync_name(inp);
            self
        }
        pub fn set_sync_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_sync_name(inp);
            self
        }
        /// <p>The type of resource data sync. The supported <code>SyncType</code> is
        /// SyncFromSource.</p>
        pub fn sync_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sync_type(inp);
            self
        }
        pub fn set_sync_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_sync_type(inp);
            self
        }
        /// <p>Specify information about the data sources to synchronize.</p>
        pub fn sync_source(mut self, inp: crate::model::ResourceDataSyncSource) -> Self {
            self.inner = self.inner.sync_source(inp);
            self
        }
        pub fn set_sync_source(
            mut self,
            inp: std::option::Option<crate::model::ResourceDataSyncSource>,
        ) -> Self {
            self.inner = self.inner.set_sync_source(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateServiceSetting {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_service_setting_input::Builder,
    }
    impl UpdateServiceSetting {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateServiceSettingOutput,
            smithy_http::result::SdkError<crate::error::UpdateServiceSettingError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The Amazon Resource Name (ARN) of the service setting to reset. For example,
        /// <code>arn:aws:ssm:us-east-1:111122223333:servicesetting/ssm/parameter-store/high-throughput-enabled</code>.
        /// The setting ID can be one of the following.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>/ssm/automation/customer-script-log-destination</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>/ssm/automation/customer-script-log-group-name</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>/ssm/parameter-store/default-parameter-tier</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>/ssm/parameter-store/high-throughput-enabled</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>/ssm/managed-instance/activation-tier</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn setting_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.setting_id(inp);
            self
        }
        pub fn set_setting_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_setting_id(inp);
            self
        }
        /// <p>The new value to specify for the service setting. For the
        /// <code>/ssm/parameter-store/default-parameter-tier</code> setting ID, the setting value can be
        /// one of the following.</p>
        /// <ul>
        /// <li>
        /// <p>Standard</p>
        /// </li>
        /// <li>
        /// <p>Advanced</p>
        /// </li>
        /// <li>
        /// <p>Intelligent-Tiering</p>
        /// </li>
        /// </ul>
        /// <p>For the <code>/ssm/parameter-store/high-throughput-enabled</code>, and
        /// <code>/ssm/managed-instance/activation-tier</code> setting IDs, the setting value can be true or
        /// false.</p>
        /// <p>For the <code>/ssm/automation/customer-script-log-destination</code> setting ID, the setting
        /// value can be CloudWatch.</p>
        /// <p>For the <code>/ssm/automation/customer-script-log-group-name</code> setting ID, the setting
        /// value can be the name of a CloudWatch Logs log group.</p>
        pub fn setting_value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.setting_value(inp);
            self
        }
        pub fn set_setting_value(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_setting_value(inp);
            self
        }
    }
}
