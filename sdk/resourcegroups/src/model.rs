// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A mapping of a query attached to a resource group that determines the Amazon Web Services resources that are members of the group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupQuery {
    /// <p>The name of the resource group that is associated with the specified resource query.</p>
    #[doc(hidden)]
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The resource query that determines which Amazon Web Services resources are members of the associated resource group.</p>
    #[doc(hidden)]
    pub resource_query: std::option::Option<crate::model::ResourceQuery>,
}
impl GroupQuery {
    /// <p>The name of the resource group that is associated with the specified resource query.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The resource query that determines which Amazon Web Services resources are members of the associated resource group.</p>
    pub fn resource_query(&self) -> std::option::Option<&crate::model::ResourceQuery> {
        self.resource_query.as_ref()
    }
}
/// See [`GroupQuery`](crate::model::GroupQuery).
pub mod group_query {

    /// A builder for [`GroupQuery`](crate::model::GroupQuery).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) resource_query: std::option::Option<crate::model::ResourceQuery>,
    }
    impl Builder {
        /// <p>The name of the resource group that is associated with the specified resource query.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The name of the resource group that is associated with the specified resource query.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The resource query that determines which Amazon Web Services resources are members of the associated resource group.</p>
        pub fn resource_query(mut self, input: crate::model::ResourceQuery) -> Self {
            self.resource_query = Some(input);
            self
        }
        /// <p>The resource query that determines which Amazon Web Services resources are members of the associated resource group.</p>
        pub fn set_resource_query(
            mut self,
            input: std::option::Option<crate::model::ResourceQuery>,
        ) -> Self {
            self.resource_query = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupQuery`](crate::model::GroupQuery).
        pub fn build(self) -> crate::model::GroupQuery {
            crate::model::GroupQuery {
                group_name: self.group_name,
                resource_query: self.resource_query,
            }
        }
    }
}
impl GroupQuery {
    /// Creates a new builder-style object to manufacture [`GroupQuery`](crate::model::GroupQuery).
    pub fn builder() -> crate::model::group_query::Builder {
        crate::model::group_query::Builder::default()
    }
}

/// <p>The query you can use to define a resource group or a search for resources. A <code>ResourceQuery</code> specifies both a query <code>Type</code> and a <code>Query</code> string as JSON string objects. See the examples section for example JSON strings. For more information about creating a resource group with a resource query, see <a href="https://docs.aws.amazon.com/ARG/latest/userguide/gettingstarted-query.html">Build queries and groups in Resource Groups</a> in the <i>Resource Groups User Guide</i> </p>
/// <p>When you combine all of the elements together into a single string, any double quotes that are embedded inside another double quote pair must be escaped by preceding the embedded double quote with a backslash character (\). For example, a complete <code>ResourceQuery</code> parameter must be formatted like the following CLI parameter example:</p>
/// <p> <code>--resource-query '{"Type":"TAG_FILTERS_1_0","Query":"{\"ResourceTypeFilters\":[\"AWS::AllSupported\"],\"TagFilters\":[{\"Key\":\"Stage\",\"Values\":[\"Test\"]}]}"}'</code> </p>
/// <p>In the preceding example, all of the double quote characters in the value part of the <code>Query</code> element must be escaped because the value itself is surrounded by double quotes. For more information, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters-quoting-strings.html">Quoting strings</a> in the <i>Command Line Interface User Guide</i>.</p>
/// <p>For the complete list of resource types that you can use in the array value for <code>ResourceTypeFilters</code>, see <a href="https://docs.aws.amazon.com/ARG/latest/userguide/supported-resources.html">Resources you can use with Resource Groups and Tag Editor</a> in the <i>Resource Groups User Guide</i>. For example:</p>
/// <p> <code>"ResourceTypeFilters":["AWS::S3::Bucket", "AWS::EC2::Instance"]</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceQuery {
    /// <p>The type of the query to perform. This can have one of two values:</p>
    /// <ul>
    /// <li> <p> <i> <code>CLOUDFORMATION_STACK_1_0:</code> </i> Specifies that you want the group to contain the members of an CloudFormation stack. The <code>Query</code> contains a <code>StackIdentifier</code> element with an ARN for a CloudFormation stack.</p> </li>
    /// <li> <p> <i> <code>TAG_FILTERS_1_0:</code> </i> Specifies that you want the group to include resource that have tags that match the query. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::QueryType>,
    /// <p>The query that defines a group or a search. The contents depends on the value of the <code>Type</code> element.</p>
    /// <ul>
    /// <li> <p> <code>ResourceTypeFilters</code> – Applies to all <code>ResourceQuery</code> objects of either <code>Type</code>. This element contains one of the following two items:</p>
    /// <ul>
    /// <li> <p>The value <code>AWS::AllSupported</code>. This causes the ResourceQuery to match resources of any resource type that also match the query.</p> </li>
    /// <li> <p>A list (a JSON array) of resource type identifiers that limit the query to only resources of the specified types. For the complete list of resource types that you can use in the array value for <code>ResourceTypeFilters</code>, see <a href="https://docs.aws.amazon.com/ARG/latest/userguide/supported-resources.html">Resources you can use with Resource Groups and Tag Editor</a> in the <i>Resource Groups User Guide</i>.</p> </li>
    /// </ul> <p>Example: <code>"ResourceTypeFilters": ["AWS::AllSupported"]</code> or <code>"ResourceTypeFilters": ["AWS::EC2::Instance", "AWS::S3::Bucket"]</code> </p> </li>
    /// <li> <p> <code>TagFilters</code> – applicable only if <code>Type</code> = <code>TAG_FILTERS_1_0</code>. The <code>Query</code> contains a JSON string that represents a collection of simple tag filters. The JSON string uses a syntax similar to the <code> <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html">GetResources</a> </code> operation, but uses only the <code> <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html#resourcegrouptagging-GetResources-request-ResourceTypeFilters"> ResourceTypeFilters</a> </code> and <code> <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html#resourcegrouptagging-GetResources-request-TagFiltersTagFilters">TagFilters</a> </code> fields. If you specify more than one tag key, only resources that match all tag keys, and at least one value of each specified tag key, are returned in your query. If you specify more than one value for a tag key, a resource matches the filter if it has a tag key value that matches <i>any</i> of the specified values.</p> <p>For example, consider the following sample query for resources that have two tags, <code>Stage</code> and <code>Version</code>, with two values each:</p> <p> <code>[{"Stage":["Test","Deploy"]},{"Version":["1","2"]}]</code> </p> <p>The results of this resource query could include the following.</p>
    /// <ul>
    /// <li> <p>An Amazon EC2 instance that has the following two tags: <code>{"Stage":"Deploy"}</code>, and <code>{"Version":"2"}</code> </p> </li>
    /// <li> <p>An S3 bucket that has the following two tags: <code>{"Stage":"Test"}</code>, and <code>{"Version":"1"}</code> </p> </li>
    /// </ul> <p>The resource query results would <i>not</i> include the following items in the results, however. </p>
    /// <ul>
    /// <li> <p>An Amazon EC2 instance that has only the following tag: <code>{"Stage":"Deploy"}</code>.</p> <p>The instance does not have <b>all</b> of the tag keys specified in the filter, so it is excluded from the results.</p> </li>
    /// <li> <p>An RDS database that has the following two tags: <code>{"Stage":"Archived"}</code> and <code>{"Version":"4"}</code> </p> <p>The database has all of the tag keys, but none of those keys has an associated value that matches at least one of the specified values in the filter.</p> </li>
    /// </ul> <p>Example: <code>"TagFilters": [ { "Key": "Stage", "Values": [ "Gamma", "Beta" ] }</code> </p> </li>
    /// <li> <p> <code>StackIdentifier</code> – applicable only if <code>Type</code> = <code>CLOUDFORMATION_STACK_1_0</code>. The value of this parameter is the Amazon Resource Name (ARN) of the CloudFormation stack whose resources you want included in the group.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub query: std::option::Option<std::string::String>,
}
impl ResourceQuery {
    /// <p>The type of the query to perform. This can have one of two values:</p>
    /// <ul>
    /// <li> <p> <i> <code>CLOUDFORMATION_STACK_1_0:</code> </i> Specifies that you want the group to contain the members of an CloudFormation stack. The <code>Query</code> contains a <code>StackIdentifier</code> element with an ARN for a CloudFormation stack.</p> </li>
    /// <li> <p> <i> <code>TAG_FILTERS_1_0:</code> </i> Specifies that you want the group to include resource that have tags that match the query. </p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::QueryType> {
        self.r#type.as_ref()
    }
    /// <p>The query that defines a group or a search. The contents depends on the value of the <code>Type</code> element.</p>
    /// <ul>
    /// <li> <p> <code>ResourceTypeFilters</code> – Applies to all <code>ResourceQuery</code> objects of either <code>Type</code>. This element contains one of the following two items:</p>
    /// <ul>
    /// <li> <p>The value <code>AWS::AllSupported</code>. This causes the ResourceQuery to match resources of any resource type that also match the query.</p> </li>
    /// <li> <p>A list (a JSON array) of resource type identifiers that limit the query to only resources of the specified types. For the complete list of resource types that you can use in the array value for <code>ResourceTypeFilters</code>, see <a href="https://docs.aws.amazon.com/ARG/latest/userguide/supported-resources.html">Resources you can use with Resource Groups and Tag Editor</a> in the <i>Resource Groups User Guide</i>.</p> </li>
    /// </ul> <p>Example: <code>"ResourceTypeFilters": ["AWS::AllSupported"]</code> or <code>"ResourceTypeFilters": ["AWS::EC2::Instance", "AWS::S3::Bucket"]</code> </p> </li>
    /// <li> <p> <code>TagFilters</code> – applicable only if <code>Type</code> = <code>TAG_FILTERS_1_0</code>. The <code>Query</code> contains a JSON string that represents a collection of simple tag filters. The JSON string uses a syntax similar to the <code> <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html">GetResources</a> </code> operation, but uses only the <code> <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html#resourcegrouptagging-GetResources-request-ResourceTypeFilters"> ResourceTypeFilters</a> </code> and <code> <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html#resourcegrouptagging-GetResources-request-TagFiltersTagFilters">TagFilters</a> </code> fields. If you specify more than one tag key, only resources that match all tag keys, and at least one value of each specified tag key, are returned in your query. If you specify more than one value for a tag key, a resource matches the filter if it has a tag key value that matches <i>any</i> of the specified values.</p> <p>For example, consider the following sample query for resources that have two tags, <code>Stage</code> and <code>Version</code>, with two values each:</p> <p> <code>[{"Stage":["Test","Deploy"]},{"Version":["1","2"]}]</code> </p> <p>The results of this resource query could include the following.</p>
    /// <ul>
    /// <li> <p>An Amazon EC2 instance that has the following two tags: <code>{"Stage":"Deploy"}</code>, and <code>{"Version":"2"}</code> </p> </li>
    /// <li> <p>An S3 bucket that has the following two tags: <code>{"Stage":"Test"}</code>, and <code>{"Version":"1"}</code> </p> </li>
    /// </ul> <p>The resource query results would <i>not</i> include the following items in the results, however. </p>
    /// <ul>
    /// <li> <p>An Amazon EC2 instance that has only the following tag: <code>{"Stage":"Deploy"}</code>.</p> <p>The instance does not have <b>all</b> of the tag keys specified in the filter, so it is excluded from the results.</p> </li>
    /// <li> <p>An RDS database that has the following two tags: <code>{"Stage":"Archived"}</code> and <code>{"Version":"4"}</code> </p> <p>The database has all of the tag keys, but none of those keys has an associated value that matches at least one of the specified values in the filter.</p> </li>
    /// </ul> <p>Example: <code>"TagFilters": [ { "Key": "Stage", "Values": [ "Gamma", "Beta" ] }</code> </p> </li>
    /// <li> <p> <code>StackIdentifier</code> – applicable only if <code>Type</code> = <code>CLOUDFORMATION_STACK_1_0</code>. The value of this parameter is the Amazon Resource Name (ARN) of the CloudFormation stack whose resources you want included in the group.</p> </li>
    /// </ul>
    pub fn query(&self) -> std::option::Option<&str> {
        self.query.as_deref()
    }
}
/// See [`ResourceQuery`](crate::model::ResourceQuery).
pub mod resource_query {

    /// A builder for [`ResourceQuery`](crate::model::ResourceQuery).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::QueryType>,
        pub(crate) query: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the query to perform. This can have one of two values:</p>
        /// <ul>
        /// <li> <p> <i> <code>CLOUDFORMATION_STACK_1_0:</code> </i> Specifies that you want the group to contain the members of an CloudFormation stack. The <code>Query</code> contains a <code>StackIdentifier</code> element with an ARN for a CloudFormation stack.</p> </li>
        /// <li> <p> <i> <code>TAG_FILTERS_1_0:</code> </i> Specifies that you want the group to include resource that have tags that match the query. </p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::QueryType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the query to perform. This can have one of two values:</p>
        /// <ul>
        /// <li> <p> <i> <code>CLOUDFORMATION_STACK_1_0:</code> </i> Specifies that you want the group to contain the members of an CloudFormation stack. The <code>Query</code> contains a <code>StackIdentifier</code> element with an ARN for a CloudFormation stack.</p> </li>
        /// <li> <p> <i> <code>TAG_FILTERS_1_0:</code> </i> Specifies that you want the group to include resource that have tags that match the query. </p> </li>
        /// </ul>
        pub fn set_type(mut self, input: std::option::Option<crate::model::QueryType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The query that defines a group or a search. The contents depends on the value of the <code>Type</code> element.</p>
        /// <ul>
        /// <li> <p> <code>ResourceTypeFilters</code> – Applies to all <code>ResourceQuery</code> objects of either <code>Type</code>. This element contains one of the following two items:</p>
        /// <ul>
        /// <li> <p>The value <code>AWS::AllSupported</code>. This causes the ResourceQuery to match resources of any resource type that also match the query.</p> </li>
        /// <li> <p>A list (a JSON array) of resource type identifiers that limit the query to only resources of the specified types. For the complete list of resource types that you can use in the array value for <code>ResourceTypeFilters</code>, see <a href="https://docs.aws.amazon.com/ARG/latest/userguide/supported-resources.html">Resources you can use with Resource Groups and Tag Editor</a> in the <i>Resource Groups User Guide</i>.</p> </li>
        /// </ul> <p>Example: <code>"ResourceTypeFilters": ["AWS::AllSupported"]</code> or <code>"ResourceTypeFilters": ["AWS::EC2::Instance", "AWS::S3::Bucket"]</code> </p> </li>
        /// <li> <p> <code>TagFilters</code> – applicable only if <code>Type</code> = <code>TAG_FILTERS_1_0</code>. The <code>Query</code> contains a JSON string that represents a collection of simple tag filters. The JSON string uses a syntax similar to the <code> <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html">GetResources</a> </code> operation, but uses only the <code> <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html#resourcegrouptagging-GetResources-request-ResourceTypeFilters"> ResourceTypeFilters</a> </code> and <code> <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html#resourcegrouptagging-GetResources-request-TagFiltersTagFilters">TagFilters</a> </code> fields. If you specify more than one tag key, only resources that match all tag keys, and at least one value of each specified tag key, are returned in your query. If you specify more than one value for a tag key, a resource matches the filter if it has a tag key value that matches <i>any</i> of the specified values.</p> <p>For example, consider the following sample query for resources that have two tags, <code>Stage</code> and <code>Version</code>, with two values each:</p> <p> <code>[{"Stage":["Test","Deploy"]},{"Version":["1","2"]}]</code> </p> <p>The results of this resource query could include the following.</p>
        /// <ul>
        /// <li> <p>An Amazon EC2 instance that has the following two tags: <code>{"Stage":"Deploy"}</code>, and <code>{"Version":"2"}</code> </p> </li>
        /// <li> <p>An S3 bucket that has the following two tags: <code>{"Stage":"Test"}</code>, and <code>{"Version":"1"}</code> </p> </li>
        /// </ul> <p>The resource query results would <i>not</i> include the following items in the results, however. </p>
        /// <ul>
        /// <li> <p>An Amazon EC2 instance that has only the following tag: <code>{"Stage":"Deploy"}</code>.</p> <p>The instance does not have <b>all</b> of the tag keys specified in the filter, so it is excluded from the results.</p> </li>
        /// <li> <p>An RDS database that has the following two tags: <code>{"Stage":"Archived"}</code> and <code>{"Version":"4"}</code> </p> <p>The database has all of the tag keys, but none of those keys has an associated value that matches at least one of the specified values in the filter.</p> </li>
        /// </ul> <p>Example: <code>"TagFilters": [ { "Key": "Stage", "Values": [ "Gamma", "Beta" ] }</code> </p> </li>
        /// <li> <p> <code>StackIdentifier</code> – applicable only if <code>Type</code> = <code>CLOUDFORMATION_STACK_1_0</code>. The value of this parameter is the Amazon Resource Name (ARN) of the CloudFormation stack whose resources you want included in the group.</p> </li>
        /// </ul>
        pub fn query(mut self, input: impl Into<std::string::String>) -> Self {
            self.query = Some(input.into());
            self
        }
        /// <p>The query that defines a group or a search. The contents depends on the value of the <code>Type</code> element.</p>
        /// <ul>
        /// <li> <p> <code>ResourceTypeFilters</code> – Applies to all <code>ResourceQuery</code> objects of either <code>Type</code>. This element contains one of the following two items:</p>
        /// <ul>
        /// <li> <p>The value <code>AWS::AllSupported</code>. This causes the ResourceQuery to match resources of any resource type that also match the query.</p> </li>
        /// <li> <p>A list (a JSON array) of resource type identifiers that limit the query to only resources of the specified types. For the complete list of resource types that you can use in the array value for <code>ResourceTypeFilters</code>, see <a href="https://docs.aws.amazon.com/ARG/latest/userguide/supported-resources.html">Resources you can use with Resource Groups and Tag Editor</a> in the <i>Resource Groups User Guide</i>.</p> </li>
        /// </ul> <p>Example: <code>"ResourceTypeFilters": ["AWS::AllSupported"]</code> or <code>"ResourceTypeFilters": ["AWS::EC2::Instance", "AWS::S3::Bucket"]</code> </p> </li>
        /// <li> <p> <code>TagFilters</code> – applicable only if <code>Type</code> = <code>TAG_FILTERS_1_0</code>. The <code>Query</code> contains a JSON string that represents a collection of simple tag filters. The JSON string uses a syntax similar to the <code> <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html">GetResources</a> </code> operation, but uses only the <code> <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html#resourcegrouptagging-GetResources-request-ResourceTypeFilters"> ResourceTypeFilters</a> </code> and <code> <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html#resourcegrouptagging-GetResources-request-TagFiltersTagFilters">TagFilters</a> </code> fields. If you specify more than one tag key, only resources that match all tag keys, and at least one value of each specified tag key, are returned in your query. If you specify more than one value for a tag key, a resource matches the filter if it has a tag key value that matches <i>any</i> of the specified values.</p> <p>For example, consider the following sample query for resources that have two tags, <code>Stage</code> and <code>Version</code>, with two values each:</p> <p> <code>[{"Stage":["Test","Deploy"]},{"Version":["1","2"]}]</code> </p> <p>The results of this resource query could include the following.</p>
        /// <ul>
        /// <li> <p>An Amazon EC2 instance that has the following two tags: <code>{"Stage":"Deploy"}</code>, and <code>{"Version":"2"}</code> </p> </li>
        /// <li> <p>An S3 bucket that has the following two tags: <code>{"Stage":"Test"}</code>, and <code>{"Version":"1"}</code> </p> </li>
        /// </ul> <p>The resource query results would <i>not</i> include the following items in the results, however. </p>
        /// <ul>
        /// <li> <p>An Amazon EC2 instance that has only the following tag: <code>{"Stage":"Deploy"}</code>.</p> <p>The instance does not have <b>all</b> of the tag keys specified in the filter, so it is excluded from the results.</p> </li>
        /// <li> <p>An RDS database that has the following two tags: <code>{"Stage":"Archived"}</code> and <code>{"Version":"4"}</code> </p> <p>The database has all of the tag keys, but none of those keys has an associated value that matches at least one of the specified values in the filter.</p> </li>
        /// </ul> <p>Example: <code>"TagFilters": [ { "Key": "Stage", "Values": [ "Gamma", "Beta" ] }</code> </p> </li>
        /// <li> <p> <code>StackIdentifier</code> – applicable only if <code>Type</code> = <code>CLOUDFORMATION_STACK_1_0</code>. The value of this parameter is the Amazon Resource Name (ARN) of the CloudFormation stack whose resources you want included in the group.</p> </li>
        /// </ul>
        pub fn set_query(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceQuery`](crate::model::ResourceQuery).
        pub fn build(self) -> crate::model::ResourceQuery {
            crate::model::ResourceQuery {
                r#type: self.r#type,
                query: self.query,
            }
        }
    }
}
impl ResourceQuery {
    /// Creates a new builder-style object to manufacture [`ResourceQuery`](crate::model::ResourceQuery).
    pub fn builder() -> crate::model::resource_query::Builder {
        crate::model::resource_query::Builder::default()
    }
}

/// When writing a match expression against `QueryType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let querytype = unimplemented!();
/// match querytype {
///     QueryType::CloudformationStack10 => { /* ... */ },
///     QueryType::TagFilters10 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `querytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QueryType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QueryType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QueryType::NewFeature` is defined.
/// Specifically, when `querytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QueryType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueryType {
    #[allow(missing_docs)] // documentation missing in model
    CloudformationStack10,
    #[allow(missing_docs)] // documentation missing in model
    TagFilters10,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for QueryType {
    fn from(s: &str) -> Self {
        match s {
            "CLOUDFORMATION_STACK_1_0" => QueryType::CloudformationStack10,
            "TAG_FILTERS_1_0" => QueryType::TagFilters10,
            other => QueryType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for QueryType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueryType::from(s))
    }
}
impl QueryType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueryType::CloudformationStack10 => "CLOUDFORMATION_STACK_1_0",
            QueryType::TagFilters10 => "TAG_FILTERS_1_0",
            QueryType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLOUDFORMATION_STACK_1_0", "TAG_FILTERS_1_0"]
    }
}
impl AsRef<str> for QueryType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A resource group that contains Amazon Web Services resources. You can assign resources to the group by associating either of the following elements with the group:</p>
/// <ul>
/// <li> <p> <code>ResourceQuery</code> - Use a resource query to specify a set of tag keys and values. All resources in the same Amazon Web Services Region and Amazon Web Services account that have those keys with the same values are included in the group. You can add a resource query when you create the group, or later by using the <code>PutGroupConfiguration</code> operation.</p> </li>
/// <li> <p> <code>GroupConfiguration</code> - Use a service configuration to associate the group with an Amazon Web Services service. The configuration specifies which resource types can be included in the group.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Group {
    /// <p>The ARN of the resource group.</p>
    #[doc(hidden)]
    pub group_arn: std::option::Option<std::string::String>,
    /// <p>The name of the resource group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the resource group.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl Group {
    /// <p>The ARN of the resource group.</p>
    pub fn group_arn(&self) -> std::option::Option<&str> {
        self.group_arn.as_deref()
    }
    /// <p>The name of the resource group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the resource group.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
/// See [`Group`](crate::model::Group).
pub mod group {

    /// A builder for [`Group`](crate::model::Group).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource group.</p>
        pub fn group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource group.</p>
        pub fn set_group_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_arn = input;
            self
        }
        /// <p>The name of the resource group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the resource group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the resource group.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the resource group.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`Group`](crate::model::Group).
        pub fn build(self) -> crate::model::Group {
            crate::model::Group {
                group_arn: self.group_arn,
                name: self.name,
                description: self.description,
            }
        }
    }
}
impl Group {
    /// Creates a new builder-style object to manufacture [`Group`](crate::model::Group).
    pub fn builder() -> crate::model::group::Builder {
        crate::model::group::Builder::default()
    }
}

/// <p>The Resource Groups settings for this Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccountSettings {
    /// <p>The desired target status of the group lifecycle events feature. If</p>
    #[doc(hidden)]
    pub group_lifecycle_events_desired_status:
        std::option::Option<crate::model::GroupLifecycleEventsDesiredStatus>,
    /// <p>The current status of the group lifecycle events feature.</p>
    #[doc(hidden)]
    pub group_lifecycle_events_status:
        std::option::Option<crate::model::GroupLifecycleEventsStatus>,
    /// <p>The text of any error message occurs during an attempt to turn group lifecycle events on or off.</p>
    #[doc(hidden)]
    pub group_lifecycle_events_status_message: std::option::Option<std::string::String>,
}
impl AccountSettings {
    /// <p>The desired target status of the group lifecycle events feature. If</p>
    pub fn group_lifecycle_events_desired_status(
        &self,
    ) -> std::option::Option<&crate::model::GroupLifecycleEventsDesiredStatus> {
        self.group_lifecycle_events_desired_status.as_ref()
    }
    /// <p>The current status of the group lifecycle events feature.</p>
    pub fn group_lifecycle_events_status(
        &self,
    ) -> std::option::Option<&crate::model::GroupLifecycleEventsStatus> {
        self.group_lifecycle_events_status.as_ref()
    }
    /// <p>The text of any error message occurs during an attempt to turn group lifecycle events on or off.</p>
    pub fn group_lifecycle_events_status_message(&self) -> std::option::Option<&str> {
        self.group_lifecycle_events_status_message.as_deref()
    }
}
/// See [`AccountSettings`](crate::model::AccountSettings).
pub mod account_settings {

    /// A builder for [`AccountSettings`](crate::model::AccountSettings).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_lifecycle_events_desired_status:
            std::option::Option<crate::model::GroupLifecycleEventsDesiredStatus>,
        pub(crate) group_lifecycle_events_status:
            std::option::Option<crate::model::GroupLifecycleEventsStatus>,
        pub(crate) group_lifecycle_events_status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The desired target status of the group lifecycle events feature. If</p>
        pub fn group_lifecycle_events_desired_status(
            mut self,
            input: crate::model::GroupLifecycleEventsDesiredStatus,
        ) -> Self {
            self.group_lifecycle_events_desired_status = Some(input);
            self
        }
        /// <p>The desired target status of the group lifecycle events feature. If</p>
        pub fn set_group_lifecycle_events_desired_status(
            mut self,
            input: std::option::Option<crate::model::GroupLifecycleEventsDesiredStatus>,
        ) -> Self {
            self.group_lifecycle_events_desired_status = input;
            self
        }
        /// <p>The current status of the group lifecycle events feature.</p>
        pub fn group_lifecycle_events_status(
            mut self,
            input: crate::model::GroupLifecycleEventsStatus,
        ) -> Self {
            self.group_lifecycle_events_status = Some(input);
            self
        }
        /// <p>The current status of the group lifecycle events feature.</p>
        pub fn set_group_lifecycle_events_status(
            mut self,
            input: std::option::Option<crate::model::GroupLifecycleEventsStatus>,
        ) -> Self {
            self.group_lifecycle_events_status = input;
            self
        }
        /// <p>The text of any error message occurs during an attempt to turn group lifecycle events on or off.</p>
        pub fn group_lifecycle_events_status_message(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.group_lifecycle_events_status_message = Some(input.into());
            self
        }
        /// <p>The text of any error message occurs during an attempt to turn group lifecycle events on or off.</p>
        pub fn set_group_lifecycle_events_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.group_lifecycle_events_status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountSettings`](crate::model::AccountSettings).
        pub fn build(self) -> crate::model::AccountSettings {
            crate::model::AccountSettings {
                group_lifecycle_events_desired_status: self.group_lifecycle_events_desired_status,
                group_lifecycle_events_status: self.group_lifecycle_events_status,
                group_lifecycle_events_status_message: self.group_lifecycle_events_status_message,
            }
        }
    }
}
impl AccountSettings {
    /// Creates a new builder-style object to manufacture [`AccountSettings`](crate::model::AccountSettings).
    pub fn builder() -> crate::model::account_settings::Builder {
        crate::model::account_settings::Builder::default()
    }
}

/// When writing a match expression against `GroupLifecycleEventsStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let grouplifecycleeventsstatus = unimplemented!();
/// match grouplifecycleeventsstatus {
///     GroupLifecycleEventsStatus::Active => { /* ... */ },
///     GroupLifecycleEventsStatus::Error => { /* ... */ },
///     GroupLifecycleEventsStatus::Inactive => { /* ... */ },
///     GroupLifecycleEventsStatus::InProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `grouplifecycleeventsstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GroupLifecycleEventsStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GroupLifecycleEventsStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GroupLifecycleEventsStatus::NewFeature` is defined.
/// Specifically, when `grouplifecycleeventsstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GroupLifecycleEventsStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GroupLifecycleEventsStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GroupLifecycleEventsStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => GroupLifecycleEventsStatus::Active,
            "ERROR" => GroupLifecycleEventsStatus::Error,
            "INACTIVE" => GroupLifecycleEventsStatus::Inactive,
            "IN_PROGRESS" => GroupLifecycleEventsStatus::InProgress,
            other => GroupLifecycleEventsStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for GroupLifecycleEventsStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GroupLifecycleEventsStatus::from(s))
    }
}
impl GroupLifecycleEventsStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GroupLifecycleEventsStatus::Active => "ACTIVE",
            GroupLifecycleEventsStatus::Error => "ERROR",
            GroupLifecycleEventsStatus::Inactive => "INACTIVE",
            GroupLifecycleEventsStatus::InProgress => "IN_PROGRESS",
            GroupLifecycleEventsStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "ERROR", "INACTIVE", "IN_PROGRESS"]
    }
}
impl AsRef<str> for GroupLifecycleEventsStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `GroupLifecycleEventsDesiredStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let grouplifecycleeventsdesiredstatus = unimplemented!();
/// match grouplifecycleeventsdesiredstatus {
///     GroupLifecycleEventsDesiredStatus::Active => { /* ... */ },
///     GroupLifecycleEventsDesiredStatus::Inactive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `grouplifecycleeventsdesiredstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GroupLifecycleEventsDesiredStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GroupLifecycleEventsDesiredStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GroupLifecycleEventsDesiredStatus::NewFeature` is defined.
/// Specifically, when `grouplifecycleeventsdesiredstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GroupLifecycleEventsDesiredStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GroupLifecycleEventsDesiredStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GroupLifecycleEventsDesiredStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => GroupLifecycleEventsDesiredStatus::Active,
            "INACTIVE" => GroupLifecycleEventsDesiredStatus::Inactive,
            other => GroupLifecycleEventsDesiredStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for GroupLifecycleEventsDesiredStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GroupLifecycleEventsDesiredStatus::from(s))
    }
}
impl GroupLifecycleEventsDesiredStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GroupLifecycleEventsDesiredStatus::Active => "ACTIVE",
            GroupLifecycleEventsDesiredStatus::Inactive => "INACTIVE",
            GroupLifecycleEventsDesiredStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "INACTIVE"]
    }
}
impl AsRef<str> for GroupLifecycleEventsDesiredStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure that identifies a resource that is currently pending addition to the group as a member. Adding a resource to a resource group happens asynchronously as a background task and this one isn't completed yet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PendingResource {
    /// <p>The Amazon resource name (ARN) of the resource that's in a pending state.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl PendingResource {
    /// <p>The Amazon resource name (ARN) of the resource that's in a pending state.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
/// See [`PendingResource`](crate::model::PendingResource).
pub mod pending_resource {

    /// A builder for [`PendingResource`](crate::model::PendingResource).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon resource name (ARN) of the resource that's in a pending state.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon resource name (ARN) of the resource that's in a pending state.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`PendingResource`](crate::model::PendingResource).
        pub fn build(self) -> crate::model::PendingResource {
            crate::model::PendingResource {
                resource_arn: self.resource_arn,
            }
        }
    }
}
impl PendingResource {
    /// Creates a new builder-style object to manufacture [`PendingResource`](crate::model::PendingResource).
    pub fn builder() -> crate::model::pending_resource::Builder {
        crate::model::pending_resource::Builder::default()
    }
}

/// <p>A resource that failed to be added to or removed from a group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailedResource {
    /// <p>The ARN of the resource that failed to be added or removed.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The error message text associated with the failure.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The error code associated with the failure.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
}
impl FailedResource {
    /// <p>The ARN of the resource that failed to be added or removed.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The error message text associated with the failure.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The error code associated with the failure.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
}
/// See [`FailedResource`](crate::model::FailedResource).
pub mod failed_resource {

    /// A builder for [`FailedResource`](crate::model::FailedResource).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource that failed to be added or removed.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource that failed to be added or removed.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The error message text associated with the failure.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message text associated with the failure.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The error code associated with the failure.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code associated with the failure.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedResource`](crate::model::FailedResource).
        pub fn build(self) -> crate::model::FailedResource {
            crate::model::FailedResource {
                resource_arn: self.resource_arn,
                error_message: self.error_message,
                error_code: self.error_code,
            }
        }
    }
}
impl FailedResource {
    /// Creates a new builder-style object to manufacture [`FailedResource`](crate::model::FailedResource).
    pub fn builder() -> crate::model::failed_resource::Builder {
        crate::model::failed_resource::Builder::default()
    }
}

/// <p>A two-part error structure that can occur in <code>ListGroupResources</code> or <code>SearchResources</code> operations on CloudFront stack-based queries. The error occurs if the CloudFront stack on which the query is based either does not exist, or has a status that renders the stack inactive. A <code>QueryError</code> occurrence does not necessarily mean that Resource Groups could not complete the operation, but the resulting group might have no member resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryError {
    /// <p>Specifies the error code that was raised.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::QueryErrorCode>,
    /// <p>A message that explains the <code>ErrorCode</code> value. Messages might state that the specified CloudFront stack does not exist (or no longer exists). For <code>CLOUDFORMATION_STACK_INACTIVE</code>, the message typically states that the CloudFront stack has a status that is not (or no longer) active, such as <code>CREATE_FAILED</code>.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl QueryError {
    /// <p>Specifies the error code that was raised.</p>
    pub fn error_code(&self) -> std::option::Option<&crate::model::QueryErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>A message that explains the <code>ErrorCode</code> value. Messages might state that the specified CloudFront stack does not exist (or no longer exists). For <code>CLOUDFORMATION_STACK_INACTIVE</code>, the message typically states that the CloudFront stack has a status that is not (or no longer) active, such as <code>CREATE_FAILED</code>.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`QueryError`](crate::model::QueryError).
pub mod query_error {

    /// A builder for [`QueryError`](crate::model::QueryError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<crate::model::QueryErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the error code that was raised.</p>
        pub fn error_code(mut self, input: crate::model::QueryErrorCode) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>Specifies the error code that was raised.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::QueryErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>A message that explains the <code>ErrorCode</code> value. Messages might state that the specified CloudFront stack does not exist (or no longer exists). For <code>CLOUDFORMATION_STACK_INACTIVE</code>, the message typically states that the CloudFront stack has a status that is not (or no longer) active, such as <code>CREATE_FAILED</code>.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message that explains the <code>ErrorCode</code> value. Messages might state that the specified CloudFront stack does not exist (or no longer exists). For <code>CLOUDFORMATION_STACK_INACTIVE</code>, the message typically states that the CloudFront stack has a status that is not (or no longer) active, such as <code>CREATE_FAILED</code>.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryError`](crate::model::QueryError).
        pub fn build(self) -> crate::model::QueryError {
            crate::model::QueryError {
                error_code: self.error_code,
                message: self.message,
            }
        }
    }
}
impl QueryError {
    /// Creates a new builder-style object to manufacture [`QueryError`](crate::model::QueryError).
    pub fn builder() -> crate::model::query_error::Builder {
        crate::model::query_error::Builder::default()
    }
}

/// When writing a match expression against `QueryErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let queryerrorcode = unimplemented!();
/// match queryerrorcode {
///     QueryErrorCode::CloudformationStackInactive => { /* ... */ },
///     QueryErrorCode::CloudformationStackNotExisting => { /* ... */ },
///     QueryErrorCode::CloudformationStackUnassumableRole => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `queryerrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QueryErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QueryErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QueryErrorCode::NewFeature` is defined.
/// Specifically, when `queryerrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QueryErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueryErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    CloudformationStackInactive,
    #[allow(missing_docs)] // documentation missing in model
    CloudformationStackNotExisting,
    #[allow(missing_docs)] // documentation missing in model
    CloudformationStackUnassumableRole,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for QueryErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "CLOUDFORMATION_STACK_INACTIVE" => QueryErrorCode::CloudformationStackInactive,
            "CLOUDFORMATION_STACK_NOT_EXISTING" => QueryErrorCode::CloudformationStackNotExisting,
            "CLOUDFORMATION_STACK_UNASSUMABLE_ROLE" => {
                QueryErrorCode::CloudformationStackUnassumableRole
            }
            other => QueryErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for QueryErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueryErrorCode::from(s))
    }
}
impl QueryErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueryErrorCode::CloudformationStackInactive => "CLOUDFORMATION_STACK_INACTIVE",
            QueryErrorCode::CloudformationStackNotExisting => "CLOUDFORMATION_STACK_NOT_EXISTING",
            QueryErrorCode::CloudformationStackUnassumableRole => {
                "CLOUDFORMATION_STACK_UNASSUMABLE_ROLE"
            }
            QueryErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CLOUDFORMATION_STACK_INACTIVE",
            "CLOUDFORMATION_STACK_NOT_EXISTING",
            "CLOUDFORMATION_STACK_UNASSUMABLE_ROLE",
        ]
    }
}
impl AsRef<str> for QueryErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure that contains the ARN of a resource and its resource type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceIdentifier {
    /// <p>The ARN of a resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The resource type of a resource, such as <code>AWS::EC2::Instance</code>.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
}
impl ResourceIdentifier {
    /// <p>The ARN of a resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The resource type of a resource, such as <code>AWS::EC2::Instance</code>.</p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
}
/// See [`ResourceIdentifier`](crate::model::ResourceIdentifier).
pub mod resource_identifier {

    /// A builder for [`ResourceIdentifier`](crate::model::ResourceIdentifier).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of a resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The resource type of a resource, such as <code>AWS::EC2::Instance</code>.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type of a resource, such as <code>AWS::EC2::Instance</code>.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceIdentifier`](crate::model::ResourceIdentifier).
        pub fn build(self) -> crate::model::ResourceIdentifier {
            crate::model::ResourceIdentifier {
                resource_arn: self.resource_arn,
                resource_type: self.resource_type,
            }
        }
    }
}
impl ResourceIdentifier {
    /// Creates a new builder-style object to manufacture [`ResourceIdentifier`](crate::model::ResourceIdentifier).
    pub fn builder() -> crate::model::resource_identifier::Builder {
        crate::model::resource_identifier::Builder::default()
    }
}

/// <p>An item in a group configuration. A group service configuration can have one or more items. For details about group service configuration syntax, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html">Service configurations for resource groups</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupConfigurationItem {
    /// <p>Specifies the type of group configuration item. Each item must have a unique value for <code>type</code>. For the list of types that you can specify for a configuration item, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>A collection of parameters for this group configuration item. For the list of parameters that you can use with each configuration item type, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
    #[doc(hidden)]
    pub parameters: std::option::Option<std::vec::Vec<crate::model::GroupConfigurationParameter>>,
}
impl GroupConfigurationItem {
    /// <p>Specifies the type of group configuration item. Each item must have a unique value for <code>type</code>. For the list of types that you can specify for a configuration item, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>A collection of parameters for this group configuration item. For the list of parameters that you can use with each configuration item type, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
    pub fn parameters(&self) -> std::option::Option<&[crate::model::GroupConfigurationParameter]> {
        self.parameters.as_deref()
    }
}
/// See [`GroupConfigurationItem`](crate::model::GroupConfigurationItem).
pub mod group_configuration_item {

    /// A builder for [`GroupConfigurationItem`](crate::model::GroupConfigurationItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) parameters:
            std::option::Option<std::vec::Vec<crate::model::GroupConfigurationParameter>>,
    }
    impl Builder {
        /// <p>Specifies the type of group configuration item. Each item must have a unique value for <code>type</code>. For the list of types that you can specify for a configuration item, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>Specifies the type of group configuration item. Each item must have a unique value for <code>type</code>. For the list of types that you can specify for a configuration item, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>A collection of parameters for this group configuration item. For the list of parameters that you can use with each configuration item type, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
        pub fn parameters(mut self, input: crate::model::GroupConfigurationParameter) -> Self {
            let mut v = self.parameters.unwrap_or_default();
            v.push(input);
            self.parameters = Some(v);
            self
        }
        /// <p>A collection of parameters for this group configuration item. For the list of parameters that you can use with each configuration item type, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupConfigurationParameter>>,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupConfigurationItem`](crate::model::GroupConfigurationItem).
        pub fn build(self) -> crate::model::GroupConfigurationItem {
            crate::model::GroupConfigurationItem {
                r#type: self.r#type,
                parameters: self.parameters,
            }
        }
    }
}
impl GroupConfigurationItem {
    /// Creates a new builder-style object to manufacture [`GroupConfigurationItem`](crate::model::GroupConfigurationItem).
    pub fn builder() -> crate::model::group_configuration_item::Builder {
        crate::model::group_configuration_item::Builder::default()
    }
}

/// <p>A parameter for a group configuration item. For details about group service configuration syntax, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html">Service configurations for resource groups</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupConfigurationParameter {
    /// <p>The name of the group configuration parameter. For the list of parameters that you can use with each configuration item type, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The value or values to be used for the specified parameter. For the list of values you can use with each parameter, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl GroupConfigurationParameter {
    /// <p>The name of the group configuration parameter. For the list of parameters that you can use with each configuration item type, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value or values to be used for the specified parameter. For the list of values you can use with each parameter, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`GroupConfigurationParameter`](crate::model::GroupConfigurationParameter).
pub mod group_configuration_parameter {

    /// A builder for [`GroupConfigurationParameter`](crate::model::GroupConfigurationParameter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the group configuration parameter. For the list of parameters that you can use with each configuration item type, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the group configuration parameter. For the list of parameters that you can use with each configuration item type, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value or values to be used for the specified parameter. For the list of values you can use with each parameter, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The value or values to be used for the specified parameter. For the list of values you can use with each parameter, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and parameters</a>.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupConfigurationParameter`](crate::model::GroupConfigurationParameter).
        pub fn build(self) -> crate::model::GroupConfigurationParameter {
            crate::model::GroupConfigurationParameter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl GroupConfigurationParameter {
    /// Creates a new builder-style object to manufacture [`GroupConfigurationParameter`](crate::model::GroupConfigurationParameter).
    pub fn builder() -> crate::model::group_configuration_parameter::Builder {
        crate::model::group_configuration_parameter::Builder::default()
    }
}

/// <p>The unique identifiers for a resource group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupIdentifier {
    /// <p>The name of the resource group.</p>
    #[doc(hidden)]
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource group.</p>
    #[doc(hidden)]
    pub group_arn: std::option::Option<std::string::String>,
}
impl GroupIdentifier {
    /// <p>The name of the resource group.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The ARN of the resource group.</p>
    pub fn group_arn(&self) -> std::option::Option<&str> {
        self.group_arn.as_deref()
    }
}
/// See [`GroupIdentifier`](crate::model::GroupIdentifier).
pub mod group_identifier {

    /// A builder for [`GroupIdentifier`](crate::model::GroupIdentifier).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) group_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the resource group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The name of the resource group.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The ARN of the resource group.</p>
        pub fn group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource group.</p>
        pub fn set_group_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupIdentifier`](crate::model::GroupIdentifier).
        pub fn build(self) -> crate::model::GroupIdentifier {
            crate::model::GroupIdentifier {
                group_name: self.group_name,
                group_arn: self.group_arn,
            }
        }
    }
}
impl GroupIdentifier {
    /// Creates a new builder-style object to manufacture [`GroupIdentifier`](crate::model::GroupIdentifier).
    pub fn builder() -> crate::model::group_identifier::Builder {
        crate::model::group_identifier::Builder::default()
    }
}

/// <p>A filter collection that you can use to restrict the results from a <code>List</code> operation to only those you want to include.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupFilter {
    /// <p>The name of the filter. Filter names are case-sensitive.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::GroupFilterName>,
    /// <p>One or more filter values. Allowed filter values vary by group filter name, and are case-sensitive.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl GroupFilter {
    /// <p>The name of the filter. Filter names are case-sensitive.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::GroupFilterName> {
        self.name.as_ref()
    }
    /// <p>One or more filter values. Allowed filter values vary by group filter name, and are case-sensitive.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`GroupFilter`](crate::model::GroupFilter).
pub mod group_filter {

    /// A builder for [`GroupFilter`](crate::model::GroupFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::GroupFilterName>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter. Filter names are case-sensitive.</p>
        pub fn name(mut self, input: crate::model::GroupFilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the filter. Filter names are case-sensitive.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::GroupFilterName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>One or more filter values. Allowed filter values vary by group filter name, and are case-sensitive.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>One or more filter values. Allowed filter values vary by group filter name, and are case-sensitive.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupFilter`](crate::model::GroupFilter).
        pub fn build(self) -> crate::model::GroupFilter {
            crate::model::GroupFilter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl GroupFilter {
    /// Creates a new builder-style object to manufacture [`GroupFilter`](crate::model::GroupFilter).
    pub fn builder() -> crate::model::group_filter::Builder {
        crate::model::group_filter::Builder::default()
    }
}

/// When writing a match expression against `GroupFilterName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let groupfiltername = unimplemented!();
/// match groupfiltername {
///     GroupFilterName::ConfigurationType => { /* ... */ },
///     GroupFilterName::ResourceType => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `groupfiltername` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GroupFilterName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GroupFilterName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GroupFilterName::NewFeature` is defined.
/// Specifically, when `groupfiltername` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GroupFilterName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GroupFilterName {
    #[allow(missing_docs)] // documentation missing in model
    ConfigurationType,
    #[allow(missing_docs)] // documentation missing in model
    ResourceType,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GroupFilterName {
    fn from(s: &str) -> Self {
        match s {
            "configuration-type" => GroupFilterName::ConfigurationType,
            "resource-type" => GroupFilterName::ResourceType,
            other => GroupFilterName::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for GroupFilterName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GroupFilterName::from(s))
    }
}
impl GroupFilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GroupFilterName::ConfigurationType => "configuration-type",
            GroupFilterName::ResourceType => "resource-type",
            GroupFilterName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["configuration-type", "resource-type"]
    }
}
impl AsRef<str> for GroupFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure returned by the <code>ListGroupResources</code> operation that contains identity and group membership status information for one of the resources in the group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListGroupResourcesItem {
    /// <p>A structure that contains the ARN of a resource and its resource type.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<crate::model::ResourceIdentifier>,
    /// <p>A structure that contains the status of this resource's membership in the group.</p> <note>
    /// <p>This field is present in the response only if the group is of type <code>AWS::EC2::HostManagement</code>.</p>
    /// </note>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ResourceStatus>,
}
impl ListGroupResourcesItem {
    /// <p>A structure that contains the ARN of a resource and its resource type.</p>
    pub fn identifier(&self) -> std::option::Option<&crate::model::ResourceIdentifier> {
        self.identifier.as_ref()
    }
    /// <p>A structure that contains the status of this resource's membership in the group.</p> <note>
    /// <p>This field is present in the response only if the group is of type <code>AWS::EC2::HostManagement</code>.</p>
    /// </note>
    pub fn status(&self) -> std::option::Option<&crate::model::ResourceStatus> {
        self.status.as_ref()
    }
}
/// See [`ListGroupResourcesItem`](crate::model::ListGroupResourcesItem).
pub mod list_group_resources_item {

    /// A builder for [`ListGroupResourcesItem`](crate::model::ListGroupResourcesItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<crate::model::ResourceIdentifier>,
        pub(crate) status: std::option::Option<crate::model::ResourceStatus>,
    }
    impl Builder {
        /// <p>A structure that contains the ARN of a resource and its resource type.</p>
        pub fn identifier(mut self, input: crate::model::ResourceIdentifier) -> Self {
            self.identifier = Some(input);
            self
        }
        /// <p>A structure that contains the ARN of a resource and its resource type.</p>
        pub fn set_identifier(
            mut self,
            input: std::option::Option<crate::model::ResourceIdentifier>,
        ) -> Self {
            self.identifier = input;
            self
        }
        /// <p>A structure that contains the status of this resource's membership in the group.</p> <note>
        /// <p>This field is present in the response only if the group is of type <code>AWS::EC2::HostManagement</code>.</p>
        /// </note>
        pub fn status(mut self, input: crate::model::ResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>A structure that contains the status of this resource's membership in the group.</p> <note>
        /// <p>This field is present in the response only if the group is of type <code>AWS::EC2::HostManagement</code>.</p>
        /// </note>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ListGroupResourcesItem`](crate::model::ListGroupResourcesItem).
        pub fn build(self) -> crate::model::ListGroupResourcesItem {
            crate::model::ListGroupResourcesItem {
                identifier: self.identifier,
                status: self.status,
            }
        }
    }
}
impl ListGroupResourcesItem {
    /// Creates a new builder-style object to manufacture [`ListGroupResourcesItem`](crate::model::ListGroupResourcesItem).
    pub fn builder() -> crate::model::list_group_resources_item::Builder {
        crate::model::list_group_resources_item::Builder::default()
    }
}

/// <p>A structure that identifies the current group membership status for a resource. Adding a resource to a resource group is performed asynchronously as a background task. A <code>PENDING</code> status indicates, for this resource, that the process isn't completed yet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceStatus {
    /// <p>The current status.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::ResourceStatusValue>,
}
impl ResourceStatus {
    /// <p>The current status.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::ResourceStatusValue> {
        self.name.as_ref()
    }
}
/// See [`ResourceStatus`](crate::model::ResourceStatus).
pub mod resource_status {

    /// A builder for [`ResourceStatus`](crate::model::ResourceStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::ResourceStatusValue>,
    }
    impl Builder {
        /// <p>The current status.</p>
        pub fn name(mut self, input: crate::model::ResourceStatusValue) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The current status.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::ResourceStatusValue>,
        ) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceStatus`](crate::model::ResourceStatus).
        pub fn build(self) -> crate::model::ResourceStatus {
            crate::model::ResourceStatus { name: self.name }
        }
    }
}
impl ResourceStatus {
    /// Creates a new builder-style object to manufacture [`ResourceStatus`](crate::model::ResourceStatus).
    pub fn builder() -> crate::model::resource_status::Builder {
        crate::model::resource_status::Builder::default()
    }
}

/// When writing a match expression against `ResourceStatusValue`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcestatusvalue = unimplemented!();
/// match resourcestatusvalue {
///     ResourceStatusValue::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcestatusvalue` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceStatusValue::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceStatusValue::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceStatusValue::NewFeature` is defined.
/// Specifically, when `resourcestatusvalue` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceStatusValue::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceStatusValue {
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceStatusValue {
    fn from(s: &str) -> Self {
        match s {
            "PENDING" => ResourceStatusValue::Pending,
            other => {
                ResourceStatusValue::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ResourceStatusValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceStatusValue::from(s))
    }
}
impl ResourceStatusValue {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceStatusValue::Pending => "PENDING",
            ResourceStatusValue::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PENDING"]
    }
}
impl AsRef<str> for ResourceStatusValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A filter name and value pair that is used to obtain more specific results from a list of resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceFilter {
    /// <p>The name of the filter. Filter names are case-sensitive.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::ResourceFilterName>,
    /// <p>One or more filter values. Allowed filter values vary by resource filter name, and are case-sensitive.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ResourceFilter {
    /// <p>The name of the filter. Filter names are case-sensitive.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::ResourceFilterName> {
        self.name.as_ref()
    }
    /// <p>One or more filter values. Allowed filter values vary by resource filter name, and are case-sensitive.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`ResourceFilter`](crate::model::ResourceFilter).
pub mod resource_filter {

    /// A builder for [`ResourceFilter`](crate::model::ResourceFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::ResourceFilterName>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter. Filter names are case-sensitive.</p>
        pub fn name(mut self, input: crate::model::ResourceFilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the filter. Filter names are case-sensitive.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::ResourceFilterName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>One or more filter values. Allowed filter values vary by resource filter name, and are case-sensitive.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>One or more filter values. Allowed filter values vary by resource filter name, and are case-sensitive.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceFilter`](crate::model::ResourceFilter).
        pub fn build(self) -> crate::model::ResourceFilter {
            crate::model::ResourceFilter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl ResourceFilter {
    /// Creates a new builder-style object to manufacture [`ResourceFilter`](crate::model::ResourceFilter).
    pub fn builder() -> crate::model::resource_filter::Builder {
        crate::model::resource_filter::Builder::default()
    }
}

/// When writing a match expression against `ResourceFilterName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcefiltername = unimplemented!();
/// match resourcefiltername {
///     ResourceFilterName::ResourceType => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcefiltername` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceFilterName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceFilterName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceFilterName::NewFeature` is defined.
/// Specifically, when `resourcefiltername` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceFilterName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceFilterName {
    #[allow(missing_docs)] // documentation missing in model
    ResourceType,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceFilterName {
    fn from(s: &str) -> Self {
        match s {
            "resource-type" => ResourceFilterName::ResourceType,
            other => {
                ResourceFilterName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ResourceFilterName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceFilterName::from(s))
    }
}
impl ResourceFilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceFilterName::ResourceType => "resource-type",
            ResourceFilterName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["resource-type"]
    }
}
impl AsRef<str> for ResourceFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A service configuration associated with a resource group. The configuration options are determined by the Amazon Web Services service that defines the <code>Type</code>, and specifies which resources can be included in the group. You can add a service configuration when you create the group by using <code>CreateGroup</code>, or later by using the <code>PutGroupConfiguration</code> operation. For details about group service configuration syntax, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html">Service configurations for resource groups</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupConfiguration {
    /// <p>The configuration currently associated with the group and in effect.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<std::vec::Vec<crate::model::GroupConfigurationItem>>,
    /// <p>If present, the new configuration that is in the process of being applied to the group.</p>
    #[doc(hidden)]
    pub proposed_configuration:
        std::option::Option<std::vec::Vec<crate::model::GroupConfigurationItem>>,
    /// <p>The current status of an attempt to update the group configuration.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::GroupConfigurationStatus>,
    /// <p>If present, the reason why a request to update the group configuration failed.</p>
    #[doc(hidden)]
    pub failure_reason: std::option::Option<std::string::String>,
}
impl GroupConfiguration {
    /// <p>The configuration currently associated with the group and in effect.</p>
    pub fn configuration(&self) -> std::option::Option<&[crate::model::GroupConfigurationItem]> {
        self.configuration.as_deref()
    }
    /// <p>If present, the new configuration that is in the process of being applied to the group.</p>
    pub fn proposed_configuration(
        &self,
    ) -> std::option::Option<&[crate::model::GroupConfigurationItem]> {
        self.proposed_configuration.as_deref()
    }
    /// <p>The current status of an attempt to update the group configuration.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::GroupConfigurationStatus> {
        self.status.as_ref()
    }
    /// <p>If present, the reason why a request to update the group configuration failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
}
/// See [`GroupConfiguration`](crate::model::GroupConfiguration).
pub mod group_configuration {

    /// A builder for [`GroupConfiguration`](crate::model::GroupConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration:
            std::option::Option<std::vec::Vec<crate::model::GroupConfigurationItem>>,
        pub(crate) proposed_configuration:
            std::option::Option<std::vec::Vec<crate::model::GroupConfigurationItem>>,
        pub(crate) status: std::option::Option<crate::model::GroupConfigurationStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `configuration`.
        ///
        /// To override the contents of this collection use [`set_configuration`](Self::set_configuration).
        ///
        /// <p>The configuration currently associated with the group and in effect.</p>
        pub fn configuration(mut self, input: crate::model::GroupConfigurationItem) -> Self {
            let mut v = self.configuration.unwrap_or_default();
            v.push(input);
            self.configuration = Some(v);
            self
        }
        /// <p>The configuration currently associated with the group and in effect.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupConfigurationItem>>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Appends an item to `proposed_configuration`.
        ///
        /// To override the contents of this collection use [`set_proposed_configuration`](Self::set_proposed_configuration).
        ///
        /// <p>If present, the new configuration that is in the process of being applied to the group.</p>
        pub fn proposed_configuration(
            mut self,
            input: crate::model::GroupConfigurationItem,
        ) -> Self {
            let mut v = self.proposed_configuration.unwrap_or_default();
            v.push(input);
            self.proposed_configuration = Some(v);
            self
        }
        /// <p>If present, the new configuration that is in the process of being applied to the group.</p>
        pub fn set_proposed_configuration(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupConfigurationItem>>,
        ) -> Self {
            self.proposed_configuration = input;
            self
        }
        /// <p>The current status of an attempt to update the group configuration.</p>
        pub fn status(mut self, input: crate::model::GroupConfigurationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of an attempt to update the group configuration.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::GroupConfigurationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>If present, the reason why a request to update the group configuration failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If present, the reason why a request to update the group configuration failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupConfiguration`](crate::model::GroupConfiguration).
        pub fn build(self) -> crate::model::GroupConfiguration {
            crate::model::GroupConfiguration {
                configuration: self.configuration,
                proposed_configuration: self.proposed_configuration,
                status: self.status,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl GroupConfiguration {
    /// Creates a new builder-style object to manufacture [`GroupConfiguration`](crate::model::GroupConfiguration).
    pub fn builder() -> crate::model::group_configuration::Builder {
        crate::model::group_configuration::Builder::default()
    }
}

/// When writing a match expression against `GroupConfigurationStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let groupconfigurationstatus = unimplemented!();
/// match groupconfigurationstatus {
///     GroupConfigurationStatus::UpdateComplete => { /* ... */ },
///     GroupConfigurationStatus::UpdateFailed => { /* ... */ },
///     GroupConfigurationStatus::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `groupconfigurationstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GroupConfigurationStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GroupConfigurationStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GroupConfigurationStatus::NewFeature` is defined.
/// Specifically, when `groupconfigurationstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GroupConfigurationStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GroupConfigurationStatus {
    #[allow(missing_docs)] // documentation missing in model
    UpdateComplete,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GroupConfigurationStatus {
    fn from(s: &str) -> Self {
        match s {
            "UPDATE_COMPLETE" => GroupConfigurationStatus::UpdateComplete,
            "UPDATE_FAILED" => GroupConfigurationStatus::UpdateFailed,
            "UPDATING" => GroupConfigurationStatus::Updating,
            other => GroupConfigurationStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for GroupConfigurationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GroupConfigurationStatus::from(s))
    }
}
impl GroupConfigurationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GroupConfigurationStatus::UpdateComplete => "UPDATE_COMPLETE",
            GroupConfigurationStatus::UpdateFailed => "UPDATE_FAILED",
            GroupConfigurationStatus::Updating => "UPDATING",
            GroupConfigurationStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["UPDATE_COMPLETE", "UPDATE_FAILED", "UPDATING"]
    }
}
impl AsRef<str> for GroupConfigurationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
