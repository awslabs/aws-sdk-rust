// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`CompareFacesInput`](crate::input::CompareFacesInput)
pub mod compare_faces_input {
    /// A builder for [`CompareFacesInput`](crate::input::CompareFacesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_image: std::option::Option<crate::model::Image>,
        pub(crate) target_image: std::option::Option<crate::model::Image>,
        pub(crate) similarity_threshold: std::option::Option<f32>,
        pub(crate) quality_filter: std::option::Option<crate::model::QualityFilter>,
    }
    impl Builder {
        /// <p>The input image as base64-encoded bytes or an S3 object.
        /// If you use the AWS CLI to call Amazon Rekognition operations,
        /// passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn source_image(mut self, input: crate::model::Image) -> Self {
            self.source_image = Some(input);
            self
        }
        /// <p>The input image as base64-encoded bytes or an S3 object.
        /// If you use the AWS CLI to call Amazon Rekognition operations,
        /// passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn set_source_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.source_image = input;
            self
        }
        /// <p>The target image as base64-encoded bytes or an S3 object. If you use the AWS CLI to
        /// call Amazon Rekognition operations, passing base64-encoded image bytes is not supported.
        /// </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn target_image(mut self, input: crate::model::Image) -> Self {
            self.target_image = Some(input);
            self
        }
        /// <p>The target image as base64-encoded bytes or an S3 object. If you use the AWS CLI to
        /// call Amazon Rekognition operations, passing base64-encoded image bytes is not supported.
        /// </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn set_target_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.target_image = input;
            self
        }
        /// <p>The minimum level of confidence in the face matches that a match must meet to be
        /// included in the <code>FaceMatches</code> array.</p>
        pub fn similarity_threshold(mut self, input: f32) -> Self {
            self.similarity_threshold = Some(input);
            self
        }
        /// <p>The minimum level of confidence in the face matches that a match must meet to be
        /// included in the <code>FaceMatches</code> array.</p>
        pub fn set_similarity_threshold(mut self, input: std::option::Option<f32>) -> Self {
            self.similarity_threshold = input;
            self
        }
        /// <p>A filter that specifies a quality bar for how much filtering is done to identify faces.
        /// Filtered faces aren't compared. If you specify <code>AUTO</code>, Amazon Rekognition chooses the quality bar.
        /// If you specify <code>LOW</code>,
        /// <code>MEDIUM</code>, or <code>HIGH</code>, filtering removes all faces that
        /// don’t meet the chosen quality bar.
        ///
        /// The quality bar is based on a variety of common use cases. Low-quality
        /// detections can occur for a number of reasons. Some examples are an object that's misidentified
        /// as a face, a face that's too blurry, or a face with a
        /// pose that's too extreme to use. If you specify <code>NONE</code>, no
        /// filtering is performed. The default value is <code>NONE</code>.
        /// </p>
        /// <p>To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.</p>
        pub fn quality_filter(mut self, input: crate::model::QualityFilter) -> Self {
            self.quality_filter = Some(input);
            self
        }
        /// <p>A filter that specifies a quality bar for how much filtering is done to identify faces.
        /// Filtered faces aren't compared. If you specify <code>AUTO</code>, Amazon Rekognition chooses the quality bar.
        /// If you specify <code>LOW</code>,
        /// <code>MEDIUM</code>, or <code>HIGH</code>, filtering removes all faces that
        /// don’t meet the chosen quality bar.
        ///
        /// The quality bar is based on a variety of common use cases. Low-quality
        /// detections can occur for a number of reasons. Some examples are an object that's misidentified
        /// as a face, a face that's too blurry, or a face with a
        /// pose that's too extreme to use. If you specify <code>NONE</code>, no
        /// filtering is performed. The default value is <code>NONE</code>.
        /// </p>
        /// <p>To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.</p>
        pub fn set_quality_filter(
            mut self,
            input: std::option::Option<crate::model::QualityFilter>,
        ) -> Self {
            self.quality_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`CompareFacesInput`](crate::input::CompareFacesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CompareFacesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CompareFacesInput {
                source_image: self.source_image,
                target_image: self.target_image,
                similarity_threshold: self.similarity_threshold,
                quality_filter: self.quality_filter,
            })
        }
    }
}
#[doc(hidden)]
pub type CompareFacesInputOperationOutputAlias = crate::operation::CompareFaces;
#[doc(hidden)]
pub type CompareFacesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CompareFacesInput {
    /// Consumes the builder and constructs an Operation<[`CompareFaces`](crate::operation::CompareFaces)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CompareFaces,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CompareFacesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CompareFacesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CompareFacesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.CompareFaces",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_compare_faces(&self)
            .map_err(|err| {
            aws_smithy_http::operation::BuildError::SerializationError(err.into())
        })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CompareFaces::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CompareFaces",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CompareFacesInput`](crate::input::CompareFacesInput)
    pub fn builder() -> crate::input::compare_faces_input::Builder {
        crate::input::compare_faces_input::Builder::default()
    }
}

/// See [`CreateCollectionInput`](crate::input::CreateCollectionInput)
pub mod create_collection_input {
    /// A builder for [`CreateCollectionInput`](crate::input::CreateCollectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) collection_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>ID for the collection that you are creating.</p>
        pub fn collection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collection_id = Some(input.into());
            self
        }
        /// <p>ID for the collection that you are creating.</p>
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collection_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>
        /// A set of tags (key-value pairs) that you want to attach to the collection.
        /// </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>
        /// A set of tags (key-value pairs) that you want to attach to the collection.
        /// </p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateCollectionInput`](crate::input::CreateCollectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateCollectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateCollectionInput {
                collection_id: self.collection_id,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateCollectionInputOperationOutputAlias = crate::operation::CreateCollection;
#[doc(hidden)]
pub type CreateCollectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateCollectionInput {
    /// Consumes the builder and constructs an Operation<[`CreateCollection`](crate::operation::CreateCollection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateCollection,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateCollectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateCollectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateCollectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.CreateCollection",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_collection(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateCollection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateCollection",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateCollectionInput`](crate::input::CreateCollectionInput)
    pub fn builder() -> crate::input::create_collection_input::Builder {
        crate::input::create_collection_input::Builder::default()
    }
}

/// See [`CreateProjectInput`](crate::input::CreateProjectInput)
pub mod create_project_input {
    /// A builder for [`CreateProjectInput`](crate::input::CreateProjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the project to create.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project to create.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateProjectInput`](crate::input::CreateProjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateProjectInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateProjectInput {
                project_name: self.project_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateProjectInputOperationOutputAlias = crate::operation::CreateProject;
#[doc(hidden)]
pub type CreateProjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateProjectInput {
    /// Consumes the builder and constructs an Operation<[`CreateProject`](crate::operation::CreateProject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateProject,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateProjectInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateProjectInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateProjectInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.CreateProject",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_create_project(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateProject::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateProject",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateProjectInput`](crate::input::CreateProjectInput)
    pub fn builder() -> crate::input::create_project_input::Builder {
        crate::input::create_project_input::Builder::default()
    }
}

/// See [`CreateProjectVersionInput`](crate::input::CreateProjectVersionInput)
pub mod create_project_version_input {
    /// A builder for [`CreateProjectVersionInput`](crate::input::CreateProjectVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_arn: std::option::Option<std::string::String>,
        pub(crate) version_name: std::option::Option<std::string::String>,
        pub(crate) output_config: std::option::Option<crate::model::OutputConfig>,
        pub(crate) training_data: std::option::Option<crate::model::TrainingData>,
        pub(crate) testing_data: std::option::Option<crate::model::TestingData>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the Amazon Rekognition Custom Labels project that
        /// manages the model that you want to train.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Amazon Rekognition Custom Labels project that
        /// manages the model that you want to train.</p>
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_arn = input;
            self
        }
        /// <p>A name for the version of the model. This value must be unique.</p>
        pub fn version_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_name = Some(input.into());
            self
        }
        /// <p>A name for the version of the model. This value must be unique.</p>
        pub fn set_version_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_name = input;
            self
        }
        /// <p>The Amazon S3 bucket location to store the results of training.
        /// The S3 bucket can be in any AWS account as long as the caller has
        /// <code>s3:PutObject</code> permissions on the S3 bucket.</p>
        pub fn output_config(mut self, input: crate::model::OutputConfig) -> Self {
            self.output_config = Some(input);
            self
        }
        /// <p>The Amazon S3 bucket location to store the results of training.
        /// The S3 bucket can be in any AWS account as long as the caller has
        /// <code>s3:PutObject</code> permissions on the S3 bucket.</p>
        pub fn set_output_config(
            mut self,
            input: std::option::Option<crate::model::OutputConfig>,
        ) -> Self {
            self.output_config = input;
            self
        }
        /// <p>The dataset to use for training. </p>
        pub fn training_data(mut self, input: crate::model::TrainingData) -> Self {
            self.training_data = Some(input);
            self
        }
        /// <p>The dataset to use for training. </p>
        pub fn set_training_data(
            mut self,
            input: std::option::Option<crate::model::TrainingData>,
        ) -> Self {
            self.training_data = input;
            self
        }
        /// <p>The dataset to use for testing.</p>
        pub fn testing_data(mut self, input: crate::model::TestingData) -> Self {
            self.testing_data = Some(input);
            self
        }
        /// <p>The dataset to use for testing.</p>
        pub fn set_testing_data(
            mut self,
            input: std::option::Option<crate::model::TestingData>,
        ) -> Self {
            self.testing_data = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>
        /// A set of tags (key-value pairs) that you want to attach to the model.
        /// </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>
        /// A set of tags (key-value pairs) that you want to attach to the model.
        /// </p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The identifier for your AWS Key Management Service (AWS KMS) customer master key (CMK).
        /// You can supply the Amazon Resource Name (ARN) of your CMK, the ID of your CMK,
        /// an alias for your CMK, or an alias ARN.
        /// The key is used to encrypt training and test images copied into the service for model training.
        /// Your source images are unaffected. The key is also used to encrypt training results
        /// and manifest files written to the output Amazon S3 bucket (<code>OutputConfig</code>).</p>
        /// <p>If you choose to use your own CMK, you need the following permissions on the CMK.</p>
        /// <ul>
        /// <li>
        /// <p>kms:CreateGrant</p>
        /// </li>
        /// <li>
        /// <p>kms:DescribeKey</p>
        /// </li>
        /// <li>
        /// <p>kms:GenerateDataKey</p>
        /// </li>
        /// <li>
        /// <p>kms:Decrypt</p>
        /// </li>
        /// </ul>
        /// <p>If you don't specify a value for <code>KmsKeyId</code>, images copied into the service are encrypted
        /// using a key that AWS owns and manages.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The identifier for your AWS Key Management Service (AWS KMS) customer master key (CMK).
        /// You can supply the Amazon Resource Name (ARN) of your CMK, the ID of your CMK,
        /// an alias for your CMK, or an alias ARN.
        /// The key is used to encrypt training and test images copied into the service for model training.
        /// Your source images are unaffected. The key is also used to encrypt training results
        /// and manifest files written to the output Amazon S3 bucket (<code>OutputConfig</code>).</p>
        /// <p>If you choose to use your own CMK, you need the following permissions on the CMK.</p>
        /// <ul>
        /// <li>
        /// <p>kms:CreateGrant</p>
        /// </li>
        /// <li>
        /// <p>kms:DescribeKey</p>
        /// </li>
        /// <li>
        /// <p>kms:GenerateDataKey</p>
        /// </li>
        /// <li>
        /// <p>kms:Decrypt</p>
        /// </li>
        /// </ul>
        /// <p>If you don't specify a value for <code>KmsKeyId</code>, images copied into the service are encrypted
        /// using a key that AWS owns and manages.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateProjectVersionInput`](crate::input::CreateProjectVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateProjectVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateProjectVersionInput {
                project_arn: self.project_arn,
                version_name: self.version_name,
                output_config: self.output_config,
                training_data: self.training_data,
                testing_data: self.testing_data,
                tags: self.tags,
                kms_key_id: self.kms_key_id,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateProjectVersionInputOperationOutputAlias = crate::operation::CreateProjectVersion;
#[doc(hidden)]
pub type CreateProjectVersionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateProjectVersionInput {
    /// Consumes the builder and constructs an Operation<[`CreateProjectVersion`](crate::operation::CreateProjectVersion)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateProjectVersion,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateProjectVersionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateProjectVersionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateProjectVersionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.CreateProjectVersion",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_project_version(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateProjectVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateProjectVersion",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateProjectVersionInput`](crate::input::CreateProjectVersionInput)
    pub fn builder() -> crate::input::create_project_version_input::Builder {
        crate::input::create_project_version_input::Builder::default()
    }
}

/// See [`CreateStreamProcessorInput`](crate::input::CreateStreamProcessorInput)
pub mod create_stream_processor_input {
    /// A builder for [`CreateStreamProcessorInput`](crate::input::CreateStreamProcessorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input: std::option::Option<crate::model::StreamProcessorInput>,
        pub(crate) output: std::option::Option<crate::model::StreamProcessorOutput>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) settings: std::option::Option<crate::model::StreamProcessorSettings>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Kinesis video stream stream that provides the source streaming video. If you are using the AWS CLI, the parameter name is <code>StreamProcessorInput</code>.</p>
        pub fn input(mut self, input: crate::model::StreamProcessorInput) -> Self {
            self.input = Some(input);
            self
        }
        /// <p>Kinesis video stream stream that provides the source streaming video. If you are using the AWS CLI, the parameter name is <code>StreamProcessorInput</code>.</p>
        pub fn set_input(
            mut self,
            input: std::option::Option<crate::model::StreamProcessorInput>,
        ) -> Self {
            self.input = input;
            self
        }
        /// <p>Kinesis data stream stream to which Amazon Rekognition Video puts the analysis results. If you are using the AWS CLI, the parameter name is <code>StreamProcessorOutput</code>.</p>
        pub fn output(mut self, input: crate::model::StreamProcessorOutput) -> Self {
            self.output = Some(input);
            self
        }
        /// <p>Kinesis data stream stream to which Amazon Rekognition Video puts the analysis results. If you are using the AWS CLI, the parameter name is <code>StreamProcessorOutput</code>.</p>
        pub fn set_output(
            mut self,
            input: std::option::Option<crate::model::StreamProcessorOutput>,
        ) -> Self {
            self.output = input;
            self
        }
        /// <p>An identifier you assign to the stream processor. You can use <code>Name</code> to
        /// manage the stream processor. For example, you can get the current status of the stream processor by calling <a>DescribeStreamProcessor</a>.
        /// <code>Name</code> is idempotent.
        /// </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>An identifier you assign to the stream processor. You can use <code>Name</code> to
        /// manage the stream processor. For example, you can get the current status of the stream processor by calling <a>DescribeStreamProcessor</a>.
        /// <code>Name</code> is idempotent.
        /// </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Face recognition input parameters to be used by the stream processor. Includes the collection to use for face recognition and the face
        /// attributes to detect.</p>
        pub fn settings(mut self, input: crate::model::StreamProcessorSettings) -> Self {
            self.settings = Some(input);
            self
        }
        /// <p>Face recognition input parameters to be used by the stream processor. Includes the collection to use for face recognition and the face
        /// attributes to detect.</p>
        pub fn set_settings(
            mut self,
            input: std::option::Option<crate::model::StreamProcessorSettings>,
        ) -> Self {
            self.settings = input;
            self
        }
        /// <p>ARN of the IAM role that allows access to the stream processor.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>ARN of the IAM role that allows access to the stream processor.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>
        /// A set of tags (key-value pairs) that you want to attach to the stream processor.
        /// </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>
        /// A set of tags (key-value pairs) that you want to attach to the stream processor.
        /// </p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateStreamProcessorInput`](crate::input::CreateStreamProcessorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateStreamProcessorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateStreamProcessorInput {
                input: self.input,
                output: self.output,
                name: self.name,
                settings: self.settings,
                role_arn: self.role_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateStreamProcessorInputOperationOutputAlias = crate::operation::CreateStreamProcessor;
#[doc(hidden)]
pub type CreateStreamProcessorInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateStreamProcessorInput {
    /// Consumes the builder and constructs an Operation<[`CreateStreamProcessor`](crate::operation::CreateStreamProcessor)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateStreamProcessor,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateStreamProcessorInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateStreamProcessorInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateStreamProcessorInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.CreateStreamProcessor",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_stream_processor(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateStreamProcessor::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateStreamProcessor",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateStreamProcessorInput`](crate::input::CreateStreamProcessorInput)
    pub fn builder() -> crate::input::create_stream_processor_input::Builder {
        crate::input::create_stream_processor_input::Builder::default()
    }
}

/// See [`DeleteCollectionInput`](crate::input::DeleteCollectionInput)
pub mod delete_collection_input {
    /// A builder for [`DeleteCollectionInput`](crate::input::DeleteCollectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) collection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>ID of the collection to delete.</p>
        pub fn collection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collection_id = Some(input.into());
            self
        }
        /// <p>ID of the collection to delete.</p>
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteCollectionInput`](crate::input::DeleteCollectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteCollectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteCollectionInput {
                collection_id: self.collection_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteCollectionInputOperationOutputAlias = crate::operation::DeleteCollection;
#[doc(hidden)]
pub type DeleteCollectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteCollectionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCollection`](crate::operation::DeleteCollection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteCollection,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteCollectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteCollectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteCollectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DeleteCollection",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_collection(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteCollection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteCollection",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteCollectionInput`](crate::input::DeleteCollectionInput)
    pub fn builder() -> crate::input::delete_collection_input::Builder {
        crate::input::delete_collection_input::Builder::default()
    }
}

/// See [`DeleteFacesInput`](crate::input::DeleteFacesInput)
pub mod delete_faces_input {
    /// A builder for [`DeleteFacesInput`](crate::input::DeleteFacesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) collection_id: std::option::Option<std::string::String>,
        pub(crate) face_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Collection from which to remove the specific faces.</p>
        pub fn collection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collection_id = Some(input.into());
            self
        }
        /// <p>Collection from which to remove the specific faces.</p>
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collection_id = input;
            self
        }
        /// Appends an item to `face_ids`.
        ///
        /// To override the contents of this collection use [`set_face_ids`](Self::set_face_ids).
        ///
        /// <p>An array of face IDs to delete.</p>
        pub fn face_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.face_ids.unwrap_or_default();
            v.push(input.into());
            self.face_ids = Some(v);
            self
        }
        /// <p>An array of face IDs to delete.</p>
        pub fn set_face_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.face_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFacesInput`](crate::input::DeleteFacesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteFacesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteFacesInput {
                collection_id: self.collection_id,
                face_ids: self.face_ids,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteFacesInputOperationOutputAlias = crate::operation::DeleteFaces;
#[doc(hidden)]
pub type DeleteFacesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteFacesInput {
    /// Consumes the builder and constructs an Operation<[`DeleteFaces`](crate::operation::DeleteFaces)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteFaces,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteFacesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteFacesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteFacesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DeleteFaces",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_delete_faces(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteFaces::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteFaces",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteFacesInput`](crate::input::DeleteFacesInput)
    pub fn builder() -> crate::input::delete_faces_input::Builder {
        crate::input::delete_faces_input::Builder::default()
    }
}

/// See [`DeleteProjectInput`](crate::input::DeleteProjectInput)
pub mod delete_project_input {
    /// A builder for [`DeleteProjectInput`](crate::input::DeleteProjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the project that you want to delete.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the project that you want to delete.</p>
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteProjectInput`](crate::input::DeleteProjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteProjectInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteProjectInput {
                project_arn: self.project_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteProjectInputOperationOutputAlias = crate::operation::DeleteProject;
#[doc(hidden)]
pub type DeleteProjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteProjectInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProject`](crate::operation::DeleteProject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteProject,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteProjectInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteProjectInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteProjectInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DeleteProject",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_delete_project(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteProject::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteProject",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteProjectInput`](crate::input::DeleteProjectInput)
    pub fn builder() -> crate::input::delete_project_input::Builder {
        crate::input::delete_project_input::Builder::default()
    }
}

/// See [`DeleteProjectVersionInput`](crate::input::DeleteProjectVersionInput)
pub mod delete_project_version_input {
    /// A builder for [`DeleteProjectVersionInput`](crate::input::DeleteProjectVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_version_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the model version that you want to delete.</p>
        pub fn project_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_version_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model version that you want to delete.</p>
        pub fn set_project_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.project_version_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteProjectVersionInput`](crate::input::DeleteProjectVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteProjectVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteProjectVersionInput {
                project_version_arn: self.project_version_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteProjectVersionInputOperationOutputAlias = crate::operation::DeleteProjectVersion;
#[doc(hidden)]
pub type DeleteProjectVersionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteProjectVersionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProjectVersion`](crate::operation::DeleteProjectVersion)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteProjectVersion,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteProjectVersionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteProjectVersionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteProjectVersionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DeleteProjectVersion",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_project_version(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteProjectVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteProjectVersion",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteProjectVersionInput`](crate::input::DeleteProjectVersionInput)
    pub fn builder() -> crate::input::delete_project_version_input::Builder {
        crate::input::delete_project_version_input::Builder::default()
    }
}

/// See [`DeleteStreamProcessorInput`](crate::input::DeleteStreamProcessorInput)
pub mod delete_stream_processor_input {
    /// A builder for [`DeleteStreamProcessorInput`](crate::input::DeleteStreamProcessorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the stream processor you want to delete.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the stream processor you want to delete.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteStreamProcessorInput`](crate::input::DeleteStreamProcessorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteStreamProcessorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteStreamProcessorInput { name: self.name })
        }
    }
}
#[doc(hidden)]
pub type DeleteStreamProcessorInputOperationOutputAlias = crate::operation::DeleteStreamProcessor;
#[doc(hidden)]
pub type DeleteStreamProcessorInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteStreamProcessorInput {
    /// Consumes the builder and constructs an Operation<[`DeleteStreamProcessor`](crate::operation::DeleteStreamProcessor)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteStreamProcessor,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteStreamProcessorInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteStreamProcessorInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteStreamProcessorInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DeleteStreamProcessor",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_stream_processor(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteStreamProcessor::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteStreamProcessor",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteStreamProcessorInput`](crate::input::DeleteStreamProcessorInput)
    pub fn builder() -> crate::input::delete_stream_processor_input::Builder {
        crate::input::delete_stream_processor_input::Builder::default()
    }
}

/// See [`DescribeCollectionInput`](crate::input::DescribeCollectionInput)
pub mod describe_collection_input {
    /// A builder for [`DescribeCollectionInput`](crate::input::DescribeCollectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) collection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the collection to describe.</p>
        pub fn collection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collection_id = Some(input.into());
            self
        }
        /// <p>The ID of the collection to describe.</p>
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeCollectionInput`](crate::input::DescribeCollectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeCollectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeCollectionInput {
                collection_id: self.collection_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeCollectionInputOperationOutputAlias = crate::operation::DescribeCollection;
#[doc(hidden)]
pub type DescribeCollectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeCollectionInput {
    /// Consumes the builder and constructs an Operation<[`DescribeCollection`](crate::operation::DescribeCollection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeCollection,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeCollectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeCollectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeCollectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DescribeCollection",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_collection(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeCollection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeCollection",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeCollectionInput`](crate::input::DescribeCollectionInput)
    pub fn builder() -> crate::input::describe_collection_input::Builder {
        crate::input::describe_collection_input::Builder::default()
    }
}

/// See [`DescribeProjectsInput`](crate::input::DescribeProjectsInput)
pub mod describe_projects_input {
    /// A builder for [`DescribeProjectsInput`](crate::input::DescribeProjectsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>If the previous response was incomplete (because there is more
        /// results to retrieve), Amazon Rekognition Custom Labels returns a pagination token in the response. You can use this pagination
        /// token to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more
        /// results to retrieve), Amazon Rekognition Custom Labels returns a pagination token in the response. You can use this pagination
        /// token to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per paginated call. The largest value you can specify is 100.
        /// If you specify a value greater than 100, a ValidationException
        /// error occurs. The default value is 100. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per paginated call. The largest value you can specify is 100.
        /// If you specify a value greater than 100, a ValidationException
        /// error occurs. The default value is 100. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeProjectsInput`](crate::input::DescribeProjectsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeProjectsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeProjectsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeProjectsInputOperationOutputAlias = crate::operation::DescribeProjects;
#[doc(hidden)]
pub type DescribeProjectsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeProjectsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeProjects`](crate::operation::DescribeProjects)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeProjects,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeProjectsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeProjectsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeProjectsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DescribeProjects",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_projects(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeProjects::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeProjects",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeProjectsInput`](crate::input::DescribeProjectsInput)
    pub fn builder() -> crate::input::describe_projects_input::Builder {
        crate::input::describe_projects_input::Builder::default()
    }
}

/// See [`DescribeProjectVersionsInput`](crate::input::DescribeProjectVersionsInput)
pub mod describe_project_versions_input {
    /// A builder for [`DescribeProjectVersionsInput`](crate::input::DescribeProjectVersionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_arn: std::option::Option<std::string::String>,
        pub(crate) version_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the project that contains the models you want to describe.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the project that contains the models you want to describe.</p>
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_arn = input;
            self
        }
        /// Appends an item to `version_names`.
        ///
        /// To override the contents of this collection use [`set_version_names`](Self::set_version_names).
        ///
        /// <p>A list of model version names that you want to describe. You can add up to 10 model version names
        /// to the list. If you don't specify a value, all model descriptions are returned.  A version name is part of a
        /// model (ProjectVersion) ARN. For example, <code>my-model.2020-01-21T09.10.15</code> is the version name in the following ARN.
        /// <code>arn:aws:rekognition:us-east-1:123456789012:project/getting-started/version/<i>my-model.2020-01-21T09.10.15</i>/1234567890123</code>.</p>
        pub fn version_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.version_names.unwrap_or_default();
            v.push(input.into());
            self.version_names = Some(v);
            self
        }
        /// <p>A list of model version names that you want to describe. You can add up to 10 model version names
        /// to the list. If you don't specify a value, all model descriptions are returned.  A version name is part of a
        /// model (ProjectVersion) ARN. For example, <code>my-model.2020-01-21T09.10.15</code> is the version name in the following ARN.
        /// <code>arn:aws:rekognition:us-east-1:123456789012:project/getting-started/version/<i>my-model.2020-01-21T09.10.15</i>/1234567890123</code>.</p>
        pub fn set_version_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.version_names = input;
            self
        }
        /// <p>If the previous response was incomplete (because there is more
        /// results to retrieve), Amazon Rekognition Custom Labels returns a pagination token in the response.
        /// You can use this pagination token to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more
        /// results to retrieve), Amazon Rekognition Custom Labels returns a pagination token in the response.
        /// You can use this pagination token to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per paginated call.
        /// The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException
        /// error occurs. The default value is 100. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per paginated call.
        /// The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException
        /// error occurs. The default value is 100. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeProjectVersionsInput`](crate::input::DescribeProjectVersionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeProjectVersionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeProjectVersionsInput {
                project_arn: self.project_arn,
                version_names: self.version_names,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeProjectVersionsInputOperationOutputAlias =
    crate::operation::DescribeProjectVersions;
#[doc(hidden)]
pub type DescribeProjectVersionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeProjectVersionsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeProjectVersions`](crate::operation::DescribeProjectVersions)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeProjectVersions,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeProjectVersionsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeProjectVersionsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeProjectVersionsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DescribeProjectVersions",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_project_versions(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeProjectVersions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeProjectVersions",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeProjectVersionsInput`](crate::input::DescribeProjectVersionsInput)
    pub fn builder() -> crate::input::describe_project_versions_input::Builder {
        crate::input::describe_project_versions_input::Builder::default()
    }
}

/// See [`DescribeStreamProcessorInput`](crate::input::DescribeStreamProcessorInput)
pub mod describe_stream_processor_input {
    /// A builder for [`DescribeStreamProcessorInput`](crate::input::DescribeStreamProcessorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of the stream processor for which you want information.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of the stream processor for which you want information.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeStreamProcessorInput`](crate::input::DescribeStreamProcessorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeStreamProcessorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeStreamProcessorInput { name: self.name })
        }
    }
}
#[doc(hidden)]
pub type DescribeStreamProcessorInputOperationOutputAlias =
    crate::operation::DescribeStreamProcessor;
#[doc(hidden)]
pub type DescribeStreamProcessorInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeStreamProcessorInput {
    /// Consumes the builder and constructs an Operation<[`DescribeStreamProcessor`](crate::operation::DescribeStreamProcessor)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeStreamProcessor,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeStreamProcessorInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeStreamProcessorInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeStreamProcessorInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DescribeStreamProcessor",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_stream_processor(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeStreamProcessor::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeStreamProcessor",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeStreamProcessorInput`](crate::input::DescribeStreamProcessorInput)
    pub fn builder() -> crate::input::describe_stream_processor_input::Builder {
        crate::input::describe_stream_processor_input::Builder::default()
    }
}

/// See [`DetectCustomLabelsInput`](crate::input::DetectCustomLabelsInput)
pub mod detect_custom_labels_input {
    /// A builder for [`DetectCustomLabelsInput`](crate::input::DetectCustomLabelsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_version_arn: std::option::Option<std::string::String>,
        pub(crate) image: std::option::Option<crate::model::Image>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) min_confidence: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The ARN of the model version that you want to use.</p>
        pub fn project_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_version_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the model version that you want to use.</p>
        pub fn set_project_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.project_version_arn = input;
            self
        }
        /// <p>Provides the input image either as bytes or an S3 object.</p>
        /// <p>You pass image bytes to an Amazon Rekognition API operation by using the <code>Bytes</code>
        /// property. For example, you would use the <code>Bytes</code> property to pass an image loaded
        /// from a local file system. Image bytes passed by using the <code>Bytes</code> property must be
        /// base64-encoded. Your code may not need to encode image bytes if you are using an AWS SDK to
        /// call Amazon Rekognition API operations. </p>
        ///
        /// <p>For more information, see Analyzing an Image Loaded from a Local File System
        /// in the Amazon Rekognition Developer Guide.</p>
        /// <p> You pass images stored in an S3 bucket to an Amazon Rekognition API operation by using the
        /// <code>S3Object</code> property. Images stored in an S3 bucket do not need to be
        /// base64-encoded.</p>
        /// <p>The region for the S3 bucket containing the S3 object must match the region you use for
        /// Amazon Rekognition operations.</p>
        /// <p>If you use the
        /// AWS
        /// CLI to call Amazon Rekognition operations, passing image bytes using the Bytes
        /// property is not supported. You must first upload the image to an Amazon S3 bucket and then
        /// call the operation using the S3Object property.</p>
        ///
        /// <p>For Amazon Rekognition to process an S3 object, the user must have permission to access the S3
        /// object. For more information, see Resource Based Policies in the Amazon Rekognition Developer Guide.
        /// </p>
        pub fn image(mut self, input: crate::model::Image) -> Self {
            self.image = Some(input);
            self
        }
        /// <p>Provides the input image either as bytes or an S3 object.</p>
        /// <p>You pass image bytes to an Amazon Rekognition API operation by using the <code>Bytes</code>
        /// property. For example, you would use the <code>Bytes</code> property to pass an image loaded
        /// from a local file system. Image bytes passed by using the <code>Bytes</code> property must be
        /// base64-encoded. Your code may not need to encode image bytes if you are using an AWS SDK to
        /// call Amazon Rekognition API operations. </p>
        ///
        /// <p>For more information, see Analyzing an Image Loaded from a Local File System
        /// in the Amazon Rekognition Developer Guide.</p>
        /// <p> You pass images stored in an S3 bucket to an Amazon Rekognition API operation by using the
        /// <code>S3Object</code> property. Images stored in an S3 bucket do not need to be
        /// base64-encoded.</p>
        /// <p>The region for the S3 bucket containing the S3 object must match the region you use for
        /// Amazon Rekognition operations.</p>
        /// <p>If you use the
        /// AWS
        /// CLI to call Amazon Rekognition operations, passing image bytes using the Bytes
        /// property is not supported. You must first upload the image to an Amazon S3 bucket and then
        /// call the operation using the S3Object property.</p>
        ///
        /// <p>For Amazon Rekognition to process an S3 object, the user must have permission to access the S3
        /// object. For more information, see Resource Based Policies in the Amazon Rekognition Developer Guide.
        /// </p>
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.image = input;
            self
        }
        /// <p>Maximum number of results you want the service to return in the response.
        /// The service returns the specified number of highest confidence labels ranked from highest confidence
        /// to lowest.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of results you want the service to return in the response.
        /// The service returns the specified number of highest confidence labels ranked from highest confidence
        /// to lowest.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Specifies the minimum confidence level for the labels to return.
        /// <code>DetectCustomLabels</code> doesn't return any labels with a confidence value that's lower than
        /// this specified value. If you specify a
        /// value of 0, <code>DetectCustomLabels</code> returns all labels, regardless of the assumed
        /// threshold applied to each label.
        /// If you don't specify a value for <code>MinConfidence</code>,  <code>DetectCustomLabels</code>
        /// returns labels based on the assumed threshold of each label.</p>
        pub fn min_confidence(mut self, input: f32) -> Self {
            self.min_confidence = Some(input);
            self
        }
        /// <p>Specifies the minimum confidence level for the labels to return.
        /// <code>DetectCustomLabels</code> doesn't return any labels with a confidence value that's lower than
        /// this specified value. If you specify a
        /// value of 0, <code>DetectCustomLabels</code> returns all labels, regardless of the assumed
        /// threshold applied to each label.
        /// If you don't specify a value for <code>MinConfidence</code>,  <code>DetectCustomLabels</code>
        /// returns labels based on the assumed threshold of each label.</p>
        pub fn set_min_confidence(mut self, input: std::option::Option<f32>) -> Self {
            self.min_confidence = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectCustomLabelsInput`](crate::input::DetectCustomLabelsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetectCustomLabelsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetectCustomLabelsInput {
                project_version_arn: self.project_version_arn,
                image: self.image,
                max_results: self.max_results,
                min_confidence: self.min_confidence,
            })
        }
    }
}
#[doc(hidden)]
pub type DetectCustomLabelsInputOperationOutputAlias = crate::operation::DetectCustomLabels;
#[doc(hidden)]
pub type DetectCustomLabelsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DetectCustomLabelsInput {
    /// Consumes the builder and constructs an Operation<[`DetectCustomLabels`](crate::operation::DetectCustomLabels)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetectCustomLabels,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DetectCustomLabelsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DetectCustomLabelsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DetectCustomLabelsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DetectCustomLabels",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_detect_custom_labels(&self)
                .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetectCustomLabels::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetectCustomLabels",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DetectCustomLabelsInput`](crate::input::DetectCustomLabelsInput)
    pub fn builder() -> crate::input::detect_custom_labels_input::Builder {
        crate::input::detect_custom_labels_input::Builder::default()
    }
}

/// See [`DetectFacesInput`](crate::input::DetectFacesInput)
pub mod detect_faces_input {
    /// A builder for [`DetectFacesInput`](crate::input::DetectFacesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image: std::option::Option<crate::model::Image>,
        pub(crate) attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
    }
    impl Builder {
        /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
        /// Amazon Rekognition operations, passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, input: crate::model::Image) -> Self {
            self.image = Some(input);
            self
        }
        /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
        /// Amazon Rekognition operations, passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.image = input;
            self
        }
        /// Appends an item to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>An array of facial attributes you want to be returned. This can be the default list of
        /// attributes or all attributes. If you don't specify a value for <code>Attributes</code> or if
        /// you specify <code>["DEFAULT"]</code>, the API returns the following subset of facial
        /// attributes: <code>BoundingBox</code>, <code>Confidence</code>, <code>Pose</code>,
        /// <code>Quality</code>, and <code>Landmarks</code>. If you provide <code>["ALL"]</code>, all
        /// facial attributes are returned, but the operation takes longer to complete.</p>
        /// <p>If you provide both, <code>["ALL", "DEFAULT"]</code>, the service uses a logical AND
        /// operator to determine which attributes to return (in this case, all attributes). </p>
        pub fn attributes(mut self, input: impl Into<crate::model::Attribute>) -> Self {
            let mut v = self.attributes.unwrap_or_default();
            v.push(input.into());
            self.attributes = Some(v);
            self
        }
        /// <p>An array of facial attributes you want to be returned. This can be the default list of
        /// attributes or all attributes. If you don't specify a value for <code>Attributes</code> or if
        /// you specify <code>["DEFAULT"]</code>, the API returns the following subset of facial
        /// attributes: <code>BoundingBox</code>, <code>Confidence</code>, <code>Pose</code>,
        /// <code>Quality</code>, and <code>Landmarks</code>. If you provide <code>["ALL"]</code>, all
        /// facial attributes are returned, but the operation takes longer to complete.</p>
        /// <p>If you provide both, <code>["ALL", "DEFAULT"]</code>, the service uses a logical AND
        /// operator to determine which attributes to return (in this case, all attributes). </p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectFacesInput`](crate::input::DetectFacesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetectFacesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetectFacesInput {
                image: self.image,
                attributes: self.attributes,
            })
        }
    }
}
#[doc(hidden)]
pub type DetectFacesInputOperationOutputAlias = crate::operation::DetectFaces;
#[doc(hidden)]
pub type DetectFacesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DetectFacesInput {
    /// Consumes the builder and constructs an Operation<[`DetectFaces`](crate::operation::DetectFaces)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetectFaces,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DetectFacesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DetectFacesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DetectFacesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DetectFaces",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_detect_faces(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetectFaces::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetectFaces",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DetectFacesInput`](crate::input::DetectFacesInput)
    pub fn builder() -> crate::input::detect_faces_input::Builder {
        crate::input::detect_faces_input::Builder::default()
    }
}

/// See [`DetectLabelsInput`](crate::input::DetectLabelsInput)
pub mod detect_labels_input {
    /// A builder for [`DetectLabelsInput`](crate::input::DetectLabelsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image: std::option::Option<crate::model::Image>,
        pub(crate) max_labels: std::option::Option<i32>,
        pub(crate) min_confidence: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
        /// Amazon Rekognition operations, passing image bytes is not supported. Images stored in an S3 Bucket do
        /// not need to be base64-encoded.</p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, input: crate::model::Image) -> Self {
            self.image = Some(input);
            self
        }
        /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
        /// Amazon Rekognition operations, passing image bytes is not supported. Images stored in an S3 Bucket do
        /// not need to be base64-encoded.</p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.image = input;
            self
        }
        /// <p>Maximum number of labels you want the service to return in the response. The service
        /// returns the specified number of highest confidence labels. </p>
        pub fn max_labels(mut self, input: i32) -> Self {
            self.max_labels = Some(input);
            self
        }
        /// <p>Maximum number of labels you want the service to return in the response. The service
        /// returns the specified number of highest confidence labels. </p>
        pub fn set_max_labels(mut self, input: std::option::Option<i32>) -> Self {
            self.max_labels = input;
            self
        }
        /// <p>Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't
        /// return any labels with confidence lower than this specified value.</p>
        /// <p>If <code>MinConfidence</code> is not specified, the operation returns labels with a
        /// confidence values greater than or equal to 55 percent.</p>
        pub fn min_confidence(mut self, input: f32) -> Self {
            self.min_confidence = Some(input);
            self
        }
        /// <p>Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't
        /// return any labels with confidence lower than this specified value.</p>
        /// <p>If <code>MinConfidence</code> is not specified, the operation returns labels with a
        /// confidence values greater than or equal to 55 percent.</p>
        pub fn set_min_confidence(mut self, input: std::option::Option<f32>) -> Self {
            self.min_confidence = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectLabelsInput`](crate::input::DetectLabelsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetectLabelsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetectLabelsInput {
                image: self.image,
                max_labels: self.max_labels,
                min_confidence: self.min_confidence,
            })
        }
    }
}
#[doc(hidden)]
pub type DetectLabelsInputOperationOutputAlias = crate::operation::DetectLabels;
#[doc(hidden)]
pub type DetectLabelsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DetectLabelsInput {
    /// Consumes the builder and constructs an Operation<[`DetectLabels`](crate::operation::DetectLabels)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetectLabels,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DetectLabelsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DetectLabelsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DetectLabelsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DetectLabels",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_detect_labels(&self)
            .map_err(|err| {
            aws_smithy_http::operation::BuildError::SerializationError(err.into())
        })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetectLabels::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetectLabels",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DetectLabelsInput`](crate::input::DetectLabelsInput)
    pub fn builder() -> crate::input::detect_labels_input::Builder {
        crate::input::detect_labels_input::Builder::default()
    }
}

/// See [`DetectModerationLabelsInput`](crate::input::DetectModerationLabelsInput)
pub mod detect_moderation_labels_input {
    /// A builder for [`DetectModerationLabelsInput`](crate::input::DetectModerationLabelsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image: std::option::Option<crate::model::Image>,
        pub(crate) min_confidence: std::option::Option<f32>,
        pub(crate) human_loop_config: std::option::Option<crate::model::HumanLoopConfig>,
    }
    impl Builder {
        /// <p>The input image as base64-encoded bytes or an S3 object.
        /// If you use the AWS CLI to call Amazon Rekognition operations,
        /// passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, input: crate::model::Image) -> Self {
            self.image = Some(input);
            self
        }
        /// <p>The input image as base64-encoded bytes or an S3 object.
        /// If you use the AWS CLI to call Amazon Rekognition operations,
        /// passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.image = input;
            self
        }
        /// <p>Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't
        /// return any labels with a confidence level lower than this specified value.</p>
        /// <p>If you don't specify <code>MinConfidence</code>, the operation returns labels with
        /// confidence values greater than or equal to 50 percent.</p>
        pub fn min_confidence(mut self, input: f32) -> Self {
            self.min_confidence = Some(input);
            self
        }
        /// <p>Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't
        /// return any labels with a confidence level lower than this specified value.</p>
        /// <p>If you don't specify <code>MinConfidence</code>, the operation returns labels with
        /// confidence values greater than or equal to 50 percent.</p>
        pub fn set_min_confidence(mut self, input: std::option::Option<f32>) -> Self {
            self.min_confidence = input;
            self
        }
        /// <p>Sets up the configuration for human evaluation, including the FlowDefinition
        /// the image will be sent to.</p>
        pub fn human_loop_config(mut self, input: crate::model::HumanLoopConfig) -> Self {
            self.human_loop_config = Some(input);
            self
        }
        /// <p>Sets up the configuration for human evaluation, including the FlowDefinition
        /// the image will be sent to.</p>
        pub fn set_human_loop_config(
            mut self,
            input: std::option::Option<crate::model::HumanLoopConfig>,
        ) -> Self {
            self.human_loop_config = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectModerationLabelsInput`](crate::input::DetectModerationLabelsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetectModerationLabelsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetectModerationLabelsInput {
                image: self.image,
                min_confidence: self.min_confidence,
                human_loop_config: self.human_loop_config,
            })
        }
    }
}
#[doc(hidden)]
pub type DetectModerationLabelsInputOperationOutputAlias = crate::operation::DetectModerationLabels;
#[doc(hidden)]
pub type DetectModerationLabelsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DetectModerationLabelsInput {
    /// Consumes the builder and constructs an Operation<[`DetectModerationLabels`](crate::operation::DetectModerationLabels)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetectModerationLabels,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DetectModerationLabelsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DetectModerationLabelsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DetectModerationLabelsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DetectModerationLabels",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_detect_moderation_labels(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetectModerationLabels::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetectModerationLabels",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DetectModerationLabelsInput`](crate::input::DetectModerationLabelsInput)
    pub fn builder() -> crate::input::detect_moderation_labels_input::Builder {
        crate::input::detect_moderation_labels_input::Builder::default()
    }
}

/// See [`DetectProtectiveEquipmentInput`](crate::input::DetectProtectiveEquipmentInput)
pub mod detect_protective_equipment_input {
    /// A builder for [`DetectProtectiveEquipmentInput`](crate::input::DetectProtectiveEquipmentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image: std::option::Option<crate::model::Image>,
        pub(crate) summarization_attributes:
            std::option::Option<crate::model::ProtectiveEquipmentSummarizationAttributes>,
    }
    impl Builder {
        /// <p>The image in which you want to detect PPE on detected persons. The image can be passed as image bytes or you can
        /// reference an image stored in an Amazon S3 bucket. </p>
        pub fn image(mut self, input: crate::model::Image) -> Self {
            self.image = Some(input);
            self
        }
        /// <p>The image in which you want to detect PPE on detected persons. The image can be passed as image bytes or you can
        /// reference an image stored in an Amazon S3 bucket. </p>
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.image = input;
            self
        }
        /// <p>An array of PPE types that you want to summarize.</p>
        pub fn summarization_attributes(
            mut self,
            input: crate::model::ProtectiveEquipmentSummarizationAttributes,
        ) -> Self {
            self.summarization_attributes = Some(input);
            self
        }
        /// <p>An array of PPE types that you want to summarize.</p>
        pub fn set_summarization_attributes(
            mut self,
            input: std::option::Option<crate::model::ProtectiveEquipmentSummarizationAttributes>,
        ) -> Self {
            self.summarization_attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectProtectiveEquipmentInput`](crate::input::DetectProtectiveEquipmentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetectProtectiveEquipmentInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetectProtectiveEquipmentInput {
                image: self.image,
                summarization_attributes: self.summarization_attributes,
            })
        }
    }
}
#[doc(hidden)]
pub type DetectProtectiveEquipmentInputOperationOutputAlias =
    crate::operation::DetectProtectiveEquipment;
#[doc(hidden)]
pub type DetectProtectiveEquipmentInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DetectProtectiveEquipmentInput {
    /// Consumes the builder and constructs an Operation<[`DetectProtectiveEquipment`](crate::operation::DetectProtectiveEquipment)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetectProtectiveEquipment,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DetectProtectiveEquipmentInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DetectProtectiveEquipmentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DetectProtectiveEquipmentInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DetectProtectiveEquipment",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_detect_protective_equipment(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetectProtectiveEquipment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetectProtectiveEquipment",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DetectProtectiveEquipmentInput`](crate::input::DetectProtectiveEquipmentInput)
    pub fn builder() -> crate::input::detect_protective_equipment_input::Builder {
        crate::input::detect_protective_equipment_input::Builder::default()
    }
}

/// See [`DetectTextInput`](crate::input::DetectTextInput)
pub mod detect_text_input {
    /// A builder for [`DetectTextInput`](crate::input::DetectTextInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image: std::option::Option<crate::model::Image>,
        pub(crate) filters: std::option::Option<crate::model::DetectTextFilters>,
    }
    impl Builder {
        /// <p>The input image as base64-encoded bytes or an Amazon S3 object. If you use the AWS CLI
        /// to call Amazon Rekognition operations, you can't pass image bytes. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, input: crate::model::Image) -> Self {
            self.image = Some(input);
            self
        }
        /// <p>The input image as base64-encoded bytes or an Amazon S3 object. If you use the AWS CLI
        /// to call Amazon Rekognition operations, you can't pass image bytes. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.image = input;
            self
        }
        /// <p>Optional parameters that let you set the criteria that the text must meet to be included in your response.</p>
        pub fn filters(mut self, input: crate::model::DetectTextFilters) -> Self {
            self.filters = Some(input);
            self
        }
        /// <p>Optional parameters that let you set the criteria that the text must meet to be included in your response.</p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<crate::model::DetectTextFilters>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectTextInput`](crate::input::DetectTextInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetectTextInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetectTextInput {
                image: self.image,
                filters: self.filters,
            })
        }
    }
}
#[doc(hidden)]
pub type DetectTextInputOperationOutputAlias = crate::operation::DetectText;
#[doc(hidden)]
pub type DetectTextInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DetectTextInput {
    /// Consumes the builder and constructs an Operation<[`DetectText`](crate::operation::DetectText)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetectText,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DetectTextInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DetectTextInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DetectTextInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.DetectText",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_detect_text(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetectText::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetectText",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DetectTextInput`](crate::input::DetectTextInput)
    pub fn builder() -> crate::input::detect_text_input::Builder {
        crate::input::detect_text_input::Builder::default()
    }
}

/// See [`GetCelebrityInfoInput`](crate::input::GetCelebrityInfoInput)
pub mod get_celebrity_info_input {
    /// A builder for [`GetCelebrityInfoInput`](crate::input::GetCelebrityInfoInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID for the celebrity. You get the celebrity ID from a call to the <a>RecognizeCelebrities</a> operation,
        /// which recognizes celebrities in an image. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID for the celebrity. You get the celebrity ID from a call to the <a>RecognizeCelebrities</a> operation,
        /// which recognizes celebrities in an image. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCelebrityInfoInput`](crate::input::GetCelebrityInfoInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetCelebrityInfoInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetCelebrityInfoInput { id: self.id })
        }
    }
}
#[doc(hidden)]
pub type GetCelebrityInfoInputOperationOutputAlias = crate::operation::GetCelebrityInfo;
#[doc(hidden)]
pub type GetCelebrityInfoInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetCelebrityInfoInput {
    /// Consumes the builder and constructs an Operation<[`GetCelebrityInfo`](crate::operation::GetCelebrityInfo)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCelebrityInfo,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetCelebrityInfoInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetCelebrityInfoInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetCelebrityInfoInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.GetCelebrityInfo",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_celebrity_info(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCelebrityInfo::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCelebrityInfo",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetCelebrityInfoInput`](crate::input::GetCelebrityInfoInput)
    pub fn builder() -> crate::input::get_celebrity_info_input::Builder {
        crate::input::get_celebrity_info_input::Builder::default()
    }
}

/// See [`GetCelebrityRecognitionInput`](crate::input::GetCelebrityRecognitionInput)
pub mod get_celebrity_recognition_input {
    /// A builder for [`GetCelebrityRecognitionInput`](crate::input::GetCelebrityRecognitionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) sort_by: std::option::Option<crate::model::CelebrityRecognitionSortBy>,
    }
    impl Builder {
        /// <p>Job identifier for the required celebrity recognition analysis. You can get the job identifer from
        /// a call to <code>StartCelebrityRecognition</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>Job identifier for the required celebrity recognition analysis. You can get the job identifer from
        /// a call to <code>StartCelebrityRecognition</code>.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>If the previous response was incomplete (because there is more recognized celebrities to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of celebrities. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more recognized celebrities to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of celebrities. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Sort to use for celebrities returned in <code>Celebrities</code> field. Specify <code>ID</code> to sort by the celebrity identifier,
        /// specify <code>TIMESTAMP</code> to sort by the time the celebrity was recognized.</p>
        pub fn sort_by(mut self, input: crate::model::CelebrityRecognitionSortBy) -> Self {
            self.sort_by = Some(input);
            self
        }
        /// <p>Sort to use for celebrities returned in <code>Celebrities</code> field. Specify <code>ID</code> to sort by the celebrity identifier,
        /// specify <code>TIMESTAMP</code> to sort by the time the celebrity was recognized.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::CelebrityRecognitionSortBy>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCelebrityRecognitionInput`](crate::input::GetCelebrityRecognitionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetCelebrityRecognitionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetCelebrityRecognitionInput {
                job_id: self.job_id,
                max_results: self.max_results,
                next_token: self.next_token,
                sort_by: self.sort_by,
            })
        }
    }
}
#[doc(hidden)]
pub type GetCelebrityRecognitionInputOperationOutputAlias =
    crate::operation::GetCelebrityRecognition;
#[doc(hidden)]
pub type GetCelebrityRecognitionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetCelebrityRecognitionInput {
    /// Consumes the builder and constructs an Operation<[`GetCelebrityRecognition`](crate::operation::GetCelebrityRecognition)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCelebrityRecognition,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetCelebrityRecognitionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetCelebrityRecognitionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetCelebrityRecognitionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.GetCelebrityRecognition",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_celebrity_recognition(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCelebrityRecognition::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCelebrityRecognition",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetCelebrityRecognitionInput`](crate::input::GetCelebrityRecognitionInput)
    pub fn builder() -> crate::input::get_celebrity_recognition_input::Builder {
        crate::input::get_celebrity_recognition_input::Builder::default()
    }
}

/// See [`GetContentModerationInput`](crate::input::GetContentModerationInput)
pub mod get_content_moderation_input {
    /// A builder for [`GetContentModerationInput`](crate::input::GetContentModerationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) sort_by: std::option::Option<crate::model::ContentModerationSortBy>,
    }
    impl Builder {
        /// <p>The identifier for the inappropriate, unwanted, or offensive content moderation job. Use <code>JobId</code> to identify the job in
        /// a subsequent call to <code>GetContentModeration</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier for the inappropriate, unwanted, or offensive content moderation job. Use <code>JobId</code> to identify the job in
        /// a subsequent call to <code>GetContentModeration</code>.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Rekognition
        /// returns a pagination token in the response. You can use this pagination token
        /// to retrieve the next set of content moderation labels.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Rekognition
        /// returns a pagination token in the response. You can use this pagination token
        /// to retrieve the next set of content moderation labels.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Sort to use for elements in the <code>ModerationLabelDetections</code> array.
        /// Use <code>TIMESTAMP</code> to sort array elements by the time labels are detected.
        /// Use <code>NAME</code> to alphabetically group elements for a label together.
        /// Within each label group, the array element are sorted by detection confidence.
        /// The default sort is by <code>TIMESTAMP</code>.</p>
        pub fn sort_by(mut self, input: crate::model::ContentModerationSortBy) -> Self {
            self.sort_by = Some(input);
            self
        }
        /// <p>Sort to use for elements in the <code>ModerationLabelDetections</code> array.
        /// Use <code>TIMESTAMP</code> to sort array elements by the time labels are detected.
        /// Use <code>NAME</code> to alphabetically group elements for a label together.
        /// Within each label group, the array element are sorted by detection confidence.
        /// The default sort is by <code>TIMESTAMP</code>.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::ContentModerationSortBy>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// Consumes the builder and constructs a [`GetContentModerationInput`](crate::input::GetContentModerationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetContentModerationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetContentModerationInput {
                job_id: self.job_id,
                max_results: self.max_results,
                next_token: self.next_token,
                sort_by: self.sort_by,
            })
        }
    }
}
#[doc(hidden)]
pub type GetContentModerationInputOperationOutputAlias = crate::operation::GetContentModeration;
#[doc(hidden)]
pub type GetContentModerationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetContentModerationInput {
    /// Consumes the builder and constructs an Operation<[`GetContentModeration`](crate::operation::GetContentModeration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetContentModeration,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetContentModerationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetContentModerationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetContentModerationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.GetContentModeration",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_content_moderation(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetContentModeration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetContentModeration",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetContentModerationInput`](crate::input::GetContentModerationInput)
    pub fn builder() -> crate::input::get_content_moderation_input::Builder {
        crate::input::get_content_moderation_input::Builder::default()
    }
}

/// See [`GetFaceDetectionInput`](crate::input::GetFaceDetectionInput)
pub mod get_face_detection_input {
    /// A builder for [`GetFaceDetectionInput`](crate::input::GetFaceDetectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Unique identifier for the face detection job. The <code>JobId</code> is returned from <code>StartFaceDetection</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>Unique identifier for the face detection job. The <code>JobId</code> is returned from <code>StartFaceDetection</code>.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>If the previous response was incomplete (because there are more faces to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of faces.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there are more faces to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of faces.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetFaceDetectionInput`](crate::input::GetFaceDetectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetFaceDetectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetFaceDetectionInput {
                job_id: self.job_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetFaceDetectionInputOperationOutputAlias = crate::operation::GetFaceDetection;
#[doc(hidden)]
pub type GetFaceDetectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetFaceDetectionInput {
    /// Consumes the builder and constructs an Operation<[`GetFaceDetection`](crate::operation::GetFaceDetection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetFaceDetection,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetFaceDetectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetFaceDetectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetFaceDetectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.GetFaceDetection",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_face_detection(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetFaceDetection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetFaceDetection",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetFaceDetectionInput`](crate::input::GetFaceDetectionInput)
    pub fn builder() -> crate::input::get_face_detection_input::Builder {
        crate::input::get_face_detection_input::Builder::default()
    }
}

/// See [`GetFaceSearchInput`](crate::input::GetFaceSearchInput)
pub mod get_face_search_input {
    /// A builder for [`GetFaceSearchInput`](crate::input::GetFaceSearchInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) sort_by: std::option::Option<crate::model::FaceSearchSortBy>,
    }
    impl Builder {
        /// <p>The job identifer for the search request. You get the job identifier from an initial call to <code>StartFaceSearch</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The job identifer for the search request. You get the job identifier from an initial call to <code>StartFaceSearch</code>.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>If the previous response was incomplete (because there is more search results to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of search results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more search results to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of search results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Sort to use for grouping faces in the response. Use <code>TIMESTAMP</code> to group faces by the time
        /// that they are recognized. Use <code>INDEX</code> to sort by recognized faces. </p>
        pub fn sort_by(mut self, input: crate::model::FaceSearchSortBy) -> Self {
            self.sort_by = Some(input);
            self
        }
        /// <p>Sort to use for grouping faces in the response. Use <code>TIMESTAMP</code> to group faces by the time
        /// that they are recognized. Use <code>INDEX</code> to sort by recognized faces. </p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::FaceSearchSortBy>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// Consumes the builder and constructs a [`GetFaceSearchInput`](crate::input::GetFaceSearchInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetFaceSearchInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetFaceSearchInput {
                job_id: self.job_id,
                max_results: self.max_results,
                next_token: self.next_token,
                sort_by: self.sort_by,
            })
        }
    }
}
#[doc(hidden)]
pub type GetFaceSearchInputOperationOutputAlias = crate::operation::GetFaceSearch;
#[doc(hidden)]
pub type GetFaceSearchInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetFaceSearchInput {
    /// Consumes the builder and constructs an Operation<[`GetFaceSearch`](crate::operation::GetFaceSearch)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetFaceSearch,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetFaceSearchInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetFaceSearchInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetFaceSearchInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.GetFaceSearch",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_face_search(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetFaceSearch::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetFaceSearch",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetFaceSearchInput`](crate::input::GetFaceSearchInput)
    pub fn builder() -> crate::input::get_face_search_input::Builder {
        crate::input::get_face_search_input::Builder::default()
    }
}

/// See [`GetLabelDetectionInput`](crate::input::GetLabelDetectionInput)
pub mod get_label_detection_input {
    /// A builder for [`GetLabelDetectionInput`](crate::input::GetLabelDetectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) sort_by: std::option::Option<crate::model::LabelDetectionSortBy>,
    }
    impl Builder {
        /// <p>Job identifier for the label detection operation for which you want results returned. You get the job identifer from
        /// an initial call to <code>StartlabelDetection</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>Job identifier for the label detection operation for which you want results returned. You get the job identifer from
        /// an initial call to <code>StartlabelDetection</code>.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>If the previous response was incomplete (because there are more labels to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of labels. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there are more labels to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of labels. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Sort to use for elements in the <code>Labels</code> array.
        /// Use <code>TIMESTAMP</code> to sort array elements by the time labels are detected.
        /// Use <code>NAME</code> to alphabetically group elements for a label together.
        /// Within each label group, the array element are sorted by detection confidence.
        /// The default sort is by <code>TIMESTAMP</code>.</p>
        pub fn sort_by(mut self, input: crate::model::LabelDetectionSortBy) -> Self {
            self.sort_by = Some(input);
            self
        }
        /// <p>Sort to use for elements in the <code>Labels</code> array.
        /// Use <code>TIMESTAMP</code> to sort array elements by the time labels are detected.
        /// Use <code>NAME</code> to alphabetically group elements for a label together.
        /// Within each label group, the array element are sorted by detection confidence.
        /// The default sort is by <code>TIMESTAMP</code>.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::LabelDetectionSortBy>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLabelDetectionInput`](crate::input::GetLabelDetectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetLabelDetectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetLabelDetectionInput {
                job_id: self.job_id,
                max_results: self.max_results,
                next_token: self.next_token,
                sort_by: self.sort_by,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLabelDetectionInputOperationOutputAlias = crate::operation::GetLabelDetection;
#[doc(hidden)]
pub type GetLabelDetectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetLabelDetectionInput {
    /// Consumes the builder and constructs an Operation<[`GetLabelDetection`](crate::operation::GetLabelDetection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLabelDetection,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetLabelDetectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetLabelDetectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetLabelDetectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.GetLabelDetection",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_label_detection(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetLabelDetection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetLabelDetection",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetLabelDetectionInput`](crate::input::GetLabelDetectionInput)
    pub fn builder() -> crate::input::get_label_detection_input::Builder {
        crate::input::get_label_detection_input::Builder::default()
    }
}

/// See [`GetPersonTrackingInput`](crate::input::GetPersonTrackingInput)
pub mod get_person_tracking_input {
    /// A builder for [`GetPersonTrackingInput`](crate::input::GetPersonTrackingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) sort_by: std::option::Option<crate::model::PersonTrackingSortBy>,
    }
    impl Builder {
        /// <p>The identifier for a job that tracks persons in a video. You get the <code>JobId</code> from a call to <code>StartPersonTracking</code>.
        /// </p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier for a job that tracks persons in a video. You get the <code>JobId</code> from a call to <code>StartPersonTracking</code>.
        /// </p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>If the previous response was incomplete (because there are more persons to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of persons. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there are more persons to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of persons. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Sort to use for elements in the <code>Persons</code> array. Use <code>TIMESTAMP</code> to sort array elements
        /// by the time persons are detected. Use <code>INDEX</code> to sort by the tracked persons.
        /// If you sort by <code>INDEX</code>, the array elements for each person are sorted by detection confidence.
        /// The default sort is by <code>TIMESTAMP</code>.</p>
        pub fn sort_by(mut self, input: crate::model::PersonTrackingSortBy) -> Self {
            self.sort_by = Some(input);
            self
        }
        /// <p>Sort to use for elements in the <code>Persons</code> array. Use <code>TIMESTAMP</code> to sort array elements
        /// by the time persons are detected. Use <code>INDEX</code> to sort by the tracked persons.
        /// If you sort by <code>INDEX</code>, the array elements for each person are sorted by detection confidence.
        /// The default sort is by <code>TIMESTAMP</code>.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::PersonTrackingSortBy>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPersonTrackingInput`](crate::input::GetPersonTrackingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetPersonTrackingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetPersonTrackingInput {
                job_id: self.job_id,
                max_results: self.max_results,
                next_token: self.next_token,
                sort_by: self.sort_by,
            })
        }
    }
}
#[doc(hidden)]
pub type GetPersonTrackingInputOperationOutputAlias = crate::operation::GetPersonTracking;
#[doc(hidden)]
pub type GetPersonTrackingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetPersonTrackingInput {
    /// Consumes the builder and constructs an Operation<[`GetPersonTracking`](crate::operation::GetPersonTracking)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetPersonTracking,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetPersonTrackingInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetPersonTrackingInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetPersonTrackingInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.GetPersonTracking",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_person_tracking(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetPersonTracking::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetPersonTracking",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetPersonTrackingInput`](crate::input::GetPersonTrackingInput)
    pub fn builder() -> crate::input::get_person_tracking_input::Builder {
        crate::input::get_person_tracking_input::Builder::default()
    }
}

/// See [`GetSegmentDetectionInput`](crate::input::GetSegmentDetectionInput)
pub mod get_segment_detection_input {
    /// A builder for [`GetSegmentDetectionInput`](crate::input::GetSegmentDetectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Job identifier for the text detection operation for which you want results returned.
        /// You get the job identifer from an initial call to <code>StartSegmentDetection</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>Job identifier for the text detection operation for which you want results returned.
        /// You get the job identifer from an initial call to <code>StartSegmentDetection</code>.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent
        /// request to retrieve the next set of text.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent
        /// request to retrieve the next set of text.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSegmentDetectionInput`](crate::input::GetSegmentDetectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetSegmentDetectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetSegmentDetectionInput {
                job_id: self.job_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetSegmentDetectionInputOperationOutputAlias = crate::operation::GetSegmentDetection;
#[doc(hidden)]
pub type GetSegmentDetectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetSegmentDetectionInput {
    /// Consumes the builder and constructs an Operation<[`GetSegmentDetection`](crate::operation::GetSegmentDetection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSegmentDetection,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetSegmentDetectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetSegmentDetectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetSegmentDetectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.GetSegmentDetection",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_segment_detection(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSegmentDetection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSegmentDetection",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetSegmentDetectionInput`](crate::input::GetSegmentDetectionInput)
    pub fn builder() -> crate::input::get_segment_detection_input::Builder {
        crate::input::get_segment_detection_input::Builder::default()
    }
}

/// See [`GetTextDetectionInput`](crate::input::GetTextDetectionInput)
pub mod get_text_detection_input {
    /// A builder for [`GetTextDetectionInput`](crate::input::GetTextDetectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Job identifier for the text detection operation for which you want results returned.
        /// You get the job identifer from an initial call to <code>StartTextDetection</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>Job identifier for the text detection operation for which you want results returned.
        /// You get the job identifer from an initial call to <code>StartTextDetection</code>.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>If the previous response was incomplete (because there are more labels to retrieve), Amazon Rekognition Video returns
        /// a pagination token in the response. You can use this pagination token to retrieve the next set of text.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there are more labels to retrieve), Amazon Rekognition Video returns
        /// a pagination token in the response. You can use this pagination token to retrieve the next set of text.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTextDetectionInput`](crate::input::GetTextDetectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetTextDetectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetTextDetectionInput {
                job_id: self.job_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetTextDetectionInputOperationOutputAlias = crate::operation::GetTextDetection;
#[doc(hidden)]
pub type GetTextDetectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetTextDetectionInput {
    /// Consumes the builder and constructs an Operation<[`GetTextDetection`](crate::operation::GetTextDetection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTextDetection,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetTextDetectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetTextDetectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetTextDetectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.GetTextDetection",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_text_detection(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetTextDetection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetTextDetection",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetTextDetectionInput`](crate::input::GetTextDetectionInput)
    pub fn builder() -> crate::input::get_text_detection_input::Builder {
        crate::input::get_text_detection_input::Builder::default()
    }
}

/// See [`IndexFacesInput`](crate::input::IndexFacesInput)
pub mod index_faces_input {
    /// A builder for [`IndexFacesInput`](crate::input::IndexFacesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) collection_id: std::option::Option<std::string::String>,
        pub(crate) image: std::option::Option<crate::model::Image>,
        pub(crate) external_image_id: std::option::Option<std::string::String>,
        pub(crate) detection_attributes:
            std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        pub(crate) max_faces: std::option::Option<i32>,
        pub(crate) quality_filter: std::option::Option<crate::model::QualityFilter>,
    }
    impl Builder {
        /// <p>The ID of an existing collection to which you want to add the faces that are detected
        /// in the input images.</p>
        pub fn collection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collection_id = Some(input.into());
            self
        }
        /// <p>The ID of an existing collection to which you want to add the faces that are detected
        /// in the input images.</p>
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collection_id = input;
            self
        }
        /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
        /// Amazon Rekognition operations, passing base64-encoded image bytes isn't supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, input: crate::model::Image) -> Self {
            self.image = Some(input);
            self
        }
        /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
        /// Amazon Rekognition operations, passing base64-encoded image bytes isn't supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.image = input;
            self
        }
        /// <p>The ID you want to assign to all the faces detected in the image.</p>
        pub fn external_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_image_id = Some(input.into());
            self
        }
        /// <p>The ID you want to assign to all the faces detected in the image.</p>
        pub fn set_external_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.external_image_id = input;
            self
        }
        /// Appends an item to `detection_attributes`.
        ///
        /// To override the contents of this collection use [`set_detection_attributes`](Self::set_detection_attributes).
        ///
        /// <p>An array of facial attributes that you want to be returned. This can be the default
        /// list of attributes or all attributes. If you don't specify a value for <code>Attributes</code>
        /// or if you specify <code>["DEFAULT"]</code>, the API returns the following subset of facial
        /// attributes: <code>BoundingBox</code>, <code>Confidence</code>, <code>Pose</code>,
        /// <code>Quality</code>, and <code>Landmarks</code>. If you provide <code>["ALL"]</code>, all
        /// facial attributes are returned, but the operation takes longer to complete.</p>
        /// <p>If you provide both, <code>["ALL", "DEFAULT"]</code>, the service uses a logical AND
        /// operator to determine which attributes to return (in this case, all attributes). </p>
        pub fn detection_attributes(mut self, input: impl Into<crate::model::Attribute>) -> Self {
            let mut v = self.detection_attributes.unwrap_or_default();
            v.push(input.into());
            self.detection_attributes = Some(v);
            self
        }
        /// <p>An array of facial attributes that you want to be returned. This can be the default
        /// list of attributes or all attributes. If you don't specify a value for <code>Attributes</code>
        /// or if you specify <code>["DEFAULT"]</code>, the API returns the following subset of facial
        /// attributes: <code>BoundingBox</code>, <code>Confidence</code>, <code>Pose</code>,
        /// <code>Quality</code>, and <code>Landmarks</code>. If you provide <code>["ALL"]</code>, all
        /// facial attributes are returned, but the operation takes longer to complete.</p>
        /// <p>If you provide both, <code>["ALL", "DEFAULT"]</code>, the service uses a logical AND
        /// operator to determine which attributes to return (in this case, all attributes). </p>
        pub fn set_detection_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.detection_attributes = input;
            self
        }
        /// <p>The maximum number of faces to index. The value of <code>MaxFaces</code> must be greater
        /// than or equal to 1. <code>IndexFaces</code> returns no more than 100 detected faces in an
        /// image, even if you specify a larger value for <code>MaxFaces</code>.</p>
        /// <p>If <code>IndexFaces</code> detects more faces than the value of <code>MaxFaces</code>, the
        /// faces with the lowest quality are filtered out first. If there are still more faces than the
        /// value of <code>MaxFaces</code>, the faces with the smallest bounding boxes are filtered out
        /// (up to the number that's needed to satisfy the value of <code>MaxFaces</code>). Information
        /// about the unindexed faces is available in the <code>UnindexedFaces</code> array. </p>
        /// <p>The faces that are returned by <code>IndexFaces</code> are sorted by the largest face
        /// bounding box size to the smallest size, in descending order.</p>
        /// <p>
        /// <code>MaxFaces</code> can be used with a collection associated with any version of
        /// the face model.</p>
        pub fn max_faces(mut self, input: i32) -> Self {
            self.max_faces = Some(input);
            self
        }
        /// <p>The maximum number of faces to index. The value of <code>MaxFaces</code> must be greater
        /// than or equal to 1. <code>IndexFaces</code> returns no more than 100 detected faces in an
        /// image, even if you specify a larger value for <code>MaxFaces</code>.</p>
        /// <p>If <code>IndexFaces</code> detects more faces than the value of <code>MaxFaces</code>, the
        /// faces with the lowest quality are filtered out first. If there are still more faces than the
        /// value of <code>MaxFaces</code>, the faces with the smallest bounding boxes are filtered out
        /// (up to the number that's needed to satisfy the value of <code>MaxFaces</code>). Information
        /// about the unindexed faces is available in the <code>UnindexedFaces</code> array. </p>
        /// <p>The faces that are returned by <code>IndexFaces</code> are sorted by the largest face
        /// bounding box size to the smallest size, in descending order.</p>
        /// <p>
        /// <code>MaxFaces</code> can be used with a collection associated with any version of
        /// the face model.</p>
        pub fn set_max_faces(mut self, input: std::option::Option<i32>) -> Self {
            self.max_faces = input;
            self
        }
        /// <p>A filter that specifies a quality bar for how much filtering is done to identify faces.
        /// Filtered faces aren't indexed. If you specify <code>AUTO</code>, Amazon Rekognition chooses the quality bar.
        /// If you specify <code>LOW</code>,
        /// <code>MEDIUM</code>, or <code>HIGH</code>, filtering removes all faces that
        /// don’t meet the chosen quality bar.  The default value is <code>AUTO</code>.
        ///
        /// The quality bar is based on a variety of common use cases. Low-quality
        /// detections can occur for a number of reasons. Some examples are an object that's misidentified
        /// as a face, a face that's too blurry, or a face with a
        /// pose that's too extreme to use. If you specify <code>NONE</code>, no
        /// filtering is performed.
        /// </p>
        /// <p>To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.</p>
        pub fn quality_filter(mut self, input: crate::model::QualityFilter) -> Self {
            self.quality_filter = Some(input);
            self
        }
        /// <p>A filter that specifies a quality bar for how much filtering is done to identify faces.
        /// Filtered faces aren't indexed. If you specify <code>AUTO</code>, Amazon Rekognition chooses the quality bar.
        /// If you specify <code>LOW</code>,
        /// <code>MEDIUM</code>, or <code>HIGH</code>, filtering removes all faces that
        /// don’t meet the chosen quality bar.  The default value is <code>AUTO</code>.
        ///
        /// The quality bar is based on a variety of common use cases. Low-quality
        /// detections can occur for a number of reasons. Some examples are an object that's misidentified
        /// as a face, a face that's too blurry, or a face with a
        /// pose that's too extreme to use. If you specify <code>NONE</code>, no
        /// filtering is performed.
        /// </p>
        /// <p>To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.</p>
        pub fn set_quality_filter(
            mut self,
            input: std::option::Option<crate::model::QualityFilter>,
        ) -> Self {
            self.quality_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`IndexFacesInput`](crate::input::IndexFacesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::IndexFacesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::IndexFacesInput {
                collection_id: self.collection_id,
                image: self.image,
                external_image_id: self.external_image_id,
                detection_attributes: self.detection_attributes,
                max_faces: self.max_faces,
                quality_filter: self.quality_filter,
            })
        }
    }
}
#[doc(hidden)]
pub type IndexFacesInputOperationOutputAlias = crate::operation::IndexFaces;
#[doc(hidden)]
pub type IndexFacesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl IndexFacesInput {
    /// Consumes the builder and constructs an Operation<[`IndexFaces`](crate::operation::IndexFaces)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::IndexFaces,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::IndexFacesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::IndexFacesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::IndexFacesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.IndexFaces",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_index_faces(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::IndexFaces::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "IndexFaces",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`IndexFacesInput`](crate::input::IndexFacesInput)
    pub fn builder() -> crate::input::index_faces_input::Builder {
        crate::input::index_faces_input::Builder::default()
    }
}

/// See [`ListCollectionsInput`](crate::input::ListCollectionsInput)
pub mod list_collections_input {
    /// A builder for [`ListCollectionsInput`](crate::input::ListCollectionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Pagination token from the previous response.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token from the previous response.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Maximum number of collection IDs to return. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of collection IDs to return. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCollectionsInput`](crate::input::ListCollectionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListCollectionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListCollectionsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListCollectionsInputOperationOutputAlias = crate::operation::ListCollections;
#[doc(hidden)]
pub type ListCollectionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListCollectionsInput {
    /// Consumes the builder and constructs an Operation<[`ListCollections`](crate::operation::ListCollections)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCollections,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListCollectionsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListCollectionsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListCollectionsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.ListCollections",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_collections(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCollections::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCollections",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListCollectionsInput`](crate::input::ListCollectionsInput)
    pub fn builder() -> crate::input::list_collections_input::Builder {
        crate::input::list_collections_input::Builder::default()
    }
}

/// See [`ListFacesInput`](crate::input::ListFacesInput)
pub mod list_faces_input {
    /// A builder for [`ListFacesInput`](crate::input::ListFacesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) collection_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>ID of the collection from which to list the faces.</p>
        pub fn collection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collection_id = Some(input.into());
            self
        }
        /// <p>ID of the collection from which to list the faces.</p>
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collection_id = input;
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve),
        /// Amazon Rekognition returns a pagination token in the response. You can use this pagination token to
        /// retrieve the next set of faces.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve),
        /// Amazon Rekognition returns a pagination token in the response. You can use this pagination token to
        /// retrieve the next set of faces.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Maximum number of faces to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of faces to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListFacesInput`](crate::input::ListFacesInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListFacesInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListFacesInput {
                collection_id: self.collection_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListFacesInputOperationOutputAlias = crate::operation::ListFaces;
#[doc(hidden)]
pub type ListFacesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListFacesInput {
    /// Consumes the builder and constructs an Operation<[`ListFaces`](crate::operation::ListFaces)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListFaces,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListFacesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListFacesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListFacesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.ListFaces",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_list_faces(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::ListFaces::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "ListFaces",
                    "rekognition",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListFacesInput`](crate::input::ListFacesInput)
    pub fn builder() -> crate::input::list_faces_input::Builder {
        crate::input::list_faces_input::Builder::default()
    }
}

/// See [`ListStreamProcessorsInput`](crate::input::ListStreamProcessorsInput)
pub mod list_stream_processors_input {
    /// A builder for [`ListStreamProcessorsInput`](crate::input::ListStreamProcessorsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>If the previous response was incomplete (because there are more stream processors to retrieve), Amazon Rekognition Video
        /// returns a pagination token in the response. You can use this pagination token to retrieve the next set of stream processors. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there are more stream processors to retrieve), Amazon Rekognition Video
        /// returns a pagination token in the response. You can use this pagination token to retrieve the next set of stream processors. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Maximum number of stream processors you want Amazon Rekognition Video to return in the response. The default is 1000. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of stream processors you want Amazon Rekognition Video to return in the response. The default is 1000. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListStreamProcessorsInput`](crate::input::ListStreamProcessorsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListStreamProcessorsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListStreamProcessorsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListStreamProcessorsInputOperationOutputAlias = crate::operation::ListStreamProcessors;
#[doc(hidden)]
pub type ListStreamProcessorsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListStreamProcessorsInput {
    /// Consumes the builder and constructs an Operation<[`ListStreamProcessors`](crate::operation::ListStreamProcessors)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListStreamProcessors,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListStreamProcessorsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListStreamProcessorsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListStreamProcessorsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.ListStreamProcessors",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_stream_processors(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListStreamProcessors::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListStreamProcessors",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListStreamProcessorsInput`](crate::input::ListStreamProcessorsInput)
    pub fn builder() -> crate::input::list_stream_processors_input::Builder {
        crate::input::list_stream_processors_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>
        /// Amazon Resource Name (ARN) of the model, collection, or stream processor that contains the tags that you want a list of.
        /// </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>
        /// Amazon Resource Name (ARN) of the model, collection, or stream processor that contains the tags that you want a list of.
        /// </p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListTagsForResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListTagsForResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListTagsForResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.ListTagsForResource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_tags_for_resource(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`RecognizeCelebritiesInput`](crate::input::RecognizeCelebritiesInput)
pub mod recognize_celebrities_input {
    /// A builder for [`RecognizeCelebritiesInput`](crate::input::RecognizeCelebritiesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image: std::option::Option<crate::model::Image>,
    }
    impl Builder {
        /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
        /// Amazon Rekognition operations, passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to
        /// base64-encode image bytes passed using the <code>Bytes</code> field. For more information, see
        /// Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, input: crate::model::Image) -> Self {
            self.image = Some(input);
            self
        }
        /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
        /// Amazon Rekognition operations, passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to
        /// base64-encode image bytes passed using the <code>Bytes</code> field. For more information, see
        /// Images in the Amazon Rekognition developer guide.</p>
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.image = input;
            self
        }
        /// Consumes the builder and constructs a [`RecognizeCelebritiesInput`](crate::input::RecognizeCelebritiesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RecognizeCelebritiesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RecognizeCelebritiesInput { image: self.image })
        }
    }
}
#[doc(hidden)]
pub type RecognizeCelebritiesInputOperationOutputAlias = crate::operation::RecognizeCelebrities;
#[doc(hidden)]
pub type RecognizeCelebritiesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl RecognizeCelebritiesInput {
    /// Consumes the builder and constructs an Operation<[`RecognizeCelebrities`](crate::operation::RecognizeCelebrities)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RecognizeCelebrities,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::RecognizeCelebritiesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::RecognizeCelebritiesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::RecognizeCelebritiesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.RecognizeCelebrities",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_recognize_celebrities(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RecognizeCelebrities::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RecognizeCelebrities",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RecognizeCelebritiesInput`](crate::input::RecognizeCelebritiesInput)
    pub fn builder() -> crate::input::recognize_celebrities_input::Builder {
        crate::input::recognize_celebrities_input::Builder::default()
    }
}

/// See [`SearchFacesInput`](crate::input::SearchFacesInput)
pub mod search_faces_input {
    /// A builder for [`SearchFacesInput`](crate::input::SearchFacesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) collection_id: std::option::Option<std::string::String>,
        pub(crate) face_id: std::option::Option<std::string::String>,
        pub(crate) max_faces: std::option::Option<i32>,
        pub(crate) face_match_threshold: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>ID of the collection the face belongs to.</p>
        pub fn collection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collection_id = Some(input.into());
            self
        }
        /// <p>ID of the collection the face belongs to.</p>
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collection_id = input;
            self
        }
        /// <p>ID of a face to find matches for in the collection.</p>
        pub fn face_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.face_id = Some(input.into());
            self
        }
        /// <p>ID of a face to find matches for in the collection.</p>
        pub fn set_face_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.face_id = input;
            self
        }
        /// <p>Maximum number of faces to return. The operation returns the maximum number of faces
        /// with the highest confidence in the match.</p>
        pub fn max_faces(mut self, input: i32) -> Self {
            self.max_faces = Some(input);
            self
        }
        /// <p>Maximum number of faces to return. The operation returns the maximum number of faces
        /// with the highest confidence in the match.</p>
        pub fn set_max_faces(mut self, input: std::option::Option<i32>) -> Self {
            self.max_faces = input;
            self
        }
        /// <p>Optional value specifying the minimum confidence in the face match to return. For
        /// example, don't return any matches where confidence in matches is less than 70%.
        /// The default value is 80%.
        /// </p>
        pub fn face_match_threshold(mut self, input: f32) -> Self {
            self.face_match_threshold = Some(input);
            self
        }
        /// <p>Optional value specifying the minimum confidence in the face match to return. For
        /// example, don't return any matches where confidence in matches is less than 70%.
        /// The default value is 80%.
        /// </p>
        pub fn set_face_match_threshold(mut self, input: std::option::Option<f32>) -> Self {
            self.face_match_threshold = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchFacesInput`](crate::input::SearchFacesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SearchFacesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SearchFacesInput {
                collection_id: self.collection_id,
                face_id: self.face_id,
                max_faces: self.max_faces,
                face_match_threshold: self.face_match_threshold,
            })
        }
    }
}
#[doc(hidden)]
pub type SearchFacesInputOperationOutputAlias = crate::operation::SearchFaces;
#[doc(hidden)]
pub type SearchFacesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl SearchFacesInput {
    /// Consumes the builder and constructs an Operation<[`SearchFaces`](crate::operation::SearchFaces)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SearchFaces,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::SearchFacesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::SearchFacesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::SearchFacesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.SearchFaces",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_search_faces(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SearchFaces::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SearchFaces",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`SearchFacesInput`](crate::input::SearchFacesInput)
    pub fn builder() -> crate::input::search_faces_input::Builder {
        crate::input::search_faces_input::Builder::default()
    }
}

/// See [`SearchFacesByImageInput`](crate::input::SearchFacesByImageInput)
pub mod search_faces_by_image_input {
    /// A builder for [`SearchFacesByImageInput`](crate::input::SearchFacesByImageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) collection_id: std::option::Option<std::string::String>,
        pub(crate) image: std::option::Option<crate::model::Image>,
        pub(crate) max_faces: std::option::Option<i32>,
        pub(crate) face_match_threshold: std::option::Option<f32>,
        pub(crate) quality_filter: std::option::Option<crate::model::QualityFilter>,
    }
    impl Builder {
        /// <p>ID of the collection to search.</p>
        pub fn collection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collection_id = Some(input.into());
            self
        }
        /// <p>ID of the collection to search.</p>
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collection_id = input;
            self
        }
        /// <p>The input image as base64-encoded bytes or an S3 object.
        /// If you use the AWS CLI to call Amazon Rekognition operations,
        /// passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, input: crate::model::Image) -> Self {
            self.image = Some(input);
            self
        }
        /// <p>The input image as base64-encoded bytes or an S3 object.
        /// If you use the AWS CLI to call Amazon Rekognition operations,
        /// passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.image = input;
            self
        }
        /// <p>Maximum number of faces to return. The operation returns the maximum number of faces
        /// with the highest confidence in the match.</p>
        pub fn max_faces(mut self, input: i32) -> Self {
            self.max_faces = Some(input);
            self
        }
        /// <p>Maximum number of faces to return. The operation returns the maximum number of faces
        /// with the highest confidence in the match.</p>
        pub fn set_max_faces(mut self, input: std::option::Option<i32>) -> Self {
            self.max_faces = input;
            self
        }
        /// <p>(Optional) Specifies the minimum confidence in the face match to return. For example,
        /// don't return any matches where confidence in matches is less than 70%.
        /// The default value is 80%.</p>
        pub fn face_match_threshold(mut self, input: f32) -> Self {
            self.face_match_threshold = Some(input);
            self
        }
        /// <p>(Optional) Specifies the minimum confidence in the face match to return. For example,
        /// don't return any matches where confidence in matches is less than 70%.
        /// The default value is 80%.</p>
        pub fn set_face_match_threshold(mut self, input: std::option::Option<f32>) -> Self {
            self.face_match_threshold = input;
            self
        }
        /// <p>A filter that specifies a quality bar for how much filtering is done to identify faces.
        /// Filtered faces aren't searched for in the collection. If you specify <code>AUTO</code>, Amazon Rekognition
        /// chooses the quality bar.  If you specify <code>LOW</code>,
        /// <code>MEDIUM</code>, or <code>HIGH</code>, filtering removes all faces that
        /// don’t meet the chosen quality bar.  
        ///
        /// The quality bar is based on a variety of common use cases. Low-quality
        /// detections can occur for a number of reasons. Some examples are an object that's misidentified
        /// as a face, a face that's too blurry, or a face with a
        /// pose that's too extreme to use. If you specify <code>NONE</code>, no
        /// filtering is performed.  The default value is <code>NONE</code>.
        /// </p>
        /// <p>To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.</p>
        pub fn quality_filter(mut self, input: crate::model::QualityFilter) -> Self {
            self.quality_filter = Some(input);
            self
        }
        /// <p>A filter that specifies a quality bar for how much filtering is done to identify faces.
        /// Filtered faces aren't searched for in the collection. If you specify <code>AUTO</code>, Amazon Rekognition
        /// chooses the quality bar.  If you specify <code>LOW</code>,
        /// <code>MEDIUM</code>, or <code>HIGH</code>, filtering removes all faces that
        /// don’t meet the chosen quality bar.  
        ///
        /// The quality bar is based on a variety of common use cases. Low-quality
        /// detections can occur for a number of reasons. Some examples are an object that's misidentified
        /// as a face, a face that's too blurry, or a face with a
        /// pose that's too extreme to use. If you specify <code>NONE</code>, no
        /// filtering is performed.  The default value is <code>NONE</code>.
        /// </p>
        /// <p>To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.</p>
        pub fn set_quality_filter(
            mut self,
            input: std::option::Option<crate::model::QualityFilter>,
        ) -> Self {
            self.quality_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchFacesByImageInput`](crate::input::SearchFacesByImageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SearchFacesByImageInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SearchFacesByImageInput {
                collection_id: self.collection_id,
                image: self.image,
                max_faces: self.max_faces,
                face_match_threshold: self.face_match_threshold,
                quality_filter: self.quality_filter,
            })
        }
    }
}
#[doc(hidden)]
pub type SearchFacesByImageInputOperationOutputAlias = crate::operation::SearchFacesByImage;
#[doc(hidden)]
pub type SearchFacesByImageInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl SearchFacesByImageInput {
    /// Consumes the builder and constructs an Operation<[`SearchFacesByImage`](crate::operation::SearchFacesByImage)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SearchFacesByImage,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::SearchFacesByImageInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::SearchFacesByImageInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::SearchFacesByImageInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.SearchFacesByImage",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_search_faces_by_image(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SearchFacesByImage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SearchFacesByImage",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`SearchFacesByImageInput`](crate::input::SearchFacesByImageInput)
    pub fn builder() -> crate::input::search_faces_by_image_input::Builder {
        crate::input::search_faces_by_image_input::Builder::default()
    }
}

/// See [`StartCelebrityRecognitionInput`](crate::input::StartCelebrityRecognitionInput)
pub mod start_celebrity_recognition_input {
    /// A builder for [`StartCelebrityRecognitionInput`](crate::input::StartCelebrityRecognitionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) video: std::option::Option<crate::model::Video>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) notification_channel: std::option::Option<crate::model::NotificationChannel>,
        pub(crate) job_tag: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The video in which you want to recognize celebrities. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn video(mut self, input: crate::model::Video) -> Self {
            self.video = Some(input);
            self
        }
        /// <p>The video in which you want to recognize celebrities. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.video = input;
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartCelebrityRecognition</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartCelebrityRecognition</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>The Amazon SNS topic ARN that you want Amazon Rekognition Video to publish the completion status of the
        /// celebrity recognition analysis to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
        pub fn notification_channel(mut self, input: crate::model::NotificationChannel) -> Self {
            self.notification_channel = Some(input);
            self
        }
        /// <p>The Amazon SNS topic ARN that you want Amazon Rekognition Video to publish the completion status of the
        /// celebrity recognition analysis to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.notification_channel = input;
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_tag = Some(input.into());
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_tag = input;
            self
        }
        /// Consumes the builder and constructs a [`StartCelebrityRecognitionInput`](crate::input::StartCelebrityRecognitionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartCelebrityRecognitionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartCelebrityRecognitionInput {
                video: self.video,
                client_request_token: self.client_request_token,
                notification_channel: self.notification_channel,
                job_tag: self.job_tag,
            })
        }
    }
}
#[doc(hidden)]
pub type StartCelebrityRecognitionInputOperationOutputAlias =
    crate::operation::StartCelebrityRecognition;
#[doc(hidden)]
pub type StartCelebrityRecognitionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartCelebrityRecognitionInput {
    /// Consumes the builder and constructs an Operation<[`StartCelebrityRecognition`](crate::operation::StartCelebrityRecognition)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartCelebrityRecognition,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartCelebrityRecognitionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartCelebrityRecognitionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartCelebrityRecognitionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.StartCelebrityRecognition",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_celebrity_recognition(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartCelebrityRecognition::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartCelebrityRecognition",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartCelebrityRecognitionInput`](crate::input::StartCelebrityRecognitionInput)
    pub fn builder() -> crate::input::start_celebrity_recognition_input::Builder {
        crate::input::start_celebrity_recognition_input::Builder::default()
    }
}

/// See [`StartContentModerationInput`](crate::input::StartContentModerationInput)
pub mod start_content_moderation_input {
    /// A builder for [`StartContentModerationInput`](crate::input::StartContentModerationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) video: std::option::Option<crate::model::Video>,
        pub(crate) min_confidence: std::option::Option<f32>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) notification_channel: std::option::Option<crate::model::NotificationChannel>,
        pub(crate) job_tag: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The video in which you want to detect inappropriate, unwanted, or offensive content. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn video(mut self, input: crate::model::Video) -> Self {
            self.video = Some(input);
            self
        }
        /// <p>The video in which you want to detect inappropriate, unwanted, or offensive content. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.video = input;
            self
        }
        /// <p>Specifies the minimum confidence that Amazon Rekognition must have in order to return a moderated content label. Confidence
        /// represents how certain Amazon Rekognition is that the moderated content is correctly identified. 0 is the lowest confidence.
        /// 100 is the highest confidence.  Amazon Rekognition doesn't return any moderated content labels with a confidence level
        /// lower than this specified value. If you don't specify <code>MinConfidence</code>, <code>GetContentModeration</code>
        /// returns labels with confidence values greater than or equal to 50 percent.</p>
        pub fn min_confidence(mut self, input: f32) -> Self {
            self.min_confidence = Some(input);
            self
        }
        /// <p>Specifies the minimum confidence that Amazon Rekognition must have in order to return a moderated content label. Confidence
        /// represents how certain Amazon Rekognition is that the moderated content is correctly identified. 0 is the lowest confidence.
        /// 100 is the highest confidence.  Amazon Rekognition doesn't return any moderated content labels with a confidence level
        /// lower than this specified value. If you don't specify <code>MinConfidence</code>, <code>GetContentModeration</code>
        /// returns labels with confidence values greater than or equal to 50 percent.</p>
        pub fn set_min_confidence(mut self, input: std::option::Option<f32>) -> Self {
            self.min_confidence = input;
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartContentModeration</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartContentModeration</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>The Amazon SNS topic ARN that you want Amazon Rekognition Video to publish the completion status of the
        /// content analysis to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
        pub fn notification_channel(mut self, input: crate::model::NotificationChannel) -> Self {
            self.notification_channel = Some(input);
            self
        }
        /// <p>The Amazon SNS topic ARN that you want Amazon Rekognition Video to publish the completion status of the
        /// content analysis to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.notification_channel = input;
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_tag = Some(input.into());
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_tag = input;
            self
        }
        /// Consumes the builder and constructs a [`StartContentModerationInput`](crate::input::StartContentModerationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartContentModerationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartContentModerationInput {
                video: self.video,
                min_confidence: self.min_confidence,
                client_request_token: self.client_request_token,
                notification_channel: self.notification_channel,
                job_tag: self.job_tag,
            })
        }
    }
}
#[doc(hidden)]
pub type StartContentModerationInputOperationOutputAlias = crate::operation::StartContentModeration;
#[doc(hidden)]
pub type StartContentModerationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartContentModerationInput {
    /// Consumes the builder and constructs an Operation<[`StartContentModeration`](crate::operation::StartContentModeration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartContentModeration,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartContentModerationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartContentModerationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartContentModerationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.StartContentModeration",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_content_moderation(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartContentModeration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartContentModeration",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartContentModerationInput`](crate::input::StartContentModerationInput)
    pub fn builder() -> crate::input::start_content_moderation_input::Builder {
        crate::input::start_content_moderation_input::Builder::default()
    }
}

/// See [`StartFaceDetectionInput`](crate::input::StartFaceDetectionInput)
pub mod start_face_detection_input {
    /// A builder for [`StartFaceDetectionInput`](crate::input::StartFaceDetectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) video: std::option::Option<crate::model::Video>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) notification_channel: std::option::Option<crate::model::NotificationChannel>,
        pub(crate) face_attributes: std::option::Option<crate::model::FaceAttributes>,
        pub(crate) job_tag: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The video in which you want to detect faces. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn video(mut self, input: crate::model::Video) -> Self {
            self.video = Some(input);
            self
        }
        /// <p>The video in which you want to detect faces. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.video = input;
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartFaceDetection</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartFaceDetection</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the
        /// face detection operation. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
        pub fn notification_channel(mut self, input: crate::model::NotificationChannel) -> Self {
            self.notification_channel = Some(input);
            self
        }
        /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the
        /// face detection operation. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.notification_channel = input;
            self
        }
        /// <p>The face attributes you want returned.</p>
        /// <p>
        /// <code>DEFAULT</code> - The following subset of facial attributes are returned: BoundingBox, Confidence, Pose, Quality and Landmarks. </p>
        /// <p>
        /// <code>ALL</code> - All facial attributes are returned.</p>
        pub fn face_attributes(mut self, input: crate::model::FaceAttributes) -> Self {
            self.face_attributes = Some(input);
            self
        }
        /// <p>The face attributes you want returned.</p>
        /// <p>
        /// <code>DEFAULT</code> - The following subset of facial attributes are returned: BoundingBox, Confidence, Pose, Quality and Landmarks. </p>
        /// <p>
        /// <code>ALL</code> - All facial attributes are returned.</p>
        pub fn set_face_attributes(
            mut self,
            input: std::option::Option<crate::model::FaceAttributes>,
        ) -> Self {
            self.face_attributes = input;
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_tag = Some(input.into());
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_tag = input;
            self
        }
        /// Consumes the builder and constructs a [`StartFaceDetectionInput`](crate::input::StartFaceDetectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartFaceDetectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartFaceDetectionInput {
                video: self.video,
                client_request_token: self.client_request_token,
                notification_channel: self.notification_channel,
                face_attributes: self.face_attributes,
                job_tag: self.job_tag,
            })
        }
    }
}
#[doc(hidden)]
pub type StartFaceDetectionInputOperationOutputAlias = crate::operation::StartFaceDetection;
#[doc(hidden)]
pub type StartFaceDetectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartFaceDetectionInput {
    /// Consumes the builder and constructs an Operation<[`StartFaceDetection`](crate::operation::StartFaceDetection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartFaceDetection,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartFaceDetectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartFaceDetectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartFaceDetectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.StartFaceDetection",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_face_detection(&self)
                .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartFaceDetection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartFaceDetection",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartFaceDetectionInput`](crate::input::StartFaceDetectionInput)
    pub fn builder() -> crate::input::start_face_detection_input::Builder {
        crate::input::start_face_detection_input::Builder::default()
    }
}

/// See [`StartFaceSearchInput`](crate::input::StartFaceSearchInput)
pub mod start_face_search_input {
    /// A builder for [`StartFaceSearchInput`](crate::input::StartFaceSearchInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) video: std::option::Option<crate::model::Video>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) face_match_threshold: std::option::Option<f32>,
        pub(crate) collection_id: std::option::Option<std::string::String>,
        pub(crate) notification_channel: std::option::Option<crate::model::NotificationChannel>,
        pub(crate) job_tag: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The video you want to search. The video must be stored in an Amazon S3 bucket. </p>
        pub fn video(mut self, input: crate::model::Video) -> Self {
            self.video = Some(input);
            self
        }
        /// <p>The video you want to search. The video must be stored in an Amazon S3 bucket. </p>
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.video = input;
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartFaceSearch</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartFaceSearch</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>The minimum confidence in the person match to return. For example, don't return any matches where confidence in matches is less than 70%.
        /// The default value is 80%.</p>
        pub fn face_match_threshold(mut self, input: f32) -> Self {
            self.face_match_threshold = Some(input);
            self
        }
        /// <p>The minimum confidence in the person match to return. For example, don't return any matches where confidence in matches is less than 70%.
        /// The default value is 80%.</p>
        pub fn set_face_match_threshold(mut self, input: std::option::Option<f32>) -> Self {
            self.face_match_threshold = input;
            self
        }
        /// <p>ID of the collection that contains the faces you want to search for.</p>
        pub fn collection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collection_id = Some(input.into());
            self
        }
        /// <p>ID of the collection that contains the faces you want to search for.</p>
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collection_id = input;
            self
        }
        /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the search. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
        pub fn notification_channel(mut self, input: crate::model::NotificationChannel) -> Self {
            self.notification_channel = Some(input);
            self
        }
        /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the search. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.notification_channel = input;
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_tag = Some(input.into());
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_tag = input;
            self
        }
        /// Consumes the builder and constructs a [`StartFaceSearchInput`](crate::input::StartFaceSearchInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartFaceSearchInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartFaceSearchInput {
                video: self.video,
                client_request_token: self.client_request_token,
                face_match_threshold: self.face_match_threshold,
                collection_id: self.collection_id,
                notification_channel: self.notification_channel,
                job_tag: self.job_tag,
            })
        }
    }
}
#[doc(hidden)]
pub type StartFaceSearchInputOperationOutputAlias = crate::operation::StartFaceSearch;
#[doc(hidden)]
pub type StartFaceSearchInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartFaceSearchInput {
    /// Consumes the builder and constructs an Operation<[`StartFaceSearch`](crate::operation::StartFaceSearch)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartFaceSearch,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartFaceSearchInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartFaceSearchInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartFaceSearchInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.StartFaceSearch",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_face_search(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartFaceSearch::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartFaceSearch",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartFaceSearchInput`](crate::input::StartFaceSearchInput)
    pub fn builder() -> crate::input::start_face_search_input::Builder {
        crate::input::start_face_search_input::Builder::default()
    }
}

/// See [`StartLabelDetectionInput`](crate::input::StartLabelDetectionInput)
pub mod start_label_detection_input {
    /// A builder for [`StartLabelDetectionInput`](crate::input::StartLabelDetectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) video: std::option::Option<crate::model::Video>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) min_confidence: std::option::Option<f32>,
        pub(crate) notification_channel: std::option::Option<crate::model::NotificationChannel>,
        pub(crate) job_tag: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The video in which you want to detect labels. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn video(mut self, input: crate::model::Video) -> Self {
            self.video = Some(input);
            self
        }
        /// <p>The video in which you want to detect labels. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.video = input;
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartLabelDetection</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartLabelDetection</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>Specifies the minimum confidence that Amazon Rekognition Video must have in order to return a detected label. Confidence
        /// represents how certain Amazon Rekognition is that a label is correctly identified.0 is the lowest confidence.
        /// 100 is the highest confidence.  Amazon Rekognition Video doesn't return any labels with a confidence level
        /// lower than this specified value.</p>
        /// <p>If you don't specify <code>MinConfidence</code>, the operation returns labels with confidence
        /// values greater than or equal to 50 percent.</p>
        pub fn min_confidence(mut self, input: f32) -> Self {
            self.min_confidence = Some(input);
            self
        }
        /// <p>Specifies the minimum confidence that Amazon Rekognition Video must have in order to return a detected label. Confidence
        /// represents how certain Amazon Rekognition is that a label is correctly identified.0 is the lowest confidence.
        /// 100 is the highest confidence.  Amazon Rekognition Video doesn't return any labels with a confidence level
        /// lower than this specified value.</p>
        /// <p>If you don't specify <code>MinConfidence</code>, the operation returns labels with confidence
        /// values greater than or equal to 50 percent.</p>
        pub fn set_min_confidence(mut self, input: std::option::Option<f32>) -> Self {
            self.min_confidence = input;
            self
        }
        /// <p>The Amazon SNS topic ARN you want Amazon Rekognition Video to publish the completion status of the label detection
        /// operation to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
        pub fn notification_channel(mut self, input: crate::model::NotificationChannel) -> Self {
            self.notification_channel = Some(input);
            self
        }
        /// <p>The Amazon SNS topic ARN you want Amazon Rekognition Video to publish the completion status of the label detection
        /// operation to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.notification_channel = input;
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_tag = Some(input.into());
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_tag = input;
            self
        }
        /// Consumes the builder and constructs a [`StartLabelDetectionInput`](crate::input::StartLabelDetectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartLabelDetectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartLabelDetectionInput {
                video: self.video,
                client_request_token: self.client_request_token,
                min_confidence: self.min_confidence,
                notification_channel: self.notification_channel,
                job_tag: self.job_tag,
            })
        }
    }
}
#[doc(hidden)]
pub type StartLabelDetectionInputOperationOutputAlias = crate::operation::StartLabelDetection;
#[doc(hidden)]
pub type StartLabelDetectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartLabelDetectionInput {
    /// Consumes the builder and constructs an Operation<[`StartLabelDetection`](crate::operation::StartLabelDetection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartLabelDetection,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartLabelDetectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartLabelDetectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartLabelDetectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.StartLabelDetection",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_label_detection(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartLabelDetection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartLabelDetection",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartLabelDetectionInput`](crate::input::StartLabelDetectionInput)
    pub fn builder() -> crate::input::start_label_detection_input::Builder {
        crate::input::start_label_detection_input::Builder::default()
    }
}

/// See [`StartPersonTrackingInput`](crate::input::StartPersonTrackingInput)
pub mod start_person_tracking_input {
    /// A builder for [`StartPersonTrackingInput`](crate::input::StartPersonTrackingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) video: std::option::Option<crate::model::Video>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) notification_channel: std::option::Option<crate::model::NotificationChannel>,
        pub(crate) job_tag: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The video in which you want to detect people. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn video(mut self, input: crate::model::Video) -> Self {
            self.video = Some(input);
            self
        }
        /// <p>The video in which you want to detect people. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.video = input;
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartPersonTracking</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartPersonTracking</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>The Amazon SNS topic ARN you want Amazon Rekognition Video to publish the completion status of the people detection
        /// operation to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
        pub fn notification_channel(mut self, input: crate::model::NotificationChannel) -> Self {
            self.notification_channel = Some(input);
            self
        }
        /// <p>The Amazon SNS topic ARN you want Amazon Rekognition Video to publish the completion status of the people detection
        /// operation to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.notification_channel = input;
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_tag = Some(input.into());
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_tag = input;
            self
        }
        /// Consumes the builder and constructs a [`StartPersonTrackingInput`](crate::input::StartPersonTrackingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartPersonTrackingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartPersonTrackingInput {
                video: self.video,
                client_request_token: self.client_request_token,
                notification_channel: self.notification_channel,
                job_tag: self.job_tag,
            })
        }
    }
}
#[doc(hidden)]
pub type StartPersonTrackingInputOperationOutputAlias = crate::operation::StartPersonTracking;
#[doc(hidden)]
pub type StartPersonTrackingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartPersonTrackingInput {
    /// Consumes the builder and constructs an Operation<[`StartPersonTracking`](crate::operation::StartPersonTracking)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartPersonTracking,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartPersonTrackingInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartPersonTrackingInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartPersonTrackingInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.StartPersonTracking",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_person_tracking(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartPersonTracking::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartPersonTracking",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartPersonTrackingInput`](crate::input::StartPersonTrackingInput)
    pub fn builder() -> crate::input::start_person_tracking_input::Builder {
        crate::input::start_person_tracking_input::Builder::default()
    }
}

/// See [`StartProjectVersionInput`](crate::input::StartProjectVersionInput)
pub mod start_project_version_input {
    /// A builder for [`StartProjectVersionInput`](crate::input::StartProjectVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_version_arn: std::option::Option<std::string::String>,
        pub(crate) min_inference_units: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name(ARN) of the model version that you want to start.</p>
        pub fn project_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_version_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name(ARN) of the model version that you want to start.</p>
        pub fn set_project_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.project_version_arn = input;
            self
        }
        /// <p>The minimum number of inference units to use. A single
        /// inference unit represents 1 hour of processing and can support up to 5 Transaction Pers Second (TPS).
        /// Use a higher number to increase the TPS throughput of your model. You are charged for the number
        /// of inference units that you use.
        /// </p>
        pub fn min_inference_units(mut self, input: i32) -> Self {
            self.min_inference_units = Some(input);
            self
        }
        /// <p>The minimum number of inference units to use. A single
        /// inference unit represents 1 hour of processing and can support up to 5 Transaction Pers Second (TPS).
        /// Use a higher number to increase the TPS throughput of your model. You are charged for the number
        /// of inference units that you use.
        /// </p>
        pub fn set_min_inference_units(mut self, input: std::option::Option<i32>) -> Self {
            self.min_inference_units = input;
            self
        }
        /// Consumes the builder and constructs a [`StartProjectVersionInput`](crate::input::StartProjectVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartProjectVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartProjectVersionInput {
                project_version_arn: self.project_version_arn,
                min_inference_units: self.min_inference_units,
            })
        }
    }
}
#[doc(hidden)]
pub type StartProjectVersionInputOperationOutputAlias = crate::operation::StartProjectVersion;
#[doc(hidden)]
pub type StartProjectVersionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartProjectVersionInput {
    /// Consumes the builder and constructs an Operation<[`StartProjectVersion`](crate::operation::StartProjectVersion)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartProjectVersion,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartProjectVersionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartProjectVersionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartProjectVersionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.StartProjectVersion",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_project_version(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartProjectVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartProjectVersion",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartProjectVersionInput`](crate::input::StartProjectVersionInput)
    pub fn builder() -> crate::input::start_project_version_input::Builder {
        crate::input::start_project_version_input::Builder::default()
    }
}

/// See [`StartSegmentDetectionInput`](crate::input::StartSegmentDetectionInput)
pub mod start_segment_detection_input {
    /// A builder for [`StartSegmentDetectionInput`](crate::input::StartSegmentDetectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) video: std::option::Option<crate::model::Video>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) notification_channel: std::option::Option<crate::model::NotificationChannel>,
        pub(crate) job_tag: std::option::Option<std::string::String>,
        pub(crate) filters: std::option::Option<crate::model::StartSegmentDetectionFilters>,
        pub(crate) segment_types: std::option::Option<std::vec::Vec<crate::model::SegmentType>>,
    }
    impl Builder {
        /// <p>Video file stored in an Amazon S3 bucket. Amazon Rekognition video start operations such as <a>StartLabelDetection</a> use <code>Video</code> to
        /// specify a video for analysis. The supported file formats are .mp4, .mov and .avi.</p>
        pub fn video(mut self, input: crate::model::Video) -> Self {
            self.video = Some(input);
            self
        }
        /// <p>Video file stored in an Amazon S3 bucket. Amazon Rekognition video start operations such as <a>StartLabelDetection</a> use <code>Video</code> to
        /// specify a video for analysis. The supported file formats are .mp4, .mov and .avi.</p>
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.video = input;
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartSegmentDetection</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartSegmentDetection</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the
        /// segment detection operation. Note that the Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
        pub fn notification_channel(mut self, input: crate::model::NotificationChannel) -> Self {
            self.notification_channel = Some(input);
            self
        }
        /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the
        /// segment detection operation. Note that the Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.notification_channel = input;
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_tag = Some(input.into());
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_tag = input;
            self
        }
        /// <p>Filters for technical cue or shot detection.</p>
        pub fn filters(mut self, input: crate::model::StartSegmentDetectionFilters) -> Self {
            self.filters = Some(input);
            self
        }
        /// <p>Filters for technical cue or shot detection.</p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<crate::model::StartSegmentDetectionFilters>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Appends an item to `segment_types`.
        ///
        /// To override the contents of this collection use [`set_segment_types`](Self::set_segment_types).
        ///
        /// <p>An array of segment types to detect in the video. Valid values are TECHNICAL_CUE and SHOT.</p>
        pub fn segment_types(mut self, input: impl Into<crate::model::SegmentType>) -> Self {
            let mut v = self.segment_types.unwrap_or_default();
            v.push(input.into());
            self.segment_types = Some(v);
            self
        }
        /// <p>An array of segment types to detect in the video. Valid values are TECHNICAL_CUE and SHOT.</p>
        pub fn set_segment_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SegmentType>>,
        ) -> Self {
            self.segment_types = input;
            self
        }
        /// Consumes the builder and constructs a [`StartSegmentDetectionInput`](crate::input::StartSegmentDetectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartSegmentDetectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartSegmentDetectionInput {
                video: self.video,
                client_request_token: self.client_request_token,
                notification_channel: self.notification_channel,
                job_tag: self.job_tag,
                filters: self.filters,
                segment_types: self.segment_types,
            })
        }
    }
}
#[doc(hidden)]
pub type StartSegmentDetectionInputOperationOutputAlias = crate::operation::StartSegmentDetection;
#[doc(hidden)]
pub type StartSegmentDetectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartSegmentDetectionInput {
    /// Consumes the builder and constructs an Operation<[`StartSegmentDetection`](crate::operation::StartSegmentDetection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartSegmentDetection,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartSegmentDetectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartSegmentDetectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartSegmentDetectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.StartSegmentDetection",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_segment_detection(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartSegmentDetection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartSegmentDetection",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartSegmentDetectionInput`](crate::input::StartSegmentDetectionInput)
    pub fn builder() -> crate::input::start_segment_detection_input::Builder {
        crate::input::start_segment_detection_input::Builder::default()
    }
}

/// See [`StartStreamProcessorInput`](crate::input::StartStreamProcessorInput)
pub mod start_stream_processor_input {
    /// A builder for [`StartStreamProcessorInput`](crate::input::StartStreamProcessorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the stream processor to start processing.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the stream processor to start processing.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`StartStreamProcessorInput`](crate::input::StartStreamProcessorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartStreamProcessorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartStreamProcessorInput { name: self.name })
        }
    }
}
#[doc(hidden)]
pub type StartStreamProcessorInputOperationOutputAlias = crate::operation::StartStreamProcessor;
#[doc(hidden)]
pub type StartStreamProcessorInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartStreamProcessorInput {
    /// Consumes the builder and constructs an Operation<[`StartStreamProcessor`](crate::operation::StartStreamProcessor)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartStreamProcessor,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartStreamProcessorInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartStreamProcessorInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartStreamProcessorInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.StartStreamProcessor",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_stream_processor(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartStreamProcessor::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartStreamProcessor",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartStreamProcessorInput`](crate::input::StartStreamProcessorInput)
    pub fn builder() -> crate::input::start_stream_processor_input::Builder {
        crate::input::start_stream_processor_input::Builder::default()
    }
}

/// See [`StartTextDetectionInput`](crate::input::StartTextDetectionInput)
pub mod start_text_detection_input {
    /// A builder for [`StartTextDetectionInput`](crate::input::StartTextDetectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) video: std::option::Option<crate::model::Video>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) notification_channel: std::option::Option<crate::model::NotificationChannel>,
        pub(crate) job_tag: std::option::Option<std::string::String>,
        pub(crate) filters: std::option::Option<crate::model::StartTextDetectionFilters>,
    }
    impl Builder {
        /// <p>Video file stored in an Amazon S3 bucket. Amazon Rekognition video start operations such as <a>StartLabelDetection</a> use <code>Video</code> to
        /// specify a video for analysis. The supported file formats are .mp4, .mov and .avi.</p>
        pub fn video(mut self, input: crate::model::Video) -> Self {
            self.video = Some(input);
            self
        }
        /// <p>Video file stored in an Amazon S3 bucket. Amazon Rekognition video start operations such as <a>StartLabelDetection</a> use <code>Video</code> to
        /// specify a video for analysis. The supported file formats are .mp4, .mov and .avi.</p>
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.video = input;
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple <code>StartTextDetection</code>
        /// requests, the same <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same job
        /// from being accidentaly started more than once.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple <code>StartTextDetection</code>
        /// requests, the same <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same job
        /// from being accidentaly started more than once.</p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>The Amazon Simple Notification Service topic to which Amazon Rekognition publishes the completion status of a video analysis operation. For more information, see
        /// <a>api-video</a>. Note that the Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.
        /// For more information, see <a href="https://docs.aws.amazon.com/rekognition/latest/dg/api-video-roles.html#api-video-roles-all-topics">Giving access to multiple Amazon SNS topics</a>.</p>
        pub fn notification_channel(mut self, input: crate::model::NotificationChannel) -> Self {
            self.notification_channel = Some(input);
            self
        }
        /// <p>The Amazon Simple Notification Service topic to which Amazon Rekognition publishes the completion status of a video analysis operation. For more information, see
        /// <a>api-video</a>. Note that the Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.
        /// For more information, see <a href="https://docs.aws.amazon.com/rekognition/latest/dg/api-video-roles.html#api-video-roles-all-topics">Giving access to multiple Amazon SNS topics</a>.</p>
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.notification_channel = input;
            self
        }
        /// <p>An identifier returned in the completion status published by your Amazon Simple Notification Service topic.  For example, you can use <code>JobTag</code> to group related jobs
        /// and identify them in the completion notification.</p>
        pub fn job_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_tag = Some(input.into());
            self
        }
        /// <p>An identifier returned in the completion status published by your Amazon Simple Notification Service topic.  For example, you can use <code>JobTag</code> to group related jobs
        /// and identify them in the completion notification.</p>
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_tag = input;
            self
        }
        /// <p>Optional parameters that let you set criteria the text must meet to be included in your response.</p>
        pub fn filters(mut self, input: crate::model::StartTextDetectionFilters) -> Self {
            self.filters = Some(input);
            self
        }
        /// <p>Optional parameters that let you set criteria the text must meet to be included in your response.</p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<crate::model::StartTextDetectionFilters>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Consumes the builder and constructs a [`StartTextDetectionInput`](crate::input::StartTextDetectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartTextDetectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartTextDetectionInput {
                video: self.video,
                client_request_token: self.client_request_token,
                notification_channel: self.notification_channel,
                job_tag: self.job_tag,
                filters: self.filters,
            })
        }
    }
}
#[doc(hidden)]
pub type StartTextDetectionInputOperationOutputAlias = crate::operation::StartTextDetection;
#[doc(hidden)]
pub type StartTextDetectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartTextDetectionInput {
    /// Consumes the builder and constructs an Operation<[`StartTextDetection`](crate::operation::StartTextDetection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartTextDetection,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartTextDetectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartTextDetectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartTextDetectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.StartTextDetection",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_text_detection(&self)
                .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartTextDetection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartTextDetection",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartTextDetectionInput`](crate::input::StartTextDetectionInput)
    pub fn builder() -> crate::input::start_text_detection_input::Builder {
        crate::input::start_text_detection_input::Builder::default()
    }
}

/// See [`StopProjectVersionInput`](crate::input::StopProjectVersionInput)
pub mod stop_project_version_input {
    /// A builder for [`StopProjectVersionInput`](crate::input::StopProjectVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_version_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the model version that you want to delete.</p>
        /// <p>This operation requires permissions to perform the <code>rekognition:StopProjectVersion</code> action.</p>
        pub fn project_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_version_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model version that you want to delete.</p>
        /// <p>This operation requires permissions to perform the <code>rekognition:StopProjectVersion</code> action.</p>
        pub fn set_project_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.project_version_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`StopProjectVersionInput`](crate::input::StopProjectVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StopProjectVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StopProjectVersionInput {
                project_version_arn: self.project_version_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type StopProjectVersionInputOperationOutputAlias = crate::operation::StopProjectVersion;
#[doc(hidden)]
pub type StopProjectVersionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StopProjectVersionInput {
    /// Consumes the builder and constructs an Operation<[`StopProjectVersion`](crate::operation::StopProjectVersion)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StopProjectVersion,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StopProjectVersionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StopProjectVersionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StopProjectVersionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.StopProjectVersion",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_stop_project_version(&self)
                .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StopProjectVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StopProjectVersion",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StopProjectVersionInput`](crate::input::StopProjectVersionInput)
    pub fn builder() -> crate::input::stop_project_version_input::Builder {
        crate::input::stop_project_version_input::Builder::default()
    }
}

/// See [`StopStreamProcessorInput`](crate::input::StopStreamProcessorInput)
pub mod stop_stream_processor_input {
    /// A builder for [`StopStreamProcessorInput`](crate::input::StopStreamProcessorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a stream processor created by <a>CreateStreamProcessor</a>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a stream processor created by <a>CreateStreamProcessor</a>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`StopStreamProcessorInput`](crate::input::StopStreamProcessorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StopStreamProcessorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StopStreamProcessorInput { name: self.name })
        }
    }
}
#[doc(hidden)]
pub type StopStreamProcessorInputOperationOutputAlias = crate::operation::StopStreamProcessor;
#[doc(hidden)]
pub type StopStreamProcessorInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StopStreamProcessorInput {
    /// Consumes the builder and constructs an Operation<[`StopStreamProcessor`](crate::operation::StopStreamProcessor)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StopStreamProcessor,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StopStreamProcessorInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StopStreamProcessorInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StopStreamProcessorInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.StopStreamProcessor",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_stop_stream_processor(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StopStreamProcessor::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StopStreamProcessor",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StopStreamProcessorInput`](crate::input::StopStreamProcessorInput)
    pub fn builder() -> crate::input::stop_stream_processor_input::Builder {
        crate::input::stop_stream_processor_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>
        /// Amazon Resource Name (ARN) of the model, collection, or stream processor that you want to assign the tags to.
        /// </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>
        /// Amazon Resource Name (ARN) of the model, collection, or stream processor that you want to assign the tags to.
        /// </p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>
        /// The key-value tags to assign to the resource.
        /// </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>
        /// The key-value tags to assign to the resource.
        /// </p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::TagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::TagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::TagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.TagResource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>
        /// Amazon Resource Name (ARN) of the model, collection, or stream processor that you want to remove the tags from.
        /// </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>
        /// Amazon Resource Name (ARN) of the model, collection, or stream processor that you want to remove the tags from.
        /// </p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>
        /// A list of the tags that you want to remove.
        /// </p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>
        /// A list of the tags that you want to remove.
        /// </p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UntagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UntagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UntagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UntagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "RekognitionService.UntagResource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_untag_resource(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "rekognition",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>
    /// Amazon Resource Name (ARN) of the model, collection, or stream processor that you want to remove the tags from.
    /// </p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>
    /// A list of the tags that you want to remove.
    /// </p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>
    /// Amazon Resource Name (ARN) of the model, collection, or stream processor that you want to assign the tags to.
    /// </p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>
    /// The key-value tags to assign to the resource.
    /// </p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopStreamProcessorInput {
    /// <p>The name of a stream processor created by <a>CreateStreamProcessor</a>.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StopStreamProcessorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopStreamProcessorInput");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopProjectVersionInput {
    /// <p>The Amazon Resource Name (ARN) of the model version that you want to delete.</p>
    /// <p>This operation requires permissions to perform the <code>rekognition:StopProjectVersion</code> action.</p>
    pub project_version_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StopProjectVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopProjectVersionInput");
        formatter.field("project_version_arn", &self.project_version_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartTextDetectionInput {
    /// <p>Video file stored in an Amazon S3 bucket. Amazon Rekognition video start operations such as <a>StartLabelDetection</a> use <code>Video</code> to
    /// specify a video for analysis. The supported file formats are .mp4, .mov and .avi.</p>
    pub video: std::option::Option<crate::model::Video>,
    /// <p>Idempotent token used to identify the start request. If you use the same token with multiple <code>StartTextDetection</code>
    /// requests, the same <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same job
    /// from being accidentaly started more than once.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The Amazon Simple Notification Service topic to which Amazon Rekognition publishes the completion status of a video analysis operation. For more information, see
    /// <a>api-video</a>. Note that the Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.
    /// For more information, see <a href="https://docs.aws.amazon.com/rekognition/latest/dg/api-video-roles.html#api-video-roles-all-topics">Giving access to multiple Amazon SNS topics</a>.</p>
    pub notification_channel: std::option::Option<crate::model::NotificationChannel>,
    /// <p>An identifier returned in the completion status published by your Amazon Simple Notification Service topic.  For example, you can use <code>JobTag</code> to group related jobs
    /// and identify them in the completion notification.</p>
    pub job_tag: std::option::Option<std::string::String>,
    /// <p>Optional parameters that let you set criteria the text must meet to be included in your response.</p>
    pub filters: std::option::Option<crate::model::StartTextDetectionFilters>,
}
impl std::fmt::Debug for StartTextDetectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartTextDetectionInput");
        formatter.field("video", &self.video);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("notification_channel", &self.notification_channel);
        formatter.field("job_tag", &self.job_tag);
        formatter.field("filters", &self.filters);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartStreamProcessorInput {
    /// <p>The name of the stream processor to start processing.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartStreamProcessorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartStreamProcessorInput");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartSegmentDetectionInput {
    /// <p>Video file stored in an Amazon S3 bucket. Amazon Rekognition video start operations such as <a>StartLabelDetection</a> use <code>Video</code> to
    /// specify a video for analysis. The supported file formats are .mp4, .mov and .avi.</p>
    pub video: std::option::Option<crate::model::Video>,
    /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
    /// <code>StartSegmentDetection</code> requests, the same <code>JobId</code> is returned. Use
    /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the
    /// segment detection operation. Note that the Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
    pub notification_channel: std::option::Option<crate::model::NotificationChannel>,
    /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
    /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
    pub job_tag: std::option::Option<std::string::String>,
    /// <p>Filters for technical cue or shot detection.</p>
    pub filters: std::option::Option<crate::model::StartSegmentDetectionFilters>,
    /// <p>An array of segment types to detect in the video. Valid values are TECHNICAL_CUE and SHOT.</p>
    pub segment_types: std::option::Option<std::vec::Vec<crate::model::SegmentType>>,
}
impl std::fmt::Debug for StartSegmentDetectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartSegmentDetectionInput");
        formatter.field("video", &self.video);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("notification_channel", &self.notification_channel);
        formatter.field("job_tag", &self.job_tag);
        formatter.field("filters", &self.filters);
        formatter.field("segment_types", &self.segment_types);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartProjectVersionInput {
    /// <p>The Amazon Resource Name(ARN) of the model version that you want to start.</p>
    pub project_version_arn: std::option::Option<std::string::String>,
    /// <p>The minimum number of inference units to use. A single
    /// inference unit represents 1 hour of processing and can support up to 5 Transaction Pers Second (TPS).
    /// Use a higher number to increase the TPS throughput of your model. You are charged for the number
    /// of inference units that you use.
    /// </p>
    pub min_inference_units: std::option::Option<i32>,
}
impl std::fmt::Debug for StartProjectVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartProjectVersionInput");
        formatter.field("project_version_arn", &self.project_version_arn);
        formatter.field("min_inference_units", &self.min_inference_units);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartPersonTrackingInput {
    /// <p>The video in which you want to detect people. The video must be stored
    /// in an Amazon S3 bucket.</p>
    pub video: std::option::Option<crate::model::Video>,
    /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
    /// <code>StartPersonTracking</code> requests, the same <code>JobId</code> is returned. Use
    /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The Amazon SNS topic ARN you want Amazon Rekognition Video to publish the completion status of the people detection
    /// operation to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
    pub notification_channel: std::option::Option<crate::model::NotificationChannel>,
    /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
    /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
    pub job_tag: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartPersonTrackingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartPersonTrackingInput");
        formatter.field("video", &self.video);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("notification_channel", &self.notification_channel);
        formatter.field("job_tag", &self.job_tag);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartLabelDetectionInput {
    /// <p>The video in which you want to detect labels. The video must be stored
    /// in an Amazon S3 bucket.</p>
    pub video: std::option::Option<crate::model::Video>,
    /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
    /// <code>StartLabelDetection</code> requests, the same <code>JobId</code> is returned. Use
    /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>Specifies the minimum confidence that Amazon Rekognition Video must have in order to return a detected label. Confidence
    /// represents how certain Amazon Rekognition is that a label is correctly identified.0 is the lowest confidence.
    /// 100 is the highest confidence.  Amazon Rekognition Video doesn't return any labels with a confidence level
    /// lower than this specified value.</p>
    /// <p>If you don't specify <code>MinConfidence</code>, the operation returns labels with confidence
    /// values greater than or equal to 50 percent.</p>
    pub min_confidence: std::option::Option<f32>,
    /// <p>The Amazon SNS topic ARN you want Amazon Rekognition Video to publish the completion status of the label detection
    /// operation to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
    pub notification_channel: std::option::Option<crate::model::NotificationChannel>,
    /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
    /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
    pub job_tag: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartLabelDetectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartLabelDetectionInput");
        formatter.field("video", &self.video);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("min_confidence", &self.min_confidence);
        formatter.field("notification_channel", &self.notification_channel);
        formatter.field("job_tag", &self.job_tag);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartFaceSearchInput {
    /// <p>The video you want to search. The video must be stored in an Amazon S3 bucket. </p>
    pub video: std::option::Option<crate::model::Video>,
    /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
    /// <code>StartFaceSearch</code> requests, the same <code>JobId</code> is returned. Use
    /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The minimum confidence in the person match to return. For example, don't return any matches where confidence in matches is less than 70%.
    /// The default value is 80%.</p>
    pub face_match_threshold: std::option::Option<f32>,
    /// <p>ID of the collection that contains the faces you want to search for.</p>
    pub collection_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the search. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
    pub notification_channel: std::option::Option<crate::model::NotificationChannel>,
    /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
    /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
    pub job_tag: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartFaceSearchInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartFaceSearchInput");
        formatter.field("video", &self.video);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("face_match_threshold", &self.face_match_threshold);
        formatter.field("collection_id", &self.collection_id);
        formatter.field("notification_channel", &self.notification_channel);
        formatter.field("job_tag", &self.job_tag);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartFaceDetectionInput {
    /// <p>The video in which you want to detect faces. The video must be stored
    /// in an Amazon S3 bucket.</p>
    pub video: std::option::Option<crate::model::Video>,
    /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
    /// <code>StartFaceDetection</code> requests, the same <code>JobId</code> is returned. Use
    /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the
    /// face detection operation. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
    pub notification_channel: std::option::Option<crate::model::NotificationChannel>,
    /// <p>The face attributes you want returned.</p>
    /// <p>
    /// <code>DEFAULT</code> - The following subset of facial attributes are returned: BoundingBox, Confidence, Pose, Quality and Landmarks. </p>
    /// <p>
    /// <code>ALL</code> - All facial attributes are returned.</p>
    pub face_attributes: std::option::Option<crate::model::FaceAttributes>,
    /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
    /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
    pub job_tag: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartFaceDetectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartFaceDetectionInput");
        formatter.field("video", &self.video);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("notification_channel", &self.notification_channel);
        formatter.field("face_attributes", &self.face_attributes);
        formatter.field("job_tag", &self.job_tag);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartContentModerationInput {
    /// <p>The video in which you want to detect inappropriate, unwanted, or offensive content. The video must be stored
    /// in an Amazon S3 bucket.</p>
    pub video: std::option::Option<crate::model::Video>,
    /// <p>Specifies the minimum confidence that Amazon Rekognition must have in order to return a moderated content label. Confidence
    /// represents how certain Amazon Rekognition is that the moderated content is correctly identified. 0 is the lowest confidence.
    /// 100 is the highest confidence.  Amazon Rekognition doesn't return any moderated content labels with a confidence level
    /// lower than this specified value. If you don't specify <code>MinConfidence</code>, <code>GetContentModeration</code>
    /// returns labels with confidence values greater than or equal to 50 percent.</p>
    pub min_confidence: std::option::Option<f32>,
    /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
    /// <code>StartContentModeration</code> requests, the same <code>JobId</code> is returned. Use
    /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The Amazon SNS topic ARN that you want Amazon Rekognition Video to publish the completion status of the
    /// content analysis to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
    pub notification_channel: std::option::Option<crate::model::NotificationChannel>,
    /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
    /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
    pub job_tag: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartContentModerationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartContentModerationInput");
        formatter.field("video", &self.video);
        formatter.field("min_confidence", &self.min_confidence);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("notification_channel", &self.notification_channel);
        formatter.field("job_tag", &self.job_tag);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartCelebrityRecognitionInput {
    /// <p>The video in which you want to recognize celebrities. The video must be stored
    /// in an Amazon S3 bucket.</p>
    pub video: std::option::Option<crate::model::Video>,
    /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
    /// <code>StartCelebrityRecognition</code> requests, the same <code>JobId</code> is returned. Use
    /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The Amazon SNS topic ARN that you want Amazon Rekognition Video to publish the completion status of the
    /// celebrity recognition analysis to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
    pub notification_channel: std::option::Option<crate::model::NotificationChannel>,
    /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
    /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
    pub job_tag: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartCelebrityRecognitionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartCelebrityRecognitionInput");
        formatter.field("video", &self.video);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("notification_channel", &self.notification_channel);
        formatter.field("job_tag", &self.job_tag);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchFacesByImageInput {
    /// <p>ID of the collection to search.</p>
    pub collection_id: std::option::Option<std::string::String>,
    /// <p>The input image as base64-encoded bytes or an S3 object.
    /// If you use the AWS CLI to call Amazon Rekognition operations,
    /// passing base64-encoded image bytes is not supported. </p>
    /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
    /// passed using the <code>Bytes</code> field.
    /// For more information, see Images in the Amazon Rekognition developer guide.</p>
    pub image: std::option::Option<crate::model::Image>,
    /// <p>Maximum number of faces to return. The operation returns the maximum number of faces
    /// with the highest confidence in the match.</p>
    pub max_faces: std::option::Option<i32>,
    /// <p>(Optional) Specifies the minimum confidence in the face match to return. For example,
    /// don't return any matches where confidence in matches is less than 70%.
    /// The default value is 80%.</p>
    pub face_match_threshold: std::option::Option<f32>,
    /// <p>A filter that specifies a quality bar for how much filtering is done to identify faces.
    /// Filtered faces aren't searched for in the collection. If you specify <code>AUTO</code>, Amazon Rekognition
    /// chooses the quality bar.  If you specify <code>LOW</code>,
    /// <code>MEDIUM</code>, or <code>HIGH</code>, filtering removes all faces that
    /// don’t meet the chosen quality bar.  
    ///
    /// The quality bar is based on a variety of common use cases. Low-quality
    /// detections can occur for a number of reasons. Some examples are an object that's misidentified
    /// as a face, a face that's too blurry, or a face with a
    /// pose that's too extreme to use. If you specify <code>NONE</code>, no
    /// filtering is performed.  The default value is <code>NONE</code>.
    /// </p>
    /// <p>To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.</p>
    pub quality_filter: std::option::Option<crate::model::QualityFilter>,
}
impl std::fmt::Debug for SearchFacesByImageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchFacesByImageInput");
        formatter.field("collection_id", &self.collection_id);
        formatter.field("image", &self.image);
        formatter.field("max_faces", &self.max_faces);
        formatter.field("face_match_threshold", &self.face_match_threshold);
        formatter.field("quality_filter", &self.quality_filter);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchFacesInput {
    /// <p>ID of the collection the face belongs to.</p>
    pub collection_id: std::option::Option<std::string::String>,
    /// <p>ID of a face to find matches for in the collection.</p>
    pub face_id: std::option::Option<std::string::String>,
    /// <p>Maximum number of faces to return. The operation returns the maximum number of faces
    /// with the highest confidence in the match.</p>
    pub max_faces: std::option::Option<i32>,
    /// <p>Optional value specifying the minimum confidence in the face match to return. For
    /// example, don't return any matches where confidence in matches is less than 70%.
    /// The default value is 80%.
    /// </p>
    pub face_match_threshold: std::option::Option<f32>,
}
impl std::fmt::Debug for SearchFacesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchFacesInput");
        formatter.field("collection_id", &self.collection_id);
        formatter.field("face_id", &self.face_id);
        formatter.field("max_faces", &self.max_faces);
        formatter.field("face_match_threshold", &self.face_match_threshold);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecognizeCelebritiesInput {
    /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
    /// Amazon Rekognition operations, passing base64-encoded image bytes is not supported. </p>
    /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to
    /// base64-encode image bytes passed using the <code>Bytes</code> field. For more information, see
    /// Images in the Amazon Rekognition developer guide.</p>
    pub image: std::option::Option<crate::model::Image>,
}
impl std::fmt::Debug for RecognizeCelebritiesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecognizeCelebritiesInput");
        formatter.field("image", &self.image);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>
    /// Amazon Resource Name (ARN) of the model, collection, or stream processor that contains the tags that you want a list of.
    /// </p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListStreamProcessorsInput {
    /// <p>If the previous response was incomplete (because there are more stream processors to retrieve), Amazon Rekognition Video
    /// returns a pagination token in the response. You can use this pagination token to retrieve the next set of stream processors. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Maximum number of stream processors you want Amazon Rekognition Video to return in the response. The default is 1000. </p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListStreamProcessorsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListStreamProcessorsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListFacesInput {
    /// <p>ID of the collection from which to list the faces.</p>
    pub collection_id: std::option::Option<std::string::String>,
    /// <p>If the previous response was incomplete (because there is more data to retrieve),
    /// Amazon Rekognition returns a pagination token in the response. You can use this pagination token to
    /// retrieve the next set of faces.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Maximum number of faces to return.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListFacesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListFacesInput");
        formatter.field("collection_id", &self.collection_id);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCollectionsInput {
    /// <p>Pagination token from the previous response.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Maximum number of collection IDs to return. </p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListCollectionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCollectionsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IndexFacesInput {
    /// <p>The ID of an existing collection to which you want to add the faces that are detected
    /// in the input images.</p>
    pub collection_id: std::option::Option<std::string::String>,
    /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
    /// Amazon Rekognition operations, passing base64-encoded image bytes isn't supported. </p>
    /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
    /// passed using the <code>Bytes</code> field.
    /// For more information, see Images in the Amazon Rekognition developer guide.</p>
    pub image: std::option::Option<crate::model::Image>,
    /// <p>The ID you want to assign to all the faces detected in the image.</p>
    pub external_image_id: std::option::Option<std::string::String>,
    /// <p>An array of facial attributes that you want to be returned. This can be the default
    /// list of attributes or all attributes. If you don't specify a value for <code>Attributes</code>
    /// or if you specify <code>["DEFAULT"]</code>, the API returns the following subset of facial
    /// attributes: <code>BoundingBox</code>, <code>Confidence</code>, <code>Pose</code>,
    /// <code>Quality</code>, and <code>Landmarks</code>. If you provide <code>["ALL"]</code>, all
    /// facial attributes are returned, but the operation takes longer to complete.</p>
    /// <p>If you provide both, <code>["ALL", "DEFAULT"]</code>, the service uses a logical AND
    /// operator to determine which attributes to return (in this case, all attributes). </p>
    pub detection_attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
    /// <p>The maximum number of faces to index. The value of <code>MaxFaces</code> must be greater
    /// than or equal to 1. <code>IndexFaces</code> returns no more than 100 detected faces in an
    /// image, even if you specify a larger value for <code>MaxFaces</code>.</p>
    /// <p>If <code>IndexFaces</code> detects more faces than the value of <code>MaxFaces</code>, the
    /// faces with the lowest quality are filtered out first. If there are still more faces than the
    /// value of <code>MaxFaces</code>, the faces with the smallest bounding boxes are filtered out
    /// (up to the number that's needed to satisfy the value of <code>MaxFaces</code>). Information
    /// about the unindexed faces is available in the <code>UnindexedFaces</code> array. </p>
    /// <p>The faces that are returned by <code>IndexFaces</code> are sorted by the largest face
    /// bounding box size to the smallest size, in descending order.</p>
    /// <p>
    /// <code>MaxFaces</code> can be used with a collection associated with any version of
    /// the face model.</p>
    pub max_faces: std::option::Option<i32>,
    /// <p>A filter that specifies a quality bar for how much filtering is done to identify faces.
    /// Filtered faces aren't indexed. If you specify <code>AUTO</code>, Amazon Rekognition chooses the quality bar.
    /// If you specify <code>LOW</code>,
    /// <code>MEDIUM</code>, or <code>HIGH</code>, filtering removes all faces that
    /// don’t meet the chosen quality bar.  The default value is <code>AUTO</code>.
    ///
    /// The quality bar is based on a variety of common use cases. Low-quality
    /// detections can occur for a number of reasons. Some examples are an object that's misidentified
    /// as a face, a face that's too blurry, or a face with a
    /// pose that's too extreme to use. If you specify <code>NONE</code>, no
    /// filtering is performed.
    /// </p>
    /// <p>To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.</p>
    pub quality_filter: std::option::Option<crate::model::QualityFilter>,
}
impl std::fmt::Debug for IndexFacesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IndexFacesInput");
        formatter.field("collection_id", &self.collection_id);
        formatter.field("image", &self.image);
        formatter.field("external_image_id", &self.external_image_id);
        formatter.field("detection_attributes", &self.detection_attributes);
        formatter.field("max_faces", &self.max_faces);
        formatter.field("quality_filter", &self.quality_filter);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetTextDetectionInput {
    /// <p>Job identifier for the text detection operation for which you want results returned.
    /// You get the job identifer from an initial call to <code>StartTextDetection</code>.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>If the previous response was incomplete (because there are more labels to retrieve), Amazon Rekognition Video returns
    /// a pagination token in the response. You can use this pagination token to retrieve the next set of text.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetTextDetectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetTextDetectionInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSegmentDetectionInput {
    /// <p>Job identifier for the text detection operation for which you want results returned.
    /// You get the job identifer from an initial call to <code>StartSegmentDetection</code>.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent
    /// request to retrieve the next set of text.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetSegmentDetectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSegmentDetectionInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPersonTrackingInput {
    /// <p>The identifier for a job that tracks persons in a video. You get the <code>JobId</code> from a call to <code>StartPersonTracking</code>.
    /// </p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
    /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
    /// The default value is 1000.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>If the previous response was incomplete (because there are more persons to retrieve), Amazon Rekognition Video returns a pagination
    /// token in the response. You can use this pagination token to retrieve the next set of persons. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Sort to use for elements in the <code>Persons</code> array. Use <code>TIMESTAMP</code> to sort array elements
    /// by the time persons are detected. Use <code>INDEX</code> to sort by the tracked persons.
    /// If you sort by <code>INDEX</code>, the array elements for each person are sorted by detection confidence.
    /// The default sort is by <code>TIMESTAMP</code>.</p>
    pub sort_by: std::option::Option<crate::model::PersonTrackingSortBy>,
}
impl std::fmt::Debug for GetPersonTrackingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPersonTrackingInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("sort_by", &self.sort_by);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLabelDetectionInput {
    /// <p>Job identifier for the label detection operation for which you want results returned. You get the job identifer from
    /// an initial call to <code>StartlabelDetection</code>.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
    /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
    /// The default value is 1000.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>If the previous response was incomplete (because there are more labels to retrieve), Amazon Rekognition Video returns a pagination
    /// token in the response. You can use this pagination token to retrieve the next set of labels. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Sort to use for elements in the <code>Labels</code> array.
    /// Use <code>TIMESTAMP</code> to sort array elements by the time labels are detected.
    /// Use <code>NAME</code> to alphabetically group elements for a label together.
    /// Within each label group, the array element are sorted by detection confidence.
    /// The default sort is by <code>TIMESTAMP</code>.</p>
    pub sort_by: std::option::Option<crate::model::LabelDetectionSortBy>,
}
impl std::fmt::Debug for GetLabelDetectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLabelDetectionInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("sort_by", &self.sort_by);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetFaceSearchInput {
    /// <p>The job identifer for the search request. You get the job identifier from an initial call to <code>StartFaceSearch</code>.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
    /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
    /// The default value is 1000.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>If the previous response was incomplete (because there is more search results to retrieve), Amazon Rekognition Video returns a pagination
    /// token in the response. You can use this pagination token to retrieve the next set of search results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Sort to use for grouping faces in the response. Use <code>TIMESTAMP</code> to group faces by the time
    /// that they are recognized. Use <code>INDEX</code> to sort by recognized faces. </p>
    pub sort_by: std::option::Option<crate::model::FaceSearchSortBy>,
}
impl std::fmt::Debug for GetFaceSearchInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetFaceSearchInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("sort_by", &self.sort_by);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetFaceDetectionInput {
    /// <p>Unique identifier for the face detection job. The <code>JobId</code> is returned from <code>StartFaceDetection</code>.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
    /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
    /// The default value is 1000.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>If the previous response was incomplete (because there are more faces to retrieve), Amazon Rekognition Video returns a pagination
    /// token in the response. You can use this pagination token to retrieve the next set of faces.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetFaceDetectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetFaceDetectionInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetContentModerationInput {
    /// <p>The identifier for the inappropriate, unwanted, or offensive content moderation job. Use <code>JobId</code> to identify the job in
    /// a subsequent call to <code>GetContentModeration</code>.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
    /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
    /// The default value is 1000.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Rekognition
    /// returns a pagination token in the response. You can use this pagination token
    /// to retrieve the next set of content moderation labels.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Sort to use for elements in the <code>ModerationLabelDetections</code> array.
    /// Use <code>TIMESTAMP</code> to sort array elements by the time labels are detected.
    /// Use <code>NAME</code> to alphabetically group elements for a label together.
    /// Within each label group, the array element are sorted by detection confidence.
    /// The default sort is by <code>TIMESTAMP</code>.</p>
    pub sort_by: std::option::Option<crate::model::ContentModerationSortBy>,
}
impl std::fmt::Debug for GetContentModerationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetContentModerationInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("sort_by", &self.sort_by);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCelebrityRecognitionInput {
    /// <p>Job identifier for the required celebrity recognition analysis. You can get the job identifer from
    /// a call to <code>StartCelebrityRecognition</code>.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
    /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
    /// The default value is 1000.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>If the previous response was incomplete (because there is more recognized celebrities to retrieve), Amazon Rekognition Video returns a pagination
    /// token in the response. You can use this pagination token to retrieve the next set of celebrities. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Sort to use for celebrities returned in <code>Celebrities</code> field. Specify <code>ID</code> to sort by the celebrity identifier,
    /// specify <code>TIMESTAMP</code> to sort by the time the celebrity was recognized.</p>
    pub sort_by: std::option::Option<crate::model::CelebrityRecognitionSortBy>,
}
impl std::fmt::Debug for GetCelebrityRecognitionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCelebrityRecognitionInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("sort_by", &self.sort_by);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCelebrityInfoInput {
    /// <p>The ID for the celebrity. You get the celebrity ID from a call to the <a>RecognizeCelebrities</a> operation,
    /// which recognizes celebrities in an image. </p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetCelebrityInfoInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCelebrityInfoInput");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectTextInput {
    /// <p>The input image as base64-encoded bytes or an Amazon S3 object. If you use the AWS CLI
    /// to call Amazon Rekognition operations, you can't pass image bytes. </p>
    /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
    /// passed using the <code>Bytes</code> field.
    /// For more information, see Images in the Amazon Rekognition developer guide.</p>
    pub image: std::option::Option<crate::model::Image>,
    /// <p>Optional parameters that let you set the criteria that the text must meet to be included in your response.</p>
    pub filters: std::option::Option<crate::model::DetectTextFilters>,
}
impl std::fmt::Debug for DetectTextInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectTextInput");
        formatter.field("image", &self.image);
        formatter.field("filters", &self.filters);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectProtectiveEquipmentInput {
    /// <p>The image in which you want to detect PPE on detected persons. The image can be passed as image bytes or you can
    /// reference an image stored in an Amazon S3 bucket. </p>
    pub image: std::option::Option<crate::model::Image>,
    /// <p>An array of PPE types that you want to summarize.</p>
    pub summarization_attributes:
        std::option::Option<crate::model::ProtectiveEquipmentSummarizationAttributes>,
}
impl std::fmt::Debug for DetectProtectiveEquipmentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectProtectiveEquipmentInput");
        formatter.field("image", &self.image);
        formatter.field("summarization_attributes", &self.summarization_attributes);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectModerationLabelsInput {
    /// <p>The input image as base64-encoded bytes or an S3 object.
    /// If you use the AWS CLI to call Amazon Rekognition operations,
    /// passing base64-encoded image bytes is not supported. </p>
    /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
    /// passed using the <code>Bytes</code> field.
    /// For more information, see Images in the Amazon Rekognition developer guide.</p>
    pub image: std::option::Option<crate::model::Image>,
    /// <p>Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't
    /// return any labels with a confidence level lower than this specified value.</p>
    /// <p>If you don't specify <code>MinConfidence</code>, the operation returns labels with
    /// confidence values greater than or equal to 50 percent.</p>
    pub min_confidence: std::option::Option<f32>,
    /// <p>Sets up the configuration for human evaluation, including the FlowDefinition
    /// the image will be sent to.</p>
    pub human_loop_config: std::option::Option<crate::model::HumanLoopConfig>,
}
impl std::fmt::Debug for DetectModerationLabelsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectModerationLabelsInput");
        formatter.field("image", &self.image);
        formatter.field("min_confidence", &self.min_confidence);
        formatter.field("human_loop_config", &self.human_loop_config);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectLabelsInput {
    /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
    /// Amazon Rekognition operations, passing image bytes is not supported. Images stored in an S3 Bucket do
    /// not need to be base64-encoded.</p>
    /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
    /// passed using the <code>Bytes</code> field.
    /// For more information, see Images in the Amazon Rekognition developer guide.</p>
    pub image: std::option::Option<crate::model::Image>,
    /// <p>Maximum number of labels you want the service to return in the response. The service
    /// returns the specified number of highest confidence labels. </p>
    pub max_labels: std::option::Option<i32>,
    /// <p>Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't
    /// return any labels with confidence lower than this specified value.</p>
    /// <p>If <code>MinConfidence</code> is not specified, the operation returns labels with a
    /// confidence values greater than or equal to 55 percent.</p>
    pub min_confidence: std::option::Option<f32>,
}
impl std::fmt::Debug for DetectLabelsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectLabelsInput");
        formatter.field("image", &self.image);
        formatter.field("max_labels", &self.max_labels);
        formatter.field("min_confidence", &self.min_confidence);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectFacesInput {
    /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
    /// Amazon Rekognition operations, passing base64-encoded image bytes is not supported. </p>
    /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
    /// passed using the <code>Bytes</code> field.
    /// For more information, see Images in the Amazon Rekognition developer guide.</p>
    pub image: std::option::Option<crate::model::Image>,
    /// <p>An array of facial attributes you want to be returned. This can be the default list of
    /// attributes or all attributes. If you don't specify a value for <code>Attributes</code> or if
    /// you specify <code>["DEFAULT"]</code>, the API returns the following subset of facial
    /// attributes: <code>BoundingBox</code>, <code>Confidence</code>, <code>Pose</code>,
    /// <code>Quality</code>, and <code>Landmarks</code>. If you provide <code>["ALL"]</code>, all
    /// facial attributes are returned, but the operation takes longer to complete.</p>
    /// <p>If you provide both, <code>["ALL", "DEFAULT"]</code>, the service uses a logical AND
    /// operator to determine which attributes to return (in this case, all attributes). </p>
    pub attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
}
impl std::fmt::Debug for DetectFacesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectFacesInput");
        formatter.field("image", &self.image);
        formatter.field("attributes", &self.attributes);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectCustomLabelsInput {
    /// <p>The ARN of the model version that you want to use.</p>
    pub project_version_arn: std::option::Option<std::string::String>,
    /// <p>Provides the input image either as bytes or an S3 object.</p>
    /// <p>You pass image bytes to an Amazon Rekognition API operation by using the <code>Bytes</code>
    /// property. For example, you would use the <code>Bytes</code> property to pass an image loaded
    /// from a local file system. Image bytes passed by using the <code>Bytes</code> property must be
    /// base64-encoded. Your code may not need to encode image bytes if you are using an AWS SDK to
    /// call Amazon Rekognition API operations. </p>
    ///
    /// <p>For more information, see Analyzing an Image Loaded from a Local File System
    /// in the Amazon Rekognition Developer Guide.</p>
    /// <p> You pass images stored in an S3 bucket to an Amazon Rekognition API operation by using the
    /// <code>S3Object</code> property. Images stored in an S3 bucket do not need to be
    /// base64-encoded.</p>
    /// <p>The region for the S3 bucket containing the S3 object must match the region you use for
    /// Amazon Rekognition operations.</p>
    /// <p>If you use the
    /// AWS
    /// CLI to call Amazon Rekognition operations, passing image bytes using the Bytes
    /// property is not supported. You must first upload the image to an Amazon S3 bucket and then
    /// call the operation using the S3Object property.</p>
    ///
    /// <p>For Amazon Rekognition to process an S3 object, the user must have permission to access the S3
    /// object. For more information, see Resource Based Policies in the Amazon Rekognition Developer Guide.
    /// </p>
    pub image: std::option::Option<crate::model::Image>,
    /// <p>Maximum number of results you want the service to return in the response.
    /// The service returns the specified number of highest confidence labels ranked from highest confidence
    /// to lowest.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>Specifies the minimum confidence level for the labels to return.
    /// <code>DetectCustomLabels</code> doesn't return any labels with a confidence value that's lower than
    /// this specified value. If you specify a
    /// value of 0, <code>DetectCustomLabels</code> returns all labels, regardless of the assumed
    /// threshold applied to each label.
    /// If you don't specify a value for <code>MinConfidence</code>,  <code>DetectCustomLabels</code>
    /// returns labels based on the assumed threshold of each label.</p>
    pub min_confidence: std::option::Option<f32>,
}
impl std::fmt::Debug for DetectCustomLabelsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectCustomLabelsInput");
        formatter.field("project_version_arn", &self.project_version_arn);
        formatter.field("image", &self.image);
        formatter.field("max_results", &self.max_results);
        formatter.field("min_confidence", &self.min_confidence);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeStreamProcessorInput {
    /// <p>Name of the stream processor for which you want information.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeStreamProcessorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeStreamProcessorInput");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProjectVersionsInput {
    /// <p>The Amazon Resource Name (ARN) of the project that contains the models you want to describe.</p>
    pub project_arn: std::option::Option<std::string::String>,
    /// <p>A list of model version names that you want to describe. You can add up to 10 model version names
    /// to the list. If you don't specify a value, all model descriptions are returned.  A version name is part of a
    /// model (ProjectVersion) ARN. For example, <code>my-model.2020-01-21T09.10.15</code> is the version name in the following ARN.
    /// <code>arn:aws:rekognition:us-east-1:123456789012:project/getting-started/version/<i>my-model.2020-01-21T09.10.15</i>/1234567890123</code>.</p>
    pub version_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>If the previous response was incomplete (because there is more
    /// results to retrieve), Amazon Rekognition Custom Labels returns a pagination token in the response.
    /// You can use this pagination token to retrieve the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per paginated call.
    /// The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException
    /// error occurs. The default value is 100. </p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribeProjectVersionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProjectVersionsInput");
        formatter.field("project_arn", &self.project_arn);
        formatter.field("version_names", &self.version_names);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProjectsInput {
    /// <p>If the previous response was incomplete (because there is more
    /// results to retrieve), Amazon Rekognition Custom Labels returns a pagination token in the response. You can use this pagination
    /// token to retrieve the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per paginated call. The largest value you can specify is 100.
    /// If you specify a value greater than 100, a ValidationException
    /// error occurs. The default value is 100. </p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribeProjectsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProjectsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeCollectionInput {
    /// <p>The ID of the collection to describe.</p>
    pub collection_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeCollectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeCollectionInput");
        formatter.field("collection_id", &self.collection_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteStreamProcessorInput {
    /// <p>The name of the stream processor you want to delete.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteStreamProcessorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteStreamProcessorInput");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProjectVersionInput {
    /// <p>The Amazon Resource Name (ARN) of the model version that you want to delete.</p>
    pub project_version_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteProjectVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProjectVersionInput");
        formatter.field("project_version_arn", &self.project_version_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProjectInput {
    /// <p>The Amazon Resource Name (ARN) of the project that you want to delete.</p>
    pub project_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteProjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProjectInput");
        formatter.field("project_arn", &self.project_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteFacesInput {
    /// <p>Collection from which to remove the specific faces.</p>
    pub collection_id: std::option::Option<std::string::String>,
    /// <p>An array of face IDs to delete.</p>
    pub face_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DeleteFacesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteFacesInput");
        formatter.field("collection_id", &self.collection_id);
        formatter.field("face_ids", &self.face_ids);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteCollectionInput {
    /// <p>ID of the collection to delete.</p>
    pub collection_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteCollectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteCollectionInput");
        formatter.field("collection_id", &self.collection_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateStreamProcessorInput {
    /// <p>Kinesis video stream stream that provides the source streaming video. If you are using the AWS CLI, the parameter name is <code>StreamProcessorInput</code>.</p>
    pub input: std::option::Option<crate::model::StreamProcessorInput>,
    /// <p>Kinesis data stream stream to which Amazon Rekognition Video puts the analysis results. If you are using the AWS CLI, the parameter name is <code>StreamProcessorOutput</code>.</p>
    pub output: std::option::Option<crate::model::StreamProcessorOutput>,
    /// <p>An identifier you assign to the stream processor. You can use <code>Name</code> to
    /// manage the stream processor. For example, you can get the current status of the stream processor by calling <a>DescribeStreamProcessor</a>.
    /// <code>Name</code> is idempotent.
    /// </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Face recognition input parameters to be used by the stream processor. Includes the collection to use for face recognition and the face
    /// attributes to detect.</p>
    pub settings: std::option::Option<crate::model::StreamProcessorSettings>,
    /// <p>ARN of the IAM role that allows access to the stream processor.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>
    /// A set of tags (key-value pairs) that you want to attach to the stream processor.
    /// </p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for CreateStreamProcessorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateStreamProcessorInput");
        formatter.field("input", &self.input);
        formatter.field("output", &self.output);
        formatter.field("name", &self.name);
        formatter.field("settings", &self.settings);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProjectVersionInput {
    /// <p>The ARN of the Amazon Rekognition Custom Labels project that
    /// manages the model that you want to train.</p>
    pub project_arn: std::option::Option<std::string::String>,
    /// <p>A name for the version of the model. This value must be unique.</p>
    pub version_name: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 bucket location to store the results of training.
    /// The S3 bucket can be in any AWS account as long as the caller has
    /// <code>s3:PutObject</code> permissions on the S3 bucket.</p>
    pub output_config: std::option::Option<crate::model::OutputConfig>,
    /// <p>The dataset to use for training. </p>
    pub training_data: std::option::Option<crate::model::TrainingData>,
    /// <p>The dataset to use for testing.</p>
    pub testing_data: std::option::Option<crate::model::TestingData>,
    /// <p>
    /// A set of tags (key-value pairs) that you want to attach to the model.
    /// </p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The identifier for your AWS Key Management Service (AWS KMS) customer master key (CMK).
    /// You can supply the Amazon Resource Name (ARN) of your CMK, the ID of your CMK,
    /// an alias for your CMK, or an alias ARN.
    /// The key is used to encrypt training and test images copied into the service for model training.
    /// Your source images are unaffected. The key is also used to encrypt training results
    /// and manifest files written to the output Amazon S3 bucket (<code>OutputConfig</code>).</p>
    /// <p>If you choose to use your own CMK, you need the following permissions on the CMK.</p>
    /// <ul>
    /// <li>
    /// <p>kms:CreateGrant</p>
    /// </li>
    /// <li>
    /// <p>kms:DescribeKey</p>
    /// </li>
    /// <li>
    /// <p>kms:GenerateDataKey</p>
    /// </li>
    /// <li>
    /// <p>kms:Decrypt</p>
    /// </li>
    /// </ul>
    /// <p>If you don't specify a value for <code>KmsKeyId</code>, images copied into the service are encrypted
    /// using a key that AWS owns and manages.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateProjectVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProjectVersionInput");
        formatter.field("project_arn", &self.project_arn);
        formatter.field("version_name", &self.version_name);
        formatter.field("output_config", &self.output_config);
        formatter.field("training_data", &self.training_data);
        formatter.field("testing_data", &self.testing_data);
        formatter.field("tags", &self.tags);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProjectInput {
    /// <p>The name of the project to create.</p>
    pub project_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateProjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProjectInput");
        formatter.field("project_name", &self.project_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCollectionInput {
    /// <p>ID for the collection that you are creating.</p>
    pub collection_id: std::option::Option<std::string::String>,
    /// <p>
    /// A set of tags (key-value pairs) that you want to attach to the collection.
    /// </p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for CreateCollectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCollectionInput");
        formatter.field("collection_id", &self.collection_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompareFacesInput {
    /// <p>The input image as base64-encoded bytes or an S3 object.
    /// If you use the AWS CLI to call Amazon Rekognition operations,
    /// passing base64-encoded image bytes is not supported. </p>
    /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
    /// passed using the <code>Bytes</code> field.
    /// For more information, see Images in the Amazon Rekognition developer guide.</p>
    pub source_image: std::option::Option<crate::model::Image>,
    /// <p>The target image as base64-encoded bytes or an S3 object. If you use the AWS CLI to
    /// call Amazon Rekognition operations, passing base64-encoded image bytes is not supported.
    /// </p>
    /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
    /// passed using the <code>Bytes</code> field.
    /// For more information, see Images in the Amazon Rekognition developer guide.</p>
    pub target_image: std::option::Option<crate::model::Image>,
    /// <p>The minimum level of confidence in the face matches that a match must meet to be
    /// included in the <code>FaceMatches</code> array.</p>
    pub similarity_threshold: std::option::Option<f32>,
    /// <p>A filter that specifies a quality bar for how much filtering is done to identify faces.
    /// Filtered faces aren't compared. If you specify <code>AUTO</code>, Amazon Rekognition chooses the quality bar.
    /// If you specify <code>LOW</code>,
    /// <code>MEDIUM</code>, or <code>HIGH</code>, filtering removes all faces that
    /// don’t meet the chosen quality bar.
    ///
    /// The quality bar is based on a variety of common use cases. Low-quality
    /// detections can occur for a number of reasons. Some examples are an object that's misidentified
    /// as a face, a face that's too blurry, or a face with a
    /// pose that's too extreme to use. If you specify <code>NONE</code>, no
    /// filtering is performed. The default value is <code>NONE</code>.
    /// </p>
    /// <p>To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.</p>
    pub quality_filter: std::option::Option<crate::model::QualityFilter>,
}
impl std::fmt::Debug for CompareFacesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CompareFacesInput");
        formatter.field("source_image", &self.source_image);
        formatter.field("target_image", &self.target_image);
        formatter.field("similarity_threshold", &self.similarity_threshold);
        formatter.field("quality_filter", &self.quality_filter);
        formatter.finish()
    }
}
