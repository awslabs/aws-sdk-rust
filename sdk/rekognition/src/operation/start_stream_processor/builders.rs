// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::start_stream_processor::_start_stream_processor_output::StartStreamProcessorOutputBuilder;

pub use crate::operation::start_stream_processor::_start_stream_processor_input::StartStreamProcessorInputBuilder;

impl StartStreamProcessorInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::start_stream_processor::StartStreamProcessorOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::start_stream_processor::StartStreamProcessorError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.start_stream_processor();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `StartStreamProcessor`.
///
/// <p>Starts processing a stream processor. You create a stream processor by calling <code>CreateStreamProcessor</code>. To tell <code>StartStreamProcessor</code> which stream processor to start, use the value of the <code>Name</code> field specified in the call to <code>CreateStreamProcessor</code>.</p>
/// <p>If you are using a label detection stream processor to detect labels, you need to provide a <code>Start selector</code> and a <code>Stop selector</code> to determine the length of the stream processing time.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct StartStreamProcessorFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::start_stream_processor::builders::StartStreamProcessorInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::start_stream_processor::StartStreamProcessorOutput,
        crate::operation::start_stream_processor::StartStreamProcessorError,
    > for StartStreamProcessorFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::start_stream_processor::StartStreamProcessorOutput,
            crate::operation::start_stream_processor::StartStreamProcessorError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl StartStreamProcessorFluentBuilder {
    /// Creates a new `StartStreamProcessor`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the StartStreamProcessor as a reference.
    pub fn as_input(&self) -> &crate::operation::start_stream_processor::builders::StartStreamProcessorInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::start_stream_processor::StartStreamProcessorOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::start_stream_processor::StartStreamProcessorError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::start_stream_processor::StartStreamProcessor::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::start_stream_processor::StartStreamProcessor::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::start_stream_processor::StartStreamProcessorOutput,
        crate::operation::start_stream_processor::StartStreamProcessorError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The name of the stream processor to start processing.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>The name of the stream processor to start processing.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>The name of the stream processor to start processing.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p> Specifies the starting point in the Kinesis stream to start processing. You can use the producer timestamp or the fragment number. If you use the producer timestamp, you must put the time in milliseconds. For more information about fragment numbers, see <a href="https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_reader_Fragment.html">Fragment</a>. </p>
    /// <p>This is a required parameter for label detection stream processors and should not be used to start a face search stream processor.</p>
    pub fn start_selector(mut self, input: crate::types::StreamProcessingStartSelector) -> Self {
        self.inner = self.inner.start_selector(input);
        self
    }
    /// <p> Specifies the starting point in the Kinesis stream to start processing. You can use the producer timestamp or the fragment number. If you use the producer timestamp, you must put the time in milliseconds. For more information about fragment numbers, see <a href="https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_reader_Fragment.html">Fragment</a>. </p>
    /// <p>This is a required parameter for label detection stream processors and should not be used to start a face search stream processor.</p>
    pub fn set_start_selector(mut self, input: ::std::option::Option<crate::types::StreamProcessingStartSelector>) -> Self {
        self.inner = self.inner.set_start_selector(input);
        self
    }
    /// <p> Specifies the starting point in the Kinesis stream to start processing. You can use the producer timestamp or the fragment number. If you use the producer timestamp, you must put the time in milliseconds. For more information about fragment numbers, see <a href="https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_reader_Fragment.html">Fragment</a>. </p>
    /// <p>This is a required parameter for label detection stream processors and should not be used to start a face search stream processor.</p>
    pub fn get_start_selector(&self) -> &::std::option::Option<crate::types::StreamProcessingStartSelector> {
        self.inner.get_start_selector()
    }
    /// <p> Specifies when to stop processing the stream. You can specify a maximum amount of time to process the video. </p>
    /// <p>This is a required parameter for label detection stream processors and should not be used to start a face search stream processor.</p>
    pub fn stop_selector(mut self, input: crate::types::StreamProcessingStopSelector) -> Self {
        self.inner = self.inner.stop_selector(input);
        self
    }
    /// <p> Specifies when to stop processing the stream. You can specify a maximum amount of time to process the video. </p>
    /// <p>This is a required parameter for label detection stream processors and should not be used to start a face search stream processor.</p>
    pub fn set_stop_selector(mut self, input: ::std::option::Option<crate::types::StreamProcessingStopSelector>) -> Self {
        self.inner = self.inner.set_stop_selector(input);
        self
    }
    /// <p> Specifies when to stop processing the stream. You can specify a maximum amount of time to process the video. </p>
    /// <p>This is a required parameter for label detection stream processors and should not be used to start a face search stream processor.</p>
    pub fn get_stop_selector(&self) -> &::std::option::Option<crate::types::StreamProcessingStopSelector> {
        self.inner.get_stop_selector()
    }
}
