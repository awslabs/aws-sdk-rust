// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::start_segment_detection::_start_segment_detection_output::StartSegmentDetectionOutputBuilder;

pub use crate::operation::start_segment_detection::_start_segment_detection_input::StartSegmentDetectionInputBuilder;

/// Fluent builder constructing a request to `StartSegmentDetection`.
///
/// <p>Starts asynchronous detection of segment detection in a stored video.</p>
/// <p>Amazon Rekognition Video can detect segments in a video stored in an Amazon S3 bucket. Use <code>Video</code> to specify the bucket name and the filename of the video. <code>StartSegmentDetection</code> returns a job identifier (<code>JobId</code>) which you use to get the results of the operation. When segment detection is finished, Amazon Rekognition Video publishes a completion status to the Amazon Simple Notification Service topic that you specify in <code>NotificationChannel</code>.</p>
/// <p>You can use the <code>Filters</code> (<code>StartSegmentDetectionFilters</code>) input parameter to specify the minimum detection confidence returned in the response. Within <code>Filters</code>, use <code>ShotFilter</code> (<code>StartShotDetectionFilter</code>) to filter detected shots. Use <code>TechnicalCueFilter</code> (<code>StartTechnicalCueDetectionFilter</code>) to filter technical cues. </p>
/// <p>To get the results of the segment detection operation, first check that the status value published to the Amazon SNS topic is <code>SUCCEEDED</code>. if so, call <code>GetSegmentDetection</code> and pass the job identifier (<code>JobId</code>) from the initial call to <code>StartSegmentDetection</code>. </p>
/// <p>For more information, see Detecting video segments in stored video in the Amazon Rekognition Developer Guide.</p>
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct StartSegmentDetectionFluentBuilder {
    handle: std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::start_segment_detection::builders::StartSegmentDetectionInputBuilder,
}
impl StartSegmentDetectionFluentBuilder {
    /// Creates a new `StartSegmentDetection`.
    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: Default::default(),
        }
    }

    /// Consume this builder, creating a customizable operation that can be modified before being
    /// sent. The operation's inner [http::Request] can be modified as well.
    pub async fn customize(
        self,
    ) -> std::result::Result<
        crate::client::customize::CustomizableOperation<
            crate::operation::start_segment_detection::StartSegmentDetection,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::result::SdkError<
            crate::operation::start_segment_detection::StartSegmentDetectionError,
        >,
    > {
        let handle = self.handle.clone();
        let operation = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        Ok(crate::client::customize::CustomizableOperation { handle, operation })
    }

    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> std::result::Result<
        crate::operation::start_segment_detection::StartSegmentDetectionOutput,
        aws_smithy_http::result::SdkError<
            crate::operation::start_segment_detection::StartSegmentDetectionError,
        >,
    > {
        let op = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&self.handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        self.handle.client.call(op).await
    }
    /// <p>Video file stored in an Amazon S3 bucket. Amazon Rekognition video start operations such as <code>StartLabelDetection</code> use <code>Video</code> to specify a video for analysis. The supported file formats are .mp4, .mov and .avi.</p>
    pub fn video(mut self, input: crate::types::Video) -> Self {
        self.inner = self.inner.video(input);
        self
    }
    /// <p>Video file stored in an Amazon S3 bucket. Amazon Rekognition video start operations such as <code>StartLabelDetection</code> use <code>Video</code> to specify a video for analysis. The supported file formats are .mp4, .mov and .avi.</p>
    pub fn set_video(mut self, input: std::option::Option<crate::types::Video>) -> Self {
        self.inner = self.inner.set_video(input);
        self
    }
    /// <p>Idempotent token used to identify the start request. If you use the same token with multiple <code>StartSegmentDetection</code> requests, the same <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
    pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.client_request_token(input.into());
        self
    }
    /// <p>Idempotent token used to identify the start request. If you use the same token with multiple <code>StartSegmentDetection</code> requests, the same <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
    pub fn set_client_request_token(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.inner = self.inner.set_client_request_token(input);
        self
    }
    /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the segment detection operation. Note that the Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
    pub fn notification_channel(mut self, input: crate::types::NotificationChannel) -> Self {
        self.inner = self.inner.notification_channel(input);
        self
    }
    /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the segment detection operation. Note that the Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
    pub fn set_notification_channel(
        mut self,
        input: std::option::Option<crate::types::NotificationChannel>,
    ) -> Self {
        self.inner = self.inner.set_notification_channel(input);
        self
    }
    /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic. For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
    pub fn job_tag(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.job_tag(input.into());
        self
    }
    /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic. For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
    pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_job_tag(input);
        self
    }
    /// <p>Filters for technical cue or shot detection.</p>
    pub fn filters(mut self, input: crate::types::StartSegmentDetectionFilters) -> Self {
        self.inner = self.inner.filters(input);
        self
    }
    /// <p>Filters for technical cue or shot detection.</p>
    pub fn set_filters(
        mut self,
        input: std::option::Option<crate::types::StartSegmentDetectionFilters>,
    ) -> Self {
        self.inner = self.inner.set_filters(input);
        self
    }
    /// Appends an item to `SegmentTypes`.
    ///
    /// To override the contents of this collection use [`set_segment_types`](Self::set_segment_types).
    ///
    /// <p>An array of segment types to detect in the video. Valid values are TECHNICAL_CUE and SHOT.</p>
    pub fn segment_types(mut self, input: crate::types::SegmentType) -> Self {
        self.inner = self.inner.segment_types(input);
        self
    }
    /// <p>An array of segment types to detect in the video. Valid values are TECHNICAL_CUE and SHOT.</p>
    pub fn set_segment_types(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::SegmentType>>,
    ) -> Self {
        self.inner = self.inner.set_segment_types(input);
        self
    }
}
