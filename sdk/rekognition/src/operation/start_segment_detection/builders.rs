// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::start_segment_detection::_start_segment_detection_output::StartSegmentDetectionOutputBuilder;

pub use crate::operation::start_segment_detection::_start_segment_detection_input::StartSegmentDetectionInputBuilder;

impl StartSegmentDetectionInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::start_segment_detection::StartSegmentDetectionOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::start_segment_detection::StartSegmentDetectionError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.start_segment_detection();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `StartSegmentDetection`.
///
/// <p>Starts asynchronous detection of segment detection in a stored video.</p>
/// <p>Amazon Rekognition Video can detect segments in a video stored in an Amazon S3 bucket. Use <code>Video</code> to specify the bucket name and the filename of the video. <code>StartSegmentDetection</code> returns a job identifier (<code>JobId</code>) which you use to get the results of the operation. When segment detection is finished, Amazon Rekognition Video publishes a completion status to the Amazon Simple Notification Service topic that you specify in <code>NotificationChannel</code>.</p>
/// <p>You can use the <code>Filters</code> (<code>StartSegmentDetectionFilters</code>) input parameter to specify the minimum detection confidence returned in the response. Within <code>Filters</code>, use <code>ShotFilter</code> (<code>StartShotDetectionFilter</code>) to filter detected shots. Use <code>TechnicalCueFilter</code> (<code>StartTechnicalCueDetectionFilter</code>) to filter technical cues. </p>
/// <p>To get the results of the segment detection operation, first check that the status value published to the Amazon SNS topic is <code>SUCCEEDED</code>. if so, call <code>GetSegmentDetection</code> and pass the job identifier (<code>JobId</code>) from the initial call to <code>StartSegmentDetection</code>. </p>
/// <p>For more information, see Detecting video segments in stored video in the Amazon Rekognition Developer Guide.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct StartSegmentDetectionFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::start_segment_detection::builders::StartSegmentDetectionInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::start_segment_detection::StartSegmentDetectionOutput,
        crate::operation::start_segment_detection::StartSegmentDetectionError,
    > for StartSegmentDetectionFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::start_segment_detection::StartSegmentDetectionOutput,
            crate::operation::start_segment_detection::StartSegmentDetectionError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl StartSegmentDetectionFluentBuilder {
    /// Creates a new `StartSegmentDetection`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the StartSegmentDetection as a reference.
    pub fn as_input(&self) -> &crate::operation::start_segment_detection::builders::StartSegmentDetectionInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::start_segment_detection::StartSegmentDetectionOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::start_segment_detection::StartSegmentDetectionError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::start_segment_detection::StartSegmentDetection::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::start_segment_detection::StartSegmentDetection::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::start_segment_detection::StartSegmentDetectionOutput,
        crate::operation::start_segment_detection::StartSegmentDetectionError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>Video file stored in an Amazon S3 bucket. Amazon Rekognition video start operations such as <code>StartLabelDetection</code> use <code>Video</code> to specify a video for analysis. The supported file formats are .mp4, .mov and .avi.</p>
    pub fn video(mut self, input: crate::types::Video) -> Self {
        self.inner = self.inner.video(input);
        self
    }
    /// <p>Video file stored in an Amazon S3 bucket. Amazon Rekognition video start operations such as <code>StartLabelDetection</code> use <code>Video</code> to specify a video for analysis. The supported file formats are .mp4, .mov and .avi.</p>
    pub fn set_video(mut self, input: ::std::option::Option<crate::types::Video>) -> Self {
        self.inner = self.inner.set_video(input);
        self
    }
    /// <p>Video file stored in an Amazon S3 bucket. Amazon Rekognition video start operations such as <code>StartLabelDetection</code> use <code>Video</code> to specify a video for analysis. The supported file formats are .mp4, .mov and .avi.</p>
    pub fn get_video(&self) -> &::std::option::Option<crate::types::Video> {
        self.inner.get_video()
    }
    /// <p>Idempotent token used to identify the start request. If you use the same token with multiple <code>StartSegmentDetection</code> requests, the same <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
    pub fn client_request_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_request_token(input.into());
        self
    }
    /// <p>Idempotent token used to identify the start request. If you use the same token with multiple <code>StartSegmentDetection</code> requests, the same <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
    pub fn set_client_request_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_request_token(input);
        self
    }
    /// <p>Idempotent token used to identify the start request. If you use the same token with multiple <code>StartSegmentDetection</code> requests, the same <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
    pub fn get_client_request_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_request_token()
    }
    /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the segment detection operation. Note that the Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
    pub fn notification_channel(mut self, input: crate::types::NotificationChannel) -> Self {
        self.inner = self.inner.notification_channel(input);
        self
    }
    /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the segment detection operation. Note that the Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
    pub fn set_notification_channel(mut self, input: ::std::option::Option<crate::types::NotificationChannel>) -> Self {
        self.inner = self.inner.set_notification_channel(input);
        self
    }
    /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the segment detection operation. Note that the Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
    pub fn get_notification_channel(&self) -> &::std::option::Option<crate::types::NotificationChannel> {
        self.inner.get_notification_channel()
    }
    /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic. For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
    pub fn job_tag(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.job_tag(input.into());
        self
    }
    /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic. For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
    pub fn set_job_tag(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_job_tag(input);
        self
    }
    /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic. For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
    pub fn get_job_tag(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_job_tag()
    }
    /// <p>Filters for technical cue or shot detection.</p>
    pub fn filters(mut self, input: crate::types::StartSegmentDetectionFilters) -> Self {
        self.inner = self.inner.filters(input);
        self
    }
    /// <p>Filters for technical cue or shot detection.</p>
    pub fn set_filters(mut self, input: ::std::option::Option<crate::types::StartSegmentDetectionFilters>) -> Self {
        self.inner = self.inner.set_filters(input);
        self
    }
    /// <p>Filters for technical cue or shot detection.</p>
    pub fn get_filters(&self) -> &::std::option::Option<crate::types::StartSegmentDetectionFilters> {
        self.inner.get_filters()
    }
    /// Appends an item to `SegmentTypes`.
    ///
    /// To override the contents of this collection use [`set_segment_types`](Self::set_segment_types).
    ///
    /// <p>An array of segment types to detect in the video. Valid values are TECHNICAL_CUE and SHOT.</p>
    pub fn segment_types(mut self, input: crate::types::SegmentType) -> Self {
        self.inner = self.inner.segment_types(input);
        self
    }
    /// <p>An array of segment types to detect in the video. Valid values are TECHNICAL_CUE and SHOT.</p>
    pub fn set_segment_types(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::SegmentType>>) -> Self {
        self.inner = self.inner.set_segment_types(input);
        self
    }
    /// <p>An array of segment types to detect in the video. Valid values are TECHNICAL_CUE and SHOT.</p>
    pub fn get_segment_types(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::SegmentType>> {
        self.inner.get_segment_types()
    }
}
