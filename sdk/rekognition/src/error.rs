// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `CompareFaces` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CompareFacesError {
    /// Kind of error that occurred.
    pub kind: CompareFacesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CompareFaces` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CompareFacesErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The input image size exceeds the allowed limit. If you are calling
    /// DetectProtectiveEquipment, the image size or resolution exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ImageTooLargeException(crate::error::ImageTooLargeException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The provided image format is not supported. </p>
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CompareFacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CompareFacesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CompareFacesError {
    fn code(&self) -> Option<&str> {
        CompareFacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CompareFacesError {
    /// Creates a new `CompareFacesError`.
    pub fn new(kind: CompareFacesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CompareFacesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CompareFacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CompareFacesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CompareFacesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CompareFacesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CompareFacesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CompareFacesErrorKind::ImageTooLargeException`.
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(&self.kind, CompareFacesErrorKind::ImageTooLargeException(_))
    }
    /// Returns `true` if the error kind is `CompareFacesErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CompareFacesErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CompareFacesErrorKind::InvalidImageFormatException`.
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            CompareFacesErrorKind::InvalidImageFormatException(_)
        )
    }
    /// Returns `true` if the error kind is `CompareFacesErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CompareFacesErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `CompareFacesErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            CompareFacesErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `CompareFacesErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CompareFacesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CompareFacesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CompareFacesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CompareFacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CompareFacesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CompareFacesErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            CompareFacesErrorKind::InternalServerError(_inner) => Some(_inner),
            CompareFacesErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            CompareFacesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CompareFacesErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            CompareFacesErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            CompareFacesErrorKind::ThrottlingException(_inner) => Some(_inner),
            CompareFacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateCollection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCollectionError {
    /// Kind of error that occurred.
    pub kind: CreateCollectionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateCollection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCollectionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>A resource with the specified ID already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p></p>
    ///
    ///
    /// <p>The size of the collection exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCollectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCollectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateCollectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateCollectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateCollectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateCollectionErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateCollectionErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateCollectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateCollectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCollectionError {
    fn code(&self) -> Option<&str> {
        CreateCollectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCollectionError {
    /// Creates a new `CreateCollectionError`.
    pub fn new(kind: CreateCollectionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateCollectionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCollectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateCollectionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCollectionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateCollectionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCollectionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCollectionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCollectionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCollectionErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCollectionErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCollectionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateCollectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCollectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateCollectionErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateCollectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateCollectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            CreateCollectionErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateCollectionErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateCollectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateCollectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateDataset` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDatasetError {
    /// Kind of error that occurred.
    pub kind: CreateDatasetErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateDataset` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDatasetErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>A resource with the specified ID already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDatasetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDatasetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateDatasetErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateDatasetErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateDatasetErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            CreateDatasetErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDatasetErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            CreateDatasetErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateDatasetErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateDatasetErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDatasetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDatasetError {
    fn code(&self) -> Option<&str> {
        CreateDatasetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDatasetError {
    /// Creates a new `CreateDatasetError`.
    pub fn new(kind: CreateDatasetErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateDatasetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDatasetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateDatasetError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDatasetErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateDatasetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateDatasetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateDatasetErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CreateDatasetErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateDatasetErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDatasetErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDatasetErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDatasetErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDatasetErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDatasetErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDatasetErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDatasetErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDatasetErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDatasetErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDatasetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDatasetErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDatasetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateDatasetErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateDatasetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDatasetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateDatasetErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateDatasetErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateDatasetErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            CreateDatasetErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDatasetErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            CreateDatasetErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateDatasetErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateDatasetErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDatasetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateProject` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProjectError {
    /// Kind of error that occurred.
    pub kind: CreateProjectErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateProject` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProjectErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProjectErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateProjectError {
    fn code(&self) -> Option<&str> {
        CreateProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProjectError {
    /// Creates a new `CreateProjectError`.
    pub fn new(kind: CreateProjectErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateProjectError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateProjectError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProjectErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateProjectErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateProjectErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateProjectErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CreateProjectErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateProjectErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProjectErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProjectErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProjectErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProjectErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateProjectErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProjectErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateProjectErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateProjectErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateProjectErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateProjectErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            CreateProjectErrorKind::ResourceInUseException(_inner) => Some(_inner),
            CreateProjectErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateProjectVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProjectVersionError {
    /// Kind of error that occurred.
    pub kind: CreateProjectVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateProjectVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProjectVersionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p></p>
    ///
    ///
    /// <p>The size of the collection exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateProjectVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProjectVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateProjectVersionErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateProjectVersionError {
    fn code(&self) -> Option<&str> {
        CreateProjectVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProjectVersionError {
    /// Creates a new `CreateProjectVersionError`.
    pub fn new(kind: CreateProjectVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateProjectVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProjectVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateProjectVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProjectVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateProjectVersionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProjectVersionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProjectVersionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProjectVersionErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProjectVersionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProjectVersionErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProjectVersionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProjectVersionErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProjectVersionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateProjectVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProjectVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            CreateProjectVersionErrorKind::ResourceInUseException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateStreamProcessor` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateStreamProcessorError {
    /// Kind of error that occurred.
    pub kind: CreateStreamProcessorErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateStreamProcessor` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateStreamProcessorErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p></p>
    ///
    ///
    /// <p>The size of the collection exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateStreamProcessorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateStreamProcessorErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateStreamProcessorErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateStreamProcessorError {
    fn code(&self) -> Option<&str> {
        CreateStreamProcessorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateStreamProcessorError {
    /// Creates a new `CreateStreamProcessorError`.
    pub fn new(kind: CreateStreamProcessorErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateStreamProcessorError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateStreamProcessorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateStreamProcessorError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateStreamProcessorErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateStreamProcessorErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateStreamProcessorErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `CreateStreamProcessorErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateStreamProcessorErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateStreamProcessorErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateStreamProcessorErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateStreamProcessorErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateStreamProcessorErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateStreamProcessorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateStreamProcessorErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            CreateStreamProcessorErrorKind::ResourceInUseException(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteCollection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCollectionError {
    /// Kind of error that occurred.
    pub kind: DeleteCollectionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteCollection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCollectionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCollectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCollectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteCollectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteCollectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteCollectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DeleteCollectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteCollectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteCollectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCollectionError {
    fn code(&self) -> Option<&str> {
        DeleteCollectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCollectionError {
    /// Creates a new `DeleteCollectionError`.
    pub fn new(kind: DeleteCollectionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteCollectionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCollectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteCollectionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCollectionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteCollectionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCollectionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCollectionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCollectionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCollectionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCollectionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCollectionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCollectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCollectionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCollectionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCollectionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCollectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteCollectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCollectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteCollectionErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteCollectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteCollectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DeleteCollectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteCollectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteCollectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteDataset` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDatasetError {
    /// Kind of error that occurred.
    pub kind: DeleteDatasetErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteDataset` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDatasetErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDatasetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDatasetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteDatasetErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteDatasetErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteDatasetErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteDatasetErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            DeleteDatasetErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteDatasetErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteDatasetErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteDatasetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDatasetError {
    fn code(&self) -> Option<&str> {
        DeleteDatasetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDatasetError {
    /// Creates a new `DeleteDatasetError`.
    pub fn new(kind: DeleteDatasetErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteDatasetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDatasetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteDatasetError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDatasetErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteDatasetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteDatasetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteDatasetErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteDatasetErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DeleteDatasetErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDatasetErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDatasetErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDatasetErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDatasetErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDatasetErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDatasetErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDatasetErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDatasetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDatasetErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDatasetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteDatasetErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteDatasetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDatasetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteDatasetErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteDatasetErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteDatasetErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteDatasetErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            DeleteDatasetErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteDatasetErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteDatasetErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteDatasetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteFaces` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFacesError {
    /// Kind of error that occurred.
    pub kind: DeleteFacesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteFaces` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFacesErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFacesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteFacesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteFacesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteFacesErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            DeleteFacesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteFacesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteFacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteFacesError {
    fn code(&self) -> Option<&str> {
        DeleteFacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFacesError {
    /// Creates a new `DeleteFacesError`.
    pub fn new(kind: DeleteFacesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteFacesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteFacesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFacesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteFacesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteFacesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteFacesErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteFacesErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DeleteFacesErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFacesErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFacesErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFacesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFacesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFacesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFacesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteFacesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteFacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFacesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteFacesErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteFacesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteFacesErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            DeleteFacesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteFacesErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteFacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteProject` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProjectError {
    /// Kind of error that occurred.
    pub kind: DeleteProjectErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteProject` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProjectErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProjectErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteProjectError {
    fn code(&self) -> Option<&str> {
        DeleteProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProjectError {
    /// Creates a new `DeleteProjectError`.
    pub fn new(kind: DeleteProjectErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteProjectError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteProjectError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProjectErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteProjectErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteProjectErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteProjectErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteProjectErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DeleteProjectErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProjectErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProjectErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProjectErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProjectErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteProjectErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProjectErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteProjectErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteProjectErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteProjectErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            DeleteProjectErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteProjectErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteProjectErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteProjectVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProjectVersionError {
    /// Kind of error that occurred.
    pub kind: DeleteProjectVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteProjectVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProjectVersionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteProjectVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProjectVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteProjectVersionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteProjectVersionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProjectVersionErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteProjectVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteProjectVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteProjectVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteProjectVersionError {
    fn code(&self) -> Option<&str> {
        DeleteProjectVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProjectVersionError {
    /// Creates a new `DeleteProjectVersionError`.
    pub fn new(kind: DeleteProjectVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteProjectVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProjectVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteProjectVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProjectVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteProjectVersionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProjectVersionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProjectVersionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProjectVersionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProjectVersionErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProjectVersionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProjectVersionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteProjectVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProjectVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteProjectVersionErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteProjectVersionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DeleteProjectVersionErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteProjectVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteProjectVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteProjectVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteStreamProcessor` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteStreamProcessorError {
    /// Kind of error that occurred.
    pub kind: DeleteStreamProcessorErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteStreamProcessor` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteStreamProcessorErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteStreamProcessorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteStreamProcessorErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteStreamProcessorErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteStreamProcessorErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DeleteStreamProcessorErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteStreamProcessorErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteStreamProcessorErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteStreamProcessorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteStreamProcessorError {
    fn code(&self) -> Option<&str> {
        DeleteStreamProcessorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteStreamProcessorError {
    /// Creates a new `DeleteStreamProcessorError`.
    pub fn new(kind: DeleteStreamProcessorErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteStreamProcessorError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteStreamProcessorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteStreamProcessorError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteStreamProcessorErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteStreamProcessorErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteStreamProcessorErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteStreamProcessorErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteStreamProcessorErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteStreamProcessorErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteStreamProcessorErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteStreamProcessorErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteStreamProcessorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteStreamProcessorErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteStreamProcessorErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteStreamProcessorErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DeleteStreamProcessorErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteStreamProcessorErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteStreamProcessorErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteStreamProcessorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeCollection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCollectionError {
    /// Kind of error that occurred.
    pub kind: DescribeCollectionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeCollection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCollectionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCollectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCollectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeCollectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeCollectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeCollectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCollectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeCollectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeCollectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeCollectionError {
    fn code(&self) -> Option<&str> {
        DescribeCollectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCollectionError {
    /// Creates a new `DescribeCollectionError`.
    pub fn new(kind: DescribeCollectionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeCollectionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCollectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeCollectionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCollectionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeCollectionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCollectionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCollectionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCollectionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCollectionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCollectionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCollectionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCollectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCollectionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCollectionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCollectionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCollectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeCollectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCollectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeCollectionErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeCollectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeCollectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DescribeCollectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeCollectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeCollectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeDataset` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDatasetError {
    /// Kind of error that occurred.
    pub kind: DescribeDatasetErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeDataset` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDatasetErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDatasetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDatasetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeDatasetErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeDatasetErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeDatasetErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDatasetErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeDatasetErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDatasetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDatasetError {
    fn code(&self) -> Option<&str> {
        DescribeDatasetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDatasetError {
    /// Creates a new `DescribeDatasetError`.
    pub fn new(kind: DescribeDatasetErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeDatasetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDatasetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeDatasetError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDatasetErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeDatasetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDatasetErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDatasetErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DescribeDatasetErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DescribeDatasetErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDatasetErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDatasetErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDatasetErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDatasetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDatasetErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDatasetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeDatasetErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DescribeDatasetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDatasetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeDatasetErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeDatasetErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeDatasetErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DescribeDatasetErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDatasetErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDatasetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeProjects` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeProjectsError {
    /// Kind of error that occurred.
    pub kind: DescribeProjectsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeProjects` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeProjectsErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeProjectsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeProjectsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeProjectsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeProjectsErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            DescribeProjectsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeProjectsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProjectsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeProjectsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeProjectsError {
    fn code(&self) -> Option<&str> {
        DescribeProjectsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeProjectsError {
    /// Creates a new `DescribeProjectsError`.
    pub fn new(kind: DescribeProjectsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeProjectsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeProjectsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeProjectsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeProjectsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeProjectsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProjectsErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectsErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProjectsErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectsErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProjectsErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectsErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProjectsErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProjectsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeProjectsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeProjectsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeProjectsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeProjectsErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            DescribeProjectsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeProjectsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DescribeProjectsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeProjectsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeProjectVersions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeProjectVersionsError {
    /// Kind of error that occurred.
    pub kind: DescribeProjectVersionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeProjectVersions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeProjectVersionsErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeProjectVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeProjectVersionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeProjectVersionsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeProjectVersionsErrorKind::InvalidPaginationTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProjectVersionsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeProjectVersionsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProjectVersionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeProjectVersionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeProjectVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeProjectVersionsError {
    fn code(&self) -> Option<&str> {
        DescribeProjectVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeProjectVersionsError {
    /// Creates a new `DescribeProjectVersionsError`.
    pub fn new(kind: DescribeProjectVersionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeProjectVersionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeProjectVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeProjectVersionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeProjectVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeProjectVersionsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProjectVersionsErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProjectVersionsErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProjectVersionsErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProjectVersionsErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProjectVersionsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProjectVersionsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeProjectVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeProjectVersionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeProjectVersionsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeProjectVersionsErrorKind::InvalidPaginationTokenException(_inner) => {
                Some(_inner)
            }
            DescribeProjectVersionsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeProjectVersionsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DescribeProjectVersionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeProjectVersionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeProjectVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeStreamProcessor` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStreamProcessorError {
    /// Kind of error that occurred.
    pub kind: DescribeStreamProcessorErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeStreamProcessor` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStreamProcessorErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStreamProcessorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStreamProcessorErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeStreamProcessorErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeStreamProcessorErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeStreamProcessorErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeStreamProcessorErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeStreamProcessorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeStreamProcessorError {
    fn code(&self) -> Option<&str> {
        DescribeStreamProcessorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStreamProcessorError {
    /// Creates a new `DescribeStreamProcessorError`.
    pub fn new(kind: DescribeStreamProcessorErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeStreamProcessorError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStreamProcessorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeStreamProcessorError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStreamProcessorErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeStreamProcessorErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamProcessorErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeStreamProcessorErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamProcessorErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeStreamProcessorErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamProcessorErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeStreamProcessorErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamProcessorErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeStreamProcessorErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamProcessorErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeStreamProcessorErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamProcessorErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeStreamProcessorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStreamProcessorErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeStreamProcessorErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeStreamProcessorErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DescribeStreamProcessorErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeStreamProcessorErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeStreamProcessorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DetectCustomLabels` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectCustomLabelsError {
    /// Kind of error that occurred.
    pub kind: DetectCustomLabelsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DetectCustomLabels` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectCustomLabelsErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The input image size exceeds the allowed limit. If you are calling
    /// DetectProtectiveEquipment, the image size or resolution exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ImageTooLargeException(crate::error::ImageTooLargeException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The provided image format is not supported. </p>
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The requested resource isn't ready. For example,  
    /// this exception occurs when you call <code>DetectCustomLabels</code> with a
    /// model version that isn't deployed. </p>
    ResourceNotReadyException(crate::error::ResourceNotReadyException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectCustomLabelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectCustomLabelsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DetectCustomLabelsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::ResourceNotReadyException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DetectCustomLabelsError {
    fn code(&self) -> Option<&str> {
        DetectCustomLabelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectCustomLabelsError {
    /// Creates a new `DetectCustomLabelsError`.
    pub fn new(kind: DetectCustomLabelsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DetectCustomLabelsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectCustomLabelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DetectCustomLabelsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectCustomLabelsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DetectCustomLabelsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectCustomLabelsErrorKind::ImageTooLargeException`.
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::ImageTooLargeException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectCustomLabelsErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `DetectCustomLabelsErrorKind::InvalidImageFormatException`.
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::InvalidImageFormatException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectCustomLabelsErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectCustomLabelsErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectCustomLabelsErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectCustomLabelsErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectCustomLabelsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectCustomLabelsErrorKind::ResourceNotReadyException`.
    pub fn is_resource_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::ResourceNotReadyException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectCustomLabelsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DetectCustomLabelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectCustomLabelsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::InternalServerError(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::LimitExceededException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DetectCustomLabelsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::ResourceNotReadyException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DetectFaces` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectFacesError {
    /// Kind of error that occurred.
    pub kind: DetectFacesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DetectFaces` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectFacesErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The input image size exceeds the allowed limit. If you are calling
    /// DetectProtectiveEquipment, the image size or resolution exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ImageTooLargeException(crate::error::ImageTooLargeException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The provided image format is not supported. </p>
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectFacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectFacesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DetectFacesError {
    fn code(&self) -> Option<&str> {
        DetectFacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectFacesError {
    /// Creates a new `DetectFacesError`.
    pub fn new(kind: DetectFacesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DetectFacesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectFacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DetectFacesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectFacesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DetectFacesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DetectFacesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DetectFacesErrorKind::ImageTooLargeException`.
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(&self.kind, DetectFacesErrorKind::ImageTooLargeException(_))
    }
    /// Returns `true` if the error kind is `DetectFacesErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DetectFacesErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DetectFacesErrorKind::InvalidImageFormatException`.
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectFacesErrorKind::InvalidImageFormatException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectFacesErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectFacesErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectFacesErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectFacesErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectFacesErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectFacesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectFacesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DetectFacesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DetectFacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectFacesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetectFacesErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            DetectFacesErrorKind::InternalServerError(_inner) => Some(_inner),
            DetectFacesErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            DetectFacesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DetectFacesErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            DetectFacesErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            DetectFacesErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetectFacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DetectLabels` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectLabelsError {
    /// Kind of error that occurred.
    pub kind: DetectLabelsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DetectLabels` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectLabelsErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The input image size exceeds the allowed limit. If you are calling
    /// DetectProtectiveEquipment, the image size or resolution exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ImageTooLargeException(crate::error::ImageTooLargeException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The provided image format is not supported. </p>
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectLabelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectLabelsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DetectLabelsError {
    fn code(&self) -> Option<&str> {
        DetectLabelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectLabelsError {
    /// Creates a new `DetectLabelsError`.
    pub fn new(kind: DetectLabelsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DetectLabelsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectLabelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DetectLabelsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectLabelsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DetectLabelsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DetectLabelsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DetectLabelsErrorKind::ImageTooLargeException`.
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(&self.kind, DetectLabelsErrorKind::ImageTooLargeException(_))
    }
    /// Returns `true` if the error kind is `DetectLabelsErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DetectLabelsErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DetectLabelsErrorKind::InvalidImageFormatException`.
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectLabelsErrorKind::InvalidImageFormatException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectLabelsErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectLabelsErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectLabelsErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectLabelsErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectLabelsErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectLabelsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectLabelsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DetectLabelsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DetectLabelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectLabelsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetectLabelsErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            DetectLabelsErrorKind::InternalServerError(_inner) => Some(_inner),
            DetectLabelsErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            DetectLabelsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DetectLabelsErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            DetectLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            DetectLabelsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetectLabelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DetectModerationLabels` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectModerationLabelsError {
    /// Kind of error that occurred.
    pub kind: DetectModerationLabelsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DetectModerationLabels` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectModerationLabelsErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The number of in-progress human reviews you have has exceeded the number allowed.</p>
    HumanLoopQuotaExceededException(crate::error::HumanLoopQuotaExceededException),
    /// <p>The input image size exceeds the allowed limit. If you are calling
    /// DetectProtectiveEquipment, the image size or resolution exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ImageTooLargeException(crate::error::ImageTooLargeException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The provided image format is not supported. </p>
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectModerationLabelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectModerationLabelsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::HumanLoopQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            DetectModerationLabelsErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DetectModerationLabelsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DetectModerationLabelsError {
    fn code(&self) -> Option<&str> {
        DetectModerationLabelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectModerationLabelsError {
    /// Creates a new `DetectModerationLabelsError`.
    pub fn new(kind: DetectModerationLabelsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DetectModerationLabelsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectModerationLabelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DetectModerationLabelsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectModerationLabelsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DetectModerationLabelsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectModerationLabelsErrorKind::HumanLoopQuotaExceededException`.
    pub fn is_human_loop_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::HumanLoopQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectModerationLabelsErrorKind::ImageTooLargeException`.
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::ImageTooLargeException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectModerationLabelsErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `DetectModerationLabelsErrorKind::InvalidImageFormatException`.
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::InvalidImageFormatException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectModerationLabelsErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectModerationLabelsErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectModerationLabelsErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectModerationLabelsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DetectModerationLabelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectModerationLabelsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::HumanLoopQuotaExceededException(_inner) => {
                Some(_inner)
            }
            DetectModerationLabelsErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::InternalServerError(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DetectModerationLabelsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DetectProtectiveEquipment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectProtectiveEquipmentError {
    /// Kind of error that occurred.
    pub kind: DetectProtectiveEquipmentErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DetectProtectiveEquipment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectProtectiveEquipmentErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The input image size exceeds the allowed limit. If you are calling
    /// DetectProtectiveEquipment, the image size or resolution exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ImageTooLargeException(crate::error::ImageTooLargeException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The provided image format is not supported. </p>
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectProtectiveEquipmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectProtectiveEquipmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetectProtectiveEquipmentErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            DetectProtectiveEquipmentErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DetectProtectiveEquipmentErrorKind::InvalidImageFormatException(_inner) => {
                _inner.fmt(f)
            }
            DetectProtectiveEquipmentErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DetectProtectiveEquipmentErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            DetectProtectiveEquipmentErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DetectProtectiveEquipmentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetectProtectiveEquipmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DetectProtectiveEquipmentError {
    fn code(&self) -> Option<&str> {
        DetectProtectiveEquipmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectProtectiveEquipmentError {
    /// Creates a new `DetectProtectiveEquipmentError`.
    pub fn new(kind: DetectProtectiveEquipmentErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DetectProtectiveEquipmentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectProtectiveEquipmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DetectProtectiveEquipmentError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectProtectiveEquipmentErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DetectProtectiveEquipmentErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectProtectiveEquipmentErrorKind::ImageTooLargeException`.
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::ImageTooLargeException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectProtectiveEquipmentErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `DetectProtectiveEquipmentErrorKind::InvalidImageFormatException`.
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::InvalidImageFormatException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectProtectiveEquipmentErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectProtectiveEquipmentErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectProtectiveEquipmentErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectProtectiveEquipmentErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DetectProtectiveEquipmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectProtectiveEquipmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::InternalServerError(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DetectProtectiveEquipmentErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DetectText` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectTextError {
    /// Kind of error that occurred.
    pub kind: DetectTextErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DetectText` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectTextErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The input image size exceeds the allowed limit. If you are calling
    /// DetectProtectiveEquipment, the image size or resolution exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ImageTooLargeException(crate::error::ImageTooLargeException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The provided image format is not supported. </p>
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectTextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectTextErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DetectTextErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DetectTextError {
    fn code(&self) -> Option<&str> {
        DetectTextError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectTextError {
    /// Creates a new `DetectTextError`.
    pub fn new(kind: DetectTextErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DetectTextError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectTextErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DetectTextError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectTextErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DetectTextErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DetectTextErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DetectTextErrorKind::ImageTooLargeException`.
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(&self.kind, DetectTextErrorKind::ImageTooLargeException(_))
    }
    /// Returns `true` if the error kind is `DetectTextErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DetectTextErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DetectTextErrorKind::InvalidImageFormatException`.
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectTextErrorKind::InvalidImageFormatException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectTextErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectTextErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectTextErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(&self.kind, DetectTextErrorKind::InvalidS3ObjectException(_))
    }
    /// Returns `true` if the error kind is `DetectTextErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectTextErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DetectTextErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DetectTextErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DetectTextError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectTextErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetectTextErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            DetectTextErrorKind::InternalServerError(_inner) => Some(_inner),
            DetectTextErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            DetectTextErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DetectTextErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            DetectTextErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            DetectTextErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetectTextErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DistributeDatasetEntries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DistributeDatasetEntriesError {
    /// Kind of error that occurred.
    pub kind: DistributeDatasetEntriesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DistributeDatasetEntries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DistributeDatasetEntriesErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The requested resource isn't ready. For example,  
    /// this exception occurs when you call <code>DetectCustomLabels</code> with a
    /// model version that isn't deployed. </p>
    ResourceNotReadyException(crate::error::ResourceNotReadyException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DistributeDatasetEntriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DistributeDatasetEntriesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DistributeDatasetEntriesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DistributeDatasetEntriesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DistributeDatasetEntriesErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DistributeDatasetEntriesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DistributeDatasetEntriesErrorKind::ResourceNotReadyException(_inner) => _inner.fmt(f),
            DistributeDatasetEntriesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DistributeDatasetEntriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DistributeDatasetEntriesError {
    fn code(&self) -> Option<&str> {
        DistributeDatasetEntriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DistributeDatasetEntriesError {
    /// Creates a new `DistributeDatasetEntriesError`.
    pub fn new(kind: DistributeDatasetEntriesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DistributeDatasetEntriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DistributeDatasetEntriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DistributeDatasetEntriesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DistributeDatasetEntriesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DistributeDatasetEntriesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DistributeDatasetEntriesErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DistributeDatasetEntriesErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DistributeDatasetEntriesErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `DistributeDatasetEntriesErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DistributeDatasetEntriesErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `DistributeDatasetEntriesErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DistributeDatasetEntriesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DistributeDatasetEntriesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DistributeDatasetEntriesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DistributeDatasetEntriesErrorKind::ResourceNotReadyException`.
    pub fn is_resource_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            DistributeDatasetEntriesErrorKind::ResourceNotReadyException(_)
        )
    }
    /// Returns `true` if the error kind is `DistributeDatasetEntriesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DistributeDatasetEntriesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DistributeDatasetEntriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DistributeDatasetEntriesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DistributeDatasetEntriesErrorKind::InternalServerError(_inner) => Some(_inner),
            DistributeDatasetEntriesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DistributeDatasetEntriesErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DistributeDatasetEntriesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DistributeDatasetEntriesErrorKind::ResourceNotReadyException(_inner) => Some(_inner),
            DistributeDatasetEntriesErrorKind::ThrottlingException(_inner) => Some(_inner),
            DistributeDatasetEntriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetCelebrityInfo` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCelebrityInfoError {
    /// Kind of error that occurred.
    pub kind: GetCelebrityInfoErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetCelebrityInfo` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCelebrityInfoErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCelebrityInfoError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCelebrityInfoErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetCelebrityInfoErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetCelebrityInfoErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetCelebrityInfoErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetCelebrityInfoErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetCelebrityInfoErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetCelebrityInfoErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCelebrityInfoError {
    fn code(&self) -> Option<&str> {
        GetCelebrityInfoError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCelebrityInfoError {
    /// Creates a new `GetCelebrityInfoError`.
    pub fn new(kind: GetCelebrityInfoErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCelebrityInfoError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCelebrityInfoErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCelebrityInfoError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCelebrityInfoErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetCelebrityInfoErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityInfoErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCelebrityInfoErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityInfoErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `GetCelebrityInfoErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityInfoErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCelebrityInfoErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityInfoErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCelebrityInfoErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityInfoErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCelebrityInfoErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityInfoErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetCelebrityInfoError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCelebrityInfoErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetCelebrityInfoErrorKind::InternalServerError(_inner) => Some(_inner),
            GetCelebrityInfoErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetCelebrityInfoErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetCelebrityInfoErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetCelebrityInfoErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetCelebrityInfoErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetCelebrityRecognition` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCelebrityRecognitionError {
    /// Kind of error that occurred.
    pub kind: GetCelebrityRecognitionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetCelebrityRecognition` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCelebrityRecognitionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCelebrityRecognitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCelebrityRecognitionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetCelebrityRecognitionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetCelebrityRecognitionErrorKind::InvalidPaginationTokenException(_inner) => {
                _inner.fmt(f)
            }
            GetCelebrityRecognitionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetCelebrityRecognitionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetCelebrityRecognitionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetCelebrityRecognitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCelebrityRecognitionError {
    fn code(&self) -> Option<&str> {
        GetCelebrityRecognitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCelebrityRecognitionError {
    /// Creates a new `GetCelebrityRecognitionError`.
    pub fn new(kind: GetCelebrityRecognitionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCelebrityRecognitionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCelebrityRecognitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCelebrityRecognitionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCelebrityRecognitionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetCelebrityRecognitionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCelebrityRecognitionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `GetCelebrityRecognitionErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCelebrityRecognitionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCelebrityRecognitionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCelebrityRecognitionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetCelebrityRecognitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCelebrityRecognitionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetCelebrityRecognitionErrorKind::InternalServerError(_inner) => Some(_inner),
            GetCelebrityRecognitionErrorKind::InvalidPaginationTokenException(_inner) => {
                Some(_inner)
            }
            GetCelebrityRecognitionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetCelebrityRecognitionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetCelebrityRecognitionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetCelebrityRecognitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetContentModeration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContentModerationError {
    /// Kind of error that occurred.
    pub kind: GetContentModerationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetContentModeration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContentModerationErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContentModerationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContentModerationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetContentModerationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetContentModerationErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetContentModerationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetContentModerationErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetContentModerationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetContentModerationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetContentModerationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetContentModerationError {
    fn code(&self) -> Option<&str> {
        GetContentModerationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContentModerationError {
    /// Creates a new `GetContentModerationError`.
    pub fn new(kind: GetContentModerationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetContentModerationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContentModerationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetContentModerationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContentModerationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetContentModerationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetContentModerationErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `GetContentModerationErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetContentModerationErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `GetContentModerationErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetContentModerationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetContentModerationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetContentModerationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContentModerationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetContentModerationErrorKind::InternalServerError(_inner) => Some(_inner),
            GetContentModerationErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetContentModerationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetContentModerationErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetContentModerationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetContentModerationErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetContentModerationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetFaceDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFaceDetectionError {
    /// Kind of error that occurred.
    pub kind: GetFaceDetectionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetFaceDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFaceDetectionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFaceDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFaceDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetFaceDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetFaceDetectionErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetFaceDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetFaceDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetFaceDetectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetFaceDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetFaceDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetFaceDetectionError {
    fn code(&self) -> Option<&str> {
        GetFaceDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFaceDetectionError {
    /// Creates a new `GetFaceDetectionError`.
    pub fn new(kind: GetFaceDetectionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetFaceDetectionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFaceDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetFaceDetectionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFaceDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetFaceDetectionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFaceDetectionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `GetFaceDetectionErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFaceDetectionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFaceDetectionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFaceDetectionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFaceDetectionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetFaceDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFaceDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetFaceDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            GetFaceDetectionErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetFaceDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetFaceDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetFaceDetectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetFaceDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetFaceDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetFaceSearch` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFaceSearchError {
    /// Kind of error that occurred.
    pub kind: GetFaceSearchErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetFaceSearch` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFaceSearchErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFaceSearchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFaceSearchErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetFaceSearchError {
    fn code(&self) -> Option<&str> {
        GetFaceSearchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFaceSearchError {
    /// Creates a new `GetFaceSearchError`.
    pub fn new(kind: GetFaceSearchErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetFaceSearchError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFaceSearchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetFaceSearchError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFaceSearchErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetFaceSearchErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetFaceSearchErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetFaceSearchErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, GetFaceSearchErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `GetFaceSearchErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceSearchErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFaceSearchErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceSearchErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFaceSearchErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceSearchErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFaceSearchErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceSearchErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFaceSearchErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetFaceSearchErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for GetFaceSearchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFaceSearchErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetFaceSearchErrorKind::InternalServerError(_inner) => Some(_inner),
            GetFaceSearchErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetFaceSearchErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetFaceSearchErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            GetFaceSearchErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetFaceSearchErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetFaceSearchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetLabelDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLabelDetectionError {
    /// Kind of error that occurred.
    pub kind: GetLabelDetectionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetLabelDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLabelDetectionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLabelDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLabelDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetLabelDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetLabelDetectionErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetLabelDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetLabelDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetLabelDetectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetLabelDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetLabelDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetLabelDetectionError {
    fn code(&self) -> Option<&str> {
        GetLabelDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLabelDetectionError {
    /// Creates a new `GetLabelDetectionError`.
    pub fn new(kind: GetLabelDetectionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetLabelDetectionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLabelDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetLabelDetectionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLabelDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetLabelDetectionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetLabelDetectionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `GetLabelDetectionErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetLabelDetectionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `GetLabelDetectionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetLabelDetectionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetLabelDetectionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetLabelDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLabelDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetLabelDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            GetLabelDetectionErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetLabelDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetLabelDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetLabelDetectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetLabelDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetLabelDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetPersonTracking` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPersonTrackingError {
    /// Kind of error that occurred.
    pub kind: GetPersonTrackingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetPersonTracking` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPersonTrackingErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPersonTrackingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPersonTrackingErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetPersonTrackingErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetPersonTrackingErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetPersonTrackingErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetPersonTrackingErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetPersonTrackingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetPersonTrackingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetPersonTrackingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPersonTrackingError {
    fn code(&self) -> Option<&str> {
        GetPersonTrackingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPersonTrackingError {
    /// Creates a new `GetPersonTrackingError`.
    pub fn new(kind: GetPersonTrackingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetPersonTrackingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPersonTrackingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetPersonTrackingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPersonTrackingErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetPersonTrackingErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPersonTrackingErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `GetPersonTrackingErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPersonTrackingErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPersonTrackingErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPersonTrackingErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPersonTrackingErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetPersonTrackingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPersonTrackingErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetPersonTrackingErrorKind::InternalServerError(_inner) => Some(_inner),
            GetPersonTrackingErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetPersonTrackingErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetPersonTrackingErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetPersonTrackingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetPersonTrackingErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetPersonTrackingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetSegmentDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSegmentDetectionError {
    /// Kind of error that occurred.
    pub kind: GetSegmentDetectionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetSegmentDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSegmentDetectionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSegmentDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSegmentDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetSegmentDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetSegmentDetectionErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetSegmentDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetSegmentDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetSegmentDetectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetSegmentDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetSegmentDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSegmentDetectionError {
    fn code(&self) -> Option<&str> {
        GetSegmentDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSegmentDetectionError {
    /// Creates a new `GetSegmentDetectionError`.
    pub fn new(kind: GetSegmentDetectionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetSegmentDetectionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSegmentDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetSegmentDetectionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSegmentDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetSegmentDetectionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSegmentDetectionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `GetSegmentDetectionErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSegmentDetectionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSegmentDetectionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSegmentDetectionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSegmentDetectionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetSegmentDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSegmentDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetSegmentDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            GetSegmentDetectionErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetSegmentDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetSegmentDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetSegmentDetectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetSegmentDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetSegmentDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetTextDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTextDetectionError {
    /// Kind of error that occurred.
    pub kind: GetTextDetectionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetTextDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTextDetectionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTextDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTextDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetTextDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetTextDetectionErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetTextDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetTextDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetTextDetectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetTextDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetTextDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetTextDetectionError {
    fn code(&self) -> Option<&str> {
        GetTextDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTextDetectionError {
    /// Creates a new `GetTextDetectionError`.
    pub fn new(kind: GetTextDetectionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetTextDetectionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTextDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetTextDetectionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTextDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetTextDetectionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetTextDetectionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `GetTextDetectionErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetTextDetectionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `GetTextDetectionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetTextDetectionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetTextDetectionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetTextDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTextDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetTextDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            GetTextDetectionErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetTextDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetTextDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetTextDetectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetTextDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetTextDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `IndexFaces` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct IndexFacesError {
    /// Kind of error that occurred.
    pub kind: IndexFacesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `IndexFaces` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum IndexFacesErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The input image size exceeds the allowed limit. If you are calling
    /// DetectProtectiveEquipment, the image size or resolution exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ImageTooLargeException(crate::error::ImageTooLargeException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The provided image format is not supported. </p>
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p></p>
    ///
    ///
    /// <p>The size of the collection exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for IndexFacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            IndexFacesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for IndexFacesError {
    fn code(&self) -> Option<&str> {
        IndexFacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl IndexFacesError {
    /// Creates a new `IndexFacesError`.
    pub fn new(kind: IndexFacesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `IndexFacesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: IndexFacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `IndexFacesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: IndexFacesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `IndexFacesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, IndexFacesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `IndexFacesErrorKind::ImageTooLargeException`.
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(&self.kind, IndexFacesErrorKind::ImageTooLargeException(_))
    }
    /// Returns `true` if the error kind is `IndexFacesErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, IndexFacesErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `IndexFacesErrorKind::InvalidImageFormatException`.
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            IndexFacesErrorKind::InvalidImageFormatException(_)
        )
    }
    /// Returns `true` if the error kind is `IndexFacesErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            IndexFacesErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `IndexFacesErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(&self.kind, IndexFacesErrorKind::InvalidS3ObjectException(_))
    }
    /// Returns `true` if the error kind is `IndexFacesErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            IndexFacesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `IndexFacesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            IndexFacesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `IndexFacesErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            IndexFacesErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `IndexFacesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, IndexFacesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for IndexFacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            IndexFacesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            IndexFacesErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            IndexFacesErrorKind::InternalServerError(_inner) => Some(_inner),
            IndexFacesErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            IndexFacesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            IndexFacesErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            IndexFacesErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            IndexFacesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            IndexFacesErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            IndexFacesErrorKind::ThrottlingException(_inner) => Some(_inner),
            IndexFacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListCollections` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCollectionsError {
    /// Kind of error that occurred.
    pub kind: ListCollectionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListCollections` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCollectionsErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCollectionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCollectionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListCollectionsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListCollectionsErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            ListCollectionsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListCollectionsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListCollectionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListCollectionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListCollectionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCollectionsError {
    fn code(&self) -> Option<&str> {
        ListCollectionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCollectionsError {
    /// Creates a new `ListCollectionsError`.
    pub fn new(kind: ListCollectionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListCollectionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCollectionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListCollectionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCollectionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListCollectionsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCollectionsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCollectionsErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListCollectionsErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `ListCollectionsErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCollectionsErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCollectionsErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCollectionsErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCollectionsErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCollectionsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCollectionsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCollectionsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCollectionsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListCollectionsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListCollectionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCollectionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListCollectionsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListCollectionsErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            ListCollectionsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListCollectionsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            ListCollectionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListCollectionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListCollectionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListDatasetEntries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDatasetEntriesError {
    /// Kind of error that occurred.
    pub kind: ListDatasetEntriesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListDatasetEntries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDatasetEntriesErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The requested resource isn't ready. For example,  
    /// this exception occurs when you call <code>DetectCustomLabels</code> with a
    /// model version that isn't deployed. </p>
    ResourceNotReadyException(crate::error::ResourceNotReadyException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDatasetEntriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDatasetEntriesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListDatasetEntriesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListDatasetEntriesErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            ListDatasetEntriesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListDatasetEntriesErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListDatasetEntriesErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            ListDatasetEntriesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListDatasetEntriesErrorKind::ResourceNotReadyException(_inner) => _inner.fmt(f),
            ListDatasetEntriesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDatasetEntriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDatasetEntriesError {
    fn code(&self) -> Option<&str> {
        ListDatasetEntriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDatasetEntriesError {
    /// Creates a new `ListDatasetEntriesError`.
    pub fn new(kind: ListDatasetEntriesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListDatasetEntriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDatasetEntriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListDatasetEntriesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDatasetEntriesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListDatasetEntriesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetEntriesErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetEntriesErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetEntriesErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetEntriesErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetEntriesErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetEntriesErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetEntriesErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetEntriesErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetEntriesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetEntriesErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetEntriesErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetEntriesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetEntriesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetEntriesErrorKind::ResourceNotReadyException`.
    pub fn is_resource_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetEntriesErrorKind::ResourceNotReadyException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetEntriesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetEntriesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListDatasetEntriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDatasetEntriesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListDatasetEntriesErrorKind::InternalServerError(_inner) => Some(_inner),
            ListDatasetEntriesErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            ListDatasetEntriesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListDatasetEntriesErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            ListDatasetEntriesErrorKind::ResourceInUseException(_inner) => Some(_inner),
            ListDatasetEntriesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListDatasetEntriesErrorKind::ResourceNotReadyException(_inner) => Some(_inner),
            ListDatasetEntriesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDatasetEntriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListDatasetLabels` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDatasetLabelsError {
    /// Kind of error that occurred.
    pub kind: ListDatasetLabelsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListDatasetLabels` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDatasetLabelsErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The requested resource isn't ready. For example,  
    /// this exception occurs when you call <code>DetectCustomLabels</code> with a
    /// model version that isn't deployed. </p>
    ResourceNotReadyException(crate::error::ResourceNotReadyException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDatasetLabelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDatasetLabelsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListDatasetLabelsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListDatasetLabelsErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            ListDatasetLabelsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListDatasetLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListDatasetLabelsErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            ListDatasetLabelsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListDatasetLabelsErrorKind::ResourceNotReadyException(_inner) => _inner.fmt(f),
            ListDatasetLabelsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDatasetLabelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDatasetLabelsError {
    fn code(&self) -> Option<&str> {
        ListDatasetLabelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDatasetLabelsError {
    /// Creates a new `ListDatasetLabelsError`.
    pub fn new(kind: ListDatasetLabelsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListDatasetLabelsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDatasetLabelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListDatasetLabelsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDatasetLabelsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListDatasetLabelsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetLabelsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetLabelsErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetLabelsErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetLabelsErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetLabelsErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetLabelsErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetLabelsErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetLabelsErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetLabelsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetLabelsErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetLabelsErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetLabelsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetLabelsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetLabelsErrorKind::ResourceNotReadyException`.
    pub fn is_resource_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetLabelsErrorKind::ResourceNotReadyException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDatasetLabelsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDatasetLabelsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListDatasetLabelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDatasetLabelsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListDatasetLabelsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListDatasetLabelsErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            ListDatasetLabelsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListDatasetLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            ListDatasetLabelsErrorKind::ResourceInUseException(_inner) => Some(_inner),
            ListDatasetLabelsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListDatasetLabelsErrorKind::ResourceNotReadyException(_inner) => Some(_inner),
            ListDatasetLabelsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDatasetLabelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListFaces` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFacesError {
    /// Kind of error that occurred.
    pub kind: ListFacesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListFaces` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFacesErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFacesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListFacesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListFacesErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            ListFacesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListFacesErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            ListFacesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListFacesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListFacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListFacesError {
    fn code(&self) -> Option<&str> {
        ListFacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFacesError {
    /// Creates a new `ListFacesError`.
    pub fn new(kind: ListFacesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListFacesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListFacesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFacesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListFacesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListFacesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListFacesErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListFacesErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `ListFacesErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFacesErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListFacesErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(&self.kind, ListFacesErrorKind::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `ListFacesErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFacesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `ListFacesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListFacesErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListFacesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListFacesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListFacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFacesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListFacesErrorKind::InternalServerError(_inner) => Some(_inner),
            ListFacesErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            ListFacesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListFacesErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            ListFacesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListFacesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListStreamProcessors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListStreamProcessorsError {
    /// Kind of error that occurred.
    pub kind: ListStreamProcessorsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListStreamProcessors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListStreamProcessorsErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Pagination token in the request is not valid.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListStreamProcessorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListStreamProcessorsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListStreamProcessorsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListStreamProcessorsErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            ListStreamProcessorsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListStreamProcessorsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListStreamProcessorsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListStreamProcessorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListStreamProcessorsError {
    fn code(&self) -> Option<&str> {
        ListStreamProcessorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListStreamProcessorsError {
    /// Creates a new `ListStreamProcessorsError`.
    pub fn new(kind: ListStreamProcessorsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListStreamProcessorsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListStreamProcessorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListStreamProcessorsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListStreamProcessorsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListStreamProcessorsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamProcessorsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListStreamProcessorsErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamProcessorsErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `ListStreamProcessorsErrorKind::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamProcessorsErrorKind::InvalidPaginationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListStreamProcessorsErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamProcessorsErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `ListStreamProcessorsErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamProcessorsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `ListStreamProcessorsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamProcessorsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListStreamProcessorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListStreamProcessorsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListStreamProcessorsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListStreamProcessorsErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            ListStreamProcessorsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListStreamProcessorsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            ListStreamProcessorsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListStreamProcessorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    /// Kind of error that occurred.
    pub kind: ListTagsForResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates a new `ListTagsForResourceError`.
    pub fn new(kind: ListTagsForResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `RecognizeCelebrities` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RecognizeCelebritiesError {
    /// Kind of error that occurred.
    pub kind: RecognizeCelebritiesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RecognizeCelebrities` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RecognizeCelebritiesErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The input image size exceeds the allowed limit. If you are calling
    /// DetectProtectiveEquipment, the image size or resolution exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ImageTooLargeException(crate::error::ImageTooLargeException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The provided image format is not supported. </p>
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RecognizeCelebritiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RecognizeCelebritiesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            RecognizeCelebritiesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RecognizeCelebritiesError {
    fn code(&self) -> Option<&str> {
        RecognizeCelebritiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RecognizeCelebritiesError {
    /// Creates a new `RecognizeCelebritiesError`.
    pub fn new(kind: RecognizeCelebritiesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RecognizeCelebritiesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RecognizeCelebritiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `RecognizeCelebritiesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RecognizeCelebritiesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `RecognizeCelebritiesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `RecognizeCelebritiesErrorKind::ImageTooLargeException`.
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::ImageTooLargeException(_)
        )
    }
    /// Returns `true` if the error kind is `RecognizeCelebritiesErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `RecognizeCelebritiesErrorKind::InvalidImageFormatException`.
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::InvalidImageFormatException(_)
        )
    }
    /// Returns `true` if the error kind is `RecognizeCelebritiesErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `RecognizeCelebritiesErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `RecognizeCelebritiesErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `RecognizeCelebritiesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for RecognizeCelebritiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RecognizeCelebritiesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::InternalServerError(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            RecognizeCelebritiesErrorKind::ThrottlingException(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `SearchFaces` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchFacesError {
    /// Kind of error that occurred.
    pub kind: SearchFacesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SearchFaces` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchFacesErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SearchFacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchFacesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SearchFacesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            SearchFacesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            SearchFacesErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            SearchFacesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SearchFacesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SearchFacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for SearchFacesError {
    fn code(&self) -> Option<&str> {
        SearchFacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl SearchFacesError {
    /// Creates a new `SearchFacesError`.
    pub fn new(kind: SearchFacesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `SearchFacesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SearchFacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `SearchFacesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SearchFacesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `SearchFacesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, SearchFacesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `SearchFacesErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, SearchFacesErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `SearchFacesErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchFacesErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchFacesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchFacesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, SearchFacesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for SearchFacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchFacesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SearchFacesErrorKind::InternalServerError(_inner) => Some(_inner),
            SearchFacesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            SearchFacesErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            SearchFacesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SearchFacesErrorKind::ThrottlingException(_inner) => Some(_inner),
            SearchFacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `SearchFacesByImage` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchFacesByImageError {
    /// Kind of error that occurred.
    pub kind: SearchFacesByImageErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SearchFacesByImage` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchFacesByImageErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The input image size exceeds the allowed limit. If you are calling
    /// DetectProtectiveEquipment, the image size or resolution exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ImageTooLargeException(crate::error::ImageTooLargeException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The provided image format is not supported. </p>
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SearchFacesByImageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchFacesByImageErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            SearchFacesByImageErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for SearchFacesByImageError {
    fn code(&self) -> Option<&str> {
        SearchFacesByImageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl SearchFacesByImageError {
    /// Creates a new `SearchFacesByImageError`.
    pub fn new(kind: SearchFacesByImageErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `SearchFacesByImageError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SearchFacesByImageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `SearchFacesByImageError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SearchFacesByImageErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `SearchFacesByImageErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchFacesByImageErrorKind::ImageTooLargeException`.
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::ImageTooLargeException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchFacesByImageErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `SearchFacesByImageErrorKind::InvalidImageFormatException`.
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::InvalidImageFormatException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchFacesByImageErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchFacesByImageErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchFacesByImageErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchFacesByImageErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchFacesByImageErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for SearchFacesByImageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchFacesByImageErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::InternalServerError(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::InvalidParameterException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            SearchFacesByImageErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::ThrottlingException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartCelebrityRecognition` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartCelebrityRecognitionError {
    /// Kind of error that occurred.
    pub kind: StartCelebrityRecognitionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartCelebrityRecognition` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartCelebrityRecognitionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A <code>ClientRequestToken</code> input parameter was reused with an operation, but at least one of the other input
    /// parameters is different from the previous call to the operation.</p>
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The file size or duration of the supplied media is too large. The maximum file size is 10GB.
    /// The maximum duration is 6 hours. </p>
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartCelebrityRecognitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartCelebrityRecognitionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartCelebrityRecognitionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartCelebrityRecognitionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartCelebrityRecognitionError {
    fn code(&self) -> Option<&str> {
        StartCelebrityRecognitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartCelebrityRecognitionError {
    /// Creates a new `StartCelebrityRecognitionError`.
    pub fn new(kind: StartCelebrityRecognitionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartCelebrityRecognitionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartCelebrityRecognitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartCelebrityRecognitionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartCelebrityRecognitionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartCelebrityRecognitionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StartCelebrityRecognitionErrorKind::IdempotentParameterMismatchException`.
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    /// Returns `true` if the error kind is `StartCelebrityRecognitionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `StartCelebrityRecognitionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `StartCelebrityRecognitionErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `StartCelebrityRecognitionErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartCelebrityRecognitionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `StartCelebrityRecognitionErrorKind::VideoTooLargeException`.
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartCelebrityRecognitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartCelebrityRecognitionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartCelebrityRecognitionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartCelebrityRecognitionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartContentModeration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartContentModerationError {
    /// Kind of error that occurred.
    pub kind: StartContentModerationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartContentModeration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartContentModerationErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A <code>ClientRequestToken</code> input parameter was reused with an operation, but at least one of the other input
    /// parameters is different from the previous call to the operation.</p>
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The file size or duration of the supplied media is too large. The maximum file size is 10GB.
    /// The maximum duration is 6 hours. </p>
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartContentModerationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartContentModerationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartContentModerationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartContentModerationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartContentModerationError {
    fn code(&self) -> Option<&str> {
        StartContentModerationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartContentModerationError {
    /// Creates a new `StartContentModerationError`.
    pub fn new(kind: StartContentModerationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartContentModerationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartContentModerationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartContentModerationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartContentModerationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartContentModerationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StartContentModerationErrorKind::IdempotentParameterMismatchException`.
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    /// Returns `true` if the error kind is `StartContentModerationErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `StartContentModerationErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `StartContentModerationErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `StartContentModerationErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartContentModerationErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartContentModerationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `StartContentModerationErrorKind::VideoTooLargeException`.
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartContentModerationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartContentModerationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartContentModerationErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartContentModerationErrorKind::InternalServerError(_inner) => Some(_inner),
            StartContentModerationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartContentModerationErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartContentModerationErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartContentModerationErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartContentModerationErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartContentModerationErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartContentModerationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartFaceDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartFaceDetectionError {
    /// Kind of error that occurred.
    pub kind: StartFaceDetectionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartFaceDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartFaceDetectionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A <code>ClientRequestToken</code> input parameter was reused with an operation, but at least one of the other input
    /// parameters is different from the previous call to the operation.</p>
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The file size or duration of the supplied media is too large. The maximum file size is 10GB.
    /// The maximum duration is 6 hours. </p>
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartFaceDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartFaceDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartFaceDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartFaceDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartFaceDetectionError {
    fn code(&self) -> Option<&str> {
        StartFaceDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartFaceDetectionError {
    /// Creates a new `StartFaceDetectionError`.
    pub fn new(kind: StartFaceDetectionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartFaceDetectionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartFaceDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartFaceDetectionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartFaceDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartFaceDetectionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceDetectionErrorKind::IdempotentParameterMismatchException`.
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceDetectionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceDetectionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceDetectionErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceDetectionErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceDetectionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceDetectionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceDetectionErrorKind::VideoTooLargeException`.
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartFaceDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartFaceDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartFaceDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartFaceDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartFaceSearch` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartFaceSearchError {
    /// Kind of error that occurred.
    pub kind: StartFaceSearchErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartFaceSearch` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartFaceSearchErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A <code>ClientRequestToken</code> input parameter was reused with an operation, but at least one of the other input
    /// parameters is different from the previous call to the operation.</p>
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The file size or duration of the supplied media is too large. The maximum file size is 10GB.
    /// The maximum duration is 6 hours. </p>
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartFaceSearchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartFaceSearchErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::IdempotentParameterMismatchException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartFaceSearchErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartFaceSearchError {
    fn code(&self) -> Option<&str> {
        StartFaceSearchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartFaceSearchError {
    /// Creates a new `StartFaceSearchError`.
    pub fn new(kind: StartFaceSearchErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartFaceSearchError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartFaceSearchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartFaceSearchError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartFaceSearchErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartFaceSearchErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceSearchErrorKind::IdempotentParameterMismatchException`.
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceSearchErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, StartFaceSearchErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `StartFaceSearchErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceSearchErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceSearchErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceSearchErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceSearchErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `StartFaceSearchErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, StartFaceSearchErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `StartFaceSearchErrorKind::VideoTooLargeException`.
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartFaceSearchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartFaceSearchErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::IdempotentParameterMismatchException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::InternalServerError(_inner) => Some(_inner),
            StartFaceSearchErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartFaceSearchErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartLabelDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartLabelDetectionError {
    /// Kind of error that occurred.
    pub kind: StartLabelDetectionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartLabelDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartLabelDetectionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A <code>ClientRequestToken</code> input parameter was reused with an operation, but at least one of the other input
    /// parameters is different from the previous call to the operation.</p>
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The file size or duration of the supplied media is too large. The maximum file size is 10GB.
    /// The maximum duration is 6 hours. </p>
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartLabelDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartLabelDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartLabelDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartLabelDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartLabelDetectionError {
    fn code(&self) -> Option<&str> {
        StartLabelDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartLabelDetectionError {
    /// Creates a new `StartLabelDetectionError`.
    pub fn new(kind: StartLabelDetectionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartLabelDetectionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartLabelDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartLabelDetectionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartLabelDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartLabelDetectionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StartLabelDetectionErrorKind::IdempotentParameterMismatchException`.
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    /// Returns `true` if the error kind is `StartLabelDetectionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `StartLabelDetectionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `StartLabelDetectionErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `StartLabelDetectionErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartLabelDetectionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartLabelDetectionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `StartLabelDetectionErrorKind::VideoTooLargeException`.
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartLabelDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartLabelDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartLabelDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartLabelDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartPersonTracking` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartPersonTrackingError {
    /// Kind of error that occurred.
    pub kind: StartPersonTrackingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartPersonTracking` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartPersonTrackingErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A <code>ClientRequestToken</code> input parameter was reused with an operation, but at least one of the other input
    /// parameters is different from the previous call to the operation.</p>
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The file size or duration of the supplied media is too large. The maximum file size is 10GB.
    /// The maximum duration is 6 hours. </p>
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartPersonTrackingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartPersonTrackingErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartPersonTrackingErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartPersonTrackingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartPersonTrackingError {
    fn code(&self) -> Option<&str> {
        StartPersonTrackingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartPersonTrackingError {
    /// Creates a new `StartPersonTrackingError`.
    pub fn new(kind: StartPersonTrackingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartPersonTrackingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartPersonTrackingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartPersonTrackingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartPersonTrackingErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartPersonTrackingErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StartPersonTrackingErrorKind::IdempotentParameterMismatchException`.
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    /// Returns `true` if the error kind is `StartPersonTrackingErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `StartPersonTrackingErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `StartPersonTrackingErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `StartPersonTrackingErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartPersonTrackingErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartPersonTrackingErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `StartPersonTrackingErrorKind::VideoTooLargeException`.
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartPersonTrackingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartPersonTrackingErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartPersonTrackingErrorKind::InternalServerError(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartPersonTrackingErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartProjectVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartProjectVersionError {
    /// Kind of error that occurred.
    pub kind: StartProjectVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartProjectVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartProjectVersionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartProjectVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartProjectVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartProjectVersionErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartProjectVersionError {
    fn code(&self) -> Option<&str> {
        StartProjectVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartProjectVersionError {
    /// Creates a new `StartProjectVersionError`.
    pub fn new(kind: StartProjectVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartProjectVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartProjectVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartProjectVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartProjectVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartProjectVersionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StartProjectVersionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `StartProjectVersionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `StartProjectVersionErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartProjectVersionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartProjectVersionErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `StartProjectVersionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `StartProjectVersionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StartProjectVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartProjectVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartProjectVersionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartProjectVersionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartProjectVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartProjectVersionErrorKind::ResourceInUseException(_inner) => Some(_inner),
            StartProjectVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartProjectVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartProjectVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartSegmentDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartSegmentDetectionError {
    /// Kind of error that occurred.
    pub kind: StartSegmentDetectionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartSegmentDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartSegmentDetectionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A <code>ClientRequestToken</code> input parameter was reused with an operation, but at least one of the other input
    /// parameters is different from the previous call to the operation.</p>
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The file size or duration of the supplied media is too large. The maximum file size is 10GB.
    /// The maximum duration is 6 hours. </p>
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartSegmentDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartSegmentDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartSegmentDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartSegmentDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartSegmentDetectionError {
    fn code(&self) -> Option<&str> {
        StartSegmentDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartSegmentDetectionError {
    /// Creates a new `StartSegmentDetectionError`.
    pub fn new(kind: StartSegmentDetectionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartSegmentDetectionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartSegmentDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartSegmentDetectionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartSegmentDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartSegmentDetectionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StartSegmentDetectionErrorKind::IdempotentParameterMismatchException`.
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    /// Returns `true` if the error kind is `StartSegmentDetectionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `StartSegmentDetectionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `StartSegmentDetectionErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `StartSegmentDetectionErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartSegmentDetectionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartSegmentDetectionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `StartSegmentDetectionErrorKind::VideoTooLargeException`.
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartSegmentDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartSegmentDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartSegmentDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartSegmentDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartStreamProcessor` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartStreamProcessorError {
    /// Kind of error that occurred.
    pub kind: StartStreamProcessorErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartStreamProcessor` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartStreamProcessorErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartStreamProcessorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartStreamProcessorErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartStreamProcessorErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartStreamProcessorErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartStreamProcessorErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            StartStreamProcessorErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartStreamProcessorErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartStreamProcessorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartStreamProcessorError {
    fn code(&self) -> Option<&str> {
        StartStreamProcessorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartStreamProcessorError {
    /// Creates a new `StartStreamProcessorError`.
    pub fn new(kind: StartStreamProcessorErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartStreamProcessorError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartStreamProcessorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartStreamProcessorError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartStreamProcessorErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartStreamProcessorErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StartStreamProcessorErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `StartStreamProcessorErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `StartStreamProcessorErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartStreamProcessorErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `StartStreamProcessorErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `StartStreamProcessorErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StartStreamProcessorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartStreamProcessorErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartStreamProcessorErrorKind::InternalServerError(_inner) => Some(_inner),
            StartStreamProcessorErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartStreamProcessorErrorKind::ResourceInUseException(_inner) => Some(_inner),
            StartStreamProcessorErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartStreamProcessorErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartStreamProcessorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartTextDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartTextDetectionError {
    /// Kind of error that occurred.
    pub kind: StartTextDetectionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartTextDetection` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartTextDetectionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A <code>ClientRequestToken</code> input parameter was reused with an operation, but at least one of the other input
    /// parameters is different from the previous call to the operation.</p>
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The file size or duration of the supplied media is too large. The maximum file size is 10GB.
    /// The maximum duration is 6 hours. </p>
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartTextDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartTextDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartTextDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartTextDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartTextDetectionError {
    fn code(&self) -> Option<&str> {
        StartTextDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartTextDetectionError {
    /// Creates a new `StartTextDetectionError`.
    pub fn new(kind: StartTextDetectionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartTextDetectionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartTextDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartTextDetectionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartTextDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartTextDetectionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StartTextDetectionErrorKind::IdempotentParameterMismatchException`.
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    /// Returns `true` if the error kind is `StartTextDetectionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `StartTextDetectionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `StartTextDetectionErrorKind::InvalidS3ObjectException`.
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::InvalidS3ObjectException(_)
        )
    }
    /// Returns `true` if the error kind is `StartTextDetectionErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartTextDetectionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartTextDetectionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `StartTextDetectionErrorKind::VideoTooLargeException`.
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartTextDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartTextDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartTextDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartTextDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartTextDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartTextDetectionErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartTextDetectionErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartTextDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartTextDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartTextDetectionErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartTextDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StopProjectVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopProjectVersionError {
    /// Kind of error that occurred.
    pub kind: StopProjectVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StopProjectVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopProjectVersionErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopProjectVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopProjectVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StopProjectVersionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StopProjectVersionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StopProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StopProjectVersionErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            StopProjectVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StopProjectVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StopProjectVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StopProjectVersionError {
    fn code(&self) -> Option<&str> {
        StopProjectVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopProjectVersionError {
    /// Creates a new `StopProjectVersionError`.
    pub fn new(kind: StopProjectVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StopProjectVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopProjectVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StopProjectVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopProjectVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StopProjectVersionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StopProjectVersionErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `StopProjectVersionErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `StopProjectVersionErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StopProjectVersionErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `StopProjectVersionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `StopProjectVersionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StopProjectVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopProjectVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StopProjectVersionErrorKind::InternalServerError(_inner) => Some(_inner),
            StopProjectVersionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StopProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StopProjectVersionErrorKind::ResourceInUseException(_inner) => Some(_inner),
            StopProjectVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StopProjectVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StopProjectVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StopStreamProcessor` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopStreamProcessorError {
    /// Kind of error that occurred.
    pub kind: StopStreamProcessorErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StopStreamProcessor` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopStreamProcessorErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopStreamProcessorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopStreamProcessorErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StopStreamProcessorErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StopStreamProcessorErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StopStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StopStreamProcessorErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            StopStreamProcessorErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StopStreamProcessorErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StopStreamProcessorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StopStreamProcessorError {
    fn code(&self) -> Option<&str> {
        StopStreamProcessorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopStreamProcessorError {
    /// Creates a new `StopStreamProcessorError`.
    pub fn new(kind: StopStreamProcessorErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StopStreamProcessorError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopStreamProcessorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StopStreamProcessorError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopStreamProcessorErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StopStreamProcessorErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StopStreamProcessorErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `StopStreamProcessorErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `StopStreamProcessorErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StopStreamProcessorErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `StopStreamProcessorErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `StopStreamProcessorErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StopStreamProcessorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopStreamProcessorErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StopStreamProcessorErrorKind::InternalServerError(_inner) => Some(_inner),
            StopStreamProcessorErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StopStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StopStreamProcessorErrorKind::ResourceInUseException(_inner) => Some(_inner),
            StopStreamProcessorErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StopStreamProcessorErrorKind::ThrottlingException(_inner) => Some(_inner),
            StopStreamProcessorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    /// Kind of error that occurred.
    pub kind: TagResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p></p>
    ///
    ///
    /// <p>The size of the collection exceeds the allowed limit. For more information, see
    /// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates a new `TagResourceError`.
    pub fn new(kind: TagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `TagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            TagResourceErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    /// Kind of error that occurred.
    pub kind: UntagResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates a new `UntagResourceError`.
    pub fn new(kind: UntagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UntagResourceErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateDatasetEntries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDatasetEntriesError {
    /// Kind of error that occurred.
    pub kind: UpdateDatasetEntriesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateDatasetEntries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDatasetEntriesErrorKind {
    /// <p>You are not authorized to perform the action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Input parameter violated a constraint. Validate your parameter before calling the API
    /// operation again.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
    /// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
    /// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The number of requests exceeded your throughput limit. If you want to increase this
    /// limit, contact Amazon Rekognition.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified resource is already being used.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>The resource specified in the request cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDatasetEntriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDatasetEntriesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateDatasetEntriesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateDatasetEntriesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateDatasetEntriesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateDatasetEntriesErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDatasetEntriesErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            UpdateDatasetEntriesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDatasetEntriesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDatasetEntriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateDatasetEntriesError {
    fn code(&self) -> Option<&str> {
        UpdateDatasetEntriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDatasetEntriesError {
    /// Creates a new `UpdateDatasetEntriesError`.
    pub fn new(kind: UpdateDatasetEntriesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateDatasetEntriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDatasetEntriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateDatasetEntriesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDatasetEntriesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateDatasetEntriesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatasetEntriesErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDatasetEntriesErrorKind::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatasetEntriesErrorKind::InternalServerError(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDatasetEntriesErrorKind::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatasetEntriesErrorKind::InvalidParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDatasetEntriesErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatasetEntriesErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDatasetEntriesErrorKind::ProvisionedThroughputExceededException`.
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatasetEntriesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDatasetEntriesErrorKind::ResourceInUseException`.
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatasetEntriesErrorKind::ResourceInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDatasetEntriesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatasetEntriesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDatasetEntriesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatasetEntriesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateDatasetEntriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDatasetEntriesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateDatasetEntriesErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateDatasetEntriesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateDatasetEntriesErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateDatasetEntriesErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            UpdateDatasetEntriesErrorKind::ResourceInUseException(_inner) => Some(_inner),
            UpdateDatasetEntriesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDatasetEntriesErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDatasetEntriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ThrottlingException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException)
pub mod throttling_exception {
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException)
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException)
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>The resource specified in the request cannot be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The specified resource is already being used.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ResourceInUseException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseException {}
/// See [`ResourceInUseException`](crate::error::ResourceInUseException)
pub mod resource_in_use_exception {
    /// A builder for [`ResourceInUseException`](crate::error::ResourceInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseException`](crate::error::ResourceInUseException)
        pub fn build(self) -> crate::error::ResourceInUseException {
            crate::error::ResourceInUseException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ResourceInUseException {
    /// Creates a new builder-style object to manufacture [`ResourceInUseException`](crate::error::ResourceInUseException)
    pub fn builder() -> crate::error::resource_in_use_exception::Builder {
        crate::error::resource_in_use_exception::Builder::default()
    }
}

/// <p>The number of requests exceeded your throughput limit. If you want to increase this
/// limit, contact Amazon Rekognition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProvisionedThroughputExceededException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProvisionedThroughputExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisionedThroughputExceededException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ProvisionedThroughputExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ProvisionedThroughputExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ProvisionedThroughputExceededException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ProvisionedThroughputExceededException {}
/// See [`ProvisionedThroughputExceededException`](crate::error::ProvisionedThroughputExceededException)
pub mod provisioned_throughput_exceeded_exception {
    /// A builder for [`ProvisionedThroughputExceededException`](crate::error::ProvisionedThroughputExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedThroughputExceededException`](crate::error::ProvisionedThroughputExceededException)
        pub fn build(self) -> crate::error::ProvisionedThroughputExceededException {
            crate::error::ProvisionedThroughputExceededException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ProvisionedThroughputExceededException {
    /// Creates a new builder-style object to manufacture [`ProvisionedThroughputExceededException`](crate::error::ProvisionedThroughputExceededException)
    pub fn builder() -> crate::error::provisioned_throughput_exceeded_exception::Builder {
        crate::error::provisioned_throughput_exceeded_exception::Builder::default()
    }
}

/// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
/// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
/// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl LimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>Input parameter violated a constraint. Validate your parameter before calling the API
/// operation again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl InvalidParameterException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterException {}
/// See [`InvalidParameterException`](crate::error::InvalidParameterException)
pub mod invalid_parameter_exception {
    /// A builder for [`InvalidParameterException`](crate::error::InvalidParameterException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterException`](crate::error::InvalidParameterException)
        pub fn build(self) -> crate::error::InvalidParameterException {
            crate::error::InvalidParameterException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl InvalidParameterException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterException`](crate::error::InvalidParameterException)
    pub fn builder() -> crate::error::invalid_parameter_exception::Builder {
        crate::error::invalid_parameter_exception::Builder::default()
    }
}

/// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerError {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerError");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl InternalServerError {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerError")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerError {}
/// See [`InternalServerError`](crate::error::InternalServerError)
pub mod internal_server_error {
    /// A builder for [`InternalServerError`](crate::error::InternalServerError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerError`](crate::error::InternalServerError)
        pub fn build(self) -> crate::error::InternalServerError {
            crate::error::InternalServerError {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl InternalServerError {
    /// Creates a new builder-style object to manufacture [`InternalServerError`](crate::error::InternalServerError)
    pub fn builder() -> crate::error::internal_server_error::Builder {
        crate::error::internal_server_error::Builder::default()
    }
}

/// <p>You are not authorized to perform the action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl AccessDeniedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p></p>
///
///
/// <p>The size of the collection exceeds the allowed limit. For more information, see
/// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceQuotaExceededException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceQuotaExceededException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ServiceQuotaExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaExceededException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaExceededException {}
/// See [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
pub mod service_quota_exceeded_exception {
    /// A builder for [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
        pub fn build(self) -> crate::error::ServiceQuotaExceededException {
            crate::error::ServiceQuotaExceededException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ServiceQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    pub fn builder() -> crate::error::service_quota_exceeded_exception::Builder {
        crate::error::service_quota_exceeded_exception::Builder::default()
    }
}

/// <p>The file size or duration of the supplied media is too large. The maximum file size is 10GB.
/// The maximum duration is 6 hours. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VideoTooLargeException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VideoTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VideoTooLargeException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl VideoTooLargeException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for VideoTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "VideoTooLargeException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for VideoTooLargeException {}
/// See [`VideoTooLargeException`](crate::error::VideoTooLargeException)
pub mod video_too_large_exception {
    /// A builder for [`VideoTooLargeException`](crate::error::VideoTooLargeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`VideoTooLargeException`](crate::error::VideoTooLargeException)
        pub fn build(self) -> crate::error::VideoTooLargeException {
            crate::error::VideoTooLargeException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl VideoTooLargeException {
    /// Creates a new builder-style object to manufacture [`VideoTooLargeException`](crate::error::VideoTooLargeException)
    pub fn builder() -> crate::error::video_too_large_exception::Builder {
        crate::error::video_too_large_exception::Builder::default()
    }
}

/// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidS3ObjectException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidS3ObjectException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidS3ObjectException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl InvalidS3ObjectException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidS3ObjectException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidS3ObjectException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidS3ObjectException {}
/// See [`InvalidS3ObjectException`](crate::error::InvalidS3ObjectException)
pub mod invalid_s3_object_exception {
    /// A builder for [`InvalidS3ObjectException`](crate::error::InvalidS3ObjectException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidS3ObjectException`](crate::error::InvalidS3ObjectException)
        pub fn build(self) -> crate::error::InvalidS3ObjectException {
            crate::error::InvalidS3ObjectException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl InvalidS3ObjectException {
    /// Creates a new builder-style object to manufacture [`InvalidS3ObjectException`](crate::error::InvalidS3ObjectException)
    pub fn builder() -> crate::error::invalid_s3_object_exception::Builder {
        crate::error::invalid_s3_object_exception::Builder::default()
    }
}

/// <p>A <code>ClientRequestToken</code> input parameter was reused with an operation, but at least one of the other input
/// parameters is different from the previous call to the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdempotentParameterMismatchException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IdempotentParameterMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IdempotentParameterMismatchException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl IdempotentParameterMismatchException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IdempotentParameterMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IdempotentParameterMismatchException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for IdempotentParameterMismatchException {}
/// See [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
pub mod idempotent_parameter_mismatch_exception {
    /// A builder for [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
        pub fn build(self) -> crate::error::IdempotentParameterMismatchException {
            crate::error::IdempotentParameterMismatchException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl IdempotentParameterMismatchException {
    /// Creates a new builder-style object to manufacture [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
    pub fn builder() -> crate::error::idempotent_parameter_mismatch_exception::Builder {
        crate::error::idempotent_parameter_mismatch_exception::Builder::default()
    }
}

/// <p>The provided image format is not supported. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidImageFormatException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidImageFormatException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidImageFormatException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl InvalidImageFormatException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidImageFormatException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidImageFormatException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidImageFormatException {}
/// See [`InvalidImageFormatException`](crate::error::InvalidImageFormatException)
pub mod invalid_image_format_exception {
    /// A builder for [`InvalidImageFormatException`](crate::error::InvalidImageFormatException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidImageFormatException`](crate::error::InvalidImageFormatException)
        pub fn build(self) -> crate::error::InvalidImageFormatException {
            crate::error::InvalidImageFormatException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl InvalidImageFormatException {
    /// Creates a new builder-style object to manufacture [`InvalidImageFormatException`](crate::error::InvalidImageFormatException)
    pub fn builder() -> crate::error::invalid_image_format_exception::Builder {
        crate::error::invalid_image_format_exception::Builder::default()
    }
}

/// <p>The input image size exceeds the allowed limit. If you are calling
/// DetectProtectiveEquipment, the image size or resolution exceeds the allowed limit. For more information, see
/// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageTooLargeException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ImageTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageTooLargeException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ImageTooLargeException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ImageTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ImageTooLargeException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for ImageTooLargeException {}
/// See [`ImageTooLargeException`](crate::error::ImageTooLargeException)
pub mod image_too_large_exception {
    /// A builder for [`ImageTooLargeException`](crate::error::ImageTooLargeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageTooLargeException`](crate::error::ImageTooLargeException)
        pub fn build(self) -> crate::error::ImageTooLargeException {
            crate::error::ImageTooLargeException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ImageTooLargeException {
    /// Creates a new builder-style object to manufacture [`ImageTooLargeException`](crate::error::ImageTooLargeException)
    pub fn builder() -> crate::error::image_too_large_exception::Builder {
        crate::error::image_too_large_exception::Builder::default()
    }
}

/// <p>Pagination token in the request is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPaginationTokenException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPaginationTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPaginationTokenException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl InvalidPaginationTokenException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPaginationTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPaginationTokenException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPaginationTokenException {}
/// See [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException)
pub mod invalid_pagination_token_exception {
    /// A builder for [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException)
        pub fn build(self) -> crate::error::InvalidPaginationTokenException {
            crate::error::InvalidPaginationTokenException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl InvalidPaginationTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException)
    pub fn builder() -> crate::error::invalid_pagination_token_exception::Builder {
        crate::error::invalid_pagination_token_exception::Builder::default()
    }
}

/// <p>The requested resource isn't ready. For example,  
/// this exception occurs when you call <code>DetectCustomLabels</code> with a
/// model version that isn't deployed. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotReadyException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotReadyException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ResourceNotReadyException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotReadyException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotReadyException {}
/// See [`ResourceNotReadyException`](crate::error::ResourceNotReadyException)
pub mod resource_not_ready_exception {
    /// A builder for [`ResourceNotReadyException`](crate::error::ResourceNotReadyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotReadyException`](crate::error::ResourceNotReadyException)
        pub fn build(self) -> crate::error::ResourceNotReadyException {
            crate::error::ResourceNotReadyException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ResourceNotReadyException {
    /// Creates a new builder-style object to manufacture [`ResourceNotReadyException`](crate::error::ResourceNotReadyException)
    pub fn builder() -> crate::error::resource_not_ready_exception::Builder {
        crate::error::resource_not_ready_exception::Builder::default()
    }
}

/// <p>The number of in-progress human reviews you have has exceeded the number allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanLoopQuotaExceededException {
    /// <p>The resource type.</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The quota code.</p>
    pub quota_code: std::option::Option<std::string::String>,
    /// <p>The service code.</p>
    pub service_code: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HumanLoopQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanLoopQuotaExceededException");
        formatter.field("resource_type", &self.resource_type);
        formatter.field("quota_code", &self.quota_code);
        formatter.field("service_code", &self.service_code);
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl HumanLoopQuotaExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for HumanLoopQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "HumanLoopQuotaExceededException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for HumanLoopQuotaExceededException {}
/// See [`HumanLoopQuotaExceededException`](crate::error::HumanLoopQuotaExceededException)
pub mod human_loop_quota_exceeded_exception {
    /// A builder for [`HumanLoopQuotaExceededException`](crate::error::HumanLoopQuotaExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) quota_code: std::option::Option<std::string::String>,
        pub(crate) service_code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource type.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The quota code.</p>
        pub fn quota_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.quota_code = Some(input.into());
            self
        }
        /// <p>The quota code.</p>
        pub fn set_quota_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.quota_code = input;
            self
        }
        /// <p>The service code.</p>
        pub fn service_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_code = Some(input.into());
            self
        }
        /// <p>The service code.</p>
        pub fn set_service_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanLoopQuotaExceededException`](crate::error::HumanLoopQuotaExceededException)
        pub fn build(self) -> crate::error::HumanLoopQuotaExceededException {
            crate::error::HumanLoopQuotaExceededException {
                resource_type: self.resource_type,
                quota_code: self.quota_code,
                service_code: self.service_code,
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl HumanLoopQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`HumanLoopQuotaExceededException`](crate::error::HumanLoopQuotaExceededException)
    pub fn builder() -> crate::error::human_loop_quota_exceeded_exception::Builder {
        crate::error::human_loop_quota_exceeded_exception::Builder::default()
    }
}

/// <p>A resource with the specified ID already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceAlreadyExistsException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ResourceAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAlreadyExistsException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyExistsException {}
/// See [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
pub mod resource_already_exists_exception {
    /// A builder for [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
        pub fn build(self) -> crate::error::ResourceAlreadyExistsException {
            crate::error::ResourceAlreadyExistsException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ResourceAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    pub fn builder() -> crate::error::resource_already_exists_exception::Builder {
        crate::error::resource_already_exists_exception::Builder::default()
    }
}
