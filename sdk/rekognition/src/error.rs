// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CompareFacesError {
    pub kind: CompareFacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CompareFacesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ImageTooLargeException(crate::error::ImageTooLargeException),
    InternalServerError(crate::error::InternalServerError),
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CompareFacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CompareFacesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CompareFacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CompareFacesError {
    fn code(&self) -> Option<&str> {
        CompareFacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CompareFacesError {
    pub fn new(kind: CompareFacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CompareFacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CompareFacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CompareFacesErrorKind::AccessDeniedException(_))
    }
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(&self.kind, CompareFacesErrorKind::ImageTooLargeException(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CompareFacesErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            CompareFacesErrorKind::InvalidImageFormatException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CompareFacesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            CompareFacesErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CompareFacesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CompareFacesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CompareFacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CompareFacesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CompareFacesErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            CompareFacesErrorKind::InternalServerError(_inner) => Some(_inner),
            CompareFacesErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            CompareFacesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CompareFacesErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            CompareFacesErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            CompareFacesErrorKind::ThrottlingException(_inner) => Some(_inner),
            CompareFacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCollectionError {
    pub kind: CreateCollectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCollectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCollectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCollectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateCollectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateCollectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateCollectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateCollectionErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateCollectionErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateCollectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateCollectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCollectionError {
    fn code(&self) -> Option<&str> {
        CreateCollectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCollectionError {
    pub fn new(kind: CreateCollectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCollectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCollectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCollectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateCollectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCollectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateCollectionErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateCollectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateCollectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            CreateCollectionErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateCollectionErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateCollectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateCollectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProjectError {
    pub kind: CreateProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProjectErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProjectErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateProjectError {
    fn code(&self) -> Option<&str> {
        CreateProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProjectError {
    pub fn new(kind: CreateProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateProjectErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CreateProjectErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateProjectErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProjectErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateProjectErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateProjectErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateProjectErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateProjectErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            CreateProjectErrorKind::ResourceInUseException(_inner) => Some(_inner),
            CreateProjectErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProjectVersionError {
    pub kind: CreateProjectVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProjectVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateProjectVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProjectVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateProjectVersionErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateProjectVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateProjectVersionError {
    fn code(&self) -> Option<&str> {
        CreateProjectVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProjectVersionError {
    pub fn new(kind: CreateProjectVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProjectVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProjectVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectVersionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateProjectVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProjectVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            CreateProjectVersionErrorKind::ResourceInUseException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateProjectVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateStreamProcessorError {
    pub kind: CreateStreamProcessorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateStreamProcessorErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateStreamProcessorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateStreamProcessorErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateStreamProcessorErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateStreamProcessorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateStreamProcessorError {
    fn code(&self) -> Option<&str> {
        CreateStreamProcessorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateStreamProcessorError {
    pub fn new(kind: CreateStreamProcessorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateStreamProcessorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateStreamProcessorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamProcessorErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateStreamProcessorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateStreamProcessorErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            CreateStreamProcessorErrorKind::ResourceInUseException(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateStreamProcessorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCollectionError {
    pub kind: DeleteCollectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCollectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCollectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCollectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteCollectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteCollectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteCollectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DeleteCollectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteCollectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteCollectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCollectionError {
    fn code(&self) -> Option<&str> {
        DeleteCollectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCollectionError {
    pub fn new(kind: DeleteCollectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCollectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCollectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCollectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCollectionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCollectionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCollectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCollectionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCollectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteCollectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCollectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteCollectionErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteCollectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteCollectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DeleteCollectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteCollectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteCollectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFacesError {
    pub kind: DeleteFacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFacesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFacesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteFacesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteFacesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteFacesErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            DeleteFacesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteFacesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteFacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFacesError {
    fn code(&self) -> Option<&str> {
        DeleteFacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFacesError {
    pub fn new(kind: DeleteFacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteFacesErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteFacesErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFacesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFacesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFacesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteFacesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteFacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFacesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteFacesErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteFacesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteFacesErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            DeleteFacesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteFacesErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteFacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProjectError {
    pub kind: DeleteProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProjectErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProjectErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteProjectError {
    fn code(&self) -> Option<&str> {
        DeleteProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProjectError {
    pub fn new(kind: DeleteProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteProjectErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteProjectErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteProjectErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProjectErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteProjectErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteProjectErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteProjectErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            DeleteProjectErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteProjectErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteProjectErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProjectVersionError {
    pub kind: DeleteProjectVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProjectVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteProjectVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProjectVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteProjectVersionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteProjectVersionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProjectVersionErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteProjectVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteProjectVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteProjectVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteProjectVersionError {
    fn code(&self) -> Option<&str> {
        DeleteProjectVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProjectVersionError {
    pub fn new(kind: DeleteProjectVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProjectVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProjectVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectVersionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteProjectVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProjectVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteProjectVersionErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteProjectVersionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DeleteProjectVersionErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteProjectVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteProjectVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteProjectVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteStreamProcessorError {
    pub kind: DeleteStreamProcessorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteStreamProcessorErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteStreamProcessorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteStreamProcessorErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteStreamProcessorErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteStreamProcessorErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DeleteStreamProcessorErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteStreamProcessorErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteStreamProcessorErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteStreamProcessorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteStreamProcessorError {
    fn code(&self) -> Option<&str> {
        DeleteStreamProcessorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteStreamProcessorError {
    pub fn new(kind: DeleteStreamProcessorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteStreamProcessorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteStreamProcessorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamProcessorErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteStreamProcessorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteStreamProcessorErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteStreamProcessorErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteStreamProcessorErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DeleteStreamProcessorErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteStreamProcessorErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteStreamProcessorErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteStreamProcessorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCollectionError {
    pub kind: DescribeCollectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCollectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCollectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCollectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeCollectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeCollectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeCollectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCollectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeCollectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeCollectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCollectionError {
    fn code(&self) -> Option<&str> {
        DescribeCollectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCollectionError {
    pub fn new(kind: DescribeCollectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCollectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCollectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCollectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCollectionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCollectionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCollectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCollectionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCollectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeCollectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCollectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeCollectionErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeCollectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeCollectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DescribeCollectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeCollectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeCollectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeProjectsError {
    pub kind: DescribeProjectsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeProjectsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeProjectsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeProjectsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeProjectsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeProjectsErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            DescribeProjectsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeProjectsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProjectsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeProjectsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeProjectsError {
    fn code(&self) -> Option<&str> {
        DescribeProjectsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeProjectsError {
    pub fn new(kind: DescribeProjectsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeProjectsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeProjectsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectsErrorKind::InvalidPaginationTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeProjectsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeProjectsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeProjectsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeProjectsErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            DescribeProjectsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeProjectsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DescribeProjectsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeProjectsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeProjectVersionsError {
    pub kind: DescribeProjectVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeProjectVersionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeProjectVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeProjectVersionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeProjectVersionsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeProjectVersionsErrorKind::InvalidPaginationTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProjectVersionsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeProjectVersionsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProjectVersionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeProjectVersionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeProjectVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeProjectVersionsError {
    fn code(&self) -> Option<&str> {
        DescribeProjectVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeProjectVersionsError {
    pub fn new(kind: DescribeProjectVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeProjectVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeProjectVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::InvalidPaginationTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectVersionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeProjectVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeProjectVersionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeProjectVersionsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeProjectVersionsErrorKind::InvalidPaginationTokenException(_inner) => {
                Some(_inner)
            }
            DescribeProjectVersionsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeProjectVersionsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DescribeProjectVersionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeProjectVersionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeProjectVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStreamProcessorError {
    pub kind: DescribeStreamProcessorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStreamProcessorErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStreamProcessorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStreamProcessorErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeStreamProcessorErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeStreamProcessorErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeStreamProcessorErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeStreamProcessorErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeStreamProcessorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStreamProcessorError {
    fn code(&self) -> Option<&str> {
        DescribeStreamProcessorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStreamProcessorError {
    pub fn new(kind: DescribeStreamProcessorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStreamProcessorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStreamProcessorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamProcessorErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamProcessorErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamProcessorErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamProcessorErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamProcessorErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamProcessorErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeStreamProcessorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStreamProcessorErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeStreamProcessorErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeStreamProcessorErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DescribeStreamProcessorErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeStreamProcessorErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeStreamProcessorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectCustomLabelsError {
    pub kind: DetectCustomLabelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectCustomLabelsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ImageTooLargeException(crate::error::ImageTooLargeException),
    InternalServerError(crate::error::InternalServerError),
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    LimitExceededException(crate::error::LimitExceededException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceNotReadyException(crate::error::ResourceNotReadyException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectCustomLabelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectCustomLabelsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DetectCustomLabelsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::ResourceNotReadyException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetectCustomLabelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetectCustomLabelsError {
    fn code(&self) -> Option<&str> {
        DetectCustomLabelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectCustomLabelsError {
    pub fn new(kind: DetectCustomLabelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectCustomLabelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectCustomLabelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::ImageTooLargeException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::InvalidImageFormatException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::ResourceNotReadyException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectCustomLabelsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DetectCustomLabelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectCustomLabelsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::InternalServerError(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::LimitExceededException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DetectCustomLabelsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::ResourceNotReadyException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetectCustomLabelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectFacesError {
    pub kind: DetectFacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectFacesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ImageTooLargeException(crate::error::ImageTooLargeException),
    InternalServerError(crate::error::InternalServerError),
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectFacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectFacesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetectFacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetectFacesError {
    fn code(&self) -> Option<&str> {
        DetectFacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectFacesError {
    pub fn new(kind: DetectFacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectFacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectFacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DetectFacesErrorKind::AccessDeniedException(_))
    }
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(&self.kind, DetectFacesErrorKind::ImageTooLargeException(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DetectFacesErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectFacesErrorKind::InvalidImageFormatException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectFacesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectFacesErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectFacesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DetectFacesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DetectFacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectFacesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetectFacesErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            DetectFacesErrorKind::InternalServerError(_inner) => Some(_inner),
            DetectFacesErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            DetectFacesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DetectFacesErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            DetectFacesErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            DetectFacesErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetectFacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectLabelsError {
    pub kind: DetectLabelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectLabelsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ImageTooLargeException(crate::error::ImageTooLargeException),
    InternalServerError(crate::error::InternalServerError),
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectLabelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectLabelsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetectLabelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetectLabelsError {
    fn code(&self) -> Option<&str> {
        DetectLabelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectLabelsError {
    pub fn new(kind: DetectLabelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectLabelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectLabelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DetectLabelsErrorKind::AccessDeniedException(_))
    }
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(&self.kind, DetectLabelsErrorKind::ImageTooLargeException(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DetectLabelsErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectLabelsErrorKind::InvalidImageFormatException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectLabelsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectLabelsErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectLabelsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DetectLabelsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DetectLabelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectLabelsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetectLabelsErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            DetectLabelsErrorKind::InternalServerError(_inner) => Some(_inner),
            DetectLabelsErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            DetectLabelsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DetectLabelsErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            DetectLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            DetectLabelsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetectLabelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectModerationLabelsError {
    pub kind: DetectModerationLabelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectModerationLabelsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    HumanLoopQuotaExceededException(crate::error::HumanLoopQuotaExceededException),
    ImageTooLargeException(crate::error::ImageTooLargeException),
    InternalServerError(crate::error::InternalServerError),
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectModerationLabelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectModerationLabelsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::HumanLoopQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            DetectModerationLabelsErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DetectModerationLabelsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetectModerationLabelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetectModerationLabelsError {
    fn code(&self) -> Option<&str> {
        DetectModerationLabelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectModerationLabelsError {
    pub fn new(kind: DetectModerationLabelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectModerationLabelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectModerationLabelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_human_loop_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::HumanLoopQuotaExceededException(_)
        )
    }
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::ImageTooLargeException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::InvalidImageFormatException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectModerationLabelsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DetectModerationLabelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectModerationLabelsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::HumanLoopQuotaExceededException(_inner) => {
                Some(_inner)
            }
            DetectModerationLabelsErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::InternalServerError(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DetectModerationLabelsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetectModerationLabelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectProtectiveEquipmentError {
    pub kind: DetectProtectiveEquipmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectProtectiveEquipmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ImageTooLargeException(crate::error::ImageTooLargeException),
    InternalServerError(crate::error::InternalServerError),
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectProtectiveEquipmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectProtectiveEquipmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetectProtectiveEquipmentErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            DetectProtectiveEquipmentErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DetectProtectiveEquipmentErrorKind::InvalidImageFormatException(_inner) => {
                _inner.fmt(f)
            }
            DetectProtectiveEquipmentErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DetectProtectiveEquipmentErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            DetectProtectiveEquipmentErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            DetectProtectiveEquipmentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetectProtectiveEquipmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetectProtectiveEquipmentError {
    fn code(&self) -> Option<&str> {
        DetectProtectiveEquipmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectProtectiveEquipmentError {
    pub fn new(kind: DetectProtectiveEquipmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectProtectiveEquipmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectProtectiveEquipmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::ImageTooLargeException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::InvalidImageFormatException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectProtectiveEquipmentErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DetectProtectiveEquipmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectProtectiveEquipmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::InternalServerError(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            DetectProtectiveEquipmentErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetectProtectiveEquipmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectTextError {
    pub kind: DetectTextErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectTextErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ImageTooLargeException(crate::error::ImageTooLargeException),
    InternalServerError(crate::error::InternalServerError),
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectTextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectTextErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DetectTextErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetectTextErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetectTextError {
    fn code(&self) -> Option<&str> {
        DetectTextError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectTextError {
    pub fn new(kind: DetectTextErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectTextErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectTextErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DetectTextErrorKind::AccessDeniedException(_))
    }
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(&self.kind, DetectTextErrorKind::ImageTooLargeException(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DetectTextErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectTextErrorKind::InvalidImageFormatException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectTextErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(&self.kind, DetectTextErrorKind::InvalidS3ObjectException(_))
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetectTextErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DetectTextErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DetectTextError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectTextErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetectTextErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            DetectTextErrorKind::InternalServerError(_inner) => Some(_inner),
            DetectTextErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            DetectTextErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DetectTextErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            DetectTextErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            DetectTextErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetectTextErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCelebrityInfoError {
    pub kind: GetCelebrityInfoErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCelebrityInfoErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCelebrityInfoError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCelebrityInfoErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetCelebrityInfoErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetCelebrityInfoErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetCelebrityInfoErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetCelebrityInfoErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetCelebrityInfoErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetCelebrityInfoErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCelebrityInfoError {
    fn code(&self) -> Option<&str> {
        GetCelebrityInfoError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCelebrityInfoError {
    pub fn new(kind: GetCelebrityInfoErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCelebrityInfoErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCelebrityInfoErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityInfoErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityInfoErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityInfoErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityInfoErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityInfoErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityInfoErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetCelebrityInfoError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCelebrityInfoErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetCelebrityInfoErrorKind::InternalServerError(_inner) => Some(_inner),
            GetCelebrityInfoErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetCelebrityInfoErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetCelebrityInfoErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetCelebrityInfoErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetCelebrityInfoErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCelebrityRecognitionError {
    pub kind: GetCelebrityRecognitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCelebrityRecognitionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCelebrityRecognitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCelebrityRecognitionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetCelebrityRecognitionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetCelebrityRecognitionErrorKind::InvalidPaginationTokenException(_inner) => {
                _inner.fmt(f)
            }
            GetCelebrityRecognitionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetCelebrityRecognitionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetCelebrityRecognitionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetCelebrityRecognitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCelebrityRecognitionError {
    fn code(&self) -> Option<&str> {
        GetCelebrityRecognitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCelebrityRecognitionError {
    pub fn new(kind: GetCelebrityRecognitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCelebrityRecognitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCelebrityRecognitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::InvalidPaginationTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCelebrityRecognitionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetCelebrityRecognitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCelebrityRecognitionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetCelebrityRecognitionErrorKind::InternalServerError(_inner) => Some(_inner),
            GetCelebrityRecognitionErrorKind::InvalidPaginationTokenException(_inner) => {
                Some(_inner)
            }
            GetCelebrityRecognitionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetCelebrityRecognitionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetCelebrityRecognitionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetCelebrityRecognitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContentModerationError {
    pub kind: GetContentModerationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContentModerationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContentModerationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContentModerationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetContentModerationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetContentModerationErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetContentModerationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetContentModerationErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetContentModerationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetContentModerationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetContentModerationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContentModerationError {
    fn code(&self) -> Option<&str> {
        GetContentModerationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContentModerationError {
    pub fn new(kind: GetContentModerationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContentModerationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContentModerationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::InvalidPaginationTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContentModerationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetContentModerationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContentModerationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetContentModerationErrorKind::InternalServerError(_inner) => Some(_inner),
            GetContentModerationErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetContentModerationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetContentModerationErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetContentModerationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetContentModerationErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetContentModerationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFaceDetectionError {
    pub kind: GetFaceDetectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFaceDetectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFaceDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFaceDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetFaceDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetFaceDetectionErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetFaceDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetFaceDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetFaceDetectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetFaceDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetFaceDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFaceDetectionError {
    fn code(&self) -> Option<&str> {
        GetFaceDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFaceDetectionError {
    pub fn new(kind: GetFaceDetectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFaceDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFaceDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::InvalidPaginationTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceDetectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetFaceDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFaceDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetFaceDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            GetFaceDetectionErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetFaceDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetFaceDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetFaceDetectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetFaceDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetFaceDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFaceSearchError {
    pub kind: GetFaceSearchErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFaceSearchErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFaceSearchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFaceSearchErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetFaceSearchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFaceSearchError {
    fn code(&self) -> Option<&str> {
        GetFaceSearchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFaceSearchError {
    pub fn new(kind: GetFaceSearchErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFaceSearchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFaceSearchErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetFaceSearchErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, GetFaceSearchErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceSearchErrorKind::InvalidPaginationTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceSearchErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceSearchErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFaceSearchErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetFaceSearchErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for GetFaceSearchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFaceSearchErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetFaceSearchErrorKind::InternalServerError(_inner) => Some(_inner),
            GetFaceSearchErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetFaceSearchErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetFaceSearchErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            GetFaceSearchErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetFaceSearchErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetFaceSearchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLabelDetectionError {
    pub kind: GetLabelDetectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLabelDetectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLabelDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLabelDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetLabelDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetLabelDetectionErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetLabelDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetLabelDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetLabelDetectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetLabelDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetLabelDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLabelDetectionError {
    fn code(&self) -> Option<&str> {
        GetLabelDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLabelDetectionError {
    pub fn new(kind: GetLabelDetectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLabelDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLabelDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::InvalidPaginationTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLabelDetectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetLabelDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLabelDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetLabelDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            GetLabelDetectionErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetLabelDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetLabelDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetLabelDetectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetLabelDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetLabelDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPersonTrackingError {
    pub kind: GetPersonTrackingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPersonTrackingErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPersonTrackingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPersonTrackingErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetPersonTrackingErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetPersonTrackingErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetPersonTrackingErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetPersonTrackingErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetPersonTrackingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetPersonTrackingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetPersonTrackingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPersonTrackingError {
    fn code(&self) -> Option<&str> {
        GetPersonTrackingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPersonTrackingError {
    pub fn new(kind: GetPersonTrackingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPersonTrackingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPersonTrackingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::InvalidPaginationTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPersonTrackingErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetPersonTrackingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPersonTrackingErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetPersonTrackingErrorKind::InternalServerError(_inner) => Some(_inner),
            GetPersonTrackingErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetPersonTrackingErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetPersonTrackingErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetPersonTrackingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetPersonTrackingErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetPersonTrackingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSegmentDetectionError {
    pub kind: GetSegmentDetectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSegmentDetectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSegmentDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSegmentDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetSegmentDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetSegmentDetectionErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetSegmentDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetSegmentDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetSegmentDetectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetSegmentDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetSegmentDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSegmentDetectionError {
    fn code(&self) -> Option<&str> {
        GetSegmentDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSegmentDetectionError {
    pub fn new(kind: GetSegmentDetectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSegmentDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSegmentDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::InvalidPaginationTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentDetectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetSegmentDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSegmentDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetSegmentDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            GetSegmentDetectionErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetSegmentDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetSegmentDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetSegmentDetectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetSegmentDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetSegmentDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTextDetectionError {
    pub kind: GetTextDetectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTextDetectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTextDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTextDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetTextDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetTextDetectionErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            GetTextDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetTextDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetTextDetectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetTextDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetTextDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTextDetectionError {
    fn code(&self) -> Option<&str> {
        GetTextDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTextDetectionError {
    pub fn new(kind: GetTextDetectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTextDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTextDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::InvalidPaginationTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTextDetectionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetTextDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTextDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetTextDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            GetTextDetectionErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            GetTextDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetTextDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            GetTextDetectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetTextDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetTextDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct IndexFacesError {
    pub kind: IndexFacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum IndexFacesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ImageTooLargeException(crate::error::ImageTooLargeException),
    InternalServerError(crate::error::InternalServerError),
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for IndexFacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            IndexFacesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            IndexFacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for IndexFacesError {
    fn code(&self) -> Option<&str> {
        IndexFacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl IndexFacesError {
    pub fn new(kind: IndexFacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: IndexFacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: IndexFacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, IndexFacesErrorKind::AccessDeniedException(_))
    }
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(&self.kind, IndexFacesErrorKind::ImageTooLargeException(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, IndexFacesErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            IndexFacesErrorKind::InvalidImageFormatException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            IndexFacesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(&self.kind, IndexFacesErrorKind::InvalidS3ObjectException(_))
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            IndexFacesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            IndexFacesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            IndexFacesErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, IndexFacesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for IndexFacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            IndexFacesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            IndexFacesErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            IndexFacesErrorKind::InternalServerError(_inner) => Some(_inner),
            IndexFacesErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            IndexFacesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            IndexFacesErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            IndexFacesErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            IndexFacesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            IndexFacesErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            IndexFacesErrorKind::ThrottlingException(_inner) => Some(_inner),
            IndexFacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCollectionsError {
    pub kind: ListCollectionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCollectionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCollectionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCollectionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListCollectionsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListCollectionsErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            ListCollectionsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListCollectionsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListCollectionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListCollectionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListCollectionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCollectionsError {
    fn code(&self) -> Option<&str> {
        ListCollectionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCollectionsError {
    pub fn new(kind: ListCollectionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCollectionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCollectionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCollectionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListCollectionsErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCollectionsErrorKind::InvalidPaginationTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCollectionsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCollectionsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCollectionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListCollectionsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListCollectionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCollectionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListCollectionsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListCollectionsErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            ListCollectionsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListCollectionsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            ListCollectionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListCollectionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListCollectionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFacesError {
    pub kind: ListFacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFacesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFacesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListFacesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListFacesErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            ListFacesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListFacesErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            ListFacesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListFacesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListFacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFacesError {
    fn code(&self) -> Option<&str> {
        ListFacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFacesError {
    pub fn new(kind: ListFacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListFacesErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListFacesErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFacesErrorKind::InvalidPaginationTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(&self.kind, ListFacesErrorKind::InvalidParameterException(_))
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFacesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListFacesErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListFacesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListFacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFacesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListFacesErrorKind::InternalServerError(_inner) => Some(_inner),
            ListFacesErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            ListFacesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListFacesErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            ListFacesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListFacesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListStreamProcessorsError {
    pub kind: ListStreamProcessorsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListStreamProcessorsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListStreamProcessorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListStreamProcessorsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListStreamProcessorsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListStreamProcessorsErrorKind::InvalidPaginationTokenException(_inner) => _inner.fmt(f),
            ListStreamProcessorsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListStreamProcessorsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListStreamProcessorsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListStreamProcessorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListStreamProcessorsError {
    fn code(&self) -> Option<&str> {
        ListStreamProcessorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListStreamProcessorsError {
    pub fn new(kind: ListStreamProcessorsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListStreamProcessorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListStreamProcessorsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamProcessorsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamProcessorsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamProcessorsErrorKind::InvalidPaginationTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamProcessorsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamProcessorsErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamProcessorsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListStreamProcessorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListStreamProcessorsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListStreamProcessorsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListStreamProcessorsErrorKind::InvalidPaginationTokenException(_inner) => Some(_inner),
            ListStreamProcessorsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListStreamProcessorsErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            ListStreamProcessorsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListStreamProcessorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RecognizeCelebritiesError {
    pub kind: RecognizeCelebritiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RecognizeCelebritiesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ImageTooLargeException(crate::error::ImageTooLargeException),
    InternalServerError(crate::error::InternalServerError),
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RecognizeCelebritiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RecognizeCelebritiesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            RecognizeCelebritiesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RecognizeCelebritiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RecognizeCelebritiesError {
    fn code(&self) -> Option<&str> {
        RecognizeCelebritiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RecognizeCelebritiesError {
    pub fn new(kind: RecognizeCelebritiesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RecognizeCelebritiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RecognizeCelebritiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::ImageTooLargeException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::InvalidImageFormatException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RecognizeCelebritiesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for RecognizeCelebritiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RecognizeCelebritiesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::InternalServerError(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            RecognizeCelebritiesErrorKind::ThrottlingException(_inner) => Some(_inner),
            RecognizeCelebritiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchFacesError {
    pub kind: SearchFacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchFacesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SearchFacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchFacesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SearchFacesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            SearchFacesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            SearchFacesErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            SearchFacesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SearchFacesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SearchFacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SearchFacesError {
    fn code(&self) -> Option<&str> {
        SearchFacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SearchFacesError {
    pub fn new(kind: SearchFacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SearchFacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SearchFacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, SearchFacesErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, SearchFacesErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, SearchFacesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for SearchFacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchFacesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SearchFacesErrorKind::InternalServerError(_inner) => Some(_inner),
            SearchFacesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            SearchFacesErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            SearchFacesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SearchFacesErrorKind::ThrottlingException(_inner) => Some(_inner),
            SearchFacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchFacesByImageError {
    pub kind: SearchFacesByImageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchFacesByImageErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ImageTooLargeException(crate::error::ImageTooLargeException),
    InternalServerError(crate::error::InternalServerError),
    InvalidImageFormatException(crate::error::InvalidImageFormatException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SearchFacesByImageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchFacesByImageErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::ImageTooLargeException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::InvalidImageFormatException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            SearchFacesByImageErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SearchFacesByImageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SearchFacesByImageError {
    fn code(&self) -> Option<&str> {
        SearchFacesByImageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SearchFacesByImageError {
    pub fn new(kind: SearchFacesByImageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SearchFacesByImageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SearchFacesByImageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_image_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::ImageTooLargeException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_image_format_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::InvalidImageFormatException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFacesByImageErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for SearchFacesByImageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchFacesByImageErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::ImageTooLargeException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::InternalServerError(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::InvalidImageFormatException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::InvalidParameterException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            SearchFacesByImageErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::ThrottlingException(_inner) => Some(_inner),
            SearchFacesByImageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartCelebrityRecognitionError {
    pub kind: StartCelebrityRecognitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartCelebrityRecognitionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    LimitExceededException(crate::error::LimitExceededException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartCelebrityRecognitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartCelebrityRecognitionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartCelebrityRecognitionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartCelebrityRecognitionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartCelebrityRecognitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartCelebrityRecognitionError {
    fn code(&self) -> Option<&str> {
        StartCelebrityRecognitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartCelebrityRecognitionError {
    pub fn new(kind: StartCelebrityRecognitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartCelebrityRecognitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartCelebrityRecognitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCelebrityRecognitionErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartCelebrityRecognitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartCelebrityRecognitionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartCelebrityRecognitionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartCelebrityRecognitionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartCelebrityRecognitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartContentModerationError {
    pub kind: StartContentModerationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartContentModerationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    LimitExceededException(crate::error::LimitExceededException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartContentModerationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartContentModerationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartContentModerationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartContentModerationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartContentModerationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartContentModerationError {
    fn code(&self) -> Option<&str> {
        StartContentModerationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartContentModerationError {
    pub fn new(kind: StartContentModerationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartContentModerationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartContentModerationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContentModerationErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartContentModerationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartContentModerationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartContentModerationErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartContentModerationErrorKind::InternalServerError(_inner) => Some(_inner),
            StartContentModerationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartContentModerationErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartContentModerationErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartContentModerationErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartContentModerationErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartContentModerationErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartContentModerationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartFaceDetectionError {
    pub kind: StartFaceDetectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartFaceDetectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    LimitExceededException(crate::error::LimitExceededException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartFaceDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartFaceDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartFaceDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartFaceDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartFaceDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartFaceDetectionError {
    fn code(&self) -> Option<&str> {
        StartFaceDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartFaceDetectionError {
    pub fn new(kind: StartFaceDetectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartFaceDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartFaceDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceDetectionErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartFaceDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartFaceDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartFaceDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartFaceDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartFaceDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartFaceSearchError {
    pub kind: StartFaceSearchErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartFaceSearchErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    LimitExceededException(crate::error::LimitExceededException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartFaceSearchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartFaceSearchErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::IdempotentParameterMismatchException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartFaceSearchErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartFaceSearchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartFaceSearchError {
    fn code(&self) -> Option<&str> {
        StartFaceSearchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartFaceSearchError {
    pub fn new(kind: StartFaceSearchErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartFaceSearchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartFaceSearchErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, StartFaceSearchErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, StartFaceSearchErrorKind::ThrottlingException(_))
    }
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartFaceSearchErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartFaceSearchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartFaceSearchErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::IdempotentParameterMismatchException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::InternalServerError(_inner) => Some(_inner),
            StartFaceSearchErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartFaceSearchErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartFaceSearchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartLabelDetectionError {
    pub kind: StartLabelDetectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartLabelDetectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    LimitExceededException(crate::error::LimitExceededException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartLabelDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartLabelDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartLabelDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartLabelDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartLabelDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartLabelDetectionError {
    fn code(&self) -> Option<&str> {
        StartLabelDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartLabelDetectionError {
    pub fn new(kind: StartLabelDetectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartLabelDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartLabelDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLabelDetectionErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartLabelDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartLabelDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartLabelDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartLabelDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartLabelDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartPersonTrackingError {
    pub kind: StartPersonTrackingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartPersonTrackingErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    LimitExceededException(crate::error::LimitExceededException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartPersonTrackingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartPersonTrackingErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartPersonTrackingErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartPersonTrackingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartPersonTrackingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartPersonTrackingError {
    fn code(&self) -> Option<&str> {
        StartPersonTrackingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartPersonTrackingError {
    pub fn new(kind: StartPersonTrackingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartPersonTrackingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartPersonTrackingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartPersonTrackingErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartPersonTrackingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartPersonTrackingErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartPersonTrackingErrorKind::InternalServerError(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartPersonTrackingErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartPersonTrackingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartProjectVersionError {
    pub kind: StartProjectVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartProjectVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartProjectVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartProjectVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartProjectVersionErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartProjectVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartProjectVersionError {
    fn code(&self) -> Option<&str> {
        StartProjectVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartProjectVersionError {
    pub fn new(kind: StartProjectVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartProjectVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartProjectVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProjectVersionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StartProjectVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartProjectVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartProjectVersionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartProjectVersionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartProjectVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartProjectVersionErrorKind::ResourceInUseException(_inner) => Some(_inner),
            StartProjectVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartProjectVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartProjectVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartSegmentDetectionError {
    pub kind: StartSegmentDetectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartSegmentDetectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    LimitExceededException(crate::error::LimitExceededException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartSegmentDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartSegmentDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartSegmentDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartSegmentDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartSegmentDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartSegmentDetectionError {
    fn code(&self) -> Option<&str> {
        StartSegmentDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartSegmentDetectionError {
    pub fn new(kind: StartSegmentDetectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartSegmentDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartSegmentDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSegmentDetectionErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartSegmentDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartSegmentDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartSegmentDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartSegmentDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartSegmentDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartStreamProcessorError {
    pub kind: StartStreamProcessorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartStreamProcessorErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartStreamProcessorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartStreamProcessorErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartStreamProcessorErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartStreamProcessorErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartStreamProcessorErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            StartStreamProcessorErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartStreamProcessorErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartStreamProcessorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartStreamProcessorError {
    fn code(&self) -> Option<&str> {
        StartStreamProcessorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartStreamProcessorError {
    pub fn new(kind: StartStreamProcessorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartStreamProcessorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartStreamProcessorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartStreamProcessorErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StartStreamProcessorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartStreamProcessorErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartStreamProcessorErrorKind::InternalServerError(_inner) => Some(_inner),
            StartStreamProcessorErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartStreamProcessorErrorKind::ResourceInUseException(_inner) => Some(_inner),
            StartStreamProcessorErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartStreamProcessorErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartStreamProcessorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartTextDetectionError {
    pub kind: StartTextDetectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartTextDetectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidS3ObjectException(crate::error::InvalidS3ObjectException),
    LimitExceededException(crate::error::LimitExceededException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    VideoTooLargeException(crate::error::VideoTooLargeException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartTextDetectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartTextDetectionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartTextDetectionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::InvalidS3ObjectException(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartTextDetectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::VideoTooLargeException(_inner) => _inner.fmt(f),
            StartTextDetectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartTextDetectionError {
    fn code(&self) -> Option<&str> {
        StartTextDetectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartTextDetectionError {
    pub fn new(kind: StartTextDetectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartTextDetectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartTextDetectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_s3_object_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::InvalidS3ObjectException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_video_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTextDetectionErrorKind::VideoTooLargeException(_)
        )
    }
}
impl std::error::Error for StartTextDetectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartTextDetectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartTextDetectionErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartTextDetectionErrorKind::InternalServerError(_inner) => Some(_inner),
            StartTextDetectionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartTextDetectionErrorKind::InvalidS3ObjectException(_inner) => Some(_inner),
            StartTextDetectionErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartTextDetectionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StartTextDetectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartTextDetectionErrorKind::VideoTooLargeException(_inner) => Some(_inner),
            StartTextDetectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopProjectVersionError {
    pub kind: StopProjectVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopProjectVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopProjectVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopProjectVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StopProjectVersionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StopProjectVersionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StopProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StopProjectVersionErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            StopProjectVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StopProjectVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StopProjectVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopProjectVersionError {
    fn code(&self) -> Option<&str> {
        StopProjectVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopProjectVersionError {
    pub fn new(kind: StopProjectVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopProjectVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopProjectVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProjectVersionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StopProjectVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopProjectVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StopProjectVersionErrorKind::InternalServerError(_inner) => Some(_inner),
            StopProjectVersionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StopProjectVersionErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StopProjectVersionErrorKind::ResourceInUseException(_inner) => Some(_inner),
            StopProjectVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StopProjectVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StopProjectVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopStreamProcessorError {
    pub kind: StopStreamProcessorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopStreamProcessorErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopStreamProcessorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopStreamProcessorErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StopStreamProcessorErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StopStreamProcessorErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StopStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                _inner.fmt(f)
            }
            StopStreamProcessorErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            StopStreamProcessorErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StopStreamProcessorErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StopStreamProcessorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopStreamProcessorError {
    fn code(&self) -> Option<&str> {
        StopStreamProcessorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopStreamProcessorError {
    pub fn new(kind: StopStreamProcessorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopStreamProcessorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopStreamProcessorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopStreamProcessorErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StopStreamProcessorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopStreamProcessorErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StopStreamProcessorErrorKind::InternalServerError(_inner) => Some(_inner),
            StopStreamProcessorErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StopStreamProcessorErrorKind::ProvisionedThroughputExceededException(_inner) => {
                Some(_inner)
            }
            StopStreamProcessorErrorKind::ResourceInUseException(_inner) => Some(_inner),
            StopStreamProcessorErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StopStreamProcessorErrorKind::ThrottlingException(_inner) => Some(_inner),
            StopStreamProcessorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            TagResourceErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerError(crate::error::InternalServerError),
    InvalidParameterException(crate::error::InvalidParameterException),
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ProvisionedThroughputExceededException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_provisioned_throughput_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ProvisionedThroughputExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UntagResourceErrorKind::ProvisionedThroughputExceededException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>Amazon Rekognition is temporarily unable to process the request. Try your call again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ThrottlingException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException)
pub mod throttling_exception {
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException)
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException)
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>The resource specified in the request cannot be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The number of requests exceeded your throughput limit. If you want to increase this
/// limit, contact Amazon Rekognition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProvisionedThroughputExceededException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProvisionedThroughputExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisionedThroughputExceededException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ProvisionedThroughputExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ProvisionedThroughputExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ProvisionedThroughputExceededException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ProvisionedThroughputExceededException {}
/// See [`ProvisionedThroughputExceededException`](crate::error::ProvisionedThroughputExceededException)
pub mod provisioned_throughput_exceeded_exception {
    /// A builder for [`ProvisionedThroughputExceededException`](crate::error::ProvisionedThroughputExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedThroughputExceededException`](crate::error::ProvisionedThroughputExceededException)
        pub fn build(self) -> crate::error::ProvisionedThroughputExceededException {
            crate::error::ProvisionedThroughputExceededException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ProvisionedThroughputExceededException {
    /// Creates a new builder-style object to manufacture [`ProvisionedThroughputExceededException`](crate::error::ProvisionedThroughputExceededException)
    pub fn builder() -> crate::error::provisioned_throughput_exceeded_exception::Builder {
        crate::error::provisioned_throughput_exceeded_exception::Builder::default()
    }
}

/// <p>Input parameter violated a constraint. Validate your parameter before calling the API
/// operation again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl InvalidParameterException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterException {}
/// See [`InvalidParameterException`](crate::error::InvalidParameterException)
pub mod invalid_parameter_exception {
    /// A builder for [`InvalidParameterException`](crate::error::InvalidParameterException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterException`](crate::error::InvalidParameterException)
        pub fn build(self) -> crate::error::InvalidParameterException {
            crate::error::InvalidParameterException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl InvalidParameterException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterException`](crate::error::InvalidParameterException)
    pub fn builder() -> crate::error::invalid_parameter_exception::Builder {
        crate::error::invalid_parameter_exception::Builder::default()
    }
}

/// <p>Amazon Rekognition experienced a service issue. Try your call again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerError {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerError");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl InternalServerError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerError")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerError {}
/// See [`InternalServerError`](crate::error::InternalServerError)
pub mod internal_server_error {
    /// A builder for [`InternalServerError`](crate::error::InternalServerError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerError`](crate::error::InternalServerError)
        pub fn build(self) -> crate::error::InternalServerError {
            crate::error::InternalServerError {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl InternalServerError {
    /// Creates a new builder-style object to manufacture [`InternalServerError`](crate::error::InternalServerError)
    pub fn builder() -> crate::error::internal_server_error::Builder {
        crate::error::internal_server_error::Builder::default()
    }
}

/// <p>You are not authorized to perform the action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p></p>
/// <p>The size of the collection exceeds the allowed limit. For more information, see
/// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceQuotaExceededException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceQuotaExceededException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ServiceQuotaExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaExceededException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaExceededException {}
/// See [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
pub mod service_quota_exceeded_exception {
    /// A builder for [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
        pub fn build(self) -> crate::error::ServiceQuotaExceededException {
            crate::error::ServiceQuotaExceededException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ServiceQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    pub fn builder() -> crate::error::service_quota_exceeded_exception::Builder {
        crate::error::service_quota_exceeded_exception::Builder::default()
    }
}

/// <p>The specified resource is already being used.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ResourceInUseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseException {}
/// See [`ResourceInUseException`](crate::error::ResourceInUseException)
pub mod resource_in_use_exception {
    /// A builder for [`ResourceInUseException`](crate::error::ResourceInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseException`](crate::error::ResourceInUseException)
        pub fn build(self) -> crate::error::ResourceInUseException {
            crate::error::ResourceInUseException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ResourceInUseException {
    /// Creates a new builder-style object to manufacture [`ResourceInUseException`](crate::error::ResourceInUseException)
    pub fn builder() -> crate::error::resource_in_use_exception::Builder {
        crate::error::resource_in_use_exception::Builder::default()
    }
}

/// <p>The file size or duration of the supplied media is too large. The maximum file size is 10GB.
/// The maximum duration is 6 hours. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VideoTooLargeException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VideoTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VideoTooLargeException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl VideoTooLargeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for VideoTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "VideoTooLargeException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for VideoTooLargeException {}
/// See [`VideoTooLargeException`](crate::error::VideoTooLargeException)
pub mod video_too_large_exception {
    /// A builder for [`VideoTooLargeException`](crate::error::VideoTooLargeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`VideoTooLargeException`](crate::error::VideoTooLargeException)
        pub fn build(self) -> crate::error::VideoTooLargeException {
            crate::error::VideoTooLargeException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl VideoTooLargeException {
    /// Creates a new builder-style object to manufacture [`VideoTooLargeException`](crate::error::VideoTooLargeException)
    pub fn builder() -> crate::error::video_too_large_exception::Builder {
        crate::error::video_too_large_exception::Builder::default()
    }
}

/// <p>An Amazon Rekognition service limit was exceeded. For example, if you start too many Amazon Rekognition Video jobs concurrently, calls to start operations
/// (<code>StartLabelDetection</code>, for example) will raise a <code>LimitExceededException</code> exception (HTTP status code: 400) until
/// the number of concurrently running jobs is below the Amazon Rekognition service limit.  </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>Amazon Rekognition is unable to access the S3 object specified in the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidS3ObjectException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidS3ObjectException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidS3ObjectException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl InvalidS3ObjectException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidS3ObjectException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidS3ObjectException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidS3ObjectException {}
/// See [`InvalidS3ObjectException`](crate::error::InvalidS3ObjectException)
pub mod invalid_s3_object_exception {
    /// A builder for [`InvalidS3ObjectException`](crate::error::InvalidS3ObjectException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidS3ObjectException`](crate::error::InvalidS3ObjectException)
        pub fn build(self) -> crate::error::InvalidS3ObjectException {
            crate::error::InvalidS3ObjectException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl InvalidS3ObjectException {
    /// Creates a new builder-style object to manufacture [`InvalidS3ObjectException`](crate::error::InvalidS3ObjectException)
    pub fn builder() -> crate::error::invalid_s3_object_exception::Builder {
        crate::error::invalid_s3_object_exception::Builder::default()
    }
}

/// <p>A <code>ClientRequestToken</code> input parameter was reused with an operation, but at least one of the other input
/// parameters is different from the previous call to the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdempotentParameterMismatchException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IdempotentParameterMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IdempotentParameterMismatchException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl IdempotentParameterMismatchException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IdempotentParameterMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IdempotentParameterMismatchException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for IdempotentParameterMismatchException {}
/// See [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
pub mod idempotent_parameter_mismatch_exception {
    /// A builder for [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
        pub fn build(self) -> crate::error::IdempotentParameterMismatchException {
            crate::error::IdempotentParameterMismatchException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl IdempotentParameterMismatchException {
    /// Creates a new builder-style object to manufacture [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
    pub fn builder() -> crate::error::idempotent_parameter_mismatch_exception::Builder {
        crate::error::idempotent_parameter_mismatch_exception::Builder::default()
    }
}

/// <p>The provided image format is not supported. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidImageFormatException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidImageFormatException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidImageFormatException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl InvalidImageFormatException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidImageFormatException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidImageFormatException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidImageFormatException {}
/// See [`InvalidImageFormatException`](crate::error::InvalidImageFormatException)
pub mod invalid_image_format_exception {
    /// A builder for [`InvalidImageFormatException`](crate::error::InvalidImageFormatException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidImageFormatException`](crate::error::InvalidImageFormatException)
        pub fn build(self) -> crate::error::InvalidImageFormatException {
            crate::error::InvalidImageFormatException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl InvalidImageFormatException {
    /// Creates a new builder-style object to manufacture [`InvalidImageFormatException`](crate::error::InvalidImageFormatException)
    pub fn builder() -> crate::error::invalid_image_format_exception::Builder {
        crate::error::invalid_image_format_exception::Builder::default()
    }
}

/// <p>The input image size exceeds the allowed limit. If you are calling
/// DetectProtectiveEquipment, the image size or resolution exceeds the allowed limit. For more information, see
/// Limits in Amazon Rekognition in the Amazon Rekognition Developer Guide. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageTooLargeException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ImageTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageTooLargeException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ImageTooLargeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ImageTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ImageTooLargeException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for ImageTooLargeException {}
/// See [`ImageTooLargeException`](crate::error::ImageTooLargeException)
pub mod image_too_large_exception {
    /// A builder for [`ImageTooLargeException`](crate::error::ImageTooLargeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageTooLargeException`](crate::error::ImageTooLargeException)
        pub fn build(self) -> crate::error::ImageTooLargeException {
            crate::error::ImageTooLargeException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ImageTooLargeException {
    /// Creates a new builder-style object to manufacture [`ImageTooLargeException`](crate::error::ImageTooLargeException)
    pub fn builder() -> crate::error::image_too_large_exception::Builder {
        crate::error::image_too_large_exception::Builder::default()
    }
}

/// <p>Pagination token in the request is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPaginationTokenException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPaginationTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPaginationTokenException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl InvalidPaginationTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPaginationTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPaginationTokenException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPaginationTokenException {}
/// See [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException)
pub mod invalid_pagination_token_exception {
    /// A builder for [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException)
        pub fn build(self) -> crate::error::InvalidPaginationTokenException {
            crate::error::InvalidPaginationTokenException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl InvalidPaginationTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException)
    pub fn builder() -> crate::error::invalid_pagination_token_exception::Builder {
        crate::error::invalid_pagination_token_exception::Builder::default()
    }
}

/// <p>The number of in-progress human reviews you have has exceeded the number allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanLoopQuotaExceededException {
    /// <p>The resource type.</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The quota code.</p>
    pub quota_code: std::option::Option<std::string::String>,
    /// <p>The service code.</p>
    pub service_code: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HumanLoopQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanLoopQuotaExceededException");
        formatter.field("resource_type", &self.resource_type);
        formatter.field("quota_code", &self.quota_code);
        formatter.field("service_code", &self.service_code);
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl HumanLoopQuotaExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for HumanLoopQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "HumanLoopQuotaExceededException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for HumanLoopQuotaExceededException {}
/// See [`HumanLoopQuotaExceededException`](crate::error::HumanLoopQuotaExceededException)
pub mod human_loop_quota_exceeded_exception {
    /// A builder for [`HumanLoopQuotaExceededException`](crate::error::HumanLoopQuotaExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) quota_code: std::option::Option<std::string::String>,
        pub(crate) service_code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource type.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The quota code.</p>
        pub fn quota_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.quota_code = Some(input.into());
            self
        }
        pub fn set_quota_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.quota_code = input;
            self
        }
        /// <p>The service code.</p>
        pub fn service_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_code = Some(input.into());
            self
        }
        pub fn set_service_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanLoopQuotaExceededException`](crate::error::HumanLoopQuotaExceededException)
        pub fn build(self) -> crate::error::HumanLoopQuotaExceededException {
            crate::error::HumanLoopQuotaExceededException {
                resource_type: self.resource_type,
                quota_code: self.quota_code,
                service_code: self.service_code,
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl HumanLoopQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`HumanLoopQuotaExceededException`](crate::error::HumanLoopQuotaExceededException)
    pub fn builder() -> crate::error::human_loop_quota_exceeded_exception::Builder {
        crate::error::human_loop_quota_exceeded_exception::Builder::default()
    }
}

/// <p>The requested resource isn't ready. For example,  
/// this exception occurs when you call <code>DetectCustomLabels</code> with a
/// model version that isn't deployed. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotReadyException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotReadyException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ResourceNotReadyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotReadyException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotReadyException {}
/// See [`ResourceNotReadyException`](crate::error::ResourceNotReadyException)
pub mod resource_not_ready_exception {
    /// A builder for [`ResourceNotReadyException`](crate::error::ResourceNotReadyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotReadyException`](crate::error::ResourceNotReadyException)
        pub fn build(self) -> crate::error::ResourceNotReadyException {
            crate::error::ResourceNotReadyException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ResourceNotReadyException {
    /// Creates a new builder-style object to manufacture [`ResourceNotReadyException`](crate::error::ResourceNotReadyException)
    pub fn builder() -> crate::error::resource_not_ready_exception::Builder {
        crate::error::resource_not_ready_exception::Builder::default()
    }
}

/// <p>A resource with the specified ID already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceAlreadyExistsException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
    /// <p>A universally unique identifier (UUID) for the request.</p>
    pub logref: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.field("logref", &self.logref);
        formatter.finish()
    }
}
impl ResourceAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAlreadyExistsException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyExistsException {}
/// See [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
pub mod resource_already_exists_exception {
    /// A builder for [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) logref: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A universally unique identifier (UUID) for the request.</p>
        pub fn logref(mut self, input: impl Into<std::string::String>) -> Self {
            self.logref = Some(input.into());
            self
        }
        pub fn set_logref(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logref = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
        pub fn build(self) -> crate::error::ResourceAlreadyExistsException {
            crate::error::ResourceAlreadyExistsException {
                message: self.message,
                code: self.code,
                logref: self.logref,
            }
        }
    }
}
impl ResourceAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    pub fn builder() -> crate::error::resource_already_exists_exception::Builder {
        crate::error::resource_already_exists_exception::Builder::default()
    }
}
