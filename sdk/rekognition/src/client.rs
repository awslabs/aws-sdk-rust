// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `RekognitionService`.
///
/// This client allows ergonomic access to a `RekognitionService`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn compare_faces(&self) -> fluent_builders::CompareFaces<C, M, R> {
        fluent_builders::CompareFaces::new(self.handle.clone())
    }
    pub fn create_collection(&self) -> fluent_builders::CreateCollection<C, M, R> {
        fluent_builders::CreateCollection::new(self.handle.clone())
    }
    pub fn create_project(&self) -> fluent_builders::CreateProject<C, M, R> {
        fluent_builders::CreateProject::new(self.handle.clone())
    }
    pub fn create_project_version(&self) -> fluent_builders::CreateProjectVersion<C, M, R> {
        fluent_builders::CreateProjectVersion::new(self.handle.clone())
    }
    pub fn create_stream_processor(&self) -> fluent_builders::CreateStreamProcessor<C, M, R> {
        fluent_builders::CreateStreamProcessor::new(self.handle.clone())
    }
    pub fn delete_collection(&self) -> fluent_builders::DeleteCollection<C, M, R> {
        fluent_builders::DeleteCollection::new(self.handle.clone())
    }
    pub fn delete_faces(&self) -> fluent_builders::DeleteFaces<C, M, R> {
        fluent_builders::DeleteFaces::new(self.handle.clone())
    }
    pub fn delete_project(&self) -> fluent_builders::DeleteProject<C, M, R> {
        fluent_builders::DeleteProject::new(self.handle.clone())
    }
    pub fn delete_project_version(&self) -> fluent_builders::DeleteProjectVersion<C, M, R> {
        fluent_builders::DeleteProjectVersion::new(self.handle.clone())
    }
    pub fn delete_stream_processor(&self) -> fluent_builders::DeleteStreamProcessor<C, M, R> {
        fluent_builders::DeleteStreamProcessor::new(self.handle.clone())
    }
    pub fn describe_collection(&self) -> fluent_builders::DescribeCollection<C, M, R> {
        fluent_builders::DescribeCollection::new(self.handle.clone())
    }
    pub fn describe_projects(&self) -> fluent_builders::DescribeProjects<C, M, R> {
        fluent_builders::DescribeProjects::new(self.handle.clone())
    }
    pub fn describe_project_versions(&self) -> fluent_builders::DescribeProjectVersions<C, M, R> {
        fluent_builders::DescribeProjectVersions::new(self.handle.clone())
    }
    pub fn describe_stream_processor(&self) -> fluent_builders::DescribeStreamProcessor<C, M, R> {
        fluent_builders::DescribeStreamProcessor::new(self.handle.clone())
    }
    pub fn detect_custom_labels(&self) -> fluent_builders::DetectCustomLabels<C, M, R> {
        fluent_builders::DetectCustomLabels::new(self.handle.clone())
    }
    pub fn detect_faces(&self) -> fluent_builders::DetectFaces<C, M, R> {
        fluent_builders::DetectFaces::new(self.handle.clone())
    }
    pub fn detect_labels(&self) -> fluent_builders::DetectLabels<C, M, R> {
        fluent_builders::DetectLabels::new(self.handle.clone())
    }
    pub fn detect_moderation_labels(&self) -> fluent_builders::DetectModerationLabels<C, M, R> {
        fluent_builders::DetectModerationLabels::new(self.handle.clone())
    }
    pub fn detect_protective_equipment(
        &self,
    ) -> fluent_builders::DetectProtectiveEquipment<C, M, R> {
        fluent_builders::DetectProtectiveEquipment::new(self.handle.clone())
    }
    pub fn detect_text(&self) -> fluent_builders::DetectText<C, M, R> {
        fluent_builders::DetectText::new(self.handle.clone())
    }
    pub fn get_celebrity_info(&self) -> fluent_builders::GetCelebrityInfo<C, M, R> {
        fluent_builders::GetCelebrityInfo::new(self.handle.clone())
    }
    pub fn get_celebrity_recognition(&self) -> fluent_builders::GetCelebrityRecognition<C, M, R> {
        fluent_builders::GetCelebrityRecognition::new(self.handle.clone())
    }
    pub fn get_content_moderation(&self) -> fluent_builders::GetContentModeration<C, M, R> {
        fluent_builders::GetContentModeration::new(self.handle.clone())
    }
    pub fn get_face_detection(&self) -> fluent_builders::GetFaceDetection<C, M, R> {
        fluent_builders::GetFaceDetection::new(self.handle.clone())
    }
    pub fn get_face_search(&self) -> fluent_builders::GetFaceSearch<C, M, R> {
        fluent_builders::GetFaceSearch::new(self.handle.clone())
    }
    pub fn get_label_detection(&self) -> fluent_builders::GetLabelDetection<C, M, R> {
        fluent_builders::GetLabelDetection::new(self.handle.clone())
    }
    pub fn get_person_tracking(&self) -> fluent_builders::GetPersonTracking<C, M, R> {
        fluent_builders::GetPersonTracking::new(self.handle.clone())
    }
    pub fn get_segment_detection(&self) -> fluent_builders::GetSegmentDetection<C, M, R> {
        fluent_builders::GetSegmentDetection::new(self.handle.clone())
    }
    pub fn get_text_detection(&self) -> fluent_builders::GetTextDetection<C, M, R> {
        fluent_builders::GetTextDetection::new(self.handle.clone())
    }
    pub fn index_faces(&self) -> fluent_builders::IndexFaces<C, M, R> {
        fluent_builders::IndexFaces::new(self.handle.clone())
    }
    pub fn list_collections(&self) -> fluent_builders::ListCollections<C, M, R> {
        fluent_builders::ListCollections::new(self.handle.clone())
    }
    pub fn list_faces(&self) -> fluent_builders::ListFaces<C, M, R> {
        fluent_builders::ListFaces::new(self.handle.clone())
    }
    pub fn list_stream_processors(&self) -> fluent_builders::ListStreamProcessors<C, M, R> {
        fluent_builders::ListStreamProcessors::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C, M, R> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn recognize_celebrities(&self) -> fluent_builders::RecognizeCelebrities<C, M, R> {
        fluent_builders::RecognizeCelebrities::new(self.handle.clone())
    }
    pub fn search_faces(&self) -> fluent_builders::SearchFaces<C, M, R> {
        fluent_builders::SearchFaces::new(self.handle.clone())
    }
    pub fn search_faces_by_image(&self) -> fluent_builders::SearchFacesByImage<C, M, R> {
        fluent_builders::SearchFacesByImage::new(self.handle.clone())
    }
    pub fn start_celebrity_recognition(
        &self,
    ) -> fluent_builders::StartCelebrityRecognition<C, M, R> {
        fluent_builders::StartCelebrityRecognition::new(self.handle.clone())
    }
    pub fn start_content_moderation(&self) -> fluent_builders::StartContentModeration<C, M, R> {
        fluent_builders::StartContentModeration::new(self.handle.clone())
    }
    pub fn start_face_detection(&self) -> fluent_builders::StartFaceDetection<C, M, R> {
        fluent_builders::StartFaceDetection::new(self.handle.clone())
    }
    pub fn start_face_search(&self) -> fluent_builders::StartFaceSearch<C, M, R> {
        fluent_builders::StartFaceSearch::new(self.handle.clone())
    }
    pub fn start_label_detection(&self) -> fluent_builders::StartLabelDetection<C, M, R> {
        fluent_builders::StartLabelDetection::new(self.handle.clone())
    }
    pub fn start_person_tracking(&self) -> fluent_builders::StartPersonTracking<C, M, R> {
        fluent_builders::StartPersonTracking::new(self.handle.clone())
    }
    pub fn start_project_version(&self) -> fluent_builders::StartProjectVersion<C, M, R> {
        fluent_builders::StartProjectVersion::new(self.handle.clone())
    }
    pub fn start_segment_detection(&self) -> fluent_builders::StartSegmentDetection<C, M, R> {
        fluent_builders::StartSegmentDetection::new(self.handle.clone())
    }
    pub fn start_stream_processor(&self) -> fluent_builders::StartStreamProcessor<C, M, R> {
        fluent_builders::StartStreamProcessor::new(self.handle.clone())
    }
    pub fn start_text_detection(&self) -> fluent_builders::StartTextDetection<C, M, R> {
        fluent_builders::StartTextDetection::new(self.handle.clone())
    }
    pub fn stop_project_version(&self) -> fluent_builders::StopProjectVersion<C, M, R> {
        fluent_builders::StopProjectVersion::new(self.handle.clone())
    }
    pub fn stop_stream_processor(&self) -> fluent_builders::StopStreamProcessor<C, M, R> {
        fluent_builders::StopStreamProcessor::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C, M, R> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C, M, R> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CompareFaces<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::compare_faces_input::Builder,
    }
    impl<C, M, R> CompareFaces<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CompareFacesOutput,
            smithy_http::result::SdkError<crate::error::CompareFacesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CompareFacesInputOperationOutputAlias,
                crate::output::CompareFacesOutput,
                crate::error::CompareFacesError,
                crate::input::CompareFacesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The input image as base64-encoded bytes or an S3 object.
        /// If you use the AWS CLI to call Amazon Rekognition operations,
        /// passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn source_image(mut self, inp: crate::model::Image) -> Self {
            self.inner = self.inner.source_image(inp);
            self
        }
        pub fn set_source_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.inner = self.inner.set_source_image(input);
            self
        }
        /// <p>The target image as base64-encoded bytes or an S3 object. If you use the AWS CLI to
        /// call Amazon Rekognition operations, passing base64-encoded image bytes is not supported.
        /// </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn target_image(mut self, inp: crate::model::Image) -> Self {
            self.inner = self.inner.target_image(inp);
            self
        }
        pub fn set_target_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.inner = self.inner.set_target_image(input);
            self
        }
        /// <p>The minimum level of confidence in the face matches that a match must meet to be
        /// included in the <code>FaceMatches</code> array.</p>
        pub fn similarity_threshold(mut self, inp: f32) -> Self {
            self.inner = self.inner.similarity_threshold(inp);
            self
        }
        pub fn set_similarity_threshold(mut self, input: std::option::Option<f32>) -> Self {
            self.inner = self.inner.set_similarity_threshold(input);
            self
        }
        /// <p>A filter that specifies a quality bar for how much filtering is done to identify faces.
        /// Filtered faces aren't compared. If you specify <code>AUTO</code>, Amazon Rekognition chooses the quality bar.
        /// If you specify <code>LOW</code>,
        /// <code>MEDIUM</code>, or <code>HIGH</code>, filtering removes all faces that
        /// don’t meet the chosen quality bar.
        /// The quality bar is based on a variety of common use cases. Low-quality
        /// detections can occur for a number of reasons. Some examples are an object that's misidentified
        /// as a face, a face that's too blurry, or a face with a
        /// pose that's too extreme to use. If you specify <code>NONE</code>, no
        /// filtering is performed. The default value is <code>NONE</code>.
        /// </p>
        /// <p>To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.</p>
        pub fn quality_filter(mut self, inp: crate::model::QualityFilter) -> Self {
            self.inner = self.inner.quality_filter(inp);
            self
        }
        pub fn set_quality_filter(
            mut self,
            input: std::option::Option<crate::model::QualityFilter>,
        ) -> Self {
            self.inner = self.inner.set_quality_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCollection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_collection_input::Builder,
    }
    impl<C, M, R> CreateCollection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCollectionOutput,
            smithy_http::result::SdkError<crate::error::CreateCollectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateCollectionInputOperationOutputAlias,
                crate::output::CreateCollectionOutput,
                crate::error::CreateCollectionError,
                crate::input::CreateCollectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>ID for the collection that you are creating.</p>
        pub fn collection_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_id(inp);
            self
        }
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_id(input);
            self
        }
        /// Adds a key-value pair to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>
        /// A set of tags (key-value pairs) that you want to attach to the collection.
        /// </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateProject<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_project_input::Builder,
    }
    impl<C, M, R> CreateProject<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateProjectOutput,
            smithy_http::result::SdkError<crate::error::CreateProjectError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateProjectInputOperationOutputAlias,
                crate::output::CreateProjectOutput,
                crate::error::CreateProjectError,
                crate::input::CreateProjectInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the project to create.</p>
        pub fn project_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_name(inp);
            self
        }
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateProjectVersion<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_project_version_input::Builder,
    }
    impl<C, M, R> CreateProjectVersion<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateProjectVersionOutput,
            smithy_http::result::SdkError<crate::error::CreateProjectVersionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateProjectVersionInputOperationOutputAlias,
                crate::output::CreateProjectVersionOutput,
                crate::error::CreateProjectVersionError,
                crate::input::CreateProjectVersionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the Amazon Rekognition Custom Labels project that
        /// manages the model that you want to train.</p>
        pub fn project_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(inp);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
        /// <p>A name for the version of the model. This value must be unique.</p>
        pub fn version_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_name(inp);
            self
        }
        pub fn set_version_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_name(input);
            self
        }
        /// <p>The Amazon S3 bucket location to store the results of training.
        /// The S3 bucket can be in any AWS account as long as the caller has
        /// <code>s3:PutObject</code> permissions on the S3 bucket.</p>
        pub fn output_config(mut self, inp: crate::model::OutputConfig) -> Self {
            self.inner = self.inner.output_config(inp);
            self
        }
        pub fn set_output_config(
            mut self,
            input: std::option::Option<crate::model::OutputConfig>,
        ) -> Self {
            self.inner = self.inner.set_output_config(input);
            self
        }
        /// <p>The dataset to use for training. </p>
        pub fn training_data(mut self, inp: crate::model::TrainingData) -> Self {
            self.inner = self.inner.training_data(inp);
            self
        }
        pub fn set_training_data(
            mut self,
            input: std::option::Option<crate::model::TrainingData>,
        ) -> Self {
            self.inner = self.inner.set_training_data(input);
            self
        }
        /// <p>The dataset to use for testing.</p>
        pub fn testing_data(mut self, inp: crate::model::TestingData) -> Self {
            self.inner = self.inner.testing_data(inp);
            self
        }
        pub fn set_testing_data(
            mut self,
            input: std::option::Option<crate::model::TestingData>,
        ) -> Self {
            self.inner = self.inner.set_testing_data(input);
            self
        }
        /// Adds a key-value pair to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>
        /// A set of tags (key-value pairs) that you want to attach to the model.
        /// </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The identifier for your AWS Key Management Service (AWS KMS) customer master key (CMK).
        /// You can supply the Amazon Resource Name (ARN) of your CMK, the ID of your CMK,
        /// an alias for your CMK, or an alias ARN.
        /// The key is used to encrypt training and test images copied into the service for model training.
        /// Your source images are unaffected. The key is also used to encrypt training results
        /// and manifest files written to the output Amazon S3 bucket (<code>OutputConfig</code>).</p>
        /// <p>If you choose to use your own CMK, you need the following permissions on the CMK.</p>
        /// <ul>
        /// <li>
        /// <p>kms:CreateGrant</p>
        /// </li>
        /// <li>
        /// <p>kms:DescribeKey</p>
        /// </li>
        /// <li>
        /// <p>kms:GenerateDataKey</p>
        /// </li>
        /// <li>
        /// <p>kms:Decrypt</p>
        /// </li>
        /// </ul>
        /// <p>If you don't specify a value for <code>KmsKeyId</code>, images copied into the service are encrypted
        /// using a key that AWS owns and manages.</p>
        pub fn kms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(inp);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStreamProcessor<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_stream_processor_input::Builder,
    }
    impl<C, M, R> CreateStreamProcessor<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStreamProcessorOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamProcessorError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateStreamProcessorInputOperationOutputAlias,
                crate::output::CreateStreamProcessorOutput,
                crate::error::CreateStreamProcessorError,
                crate::input::CreateStreamProcessorInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Kinesis video stream stream that provides the source streaming video. If you are using the AWS CLI, the parameter name is <code>StreamProcessorInput</code>.</p>
        pub fn input(mut self, inp: crate::model::StreamProcessorInput) -> Self {
            self.inner = self.inner.input(inp);
            self
        }
        pub fn set_input(
            mut self,
            input: std::option::Option<crate::model::StreamProcessorInput>,
        ) -> Self {
            self.inner = self.inner.set_input(input);
            self
        }
        /// <p>Kinesis data stream stream to which Amazon Rekognition Video puts the analysis results. If you are using the AWS CLI, the parameter name is <code>StreamProcessorOutput</code>.</p>
        pub fn output(mut self, inp: crate::model::StreamProcessorOutput) -> Self {
            self.inner = self.inner.output(inp);
            self
        }
        pub fn set_output(
            mut self,
            input: std::option::Option<crate::model::StreamProcessorOutput>,
        ) -> Self {
            self.inner = self.inner.set_output(input);
            self
        }
        /// <p>An identifier you assign to the stream processor. You can use <code>Name</code> to
        /// manage the stream processor. For example, you can get the current status of the stream processor by calling <a>DescribeStreamProcessor</a>.
        /// <code>Name</code> is idempotent.
        /// </p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Face recognition input parameters to be used by the stream processor. Includes the collection to use for face recognition and the face
        /// attributes to detect.</p>
        pub fn settings(mut self, inp: crate::model::StreamProcessorSettings) -> Self {
            self.inner = self.inner.settings(inp);
            self
        }
        pub fn set_settings(
            mut self,
            input: std::option::Option<crate::model::StreamProcessorSettings>,
        ) -> Self {
            self.inner = self.inner.set_settings(input);
            self
        }
        /// <p>ARN of the IAM role that allows access to the stream processor.</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// Adds a key-value pair to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>
        /// A set of tags (key-value pairs) that you want to attach to the stream processor.
        /// </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCollection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_collection_input::Builder,
    }
    impl<C, M, R> DeleteCollection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCollectionOutput,
            smithy_http::result::SdkError<crate::error::DeleteCollectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteCollectionInputOperationOutputAlias,
                crate::output::DeleteCollectionOutput,
                crate::error::DeleteCollectionError,
                crate::input::DeleteCollectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>ID of the collection to delete.</p>
        pub fn collection_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_id(inp);
            self
        }
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFaces<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_faces_input::Builder,
    }
    impl<C, M, R> DeleteFaces<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFacesOutput,
            smithy_http::result::SdkError<crate::error::DeleteFacesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteFacesInputOperationOutputAlias,
                crate::output::DeleteFacesOutput,
                crate::error::DeleteFacesError,
                crate::input::DeleteFacesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Collection from which to remove the specific faces.</p>
        pub fn collection_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_id(inp);
            self
        }
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_id(input);
            self
        }
        /// Appends an item to `FaceIds`.
        ///
        /// To override the contents of this collection use [`set_face_ids`](Self::set_face_ids).
        /// <p>An array of face IDs to delete.</p>
        pub fn face_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.face_ids(inp);
            self
        }
        pub fn set_face_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_face_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteProject<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_project_input::Builder,
    }
    impl<C, M, R> DeleteProject<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteProjectOutput,
            smithy_http::result::SdkError<crate::error::DeleteProjectError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteProjectInputOperationOutputAlias,
                crate::output::DeleteProjectOutput,
                crate::error::DeleteProjectError,
                crate::input::DeleteProjectInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the project that you want to delete.</p>
        pub fn project_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(inp);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteProjectVersion<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_project_version_input::Builder,
    }
    impl<C, M, R> DeleteProjectVersion<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteProjectVersionOutput,
            smithy_http::result::SdkError<crate::error::DeleteProjectVersionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteProjectVersionInputOperationOutputAlias,
                crate::output::DeleteProjectVersionOutput,
                crate::error::DeleteProjectVersionError,
                crate::input::DeleteProjectVersionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the model version that you want to delete.</p>
        pub fn project_version_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_version_arn(inp);
            self
        }
        pub fn set_project_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_project_version_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStreamProcessor<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_stream_processor_input::Builder,
    }
    impl<C, M, R> DeleteStreamProcessor<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStreamProcessorOutput,
            smithy_http::result::SdkError<crate::error::DeleteStreamProcessorError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteStreamProcessorInputOperationOutputAlias,
                crate::output::DeleteStreamProcessorOutput,
                crate::error::DeleteStreamProcessorError,
                crate::input::DeleteStreamProcessorInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream processor you want to delete.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCollection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_collection_input::Builder,
    }
    impl<C, M, R> DescribeCollection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCollectionOutput,
            smithy_http::result::SdkError<crate::error::DescribeCollectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeCollectionInputOperationOutputAlias,
                crate::output::DescribeCollectionOutput,
                crate::error::DescribeCollectionError,
                crate::input::DescribeCollectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the collection to describe.</p>
        pub fn collection_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_id(inp);
            self
        }
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeProjects<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_projects_input::Builder,
    }
    impl<C, M, R> DescribeProjects<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeProjectsOutput,
            smithy_http::result::SdkError<crate::error::DescribeProjectsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeProjectsInputOperationOutputAlias,
                crate::output::DescribeProjectsOutput,
                crate::error::DescribeProjectsError,
                crate::input::DescribeProjectsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If the previous response was incomplete (because there is more
        /// results to retrieve), Amazon Rekognition Custom Labels returns a pagination token in the response. You can use this pagination
        /// token to retrieve the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return per paginated call. The largest value you can specify is 100.
        /// If you specify a value greater than 100, a ValidationException
        /// error occurs. The default value is 100. </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeProjectVersions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_project_versions_input::Builder,
    }
    impl<C, M, R> DescribeProjectVersions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeProjectVersionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeProjectVersionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeProjectVersionsInputOperationOutputAlias,
                crate::output::DescribeProjectVersionsOutput,
                crate::error::DescribeProjectVersionsError,
                crate::input::DescribeProjectVersionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the project that contains the models you want to describe.</p>
        pub fn project_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(inp);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
        /// Appends an item to `VersionNames`.
        ///
        /// To override the contents of this collection use [`set_version_names`](Self::set_version_names).
        /// <p>A list of model version names that you want to describe. You can add up to 10 model version names
        /// to the list. If you don't specify a value, all model descriptions are returned.  A version name is part of a
        /// model (ProjectVersion) ARN. For example, <code>my-model.2020-01-21T09.10.15</code> is the version name in the following ARN.
        /// <code>arn:aws:rekognition:us-east-1:123456789012:project/getting-started/version/<i>my-model.2020-01-21T09.10.15</i>/1234567890123</code>.</p>
        pub fn version_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_names(inp);
            self
        }
        pub fn set_version_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_version_names(input);
            self
        }
        /// <p>If the previous response was incomplete (because there is more
        /// results to retrieve), Amazon Rekognition Custom Labels returns a pagination token in the response.
        /// You can use this pagination token to retrieve the next set of results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return per paginated call.
        /// The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException
        /// error occurs. The default value is 100. </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeStreamProcessor<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_stream_processor_input::Builder,
    }
    impl<C, M, R> DescribeStreamProcessor<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeStreamProcessorOutput,
            smithy_http::result::SdkError<crate::error::DescribeStreamProcessorError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeStreamProcessorInputOperationOutputAlias,
                crate::output::DescribeStreamProcessorOutput,
                crate::error::DescribeStreamProcessorError,
                crate::input::DescribeStreamProcessorInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the stream processor for which you want information.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetectCustomLabels<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::detect_custom_labels_input::Builder,
    }
    impl<C, M, R> DetectCustomLabels<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetectCustomLabelsOutput,
            smithy_http::result::SdkError<crate::error::DetectCustomLabelsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DetectCustomLabelsInputOperationOutputAlias,
                crate::output::DetectCustomLabelsOutput,
                crate::error::DetectCustomLabelsError,
                crate::input::DetectCustomLabelsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the model version that you want to use.</p>
        pub fn project_version_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_version_arn(inp);
            self
        }
        pub fn set_project_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_project_version_arn(input);
            self
        }
        /// <p>Provides the input image either as bytes or an S3 object.</p>
        /// <p>You pass image bytes to an Amazon Rekognition API operation by using the <code>Bytes</code>
        /// property. For example, you would use the <code>Bytes</code> property to pass an image loaded
        /// from a local file system. Image bytes passed by using the <code>Bytes</code> property must be
        /// base64-encoded. Your code may not need to encode image bytes if you are using an AWS SDK to
        /// call Amazon Rekognition API operations. </p>
        /// <p>For more information, see Analyzing an Image Loaded from a Local File System
        /// in the Amazon Rekognition Developer Guide.</p>
        /// <p> You pass images stored in an S3 bucket to an Amazon Rekognition API operation by using the
        /// <code>S3Object</code> property. Images stored in an S3 bucket do not need to be
        /// base64-encoded.</p>
        /// <p>The region for the S3 bucket containing the S3 object must match the region you use for
        /// Amazon Rekognition operations.</p>
        /// <p>If you use the
        /// AWS
        /// CLI to call Amazon Rekognition operations, passing image bytes using the Bytes
        /// property is not supported. You must first upload the image to an Amazon S3 bucket and then
        /// call the operation using the S3Object property.</p>
        /// <p>For Amazon Rekognition to process an S3 object, the user must have permission to access the S3
        /// object. For more information, see Resource Based Policies in the Amazon Rekognition Developer Guide.
        /// </p>
        pub fn image(mut self, inp: crate::model::Image) -> Self {
            self.inner = self.inner.image(inp);
            self
        }
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.inner = self.inner.set_image(input);
            self
        }
        /// <p>Maximum number of results you want the service to return in the response.
        /// The service returns the specified number of highest confidence labels ranked from highest confidence
        /// to lowest.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Specifies the minimum confidence level for the labels to return.
        /// <code>DetectCustomLabels</code> doesn't return any labels with a confidence value that's lower than
        /// this specified value. If you specify a
        /// value of 0, <code>DetectCustomLabels</code> returns all labels, regardless of the assumed
        /// threshold applied to each label.
        /// If you don't specify a value for <code>MinConfidence</code>,  <code>DetectCustomLabels</code>
        /// returns labels based on the assumed threshold of each label.</p>
        pub fn min_confidence(mut self, inp: f32) -> Self {
            self.inner = self.inner.min_confidence(inp);
            self
        }
        pub fn set_min_confidence(mut self, input: std::option::Option<f32>) -> Self {
            self.inner = self.inner.set_min_confidence(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetectFaces<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::detect_faces_input::Builder,
    }
    impl<C, M, R> DetectFaces<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetectFacesOutput,
            smithy_http::result::SdkError<crate::error::DetectFacesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DetectFacesInputOperationOutputAlias,
                crate::output::DetectFacesOutput,
                crate::error::DetectFacesError,
                crate::input::DetectFacesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
        /// Amazon Rekognition operations, passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, inp: crate::model::Image) -> Self {
            self.inner = self.inner.image(inp);
            self
        }
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.inner = self.inner.set_image(input);
            self
        }
        /// Appends an item to `Attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        /// <p>An array of facial attributes you want to be returned. This can be the default list of
        /// attributes or all attributes. If you don't specify a value for <code>Attributes</code> or if
        /// you specify <code>["DEFAULT"]</code>, the API returns the following subset of facial
        /// attributes: <code>BoundingBox</code>, <code>Confidence</code>, <code>Pose</code>,
        /// <code>Quality</code>, and <code>Landmarks</code>. If you provide <code>["ALL"]</code>, all
        /// facial attributes are returned, but the operation takes longer to complete.</p>
        /// <p>If you provide both, <code>["ALL", "DEFAULT"]</code>, the service uses a logical AND
        /// operator to determine which attributes to return (in this case, all attributes). </p>
        pub fn attributes(mut self, inp: impl Into<crate::model::Attribute>) -> Self {
            self.inner = self.inner.attributes(inp);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetectLabels<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::detect_labels_input::Builder,
    }
    impl<C, M, R> DetectLabels<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetectLabelsOutput,
            smithy_http::result::SdkError<crate::error::DetectLabelsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DetectLabelsInputOperationOutputAlias,
                crate::output::DetectLabelsOutput,
                crate::error::DetectLabelsError,
                crate::input::DetectLabelsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
        /// Amazon Rekognition operations, passing image bytes is not supported. Images stored in an S3 Bucket do
        /// not need to be base64-encoded.</p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, inp: crate::model::Image) -> Self {
            self.inner = self.inner.image(inp);
            self
        }
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.inner = self.inner.set_image(input);
            self
        }
        /// <p>Maximum number of labels you want the service to return in the response. The service
        /// returns the specified number of highest confidence labels. </p>
        pub fn max_labels(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_labels(inp);
            self
        }
        pub fn set_max_labels(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_labels(input);
            self
        }
        /// <p>Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't
        /// return any labels with confidence lower than this specified value.</p>
        /// <p>If <code>MinConfidence</code> is not specified, the operation returns labels with a
        /// confidence values greater than or equal to 55 percent.</p>
        pub fn min_confidence(mut self, inp: f32) -> Self {
            self.inner = self.inner.min_confidence(inp);
            self
        }
        pub fn set_min_confidence(mut self, input: std::option::Option<f32>) -> Self {
            self.inner = self.inner.set_min_confidence(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetectModerationLabels<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::detect_moderation_labels_input::Builder,
    }
    impl<C, M, R> DetectModerationLabels<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetectModerationLabelsOutput,
            smithy_http::result::SdkError<crate::error::DetectModerationLabelsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DetectModerationLabelsInputOperationOutputAlias,
                crate::output::DetectModerationLabelsOutput,
                crate::error::DetectModerationLabelsError,
                crate::input::DetectModerationLabelsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The input image as base64-encoded bytes or an S3 object.
        /// If you use the AWS CLI to call Amazon Rekognition operations,
        /// passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, inp: crate::model::Image) -> Self {
            self.inner = self.inner.image(inp);
            self
        }
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.inner = self.inner.set_image(input);
            self
        }
        /// <p>Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't
        /// return any labels with a confidence level lower than this specified value.</p>
        /// <p>If you don't specify <code>MinConfidence</code>, the operation returns labels with
        /// confidence values greater than or equal to 50 percent.</p>
        pub fn min_confidence(mut self, inp: f32) -> Self {
            self.inner = self.inner.min_confidence(inp);
            self
        }
        pub fn set_min_confidence(mut self, input: std::option::Option<f32>) -> Self {
            self.inner = self.inner.set_min_confidence(input);
            self
        }
        /// <p>Sets up the configuration for human evaluation, including the FlowDefinition
        /// the image will be sent to.</p>
        pub fn human_loop_config(mut self, inp: crate::model::HumanLoopConfig) -> Self {
            self.inner = self.inner.human_loop_config(inp);
            self
        }
        pub fn set_human_loop_config(
            mut self,
            input: std::option::Option<crate::model::HumanLoopConfig>,
        ) -> Self {
            self.inner = self.inner.set_human_loop_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetectProtectiveEquipment<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::detect_protective_equipment_input::Builder,
    }
    impl<C, M, R> DetectProtectiveEquipment<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetectProtectiveEquipmentOutput,
            smithy_http::result::SdkError<crate::error::DetectProtectiveEquipmentError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DetectProtectiveEquipmentInputOperationOutputAlias,
                crate::output::DetectProtectiveEquipmentOutput,
                crate::error::DetectProtectiveEquipmentError,
                crate::input::DetectProtectiveEquipmentInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The image in which you want to detect PPE on detected persons. The image can be passed as image bytes or you can
        /// reference an image stored in an Amazon S3 bucket. </p>
        pub fn image(mut self, inp: crate::model::Image) -> Self {
            self.inner = self.inner.image(inp);
            self
        }
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.inner = self.inner.set_image(input);
            self
        }
        /// <p>An array of PPE types that you want to summarize.</p>
        pub fn summarization_attributes(
            mut self,
            inp: crate::model::ProtectiveEquipmentSummarizationAttributes,
        ) -> Self {
            self.inner = self.inner.summarization_attributes(inp);
            self
        }
        pub fn set_summarization_attributes(
            mut self,
            input: std::option::Option<crate::model::ProtectiveEquipmentSummarizationAttributes>,
        ) -> Self {
            self.inner = self.inner.set_summarization_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetectText<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::detect_text_input::Builder,
    }
    impl<C, M, R> DetectText<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetectTextOutput,
            smithy_http::result::SdkError<crate::error::DetectTextError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DetectTextInputOperationOutputAlias,
                crate::output::DetectTextOutput,
                crate::error::DetectTextError,
                crate::input::DetectTextInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The input image as base64-encoded bytes or an Amazon S3 object. If you use the AWS CLI
        /// to call Amazon Rekognition operations, you can't pass image bytes. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, inp: crate::model::Image) -> Self {
            self.inner = self.inner.image(inp);
            self
        }
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.inner = self.inner.set_image(input);
            self
        }
        /// <p>Optional parameters that let you set the criteria that the text must meet to be included in your response.</p>
        pub fn filters(mut self, inp: crate::model::DetectTextFilters) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<crate::model::DetectTextFilters>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCelebrityInfo<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_celebrity_info_input::Builder,
    }
    impl<C, M, R> GetCelebrityInfo<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCelebrityInfoOutput,
            smithy_http::result::SdkError<crate::error::GetCelebrityInfoError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetCelebrityInfoInputOperationOutputAlias,
                crate::output::GetCelebrityInfoOutput,
                crate::error::GetCelebrityInfoError,
                crate::input::GetCelebrityInfoInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for the celebrity. You get the celebrity ID from a call to the <a>RecognizeCelebrities</a> operation,
        /// which recognizes celebrities in an image. </p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCelebrityRecognition<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_celebrity_recognition_input::Builder,
    }
    impl<C, M, R> GetCelebrityRecognition<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCelebrityRecognitionOutput,
            smithy_http::result::SdkError<crate::error::GetCelebrityRecognitionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetCelebrityRecognitionInputOperationOutputAlias,
                crate::output::GetCelebrityRecognitionOutput,
                crate::error::GetCelebrityRecognitionError,
                crate::input::GetCelebrityRecognitionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Job identifier for the required celebrity recognition analysis. You can get the job identifer from
        /// a call to <code>StartCelebrityRecognition</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>If the previous response was incomplete (because there is more recognized celebrities to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of celebrities. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Sort to use for celebrities returned in <code>Celebrities</code> field. Specify <code>ID</code> to sort by the celebrity identifier,
        /// specify <code>TIMESTAMP</code> to sort by the time the celebrity was recognized.</p>
        pub fn sort_by(mut self, inp: crate::model::CelebrityRecognitionSortBy) -> Self {
            self.inner = self.inner.sort_by(inp);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::CelebrityRecognitionSortBy>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContentModeration<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_content_moderation_input::Builder,
    }
    impl<C, M, R> GetContentModeration<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetContentModerationOutput,
            smithy_http::result::SdkError<crate::error::GetContentModerationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetContentModerationInputOperationOutputAlias,
                crate::output::GetContentModerationOutput,
                crate::error::GetContentModerationError,
                crate::input::GetContentModerationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the inappropriate, unwanted, or offensive content moderation job. Use <code>JobId</code> to identify the job in
        /// a subsequent call to <code>GetContentModeration</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Rekognition
        /// returns a pagination token in the response. You can use this pagination token
        /// to retrieve the next set of content moderation labels.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Sort to use for elements in the <code>ModerationLabelDetections</code> array.
        /// Use <code>TIMESTAMP</code> to sort array elements by the time labels are detected.
        /// Use <code>NAME</code> to alphabetically group elements for a label together.
        /// Within each label group, the array element are sorted by detection confidence.
        /// The default sort is by <code>TIMESTAMP</code>.</p>
        pub fn sort_by(mut self, inp: crate::model::ContentModerationSortBy) -> Self {
            self.inner = self.inner.sort_by(inp);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::ContentModerationSortBy>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFaceDetection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_face_detection_input::Builder,
    }
    impl<C, M, R> GetFaceDetection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFaceDetectionOutput,
            smithy_http::result::SdkError<crate::error::GetFaceDetectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetFaceDetectionInputOperationOutputAlias,
                crate::output::GetFaceDetectionOutput,
                crate::error::GetFaceDetectionError,
                crate::input::GetFaceDetectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Unique identifier for the face detection job. The <code>JobId</code> is returned from <code>StartFaceDetection</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>If the previous response was incomplete (because there are more faces to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of faces.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFaceSearch<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_face_search_input::Builder,
    }
    impl<C, M, R> GetFaceSearch<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFaceSearchOutput,
            smithy_http::result::SdkError<crate::error::GetFaceSearchError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetFaceSearchInputOperationOutputAlias,
                crate::output::GetFaceSearchOutput,
                crate::error::GetFaceSearchError,
                crate::input::GetFaceSearchInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The job identifer for the search request. You get the job identifier from an initial call to <code>StartFaceSearch</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>If the previous response was incomplete (because there is more search results to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of search results. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Sort to use for grouping faces in the response. Use <code>TIMESTAMP</code> to group faces by the time
        /// that they are recognized. Use <code>INDEX</code> to sort by recognized faces. </p>
        pub fn sort_by(mut self, inp: crate::model::FaceSearchSortBy) -> Self {
            self.inner = self.inner.sort_by(inp);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::FaceSearchSortBy>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLabelDetection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_label_detection_input::Builder,
    }
    impl<C, M, R> GetLabelDetection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLabelDetectionOutput,
            smithy_http::result::SdkError<crate::error::GetLabelDetectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetLabelDetectionInputOperationOutputAlias,
                crate::output::GetLabelDetectionOutput,
                crate::error::GetLabelDetectionError,
                crate::input::GetLabelDetectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Job identifier for the label detection operation for which you want results returned. You get the job identifer from
        /// an initial call to <code>StartlabelDetection</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>If the previous response was incomplete (because there are more labels to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of labels. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Sort to use for elements in the <code>Labels</code> array.
        /// Use <code>TIMESTAMP</code> to sort array elements by the time labels are detected.
        /// Use <code>NAME</code> to alphabetically group elements for a label together.
        /// Within each label group, the array element are sorted by detection confidence.
        /// The default sort is by <code>TIMESTAMP</code>.</p>
        pub fn sort_by(mut self, inp: crate::model::LabelDetectionSortBy) -> Self {
            self.inner = self.inner.sort_by(inp);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::LabelDetectionSortBy>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPersonTracking<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_person_tracking_input::Builder,
    }
    impl<C, M, R> GetPersonTracking<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPersonTrackingOutput,
            smithy_http::result::SdkError<crate::error::GetPersonTrackingError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetPersonTrackingInputOperationOutputAlias,
                crate::output::GetPersonTrackingOutput,
                crate::error::GetPersonTrackingError,
                crate::input::GetPersonTrackingInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for a job that tracks persons in a video. You get the <code>JobId</code> from a call to <code>StartPersonTracking</code>.
        /// </p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        /// If you specify a value greater than 1000, a maximum of 1000 results is returned.
        /// The default value is 1000.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>If the previous response was incomplete (because there are more persons to retrieve), Amazon Rekognition Video returns a pagination
        /// token in the response. You can use this pagination token to retrieve the next set of persons. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Sort to use for elements in the <code>Persons</code> array. Use <code>TIMESTAMP</code> to sort array elements
        /// by the time persons are detected. Use <code>INDEX</code> to sort by the tracked persons.
        /// If you sort by <code>INDEX</code>, the array elements for each person are sorted by detection confidence.
        /// The default sort is by <code>TIMESTAMP</code>.</p>
        pub fn sort_by(mut self, inp: crate::model::PersonTrackingSortBy) -> Self {
            self.inner = self.inner.sort_by(inp);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::PersonTrackingSortBy>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSegmentDetection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_segment_detection_input::Builder,
    }
    impl<C, M, R> GetSegmentDetection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSegmentDetectionOutput,
            smithy_http::result::SdkError<crate::error::GetSegmentDetectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetSegmentDetectionInputOperationOutputAlias,
                crate::output::GetSegmentDetectionOutput,
                crate::error::GetSegmentDetectionError,
                crate::input::GetSegmentDetectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Job identifier for the text detection operation for which you want results returned.
        /// You get the job identifer from an initial call to <code>StartSegmentDetection</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent
        /// request to retrieve the next set of text.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTextDetection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_text_detection_input::Builder,
    }
    impl<C, M, R> GetTextDetection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTextDetectionOutput,
            smithy_http::result::SdkError<crate::error::GetTextDetectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetTextDetectionInputOperationOutputAlias,
                crate::output::GetTextDetectionOutput,
                crate::error::GetTextDetectionError,
                crate::input::GetTextDetectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Job identifier for the text detection operation for which you want results returned.
        /// You get the job identifer from an initial call to <code>StartTextDetection</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>Maximum number of results to return per paginated call. The largest value you can specify is 1000.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>If the previous response was incomplete (because there are more labels to retrieve), Amazon Rekognition Video returns
        /// a pagination token in the response. You can use this pagination token to retrieve the next set of text.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct IndexFaces<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::index_faces_input::Builder,
    }
    impl<C, M, R> IndexFaces<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::IndexFacesOutput,
            smithy_http::result::SdkError<crate::error::IndexFacesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::IndexFacesInputOperationOutputAlias,
                crate::output::IndexFacesOutput,
                crate::error::IndexFacesError,
                crate::input::IndexFacesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of an existing collection to which you want to add the faces that are detected
        /// in the input images.</p>
        pub fn collection_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_id(inp);
            self
        }
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_id(input);
            self
        }
        /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
        /// Amazon Rekognition operations, passing base64-encoded image bytes isn't supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, inp: crate::model::Image) -> Self {
            self.inner = self.inner.image(inp);
            self
        }
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.inner = self.inner.set_image(input);
            self
        }
        /// <p>The ID you want to assign to all the faces detected in the image.</p>
        pub fn external_image_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_image_id(inp);
            self
        }
        pub fn set_external_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_external_image_id(input);
            self
        }
        /// Appends an item to `DetectionAttributes`.
        ///
        /// To override the contents of this collection use [`set_detection_attributes`](Self::set_detection_attributes).
        /// <p>An array of facial attributes that you want to be returned. This can be the default
        /// list of attributes or all attributes. If you don't specify a value for <code>Attributes</code>
        /// or if you specify <code>["DEFAULT"]</code>, the API returns the following subset of facial
        /// attributes: <code>BoundingBox</code>, <code>Confidence</code>, <code>Pose</code>,
        /// <code>Quality</code>, and <code>Landmarks</code>. If you provide <code>["ALL"]</code>, all
        /// facial attributes are returned, but the operation takes longer to complete.</p>
        /// <p>If you provide both, <code>["ALL", "DEFAULT"]</code>, the service uses a logical AND
        /// operator to determine which attributes to return (in this case, all attributes). </p>
        pub fn detection_attributes(mut self, inp: impl Into<crate::model::Attribute>) -> Self {
            self.inner = self.inner.detection_attributes(inp);
            self
        }
        pub fn set_detection_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.inner = self.inner.set_detection_attributes(input);
            self
        }
        /// <p>The maximum number of faces to index. The value of <code>MaxFaces</code> must be greater
        /// than or equal to 1. <code>IndexFaces</code> returns no more than 100 detected faces in an
        /// image, even if you specify a larger value for <code>MaxFaces</code>.</p>
        /// <p>If <code>IndexFaces</code> detects more faces than the value of <code>MaxFaces</code>, the
        /// faces with the lowest quality are filtered out first. If there are still more faces than the
        /// value of <code>MaxFaces</code>, the faces with the smallest bounding boxes are filtered out
        /// (up to the number that's needed to satisfy the value of <code>MaxFaces</code>). Information
        /// about the unindexed faces is available in the <code>UnindexedFaces</code> array. </p>
        /// <p>The faces that are returned by <code>IndexFaces</code> are sorted by the largest face
        /// bounding box size to the smallest size, in descending order.</p>
        /// <p>
        /// <code>MaxFaces</code> can be used with a collection associated with any version of
        /// the face model.</p>
        pub fn max_faces(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_faces(inp);
            self
        }
        pub fn set_max_faces(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_faces(input);
            self
        }
        /// <p>A filter that specifies a quality bar for how much filtering is done to identify faces.
        /// Filtered faces aren't indexed. If you specify <code>AUTO</code>, Amazon Rekognition chooses the quality bar.
        /// If you specify <code>LOW</code>,
        /// <code>MEDIUM</code>, or <code>HIGH</code>, filtering removes all faces that
        /// don’t meet the chosen quality bar.  The default value is <code>AUTO</code>.
        /// The quality bar is based on a variety of common use cases. Low-quality
        /// detections can occur for a number of reasons. Some examples are an object that's misidentified
        /// as a face, a face that's too blurry, or a face with a
        /// pose that's too extreme to use. If you specify <code>NONE</code>, no
        /// filtering is performed.
        /// </p>
        /// <p>To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.</p>
        pub fn quality_filter(mut self, inp: crate::model::QualityFilter) -> Self {
            self.inner = self.inner.quality_filter(inp);
            self
        }
        pub fn set_quality_filter(
            mut self,
            input: std::option::Option<crate::model::QualityFilter>,
        ) -> Self {
            self.inner = self.inner.set_quality_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCollections<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_collections_input::Builder,
    }
    impl<C, M, R> ListCollections<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCollectionsOutput,
            smithy_http::result::SdkError<crate::error::ListCollectionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListCollectionsInputOperationOutputAlias,
                crate::output::ListCollectionsOutput,
                crate::error::ListCollectionsError,
                crate::input::ListCollectionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Pagination token from the previous response.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Maximum number of collection IDs to return. </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFaces<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_faces_input::Builder,
    }
    impl<C, M, R> ListFaces<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFacesOutput,
            smithy_http::result::SdkError<crate::error::ListFacesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListFacesInputOperationOutputAlias,
                crate::output::ListFacesOutput,
                crate::error::ListFacesError,
                crate::input::ListFacesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>ID of the collection from which to list the faces.</p>
        pub fn collection_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_id(inp);
            self
        }
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_id(input);
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve),
        /// Amazon Rekognition returns a pagination token in the response. You can use this pagination token to
        /// retrieve the next set of faces.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Maximum number of faces to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStreamProcessors<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_stream_processors_input::Builder,
    }
    impl<C, M, R> ListStreamProcessors<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStreamProcessorsOutput,
            smithy_http::result::SdkError<crate::error::ListStreamProcessorsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListStreamProcessorsInputOperationOutputAlias,
                crate::output::ListStreamProcessorsOutput,
                crate::error::ListStreamProcessorsError,
                crate::input::ListStreamProcessorsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If the previous response was incomplete (because there are more stream processors to retrieve), Amazon Rekognition Video
        /// returns a pagination token in the response. You can use this pagination token to retrieve the next set of stream processors. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Maximum number of stream processors you want Amazon Rekognition Video to return in the response. The default is 1000. </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C, M, R> ListTagsForResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsForResourceInputOperationOutputAlias,
                crate::output::ListTagsForResourceOutput,
                crate::error::ListTagsForResourceError,
                crate::input::ListTagsForResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// Amazon Resource Name (ARN) of the model, collection, or stream processor that contains the tags that you want a list of.
        /// </p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RecognizeCelebrities<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::recognize_celebrities_input::Builder,
    }
    impl<C, M, R> RecognizeCelebrities<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RecognizeCelebritiesOutput,
            smithy_http::result::SdkError<crate::error::RecognizeCelebritiesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RecognizeCelebritiesInputOperationOutputAlias,
                crate::output::RecognizeCelebritiesOutput,
                crate::error::RecognizeCelebritiesError,
                crate::input::RecognizeCelebritiesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call
        /// Amazon Rekognition operations, passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to
        /// base64-encode image bytes passed using the <code>Bytes</code> field. For more information, see
        /// Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, inp: crate::model::Image) -> Self {
            self.inner = self.inner.image(inp);
            self
        }
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.inner = self.inner.set_image(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SearchFaces<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::search_faces_input::Builder,
    }
    impl<C, M, R> SearchFaces<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SearchFacesOutput,
            smithy_http::result::SdkError<crate::error::SearchFacesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SearchFacesInputOperationOutputAlias,
                crate::output::SearchFacesOutput,
                crate::error::SearchFacesError,
                crate::input::SearchFacesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>ID of the collection the face belongs to.</p>
        pub fn collection_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_id(inp);
            self
        }
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_id(input);
            self
        }
        /// <p>ID of a face to find matches for in the collection.</p>
        pub fn face_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.face_id(inp);
            self
        }
        pub fn set_face_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_face_id(input);
            self
        }
        /// <p>Maximum number of faces to return. The operation returns the maximum number of faces
        /// with the highest confidence in the match.</p>
        pub fn max_faces(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_faces(inp);
            self
        }
        pub fn set_max_faces(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_faces(input);
            self
        }
        /// <p>Optional value specifying the minimum confidence in the face match to return. For
        /// example, don't return any matches where confidence in matches is less than 70%.
        /// The default value is 80%.
        /// </p>
        pub fn face_match_threshold(mut self, inp: f32) -> Self {
            self.inner = self.inner.face_match_threshold(inp);
            self
        }
        pub fn set_face_match_threshold(mut self, input: std::option::Option<f32>) -> Self {
            self.inner = self.inner.set_face_match_threshold(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SearchFacesByImage<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::search_faces_by_image_input::Builder,
    }
    impl<C, M, R> SearchFacesByImage<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SearchFacesByImageOutput,
            smithy_http::result::SdkError<crate::error::SearchFacesByImageError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SearchFacesByImageInputOperationOutputAlias,
                crate::output::SearchFacesByImageOutput,
                crate::error::SearchFacesByImageError,
                crate::input::SearchFacesByImageInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>ID of the collection to search.</p>
        pub fn collection_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_id(inp);
            self
        }
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_id(input);
            self
        }
        /// <p>The input image as base64-encoded bytes or an S3 object.
        /// If you use the AWS CLI to call Amazon Rekognition operations,
        /// passing base64-encoded image bytes is not supported. </p>
        /// <p>If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes
        /// passed using the <code>Bytes</code> field.
        /// For more information, see Images in the Amazon Rekognition developer guide.</p>
        pub fn image(mut self, inp: crate::model::Image) -> Self {
            self.inner = self.inner.image(inp);
            self
        }
        pub fn set_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.inner = self.inner.set_image(input);
            self
        }
        /// <p>Maximum number of faces to return. The operation returns the maximum number of faces
        /// with the highest confidence in the match.</p>
        pub fn max_faces(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_faces(inp);
            self
        }
        pub fn set_max_faces(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_faces(input);
            self
        }
        /// <p>(Optional) Specifies the minimum confidence in the face match to return. For example,
        /// don't return any matches where confidence in matches is less than 70%.
        /// The default value is 80%.</p>
        pub fn face_match_threshold(mut self, inp: f32) -> Self {
            self.inner = self.inner.face_match_threshold(inp);
            self
        }
        pub fn set_face_match_threshold(mut self, input: std::option::Option<f32>) -> Self {
            self.inner = self.inner.set_face_match_threshold(input);
            self
        }
        /// <p>A filter that specifies a quality bar for how much filtering is done to identify faces.
        /// Filtered faces aren't searched for in the collection. If you specify <code>AUTO</code>, Amazon Rekognition
        /// chooses the quality bar.  If you specify <code>LOW</code>,
        /// <code>MEDIUM</code>, or <code>HIGH</code>, filtering removes all faces that
        /// don’t meet the chosen quality bar.  
        /// The quality bar is based on a variety of common use cases. Low-quality
        /// detections can occur for a number of reasons. Some examples are an object that's misidentified
        /// as a face, a face that's too blurry, or a face with a
        /// pose that's too extreme to use. If you specify <code>NONE</code>, no
        /// filtering is performed.  The default value is <code>NONE</code>.
        /// </p>
        /// <p>To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.</p>
        pub fn quality_filter(mut self, inp: crate::model::QualityFilter) -> Self {
            self.inner = self.inner.quality_filter(inp);
            self
        }
        pub fn set_quality_filter(
            mut self,
            input: std::option::Option<crate::model::QualityFilter>,
        ) -> Self {
            self.inner = self.inner.set_quality_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartCelebrityRecognition<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_celebrity_recognition_input::Builder,
    }
    impl<C, M, R> StartCelebrityRecognition<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartCelebrityRecognitionOutput,
            smithy_http::result::SdkError<crate::error::StartCelebrityRecognitionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartCelebrityRecognitionInputOperationOutputAlias,
                crate::output::StartCelebrityRecognitionOutput,
                crate::error::StartCelebrityRecognitionError,
                crate::input::StartCelebrityRecognitionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The video in which you want to recognize celebrities. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn video(mut self, inp: crate::model::Video) -> Self {
            self.inner = self.inner.video(inp);
            self
        }
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.inner = self.inner.set_video(input);
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartCelebrityRecognition</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>The Amazon SNS topic ARN that you want Amazon Rekognition Video to publish the completion status of the
        /// celebrity recognition analysis to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
        pub fn notification_channel(mut self, inp: crate::model::NotificationChannel) -> Self {
            self.inner = self.inner.notification_channel(inp);
            self
        }
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.inner = self.inner.set_notification_channel(input);
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_tag(inp);
            self
        }
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_tag(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartContentModeration<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_content_moderation_input::Builder,
    }
    impl<C, M, R> StartContentModeration<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartContentModerationOutput,
            smithy_http::result::SdkError<crate::error::StartContentModerationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartContentModerationInputOperationOutputAlias,
                crate::output::StartContentModerationOutput,
                crate::error::StartContentModerationError,
                crate::input::StartContentModerationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The video in which you want to detect inappropriate, unwanted, or offensive content. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn video(mut self, inp: crate::model::Video) -> Self {
            self.inner = self.inner.video(inp);
            self
        }
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.inner = self.inner.set_video(input);
            self
        }
        /// <p>Specifies the minimum confidence that Amazon Rekognition must have in order to return a moderated content label. Confidence
        /// represents how certain Amazon Rekognition is that the moderated content is correctly identified. 0 is the lowest confidence.
        /// 100 is the highest confidence.  Amazon Rekognition doesn't return any moderated content labels with a confidence level
        /// lower than this specified value. If you don't specify <code>MinConfidence</code>, <code>GetContentModeration</code>
        /// returns labels with confidence values greater than or equal to 50 percent.</p>
        pub fn min_confidence(mut self, inp: f32) -> Self {
            self.inner = self.inner.min_confidence(inp);
            self
        }
        pub fn set_min_confidence(mut self, input: std::option::Option<f32>) -> Self {
            self.inner = self.inner.set_min_confidence(input);
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartContentModeration</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>The Amazon SNS topic ARN that you want Amazon Rekognition Video to publish the completion status of the
        /// content analysis to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
        pub fn notification_channel(mut self, inp: crate::model::NotificationChannel) -> Self {
            self.inner = self.inner.notification_channel(inp);
            self
        }
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.inner = self.inner.set_notification_channel(input);
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_tag(inp);
            self
        }
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_tag(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartFaceDetection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_face_detection_input::Builder,
    }
    impl<C, M, R> StartFaceDetection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartFaceDetectionOutput,
            smithy_http::result::SdkError<crate::error::StartFaceDetectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartFaceDetectionInputOperationOutputAlias,
                crate::output::StartFaceDetectionOutput,
                crate::error::StartFaceDetectionError,
                crate::input::StartFaceDetectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The video in which you want to detect faces. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn video(mut self, inp: crate::model::Video) -> Self {
            self.inner = self.inner.video(inp);
            self
        }
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.inner = self.inner.set_video(input);
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartFaceDetection</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the
        /// face detection operation. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
        pub fn notification_channel(mut self, inp: crate::model::NotificationChannel) -> Self {
            self.inner = self.inner.notification_channel(inp);
            self
        }
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.inner = self.inner.set_notification_channel(input);
            self
        }
        /// <p>The face attributes you want returned.</p>
        /// <p>
        /// <code>DEFAULT</code> - The following subset of facial attributes are returned: BoundingBox, Confidence, Pose, Quality and Landmarks. </p>
        /// <p>
        /// <code>ALL</code> - All facial attributes are returned.</p>
        pub fn face_attributes(mut self, inp: crate::model::FaceAttributes) -> Self {
            self.inner = self.inner.face_attributes(inp);
            self
        }
        pub fn set_face_attributes(
            mut self,
            input: std::option::Option<crate::model::FaceAttributes>,
        ) -> Self {
            self.inner = self.inner.set_face_attributes(input);
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_tag(inp);
            self
        }
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_tag(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartFaceSearch<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_face_search_input::Builder,
    }
    impl<C, M, R> StartFaceSearch<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartFaceSearchOutput,
            smithy_http::result::SdkError<crate::error::StartFaceSearchError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartFaceSearchInputOperationOutputAlias,
                crate::output::StartFaceSearchOutput,
                crate::error::StartFaceSearchError,
                crate::input::StartFaceSearchInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The video you want to search. The video must be stored in an Amazon S3 bucket. </p>
        pub fn video(mut self, inp: crate::model::Video) -> Self {
            self.inner = self.inner.video(inp);
            self
        }
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.inner = self.inner.set_video(input);
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartFaceSearch</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>The minimum confidence in the person match to return. For example, don't return any matches where confidence in matches is less than 70%.
        /// The default value is 80%.</p>
        pub fn face_match_threshold(mut self, inp: f32) -> Self {
            self.inner = self.inner.face_match_threshold(inp);
            self
        }
        pub fn set_face_match_threshold(mut self, input: std::option::Option<f32>) -> Self {
            self.inner = self.inner.set_face_match_threshold(input);
            self
        }
        /// <p>ID of the collection that contains the faces you want to search for.</p>
        pub fn collection_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_id(inp);
            self
        }
        pub fn set_collection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_id(input);
            self
        }
        /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the search. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
        pub fn notification_channel(mut self, inp: crate::model::NotificationChannel) -> Self {
            self.inner = self.inner.notification_channel(inp);
            self
        }
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.inner = self.inner.set_notification_channel(input);
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_tag(inp);
            self
        }
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_tag(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartLabelDetection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_label_detection_input::Builder,
    }
    impl<C, M, R> StartLabelDetection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartLabelDetectionOutput,
            smithy_http::result::SdkError<crate::error::StartLabelDetectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartLabelDetectionInputOperationOutputAlias,
                crate::output::StartLabelDetectionOutput,
                crate::error::StartLabelDetectionError,
                crate::input::StartLabelDetectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The video in which you want to detect labels. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn video(mut self, inp: crate::model::Video) -> Self {
            self.inner = self.inner.video(inp);
            self
        }
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.inner = self.inner.set_video(input);
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartLabelDetection</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>Specifies the minimum confidence that Amazon Rekognition Video must have in order to return a detected label. Confidence
        /// represents how certain Amazon Rekognition is that a label is correctly identified.0 is the lowest confidence.
        /// 100 is the highest confidence.  Amazon Rekognition Video doesn't return any labels with a confidence level
        /// lower than this specified value.</p>
        /// <p>If you don't specify <code>MinConfidence</code>, the operation returns labels with confidence
        /// values greater than or equal to 50 percent.</p>
        pub fn min_confidence(mut self, inp: f32) -> Self {
            self.inner = self.inner.min_confidence(inp);
            self
        }
        pub fn set_min_confidence(mut self, input: std::option::Option<f32>) -> Self {
            self.inner = self.inner.set_min_confidence(input);
            self
        }
        /// <p>The Amazon SNS topic ARN you want Amazon Rekognition Video to publish the completion status of the label detection
        /// operation to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
        pub fn notification_channel(mut self, inp: crate::model::NotificationChannel) -> Self {
            self.inner = self.inner.notification_channel(inp);
            self
        }
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.inner = self.inner.set_notification_channel(input);
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_tag(inp);
            self
        }
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_tag(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartPersonTracking<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_person_tracking_input::Builder,
    }
    impl<C, M, R> StartPersonTracking<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartPersonTrackingOutput,
            smithy_http::result::SdkError<crate::error::StartPersonTrackingError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartPersonTrackingInputOperationOutputAlias,
                crate::output::StartPersonTrackingOutput,
                crate::error::StartPersonTrackingError,
                crate::input::StartPersonTrackingInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The video in which you want to detect people. The video must be stored
        /// in an Amazon S3 bucket.</p>
        pub fn video(mut self, inp: crate::model::Video) -> Self {
            self.inner = self.inner.video(inp);
            self
        }
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.inner = self.inner.set_video(input);
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartPersonTracking</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>The Amazon SNS topic ARN you want Amazon Rekognition Video to publish the completion status of the people detection
        /// operation to. The Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy.</p>
        pub fn notification_channel(mut self, inp: crate::model::NotificationChannel) -> Self {
            self.inner = self.inner.notification_channel(inp);
            self
        }
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.inner = self.inner.set_notification_channel(input);
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_tag(inp);
            self
        }
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_tag(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartProjectVersion<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_project_version_input::Builder,
    }
    impl<C, M, R> StartProjectVersion<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartProjectVersionOutput,
            smithy_http::result::SdkError<crate::error::StartProjectVersionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartProjectVersionInputOperationOutputAlias,
                crate::output::StartProjectVersionOutput,
                crate::error::StartProjectVersionError,
                crate::input::StartProjectVersionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name(ARN) of the model version that you want to start.</p>
        pub fn project_version_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_version_arn(inp);
            self
        }
        pub fn set_project_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_project_version_arn(input);
            self
        }
        /// <p>The minimum number of inference units to use. A single
        /// inference unit represents 1 hour of processing and can support up to 5 Transaction Pers Second (TPS).
        /// Use a higher number to increase the TPS throughput of your model. You are charged for the number
        /// of inference units that you use.
        /// </p>
        pub fn min_inference_units(mut self, inp: i32) -> Self {
            self.inner = self.inner.min_inference_units(inp);
            self
        }
        pub fn set_min_inference_units(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_inference_units(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartSegmentDetection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_segment_detection_input::Builder,
    }
    impl<C, M, R> StartSegmentDetection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartSegmentDetectionOutput,
            smithy_http::result::SdkError<crate::error::StartSegmentDetectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartSegmentDetectionInputOperationOutputAlias,
                crate::output::StartSegmentDetectionOutput,
                crate::error::StartSegmentDetectionError,
                crate::input::StartSegmentDetectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Video file stored in an Amazon S3 bucket. Amazon Rekognition video start operations such as <a>StartLabelDetection</a> use <code>Video</code> to
        /// specify a video for analysis. The supported file formats are .mp4, .mov and .avi.</p>
        pub fn video(mut self, inp: crate::model::Video) -> Self {
            self.inner = self.inner.video(inp);
            self
        }
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.inner = self.inner.set_video(input);
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple
        /// <code>StartSegmentDetection</code> requests, the same <code>JobId</code> is returned. Use
        /// <code>ClientRequestToken</code> to prevent the same job from being accidently started more than once. </p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the
        /// segment detection operation. Note that the Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.</p>
        pub fn notification_channel(mut self, inp: crate::model::NotificationChannel) -> Self {
            self.inner = self.inner.notification_channel(inp);
            self
        }
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.inner = self.inner.set_notification_channel(input);
            self
        }
        /// <p>An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic.
        /// For example, you can use <code>JobTag</code> to group related jobs and identify them in the completion notification.</p>
        pub fn job_tag(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_tag(inp);
            self
        }
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_tag(input);
            self
        }
        /// <p>Filters for technical cue or shot detection.</p>
        pub fn filters(mut self, inp: crate::model::StartSegmentDetectionFilters) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<crate::model::StartSegmentDetectionFilters>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// Appends an item to `SegmentTypes`.
        ///
        /// To override the contents of this collection use [`set_segment_types`](Self::set_segment_types).
        /// <p>An array of segment types to detect in the video. Valid values are TECHNICAL_CUE and SHOT.</p>
        pub fn segment_types(mut self, inp: impl Into<crate::model::SegmentType>) -> Self {
            self.inner = self.inner.segment_types(inp);
            self
        }
        pub fn set_segment_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SegmentType>>,
        ) -> Self {
            self.inner = self.inner.set_segment_types(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartStreamProcessor<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_stream_processor_input::Builder,
    }
    impl<C, M, R> StartStreamProcessor<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartStreamProcessorOutput,
            smithy_http::result::SdkError<crate::error::StartStreamProcessorError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartStreamProcessorInputOperationOutputAlias,
                crate::output::StartStreamProcessorOutput,
                crate::error::StartStreamProcessorError,
                crate::input::StartStreamProcessorInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream processor to start processing.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartTextDetection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_text_detection_input::Builder,
    }
    impl<C, M, R> StartTextDetection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartTextDetectionOutput,
            smithy_http::result::SdkError<crate::error::StartTextDetectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartTextDetectionInputOperationOutputAlias,
                crate::output::StartTextDetectionOutput,
                crate::error::StartTextDetectionError,
                crate::input::StartTextDetectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Video file stored in an Amazon S3 bucket. Amazon Rekognition video start operations such as <a>StartLabelDetection</a> use <code>Video</code> to
        /// specify a video for analysis. The supported file formats are .mp4, .mov and .avi.</p>
        pub fn video(mut self, inp: crate::model::Video) -> Self {
            self.inner = self.inner.video(inp);
            self
        }
        pub fn set_video(mut self, input: std::option::Option<crate::model::Video>) -> Self {
            self.inner = self.inner.set_video(input);
            self
        }
        /// <p>Idempotent token used to identify the start request. If you use the same token with multiple <code>StartTextDetection</code>
        /// requests, the same <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same job
        /// from being accidentaly started more than once.</p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>The Amazon Simple Notification Service topic to which Amazon Rekognition publishes the completion status of a video analysis operation. For more information, see
        /// <a>api-video</a>. Note that the Amazon SNS topic must have a topic name that begins with <i>AmazonRekognition</i> if you are using the AmazonRekognitionServiceRole permissions policy to access the topic.
        /// For more information, see <a href="https://docs.aws.amazon.com/rekognition/latest/dg/api-video-roles.html#api-video-roles-all-topics">Giving access to multiple Amazon SNS topics</a>.</p>
        pub fn notification_channel(mut self, inp: crate::model::NotificationChannel) -> Self {
            self.inner = self.inner.notification_channel(inp);
            self
        }
        pub fn set_notification_channel(
            mut self,
            input: std::option::Option<crate::model::NotificationChannel>,
        ) -> Self {
            self.inner = self.inner.set_notification_channel(input);
            self
        }
        /// <p>An identifier returned in the completion status published by your Amazon Simple Notification Service topic.  For example, you can use <code>JobTag</code> to group related jobs
        /// and identify them in the completion notification.</p>
        pub fn job_tag(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_tag(inp);
            self
        }
        pub fn set_job_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_tag(input);
            self
        }
        /// <p>Optional parameters that let you set criteria the text must meet to be included in your response.</p>
        pub fn filters(mut self, inp: crate::model::StartTextDetectionFilters) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<crate::model::StartTextDetectionFilters>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopProjectVersion<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::stop_project_version_input::Builder,
    }
    impl<C, M, R> StopProjectVersion<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopProjectVersionOutput,
            smithy_http::result::SdkError<crate::error::StopProjectVersionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StopProjectVersionInputOperationOutputAlias,
                crate::output::StopProjectVersionOutput,
                crate::error::StopProjectVersionError,
                crate::input::StopProjectVersionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the model version that you want to delete.</p>
        /// <p>This operation requires permissions to perform the <code>rekognition:StopProjectVersion</code> action.</p>
        pub fn project_version_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_version_arn(inp);
            self
        }
        pub fn set_project_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_project_version_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopStreamProcessor<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::stop_stream_processor_input::Builder,
    }
    impl<C, M, R> StopStreamProcessor<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopStreamProcessorOutput,
            smithy_http::result::SdkError<crate::error::StopStreamProcessorError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StopStreamProcessorInputOperationOutputAlias,
                crate::output::StopStreamProcessorOutput,
                crate::error::StopStreamProcessorError,
                crate::input::StopStreamProcessorInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a stream processor created by <a>CreateStreamProcessor</a>.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C, M, R> TagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TagResourceInputOperationOutputAlias,
                crate::output::TagResourceOutput,
                crate::error::TagResourceError,
                crate::input::TagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// Amazon Resource Name (ARN) of the model, collection, or stream processor that you want to assign the tags to.
        /// </p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Adds a key-value pair to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>
        /// The key-value tags to assign to the resource.
        /// </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C, M, R> UntagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UntagResourceInputOperationOutputAlias,
                crate::output::UntagResourceOutput,
                crate::error::UntagResourceError,
                crate::input::UntagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// Amazon Resource Name (ARN) of the model, collection, or stream processor that you want to remove the tags from.
        /// </p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Appends an item to `TagKeys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        /// <p>
        /// A list of the tags that you want to remove.
        /// </p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::new(conn).with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::https().with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
