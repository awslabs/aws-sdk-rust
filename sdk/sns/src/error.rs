// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddPermissionError {
    pub kind: AddPermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddPermissionErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddPermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddPermissionErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddPermissionError {
    fn code(&self) -> Option<&str> {
        AddPermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddPermissionError {
    pub fn new(kind: AddPermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddPermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddPermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for AddPermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddPermissionErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            AddPermissionErrorKind::InternalErrorError(_inner) => Some(_inner),
            AddPermissionErrorKind::InvalidParameterError(_inner) => Some(_inner),
            AddPermissionErrorKind::NotFoundError(_inner) => Some(_inner),
            AddPermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CheckIfPhoneNumberIsOptedOutError {
    pub kind: CheckIfPhoneNumberIsOptedOutErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CheckIfPhoneNumberIsOptedOutErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ThrottledError(crate::error::ThrottledError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CheckIfPhoneNumberIsOptedOutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CheckIfPhoneNumberIsOptedOutErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            CheckIfPhoneNumberIsOptedOutErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            CheckIfPhoneNumberIsOptedOutErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CheckIfPhoneNumberIsOptedOutErrorKind::ThrottledError(_inner) => _inner.fmt(f),
            CheckIfPhoneNumberIsOptedOutErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CheckIfPhoneNumberIsOptedOutError {
    fn code(&self) -> Option<&str> {
        CheckIfPhoneNumberIsOptedOutError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CheckIfPhoneNumberIsOptedOutError {
    pub fn new(kind: CheckIfPhoneNumberIsOptedOutErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CheckIfPhoneNumberIsOptedOutErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CheckIfPhoneNumberIsOptedOutErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for CheckIfPhoneNumberIsOptedOutError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CheckIfPhoneNumberIsOptedOutErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            CheckIfPhoneNumberIsOptedOutErrorKind::InternalErrorError(_inner) => Some(_inner),
            CheckIfPhoneNumberIsOptedOutErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CheckIfPhoneNumberIsOptedOutErrorKind::ThrottledError(_inner) => Some(_inner),
            CheckIfPhoneNumberIsOptedOutErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConfirmSubscriptionError {
    pub kind: ConfirmSubscriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConfirmSubscriptionErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    FilterPolicyLimitExceededError(crate::error::FilterPolicyLimitExceededError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    NotFoundError(crate::error::NotFoundError),
    SubscriptionLimitExceededError(crate::error::SubscriptionLimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConfirmSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ConfirmSubscriptionErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            ConfirmSubscriptionErrorKind::FilterPolicyLimitExceededError(_inner) => _inner.fmt(f),
            ConfirmSubscriptionErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            ConfirmSubscriptionErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ConfirmSubscriptionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ConfirmSubscriptionErrorKind::SubscriptionLimitExceededError(_inner) => _inner.fmt(f),
            ConfirmSubscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ConfirmSubscriptionError {
    fn code(&self) -> Option<&str> {
        ConfirmSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConfirmSubscriptionError {
    pub fn new(kind: ConfirmSubscriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ConfirmSubscriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ConfirmSubscriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ConfirmSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ConfirmSubscriptionErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            ConfirmSubscriptionErrorKind::FilterPolicyLimitExceededError(_inner) => Some(_inner),
            ConfirmSubscriptionErrorKind::InternalErrorError(_inner) => Some(_inner),
            ConfirmSubscriptionErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ConfirmSubscriptionErrorKind::NotFoundError(_inner) => Some(_inner),
            ConfirmSubscriptionErrorKind::SubscriptionLimitExceededError(_inner) => Some(_inner),
            ConfirmSubscriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePlatformApplicationError {
    pub kind: CreatePlatformApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePlatformApplicationErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePlatformApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePlatformApplicationErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            CreatePlatformApplicationErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            CreatePlatformApplicationErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CreatePlatformApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePlatformApplicationError {
    fn code(&self) -> Option<&str> {
        CreatePlatformApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePlatformApplicationError {
    pub fn new(kind: CreatePlatformApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePlatformApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePlatformApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for CreatePlatformApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePlatformApplicationErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            CreatePlatformApplicationErrorKind::InternalErrorError(_inner) => Some(_inner),
            CreatePlatformApplicationErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CreatePlatformApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePlatformEndpointError {
    pub kind: CreatePlatformEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePlatformEndpointErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePlatformEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePlatformEndpointErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            CreatePlatformEndpointErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            CreatePlatformEndpointErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CreatePlatformEndpointErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreatePlatformEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePlatformEndpointError {
    fn code(&self) -> Option<&str> {
        CreatePlatformEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePlatformEndpointError {
    pub fn new(kind: CreatePlatformEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePlatformEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePlatformEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for CreatePlatformEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePlatformEndpointErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            CreatePlatformEndpointErrorKind::InternalErrorError(_inner) => Some(_inner),
            CreatePlatformEndpointErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CreatePlatformEndpointErrorKind::NotFoundError(_inner) => Some(_inner),
            CreatePlatformEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTopicError {
    pub kind: CreateTopicErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTopicErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    ConcurrentAccessError(crate::error::ConcurrentAccessError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidSecurityError(crate::error::InvalidSecurityError),
    StaleTagError(crate::error::StaleTagError),
    TagLimitExceededError(crate::error::TagLimitExceededError),
    TagPolicyError(crate::error::TagPolicyError),
    TopicLimitExceededError(crate::error::TopicLimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTopicError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTopicErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            CreateTopicErrorKind::ConcurrentAccessError(_inner) => _inner.fmt(f),
            CreateTopicErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            CreateTopicErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CreateTopicErrorKind::InvalidSecurityError(_inner) => _inner.fmt(f),
            CreateTopicErrorKind::StaleTagError(_inner) => _inner.fmt(f),
            CreateTopicErrorKind::TagLimitExceededError(_inner) => _inner.fmt(f),
            CreateTopicErrorKind::TagPolicyError(_inner) => _inner.fmt(f),
            CreateTopicErrorKind::TopicLimitExceededError(_inner) => _inner.fmt(f),
            CreateTopicErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTopicError {
    fn code(&self) -> Option<&str> {
        CreateTopicError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTopicError {
    pub fn new(kind: CreateTopicErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTopicErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTopicErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for CreateTopicError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTopicErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            CreateTopicErrorKind::ConcurrentAccessError(_inner) => Some(_inner),
            CreateTopicErrorKind::InternalErrorError(_inner) => Some(_inner),
            CreateTopicErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CreateTopicErrorKind::InvalidSecurityError(_inner) => Some(_inner),
            CreateTopicErrorKind::StaleTagError(_inner) => Some(_inner),
            CreateTopicErrorKind::TagLimitExceededError(_inner) => Some(_inner),
            CreateTopicErrorKind::TagPolicyError(_inner) => Some(_inner),
            CreateTopicErrorKind::TopicLimitExceededError(_inner) => Some(_inner),
            CreateTopicErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEndpointError {
    pub kind: DeleteEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEndpointErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEndpointErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            DeleteEndpointErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            DeleteEndpointErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEndpointError {
    fn code(&self) -> Option<&str> {
        DeleteEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEndpointError {
    pub fn new(kind: DeleteEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DeleteEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEndpointErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            DeleteEndpointErrorKind::InternalErrorError(_inner) => Some(_inner),
            DeleteEndpointErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePlatformApplicationError {
    pub kind: DeletePlatformApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePlatformApplicationErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePlatformApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePlatformApplicationErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            DeletePlatformApplicationErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            DeletePlatformApplicationErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeletePlatformApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePlatformApplicationError {
    fn code(&self) -> Option<&str> {
        DeletePlatformApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePlatformApplicationError {
    pub fn new(kind: DeletePlatformApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePlatformApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePlatformApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DeletePlatformApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePlatformApplicationErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            DeletePlatformApplicationErrorKind::InternalErrorError(_inner) => Some(_inner),
            DeletePlatformApplicationErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeletePlatformApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTopicError {
    pub kind: DeleteTopicErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTopicErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    ConcurrentAccessError(crate::error::ConcurrentAccessError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    NotFoundError(crate::error::NotFoundError),
    StaleTagError(crate::error::StaleTagError),
    TagPolicyError(crate::error::TagPolicyError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTopicError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTopicErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            DeleteTopicErrorKind::ConcurrentAccessError(_inner) => _inner.fmt(f),
            DeleteTopicErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            DeleteTopicErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteTopicErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteTopicErrorKind::StaleTagError(_inner) => _inner.fmt(f),
            DeleteTopicErrorKind::TagPolicyError(_inner) => _inner.fmt(f),
            DeleteTopicErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTopicError {
    fn code(&self) -> Option<&str> {
        DeleteTopicError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTopicError {
    pub fn new(kind: DeleteTopicErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTopicErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTopicErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DeleteTopicError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTopicErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            DeleteTopicErrorKind::ConcurrentAccessError(_inner) => Some(_inner),
            DeleteTopicErrorKind::InternalErrorError(_inner) => Some(_inner),
            DeleteTopicErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteTopicErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteTopicErrorKind::StaleTagError(_inner) => Some(_inner),
            DeleteTopicErrorKind::TagPolicyError(_inner) => Some(_inner),
            DeleteTopicErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEndpointAttributesError {
    pub kind: GetEndpointAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEndpointAttributesErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEndpointAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEndpointAttributesErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            GetEndpointAttributesErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            GetEndpointAttributesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            GetEndpointAttributesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetEndpointAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEndpointAttributesError {
    fn code(&self) -> Option<&str> {
        GetEndpointAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEndpointAttributesError {
    pub fn new(kind: GetEndpointAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEndpointAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEndpointAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetEndpointAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEndpointAttributesErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            GetEndpointAttributesErrorKind::InternalErrorError(_inner) => Some(_inner),
            GetEndpointAttributesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            GetEndpointAttributesErrorKind::NotFoundError(_inner) => Some(_inner),
            GetEndpointAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPlatformApplicationAttributesError {
    pub kind: GetPlatformApplicationAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPlatformApplicationAttributesErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPlatformApplicationAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPlatformApplicationAttributesErrorKind::AuthorizationErrorError(_inner) => {
                _inner.fmt(f)
            }
            GetPlatformApplicationAttributesErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            GetPlatformApplicationAttributesErrorKind::InvalidParameterError(_inner) => {
                _inner.fmt(f)
            }
            GetPlatformApplicationAttributesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetPlatformApplicationAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPlatformApplicationAttributesError {
    fn code(&self) -> Option<&str> {
        GetPlatformApplicationAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPlatformApplicationAttributesError {
    pub fn new(kind: GetPlatformApplicationAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPlatformApplicationAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPlatformApplicationAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetPlatformApplicationAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPlatformApplicationAttributesErrorKind::AuthorizationErrorError(_inner) => {
                Some(_inner)
            }
            GetPlatformApplicationAttributesErrorKind::InternalErrorError(_inner) => Some(_inner),
            GetPlatformApplicationAttributesErrorKind::InvalidParameterError(_inner) => {
                Some(_inner)
            }
            GetPlatformApplicationAttributesErrorKind::NotFoundError(_inner) => Some(_inner),
            GetPlatformApplicationAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSMSAttributesError {
    pub kind: GetSMSAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSMSAttributesErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ThrottledError(crate::error::ThrottledError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSMSAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSMSAttributesErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            GetSMSAttributesErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            GetSMSAttributesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            GetSMSAttributesErrorKind::ThrottledError(_inner) => _inner.fmt(f),
            GetSMSAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSMSAttributesError {
    fn code(&self) -> Option<&str> {
        GetSMSAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSMSAttributesError {
    pub fn new(kind: GetSMSAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSMSAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSMSAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetSMSAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSMSAttributesErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            GetSMSAttributesErrorKind::InternalErrorError(_inner) => Some(_inner),
            GetSMSAttributesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            GetSMSAttributesErrorKind::ThrottledError(_inner) => Some(_inner),
            GetSMSAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSubscriptionAttributesError {
    pub kind: GetSubscriptionAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSubscriptionAttributesErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSubscriptionAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSubscriptionAttributesErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            GetSubscriptionAttributesErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            GetSubscriptionAttributesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            GetSubscriptionAttributesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetSubscriptionAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSubscriptionAttributesError {
    fn code(&self) -> Option<&str> {
        GetSubscriptionAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSubscriptionAttributesError {
    pub fn new(kind: GetSubscriptionAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSubscriptionAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSubscriptionAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetSubscriptionAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSubscriptionAttributesErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            GetSubscriptionAttributesErrorKind::InternalErrorError(_inner) => Some(_inner),
            GetSubscriptionAttributesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            GetSubscriptionAttributesErrorKind::NotFoundError(_inner) => Some(_inner),
            GetSubscriptionAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTopicAttributesError {
    pub kind: GetTopicAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTopicAttributesErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidSecurityError(crate::error::InvalidSecurityError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTopicAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTopicAttributesErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            GetTopicAttributesErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            GetTopicAttributesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            GetTopicAttributesErrorKind::InvalidSecurityError(_inner) => _inner.fmt(f),
            GetTopicAttributesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetTopicAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTopicAttributesError {
    fn code(&self) -> Option<&str> {
        GetTopicAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTopicAttributesError {
    pub fn new(kind: GetTopicAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTopicAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTopicAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetTopicAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTopicAttributesErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            GetTopicAttributesErrorKind::InternalErrorError(_inner) => Some(_inner),
            GetTopicAttributesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            GetTopicAttributesErrorKind::InvalidSecurityError(_inner) => Some(_inner),
            GetTopicAttributesErrorKind::NotFoundError(_inner) => Some(_inner),
            GetTopicAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEndpointsByPlatformApplicationError {
    pub kind: ListEndpointsByPlatformApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEndpointsByPlatformApplicationErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEndpointsByPlatformApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEndpointsByPlatformApplicationErrorKind::AuthorizationErrorError(_inner) => {
                _inner.fmt(f)
            }
            ListEndpointsByPlatformApplicationErrorKind::InternalErrorError(_inner) => {
                _inner.fmt(f)
            }
            ListEndpointsByPlatformApplicationErrorKind::InvalidParameterError(_inner) => {
                _inner.fmt(f)
            }
            ListEndpointsByPlatformApplicationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListEndpointsByPlatformApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEndpointsByPlatformApplicationError {
    fn code(&self) -> Option<&str> {
        ListEndpointsByPlatformApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListEndpointsByPlatformApplicationError {
    pub fn new(
        kind: ListEndpointsByPlatformApplicationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEndpointsByPlatformApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEndpointsByPlatformApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListEndpointsByPlatformApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEndpointsByPlatformApplicationErrorKind::AuthorizationErrorError(_inner) => {
                Some(_inner)
            }
            ListEndpointsByPlatformApplicationErrorKind::InternalErrorError(_inner) => Some(_inner),
            ListEndpointsByPlatformApplicationErrorKind::InvalidParameterError(_inner) => {
                Some(_inner)
            }
            ListEndpointsByPlatformApplicationErrorKind::NotFoundError(_inner) => Some(_inner),
            ListEndpointsByPlatformApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPhoneNumbersOptedOutError {
    pub kind: ListPhoneNumbersOptedOutErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPhoneNumbersOptedOutErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ThrottledError(crate::error::ThrottledError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPhoneNumbersOptedOutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPhoneNumbersOptedOutErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            ListPhoneNumbersOptedOutErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            ListPhoneNumbersOptedOutErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListPhoneNumbersOptedOutErrorKind::ThrottledError(_inner) => _inner.fmt(f),
            ListPhoneNumbersOptedOutErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPhoneNumbersOptedOutError {
    fn code(&self) -> Option<&str> {
        ListPhoneNumbersOptedOutError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPhoneNumbersOptedOutError {
    pub fn new(kind: ListPhoneNumbersOptedOutErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPhoneNumbersOptedOutErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPhoneNumbersOptedOutErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListPhoneNumbersOptedOutError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPhoneNumbersOptedOutErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            ListPhoneNumbersOptedOutErrorKind::InternalErrorError(_inner) => Some(_inner),
            ListPhoneNumbersOptedOutErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListPhoneNumbersOptedOutErrorKind::ThrottledError(_inner) => Some(_inner),
            ListPhoneNumbersOptedOutErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPlatformApplicationsError {
    pub kind: ListPlatformApplicationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPlatformApplicationsErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPlatformApplicationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPlatformApplicationsErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            ListPlatformApplicationsErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            ListPlatformApplicationsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListPlatformApplicationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPlatformApplicationsError {
    fn code(&self) -> Option<&str> {
        ListPlatformApplicationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPlatformApplicationsError {
    pub fn new(kind: ListPlatformApplicationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPlatformApplicationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPlatformApplicationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListPlatformApplicationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPlatformApplicationsErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            ListPlatformApplicationsErrorKind::InternalErrorError(_inner) => Some(_inner),
            ListPlatformApplicationsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListPlatformApplicationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSubscriptionsError {
    pub kind: ListSubscriptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSubscriptionsErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSubscriptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSubscriptionsErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            ListSubscriptionsErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            ListSubscriptionsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListSubscriptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSubscriptionsError {
    fn code(&self) -> Option<&str> {
        ListSubscriptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSubscriptionsError {
    pub fn new(kind: ListSubscriptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSubscriptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSubscriptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListSubscriptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSubscriptionsErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            ListSubscriptionsErrorKind::InternalErrorError(_inner) => Some(_inner),
            ListSubscriptionsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListSubscriptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSubscriptionsByTopicError {
    pub kind: ListSubscriptionsByTopicErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSubscriptionsByTopicErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSubscriptionsByTopicError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSubscriptionsByTopicErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            ListSubscriptionsByTopicErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            ListSubscriptionsByTopicErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListSubscriptionsByTopicErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListSubscriptionsByTopicErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSubscriptionsByTopicError {
    fn code(&self) -> Option<&str> {
        ListSubscriptionsByTopicError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSubscriptionsByTopicError {
    pub fn new(kind: ListSubscriptionsByTopicErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSubscriptionsByTopicErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSubscriptionsByTopicErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListSubscriptionsByTopicError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSubscriptionsByTopicErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            ListSubscriptionsByTopicErrorKind::InternalErrorError(_inner) => Some(_inner),
            ListSubscriptionsByTopicErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListSubscriptionsByTopicErrorKind::NotFoundError(_inner) => Some(_inner),
            ListSubscriptionsByTopicErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    ConcurrentAccessError(crate::error::ConcurrentAccessError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    TagPolicyError(crate::error::TagPolicyError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ConcurrentAccessError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::TagPolicyError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ConcurrentAccessError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::TagPolicyError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTopicsError {
    pub kind: ListTopicsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTopicsErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTopicsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTopicsErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            ListTopicsErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            ListTopicsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListTopicsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTopicsError {
    fn code(&self) -> Option<&str> {
        ListTopicsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTopicsError {
    pub fn new(kind: ListTopicsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTopicsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTopicsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListTopicsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTopicsErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            ListTopicsErrorKind::InternalErrorError(_inner) => Some(_inner),
            ListTopicsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListTopicsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct OptInPhoneNumberError {
    pub kind: OptInPhoneNumberErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum OptInPhoneNumberErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ThrottledError(crate::error::ThrottledError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for OptInPhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            OptInPhoneNumberErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            OptInPhoneNumberErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            OptInPhoneNumberErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            OptInPhoneNumberErrorKind::ThrottledError(_inner) => _inner.fmt(f),
            OptInPhoneNumberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for OptInPhoneNumberError {
    fn code(&self) -> Option<&str> {
        OptInPhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl OptInPhoneNumberError {
    pub fn new(kind: OptInPhoneNumberErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: OptInPhoneNumberErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: OptInPhoneNumberErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for OptInPhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            OptInPhoneNumberErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            OptInPhoneNumberErrorKind::InternalErrorError(_inner) => Some(_inner),
            OptInPhoneNumberErrorKind::InvalidParameterError(_inner) => Some(_inner),
            OptInPhoneNumberErrorKind::ThrottledError(_inner) => Some(_inner),
            OptInPhoneNumberErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PublishError {
    pub kind: PublishErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PublishErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    EndpointDisabledError(crate::error::EndpointDisabledError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    InvalidSecurityError(crate::error::InvalidSecurityError),
    KMSAccessDeniedError(crate::error::KMSAccessDeniedError),
    KMSDisabledError(crate::error::KMSDisabledError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    KMSNotFoundError(crate::error::KMSNotFoundError),
    KMSOptInRequired(crate::error::KMSOptInRequired),
    KMSThrottlingError(crate::error::KMSThrottlingError),
    NotFoundError(crate::error::NotFoundError),
    PlatformApplicationDisabledError(crate::error::PlatformApplicationDisabledError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PublishError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PublishErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            PublishErrorKind::EndpointDisabledError(_inner) => _inner.fmt(f),
            PublishErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            PublishErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PublishErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            PublishErrorKind::InvalidSecurityError(_inner) => _inner.fmt(f),
            PublishErrorKind::KMSAccessDeniedError(_inner) => _inner.fmt(f),
            PublishErrorKind::KMSDisabledError(_inner) => _inner.fmt(f),
            PublishErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            PublishErrorKind::KMSNotFoundError(_inner) => _inner.fmt(f),
            PublishErrorKind::KMSOptInRequired(_inner) => _inner.fmt(f),
            PublishErrorKind::KMSThrottlingError(_inner) => _inner.fmt(f),
            PublishErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PublishErrorKind::PlatformApplicationDisabledError(_inner) => _inner.fmt(f),
            PublishErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PublishError {
    fn code(&self) -> Option<&str> {
        PublishError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PublishError {
    pub fn new(kind: PublishErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PublishErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PublishErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for PublishError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PublishErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            PublishErrorKind::EndpointDisabledError(_inner) => Some(_inner),
            PublishErrorKind::InternalErrorError(_inner) => Some(_inner),
            PublishErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PublishErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            PublishErrorKind::InvalidSecurityError(_inner) => Some(_inner),
            PublishErrorKind::KMSAccessDeniedError(_inner) => Some(_inner),
            PublishErrorKind::KMSDisabledError(_inner) => Some(_inner),
            PublishErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            PublishErrorKind::KMSNotFoundError(_inner) => Some(_inner),
            PublishErrorKind::KMSOptInRequired(_inner) => Some(_inner),
            PublishErrorKind::KMSThrottlingError(_inner) => Some(_inner),
            PublishErrorKind::NotFoundError(_inner) => Some(_inner),
            PublishErrorKind::PlatformApplicationDisabledError(_inner) => Some(_inner),
            PublishErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemovePermissionError {
    pub kind: RemovePermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemovePermissionErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemovePermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemovePermissionErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemovePermissionError {
    fn code(&self) -> Option<&str> {
        RemovePermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemovePermissionError {
    pub fn new(kind: RemovePermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemovePermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemovePermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for RemovePermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemovePermissionErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            RemovePermissionErrorKind::InternalErrorError(_inner) => Some(_inner),
            RemovePermissionErrorKind::InvalidParameterError(_inner) => Some(_inner),
            RemovePermissionErrorKind::NotFoundError(_inner) => Some(_inner),
            RemovePermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetEndpointAttributesError {
    pub kind: SetEndpointAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetEndpointAttributesErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetEndpointAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetEndpointAttributesErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            SetEndpointAttributesErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            SetEndpointAttributesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            SetEndpointAttributesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            SetEndpointAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetEndpointAttributesError {
    fn code(&self) -> Option<&str> {
        SetEndpointAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetEndpointAttributesError {
    pub fn new(kind: SetEndpointAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetEndpointAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetEndpointAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for SetEndpointAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetEndpointAttributesErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            SetEndpointAttributesErrorKind::InternalErrorError(_inner) => Some(_inner),
            SetEndpointAttributesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            SetEndpointAttributesErrorKind::NotFoundError(_inner) => Some(_inner),
            SetEndpointAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetPlatformApplicationAttributesError {
    pub kind: SetPlatformApplicationAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetPlatformApplicationAttributesErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetPlatformApplicationAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetPlatformApplicationAttributesErrorKind::AuthorizationErrorError(_inner) => {
                _inner.fmt(f)
            }
            SetPlatformApplicationAttributesErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            SetPlatformApplicationAttributesErrorKind::InvalidParameterError(_inner) => {
                _inner.fmt(f)
            }
            SetPlatformApplicationAttributesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            SetPlatformApplicationAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetPlatformApplicationAttributesError {
    fn code(&self) -> Option<&str> {
        SetPlatformApplicationAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetPlatformApplicationAttributesError {
    pub fn new(kind: SetPlatformApplicationAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetPlatformApplicationAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetPlatformApplicationAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for SetPlatformApplicationAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetPlatformApplicationAttributesErrorKind::AuthorizationErrorError(_inner) => {
                Some(_inner)
            }
            SetPlatformApplicationAttributesErrorKind::InternalErrorError(_inner) => Some(_inner),
            SetPlatformApplicationAttributesErrorKind::InvalidParameterError(_inner) => {
                Some(_inner)
            }
            SetPlatformApplicationAttributesErrorKind::NotFoundError(_inner) => Some(_inner),
            SetPlatformApplicationAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetSMSAttributesError {
    pub kind: SetSMSAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetSMSAttributesErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ThrottledError(crate::error::ThrottledError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetSMSAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetSMSAttributesErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            SetSMSAttributesErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            SetSMSAttributesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            SetSMSAttributesErrorKind::ThrottledError(_inner) => _inner.fmt(f),
            SetSMSAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetSMSAttributesError {
    fn code(&self) -> Option<&str> {
        SetSMSAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetSMSAttributesError {
    pub fn new(kind: SetSMSAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetSMSAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetSMSAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for SetSMSAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetSMSAttributesErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            SetSMSAttributesErrorKind::InternalErrorError(_inner) => Some(_inner),
            SetSMSAttributesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            SetSMSAttributesErrorKind::ThrottledError(_inner) => Some(_inner),
            SetSMSAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetSubscriptionAttributesError {
    pub kind: SetSubscriptionAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetSubscriptionAttributesErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    FilterPolicyLimitExceededError(crate::error::FilterPolicyLimitExceededError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetSubscriptionAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetSubscriptionAttributesErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            SetSubscriptionAttributesErrorKind::FilterPolicyLimitExceededError(_inner) => {
                _inner.fmt(f)
            }
            SetSubscriptionAttributesErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            SetSubscriptionAttributesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            SetSubscriptionAttributesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            SetSubscriptionAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetSubscriptionAttributesError {
    fn code(&self) -> Option<&str> {
        SetSubscriptionAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetSubscriptionAttributesError {
    pub fn new(kind: SetSubscriptionAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetSubscriptionAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetSubscriptionAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for SetSubscriptionAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetSubscriptionAttributesErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            SetSubscriptionAttributesErrorKind::FilterPolicyLimitExceededError(_inner) => {
                Some(_inner)
            }
            SetSubscriptionAttributesErrorKind::InternalErrorError(_inner) => Some(_inner),
            SetSubscriptionAttributesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            SetSubscriptionAttributesErrorKind::NotFoundError(_inner) => Some(_inner),
            SetSubscriptionAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetTopicAttributesError {
    pub kind: SetTopicAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetTopicAttributesErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidSecurityError(crate::error::InvalidSecurityError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetTopicAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetTopicAttributesErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            SetTopicAttributesErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            SetTopicAttributesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            SetTopicAttributesErrorKind::InvalidSecurityError(_inner) => _inner.fmt(f),
            SetTopicAttributesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            SetTopicAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetTopicAttributesError {
    fn code(&self) -> Option<&str> {
        SetTopicAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetTopicAttributesError {
    pub fn new(kind: SetTopicAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetTopicAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetTopicAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for SetTopicAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetTopicAttributesErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            SetTopicAttributesErrorKind::InternalErrorError(_inner) => Some(_inner),
            SetTopicAttributesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            SetTopicAttributesErrorKind::InvalidSecurityError(_inner) => Some(_inner),
            SetTopicAttributesErrorKind::NotFoundError(_inner) => Some(_inner),
            SetTopicAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SubscribeError {
    pub kind: SubscribeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SubscribeErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    FilterPolicyLimitExceededError(crate::error::FilterPolicyLimitExceededError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidSecurityError(crate::error::InvalidSecurityError),
    NotFoundError(crate::error::NotFoundError),
    SubscriptionLimitExceededError(crate::error::SubscriptionLimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SubscribeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SubscribeErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            SubscribeErrorKind::FilterPolicyLimitExceededError(_inner) => _inner.fmt(f),
            SubscribeErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            SubscribeErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            SubscribeErrorKind::InvalidSecurityError(_inner) => _inner.fmt(f),
            SubscribeErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            SubscribeErrorKind::SubscriptionLimitExceededError(_inner) => _inner.fmt(f),
            SubscribeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SubscribeError {
    fn code(&self) -> Option<&str> {
        SubscribeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SubscribeError {
    pub fn new(kind: SubscribeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SubscribeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SubscribeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for SubscribeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SubscribeErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            SubscribeErrorKind::FilterPolicyLimitExceededError(_inner) => Some(_inner),
            SubscribeErrorKind::InternalErrorError(_inner) => Some(_inner),
            SubscribeErrorKind::InvalidParameterError(_inner) => Some(_inner),
            SubscribeErrorKind::InvalidSecurityError(_inner) => Some(_inner),
            SubscribeErrorKind::NotFoundError(_inner) => Some(_inner),
            SubscribeErrorKind::SubscriptionLimitExceededError(_inner) => Some(_inner),
            SubscribeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    ConcurrentAccessError(crate::error::ConcurrentAccessError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    StaleTagError(crate::error::StaleTagError),
    TagLimitExceededError(crate::error::TagLimitExceededError),
    TagPolicyError(crate::error::TagPolicyError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ConcurrentAccessError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::StaleTagError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TagLimitExceededError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TagPolicyError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            TagResourceErrorKind::ConcurrentAccessError(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            TagResourceErrorKind::StaleTagError(_inner) => Some(_inner),
            TagResourceErrorKind::TagLimitExceededError(_inner) => Some(_inner),
            TagResourceErrorKind::TagPolicyError(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UnsubscribeError {
    pub kind: UnsubscribeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UnsubscribeErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    InternalErrorError(crate::error::InternalErrorError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidSecurityError(crate::error::InvalidSecurityError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UnsubscribeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UnsubscribeErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            UnsubscribeErrorKind::InternalErrorError(_inner) => _inner.fmt(f),
            UnsubscribeErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UnsubscribeErrorKind::InvalidSecurityError(_inner) => _inner.fmt(f),
            UnsubscribeErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UnsubscribeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UnsubscribeError {
    fn code(&self) -> Option<&str> {
        UnsubscribeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UnsubscribeError {
    pub fn new(kind: UnsubscribeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UnsubscribeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UnsubscribeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UnsubscribeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UnsubscribeErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            UnsubscribeErrorKind::InternalErrorError(_inner) => Some(_inner),
            UnsubscribeErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UnsubscribeErrorKind::InvalidSecurityError(_inner) => Some(_inner),
            UnsubscribeErrorKind::NotFoundError(_inner) => Some(_inner),
            UnsubscribeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    AuthorizationErrorError(crate::error::AuthorizationErrorError),
    ConcurrentAccessError(crate::error::ConcurrentAccessError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    StaleTagError(crate::error::StaleTagError),
    TagLimitExceededError(crate::error::TagLimitExceededError),
    TagPolicyError(crate::error::TagPolicyError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::AuthorizationErrorError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ConcurrentAccessError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::StaleTagError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TagLimitExceededError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TagPolicyError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::AuthorizationErrorError(_inner) => Some(_inner),
            UntagResourceErrorKind::ConcurrentAccessError(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UntagResourceErrorKind::StaleTagError(_inner) => Some(_inner),
            UntagResourceErrorKind::TagLimitExceededError(_inner) => Some(_inner),
            UntagResourceErrorKind::TagPolicyError(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The request doesn't comply with the IAM tag policy. Correct your request and then
/// retry it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagPolicyError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagPolicyError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagPolicyError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagPolicyError [TagPolicyException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagPolicyError {}
/// See [`TagPolicyError`](crate::error::TagPolicyError)
pub mod tag_policy_error {
    /// A builder for [`TagPolicyError`](crate::error::TagPolicyError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`TagPolicyError`](crate::error::TagPolicyError)
        pub fn build(self) -> crate::error::TagPolicyError {
            crate::error::TagPolicyError {
                message: self.message,
            }
        }
    }
}
impl TagPolicyError {
    /// Creates a new builder-style object to manufacture [`TagPolicyError`](crate::error::TagPolicyError)
    pub fn builder() -> crate::error::tag_policy_error::Builder {
        crate::error::tag_policy_error::Builder::default()
    }
}

/// <p>Can't add more than 50 tags to a topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagLimitExceededError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagLimitExceededError [TagLimitExceededException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagLimitExceededError {}
/// See [`TagLimitExceededError`](crate::error::TagLimitExceededError)
pub mod tag_limit_exceeded_error {
    /// A builder for [`TagLimitExceededError`](crate::error::TagLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`TagLimitExceededError`](crate::error::TagLimitExceededError)
        pub fn build(self) -> crate::error::TagLimitExceededError {
            crate::error::TagLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl TagLimitExceededError {
    /// Creates a new builder-style object to manufacture [`TagLimitExceededError`](crate::error::TagLimitExceededError)
    pub fn builder() -> crate::error::tag_limit_exceeded_error::Builder {
        crate::error::tag_limit_exceeded_error::Builder::default()
    }
}

/// <p>A tag has been added to a resource with the same ARN as a deleted resource.
/// Wait a short while and then retry the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StaleTagError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StaleTagError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StaleTagError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl StaleTagError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StaleTagError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StaleTagError [StaleTagException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for StaleTagError {}
/// See [`StaleTagError`](crate::error::StaleTagError)
pub mod stale_tag_error {
    /// A builder for [`StaleTagError`](crate::error::StaleTagError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`StaleTagError`](crate::error::StaleTagError)
        pub fn build(self) -> crate::error::StaleTagError {
            crate::error::StaleTagError {
                message: self.message,
            }
        }
    }
}
impl StaleTagError {
    /// Creates a new builder-style object to manufacture [`StaleTagError`](crate::error::StaleTagError)
    pub fn builder() -> crate::error::stale_tag_error::Builder {
        crate::error::stale_tag_error::Builder::default()
    }
}

/// <p>Can't tag resource. Verify that the topic exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundError [ResourceNotFoundException]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundError {}
/// See [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
pub mod resource_not_found_error {
    /// A builder for [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
        pub fn build(self) -> crate::error::ResourceNotFoundError {
            crate::error::ResourceNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundError {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    pub fn builder() -> crate::error::resource_not_found_error::Builder {
        crate::error::resource_not_found_error::Builder::default()
    }
}

/// <p>Indicates that a request parameter does not comply with the associated
/// constraints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterError [InvalidParameterException]")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterError {}
/// See [`InvalidParameterError`](crate::error::InvalidParameterError)
pub mod invalid_parameter_error {
    /// A builder for [`InvalidParameterError`](crate::error::InvalidParameterError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterError`](crate::error::InvalidParameterError)
        pub fn build(self) -> crate::error::InvalidParameterError {
            crate::error::InvalidParameterError {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterError {
    /// Creates a new builder-style object to manufacture [`InvalidParameterError`](crate::error::InvalidParameterError)
    pub fn builder() -> crate::error::invalid_parameter_error::Builder {
        crate::error::invalid_parameter_error::Builder::default()
    }
}

/// <p>Can't perform multiple operations on a tag simultaneously. Perform the operations
/// sequentially.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentAccessError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentAccessError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentAccessError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentAccessError [ConcurrentAccessException]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentAccessError {}
/// See [`ConcurrentAccessError`](crate::error::ConcurrentAccessError)
pub mod concurrent_access_error {
    /// A builder for [`ConcurrentAccessError`](crate::error::ConcurrentAccessError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentAccessError`](crate::error::ConcurrentAccessError)
        pub fn build(self) -> crate::error::ConcurrentAccessError {
            crate::error::ConcurrentAccessError {
                message: self.message,
            }
        }
    }
}
impl ConcurrentAccessError {
    /// Creates a new builder-style object to manufacture [`ConcurrentAccessError`](crate::error::ConcurrentAccessError)
    pub fn builder() -> crate::error::concurrent_access_error::Builder {
        crate::error::concurrent_access_error::Builder::default()
    }
}

/// <p>Indicates that the user has been denied access to the requested resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorizationErrorError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthorizationErrorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorizationErrorError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AuthorizationErrorError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationErrorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationErrorError [AuthorizationErrorException]")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationErrorError {}
/// See [`AuthorizationErrorError`](crate::error::AuthorizationErrorError)
pub mod authorization_error_error {
    /// A builder for [`AuthorizationErrorError`](crate::error::AuthorizationErrorError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationErrorError`](crate::error::AuthorizationErrorError)
        pub fn build(self) -> crate::error::AuthorizationErrorError {
            crate::error::AuthorizationErrorError {
                message: self.message,
            }
        }
    }
}
impl AuthorizationErrorError {
    /// Creates a new builder-style object to manufacture [`AuthorizationErrorError`](crate::error::AuthorizationErrorError)
    pub fn builder() -> crate::error::authorization_error_error::Builder {
        crate::error::authorization_error_error::Builder::default()
    }
}

/// <p>Indicates that the requested resource does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundError [NotFoundException]")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundError {}
/// See [`NotFoundError`](crate::error::NotFoundError)
pub mod not_found_error {
    /// A builder for [`NotFoundError`](crate::error::NotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError)
        pub fn build(self) -> crate::error::NotFoundError {
            crate::error::NotFoundError {
                message: self.message,
            }
        }
    }
}
impl NotFoundError {
    /// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError)
    pub fn builder() -> crate::error::not_found_error::Builder {
        crate::error::not_found_error::Builder::default()
    }
}

/// <p>The credential signature isn't valid. You must use an HTTPS endpoint and sign your
/// request using Signature Version 4.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSecurityError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSecurityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSecurityError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSecurityError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSecurityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSecurityError [InvalidSecurityException]")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSecurityError {}
/// See [`InvalidSecurityError`](crate::error::InvalidSecurityError)
pub mod invalid_security_error {
    /// A builder for [`InvalidSecurityError`](crate::error::InvalidSecurityError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSecurityError`](crate::error::InvalidSecurityError)
        pub fn build(self) -> crate::error::InvalidSecurityError {
            crate::error::InvalidSecurityError {
                message: self.message,
            }
        }
    }
}
impl InvalidSecurityError {
    /// Creates a new builder-style object to manufacture [`InvalidSecurityError`](crate::error::InvalidSecurityError)
    pub fn builder() -> crate::error::invalid_security_error::Builder {
        crate::error::invalid_security_error::Builder::default()
    }
}

/// <p>Indicates an internal service error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalErrorError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalErrorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalErrorError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalErrorError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalErrorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalErrorError [InternalErrorException]")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalErrorError {}
/// See [`InternalErrorError`](crate::error::InternalErrorError)
pub mod internal_error_error {
    /// A builder for [`InternalErrorError`](crate::error::InternalErrorError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InternalErrorError`](crate::error::InternalErrorError)
        pub fn build(self) -> crate::error::InternalErrorError {
            crate::error::InternalErrorError {
                message: self.message,
            }
        }
    }
}
impl InternalErrorError {
    /// Creates a new builder-style object to manufacture [`InternalErrorError`](crate::error::InternalErrorError)
    pub fn builder() -> crate::error::internal_error_error::Builder {
        crate::error::internal_error_error::Builder::default()
    }
}

/// <p>Indicates that the customer already owns the maximum allowed number of
/// subscriptions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubscriptionLimitExceededError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubscriptionLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubscriptionLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubscriptionLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SubscriptionLimitExceededError [SubscriptionLimitExceededException]"
        )?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionLimitExceededError {}
/// See [`SubscriptionLimitExceededError`](crate::error::SubscriptionLimitExceededError)
pub mod subscription_limit_exceeded_error {
    /// A builder for [`SubscriptionLimitExceededError`](crate::error::SubscriptionLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionLimitExceededError`](crate::error::SubscriptionLimitExceededError)
        pub fn build(self) -> crate::error::SubscriptionLimitExceededError {
            crate::error::SubscriptionLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl SubscriptionLimitExceededError {
    /// Creates a new builder-style object to manufacture [`SubscriptionLimitExceededError`](crate::error::SubscriptionLimitExceededError)
    pub fn builder() -> crate::error::subscription_limit_exceeded_error::Builder {
        crate::error::subscription_limit_exceeded_error::Builder::default()
    }
}

/// <p>Indicates that the number of filter polices in your AWS account exceeds the limit. To
/// add more filter polices, submit an SNS Limit Increase case in the AWS Support
/// Center.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FilterPolicyLimitExceededError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FilterPolicyLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FilterPolicyLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FilterPolicyLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FilterPolicyLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "FilterPolicyLimitExceededError [FilterPolicyLimitExceededException]"
        )?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for FilterPolicyLimitExceededError {}
/// See [`FilterPolicyLimitExceededError`](crate::error::FilterPolicyLimitExceededError)
pub mod filter_policy_limit_exceeded_error {
    /// A builder for [`FilterPolicyLimitExceededError`](crate::error::FilterPolicyLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`FilterPolicyLimitExceededError`](crate::error::FilterPolicyLimitExceededError)
        pub fn build(self) -> crate::error::FilterPolicyLimitExceededError {
            crate::error::FilterPolicyLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl FilterPolicyLimitExceededError {
    /// Creates a new builder-style object to manufacture [`FilterPolicyLimitExceededError`](crate::error::FilterPolicyLimitExceededError)
    pub fn builder() -> crate::error::filter_policy_limit_exceeded_error::Builder {
        crate::error::filter_policy_limit_exceeded_error::Builder::default()
    }
}

/// <p>Indicates that the rate at which requests have been submitted for this action exceeds
/// the limit for your account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottledError {
    /// <p>Throttled request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottledError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ThrottledError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottledError [ThrottledException]")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottledError {}
/// See [`ThrottledError`](crate::error::ThrottledError)
pub mod throttled_error {
    /// A builder for [`ThrottledError`](crate::error::ThrottledError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Throttled request.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ThrottledError`](crate::error::ThrottledError)
        pub fn build(self) -> crate::error::ThrottledError {
            crate::error::ThrottledError {
                message: self.message,
            }
        }
    }
}
impl ThrottledError {
    /// Creates a new builder-style object to manufacture [`ThrottledError`](crate::error::ThrottledError)
    pub fn builder() -> crate::error::throttled_error::Builder {
        crate::error::throttled_error::Builder::default()
    }
}

/// <p>Exception error indicating platform application disabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PlatformApplicationDisabledError {
    /// <p>Message for platform application disabled.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PlatformApplicationDisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PlatformApplicationDisabledError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PlatformApplicationDisabledError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PlatformApplicationDisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PlatformApplicationDisabledError [PlatformApplicationDisabledException]"
        )?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for PlatformApplicationDisabledError {}
/// See [`PlatformApplicationDisabledError`](crate::error::PlatformApplicationDisabledError)
pub mod platform_application_disabled_error {
    /// A builder for [`PlatformApplicationDisabledError`](crate::error::PlatformApplicationDisabledError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Message for platform application disabled.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`PlatformApplicationDisabledError`](crate::error::PlatformApplicationDisabledError)
        pub fn build(self) -> crate::error::PlatformApplicationDisabledError {
            crate::error::PlatformApplicationDisabledError {
                message: self.message,
            }
        }
    }
}
impl PlatformApplicationDisabledError {
    /// Creates a new builder-style object to manufacture [`PlatformApplicationDisabledError`](crate::error::PlatformApplicationDisabledError)
    pub fn builder() -> crate::error::platform_application_disabled_error::Builder {
        crate::error::platform_application_disabled_error::Builder::default()
    }
}

/// <p>The request was denied due to request throttling. For more information about
/// throttling, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html#requests-per-second">Limits</a> in
/// the <i>AWS Key Management Service Developer Guide.</i>
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSThrottlingError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSThrottlingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSThrottlingError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSThrottlingError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSThrottlingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSThrottlingError [KMSThrottlingException]")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSThrottlingError {}
/// See [`KMSThrottlingError`](crate::error::KMSThrottlingError)
pub mod kms_throttling_error {
    /// A builder for [`KMSThrottlingError`](crate::error::KMSThrottlingError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KMSThrottlingError`](crate::error::KMSThrottlingError)
        pub fn build(self) -> crate::error::KMSThrottlingError {
            crate::error::KMSThrottlingError {
                message: self.message,
            }
        }
    }
}
impl KMSThrottlingError {
    /// Creates a new builder-style object to manufacture [`KMSThrottlingError`](crate::error::KMSThrottlingError)
    pub fn builder() -> crate::error::kms_throttling_error::Builder {
        crate::error::kms_throttling_error::Builder::default()
    }
}

/// <p>The AWS access key ID needs a subscription for the service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSOptInRequired {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSOptInRequired {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSOptInRequired");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSOptInRequired {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSOptInRequired {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSOptInRequired")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSOptInRequired {}
/// See [`KMSOptInRequired`](crate::error::KMSOptInRequired)
pub mod kms_opt_in_required {
    /// A builder for [`KMSOptInRequired`](crate::error::KMSOptInRequired)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KMSOptInRequired`](crate::error::KMSOptInRequired)
        pub fn build(self) -> crate::error::KMSOptInRequired {
            crate::error::KMSOptInRequired {
                message: self.message,
            }
        }
    }
}
impl KMSOptInRequired {
    /// Creates a new builder-style object to manufacture [`KMSOptInRequired`](crate::error::KMSOptInRequired)
    pub fn builder() -> crate::error::kms_opt_in_required::Builder {
        crate::error::kms_opt_in_required::Builder::default()
    }
}

/// <p>The request was rejected because the specified entity or resource can't be
/// found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSNotFoundError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSNotFoundError [KMSNotFoundException]")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSNotFoundError {}
/// See [`KMSNotFoundError`](crate::error::KMSNotFoundError)
pub mod kms_not_found_error {
    /// A builder for [`KMSNotFoundError`](crate::error::KMSNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KMSNotFoundError`](crate::error::KMSNotFoundError)
        pub fn build(self) -> crate::error::KMSNotFoundError {
            crate::error::KMSNotFoundError {
                message: self.message,
            }
        }
    }
}
impl KMSNotFoundError {
    /// Creates a new builder-style object to manufacture [`KMSNotFoundError`](crate::error::KMSNotFoundError)
    pub fn builder() -> crate::error::kms_not_found_error::Builder {
        crate::error::kms_not_found_error::Builder::default()
    }
}

/// <p>The request was rejected because the state of the specified resource isn't valid for
/// this request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
/// Customer Master Key</a> in the <i>AWS Key Management Service Developer
/// Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSInvalidStateError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSInvalidStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSInvalidStateError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSInvalidStateError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSInvalidStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSInvalidStateError [KMSInvalidStateException]")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSInvalidStateError {}
/// See [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
pub mod kms_invalid_state_error {
    /// A builder for [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
        pub fn build(self) -> crate::error::KMSInvalidStateError {
            crate::error::KMSInvalidStateError {
                message: self.message,
            }
        }
    }
}
impl KMSInvalidStateError {
    /// Creates a new builder-style object to manufacture [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
    pub fn builder() -> crate::error::kms_invalid_state_error::Builder {
        crate::error::kms_invalid_state_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified customer master key (CMK) isn't
/// enabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSDisabledError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSDisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSDisabledError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSDisabledError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSDisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSDisabledError [KMSDisabledException]")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSDisabledError {}
/// See [`KMSDisabledError`](crate::error::KMSDisabledError)
pub mod kms_disabled_error {
    /// A builder for [`KMSDisabledError`](crate::error::KMSDisabledError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KMSDisabledError`](crate::error::KMSDisabledError)
        pub fn build(self) -> crate::error::KMSDisabledError {
            crate::error::KMSDisabledError {
                message: self.message,
            }
        }
    }
}
impl KMSDisabledError {
    /// Creates a new builder-style object to manufacture [`KMSDisabledError`](crate::error::KMSDisabledError)
    pub fn builder() -> crate::error::kms_disabled_error::Builder {
        crate::error::kms_disabled_error::Builder::default()
    }
}

/// <p>The ciphertext references a key that doesn't exist or that you don't have access
/// to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSAccessDeniedError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSAccessDeniedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSAccessDeniedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSAccessDeniedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSAccessDeniedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSAccessDeniedError [KMSAccessDeniedException]")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSAccessDeniedError {}
/// See [`KMSAccessDeniedError`](crate::error::KMSAccessDeniedError)
pub mod kms_access_denied_error {
    /// A builder for [`KMSAccessDeniedError`](crate::error::KMSAccessDeniedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KMSAccessDeniedError`](crate::error::KMSAccessDeniedError)
        pub fn build(self) -> crate::error::KMSAccessDeniedError {
            crate::error::KMSAccessDeniedError {
                message: self.message,
            }
        }
    }
}
impl KMSAccessDeniedError {
    /// Creates a new builder-style object to manufacture [`KMSAccessDeniedError`](crate::error::KMSAccessDeniedError)
    pub fn builder() -> crate::error::kms_access_denied_error::Builder {
        crate::error::kms_access_denied_error::Builder::default()
    }
}

/// <p>Indicates that a request parameter does not comply with the associated
/// constraints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterValueError {
    /// <p>The parameter value is invalid.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterValueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterValueError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterValueError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterValueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidParameterValueError [InvalidParameterValueException]"
        )?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterValueError {}
/// See [`InvalidParameterValueError`](crate::error::InvalidParameterValueError)
pub mod invalid_parameter_value_error {
    /// A builder for [`InvalidParameterValueError`](crate::error::InvalidParameterValueError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The parameter value is invalid.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterValueError`](crate::error::InvalidParameterValueError)
        pub fn build(self) -> crate::error::InvalidParameterValueError {
            crate::error::InvalidParameterValueError {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterValueError {
    /// Creates a new builder-style object to manufacture [`InvalidParameterValueError`](crate::error::InvalidParameterValueError)
    pub fn builder() -> crate::error::invalid_parameter_value_error::Builder {
        crate::error::invalid_parameter_value_error::Builder::default()
    }
}

/// <p>Exception error indicating endpoint disabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointDisabledError {
    /// <p>Message for endpoint disabled.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EndpointDisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointDisabledError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EndpointDisabledError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EndpointDisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EndpointDisabledError [EndpointDisabledException]")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for EndpointDisabledError {}
/// See [`EndpointDisabledError`](crate::error::EndpointDisabledError)
pub mod endpoint_disabled_error {
    /// A builder for [`EndpointDisabledError`](crate::error::EndpointDisabledError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Message for endpoint disabled.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`EndpointDisabledError`](crate::error::EndpointDisabledError)
        pub fn build(self) -> crate::error::EndpointDisabledError {
            crate::error::EndpointDisabledError {
                message: self.message,
            }
        }
    }
}
impl EndpointDisabledError {
    /// Creates a new builder-style object to manufacture [`EndpointDisabledError`](crate::error::EndpointDisabledError)
    pub fn builder() -> crate::error::endpoint_disabled_error::Builder {
        crate::error::endpoint_disabled_error::Builder::default()
    }
}

/// <p>Indicates that the customer already owns the maximum allowed number of topics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TopicLimitExceededError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TopicLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TopicLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TopicLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TopicLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TopicLimitExceededError [TopicLimitExceededException]")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for TopicLimitExceededError {}
/// See [`TopicLimitExceededError`](crate::error::TopicLimitExceededError)
pub mod topic_limit_exceeded_error {
    /// A builder for [`TopicLimitExceededError`](crate::error::TopicLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`TopicLimitExceededError`](crate::error::TopicLimitExceededError)
        pub fn build(self) -> crate::error::TopicLimitExceededError {
            crate::error::TopicLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl TopicLimitExceededError {
    /// Creates a new builder-style object to manufacture [`TopicLimitExceededError`](crate::error::TopicLimitExceededError)
    pub fn builder() -> crate::error::topic_limit_exceeded_error::Builder {
        crate::error::topic_limit_exceeded_error::Builder::default()
    }
}
