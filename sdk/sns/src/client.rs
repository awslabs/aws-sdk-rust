// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn add_permission(&self) -> fluent_builders::AddPermission<C> {
        fluent_builders::AddPermission::new(self.handle.clone())
    }
    pub fn check_if_phone_number_is_opted_out(
        &self,
    ) -> fluent_builders::CheckIfPhoneNumberIsOptedOut<C> {
        fluent_builders::CheckIfPhoneNumberIsOptedOut::new(self.handle.clone())
    }
    pub fn confirm_subscription(&self) -> fluent_builders::ConfirmSubscription<C> {
        fluent_builders::ConfirmSubscription::new(self.handle.clone())
    }
    pub fn create_platform_application(&self) -> fluent_builders::CreatePlatformApplication<C> {
        fluent_builders::CreatePlatformApplication::new(self.handle.clone())
    }
    pub fn create_platform_endpoint(&self) -> fluent_builders::CreatePlatformEndpoint<C> {
        fluent_builders::CreatePlatformEndpoint::new(self.handle.clone())
    }
    pub fn create_sms_sandbox_phone_number(
        &self,
    ) -> fluent_builders::CreateSMSSandboxPhoneNumber<C> {
        fluent_builders::CreateSMSSandboxPhoneNumber::new(self.handle.clone())
    }
    pub fn create_topic(&self) -> fluent_builders::CreateTopic<C> {
        fluent_builders::CreateTopic::new(self.handle.clone())
    }
    pub fn delete_endpoint(&self) -> fluent_builders::DeleteEndpoint<C> {
        fluent_builders::DeleteEndpoint::new(self.handle.clone())
    }
    pub fn delete_platform_application(&self) -> fluent_builders::DeletePlatformApplication<C> {
        fluent_builders::DeletePlatformApplication::new(self.handle.clone())
    }
    pub fn delete_sms_sandbox_phone_number(
        &self,
    ) -> fluent_builders::DeleteSMSSandboxPhoneNumber<C> {
        fluent_builders::DeleteSMSSandboxPhoneNumber::new(self.handle.clone())
    }
    pub fn delete_topic(&self) -> fluent_builders::DeleteTopic<C> {
        fluent_builders::DeleteTopic::new(self.handle.clone())
    }
    pub fn get_endpoint_attributes(&self) -> fluent_builders::GetEndpointAttributes<C> {
        fluent_builders::GetEndpointAttributes::new(self.handle.clone())
    }
    pub fn get_platform_application_attributes(
        &self,
    ) -> fluent_builders::GetPlatformApplicationAttributes<C> {
        fluent_builders::GetPlatformApplicationAttributes::new(self.handle.clone())
    }
    pub fn get_sms_attributes(&self) -> fluent_builders::GetSMSAttributes<C> {
        fluent_builders::GetSMSAttributes::new(self.handle.clone())
    }
    pub fn get_sms_sandbox_account_status(&self) -> fluent_builders::GetSMSSandboxAccountStatus<C> {
        fluent_builders::GetSMSSandboxAccountStatus::new(self.handle.clone())
    }
    pub fn get_subscription_attributes(&self) -> fluent_builders::GetSubscriptionAttributes<C> {
        fluent_builders::GetSubscriptionAttributes::new(self.handle.clone())
    }
    pub fn get_topic_attributes(&self) -> fluent_builders::GetTopicAttributes<C> {
        fluent_builders::GetTopicAttributes::new(self.handle.clone())
    }
    pub fn list_endpoints_by_platform_application(
        &self,
    ) -> fluent_builders::ListEndpointsByPlatformApplication<C> {
        fluent_builders::ListEndpointsByPlatformApplication::new(self.handle.clone())
    }
    pub fn list_origination_numbers(&self) -> fluent_builders::ListOriginationNumbers<C> {
        fluent_builders::ListOriginationNumbers::new(self.handle.clone())
    }
    pub fn list_phone_numbers_opted_out(&self) -> fluent_builders::ListPhoneNumbersOptedOut<C> {
        fluent_builders::ListPhoneNumbersOptedOut::new(self.handle.clone())
    }
    pub fn list_platform_applications(&self) -> fluent_builders::ListPlatformApplications<C> {
        fluent_builders::ListPlatformApplications::new(self.handle.clone())
    }
    pub fn list_sms_sandbox_phone_numbers(&self) -> fluent_builders::ListSMSSandboxPhoneNumbers<C> {
        fluent_builders::ListSMSSandboxPhoneNumbers::new(self.handle.clone())
    }
    pub fn list_subscriptions(&self) -> fluent_builders::ListSubscriptions<C> {
        fluent_builders::ListSubscriptions::new(self.handle.clone())
    }
    pub fn list_subscriptions_by_topic(&self) -> fluent_builders::ListSubscriptionsByTopic<C> {
        fluent_builders::ListSubscriptionsByTopic::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_topics(&self) -> fluent_builders::ListTopics<C> {
        fluent_builders::ListTopics::new(self.handle.clone())
    }
    pub fn opt_in_phone_number(&self) -> fluent_builders::OptInPhoneNumber<C> {
        fluent_builders::OptInPhoneNumber::new(self.handle.clone())
    }
    pub fn publish(&self) -> fluent_builders::Publish<C> {
        fluent_builders::Publish::new(self.handle.clone())
    }
    pub fn remove_permission(&self) -> fluent_builders::RemovePermission<C> {
        fluent_builders::RemovePermission::new(self.handle.clone())
    }
    pub fn set_endpoint_attributes(&self) -> fluent_builders::SetEndpointAttributes<C> {
        fluent_builders::SetEndpointAttributes::new(self.handle.clone())
    }
    pub fn set_platform_application_attributes(
        &self,
    ) -> fluent_builders::SetPlatformApplicationAttributes<C> {
        fluent_builders::SetPlatformApplicationAttributes::new(self.handle.clone())
    }
    pub fn set_sms_attributes(&self) -> fluent_builders::SetSMSAttributes<C> {
        fluent_builders::SetSMSAttributes::new(self.handle.clone())
    }
    pub fn set_subscription_attributes(&self) -> fluent_builders::SetSubscriptionAttributes<C> {
        fluent_builders::SetSubscriptionAttributes::new(self.handle.clone())
    }
    pub fn set_topic_attributes(&self) -> fluent_builders::SetTopicAttributes<C> {
        fluent_builders::SetTopicAttributes::new(self.handle.clone())
    }
    pub fn subscribe(&self) -> fluent_builders::Subscribe<C> {
        fluent_builders::Subscribe::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn unsubscribe(&self) -> fluent_builders::Unsubscribe<C> {
        fluent_builders::Unsubscribe::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn verify_sms_sandbox_phone_number(
        &self,
    ) -> fluent_builders::VerifySMSSandboxPhoneNumber<C> {
        fluent_builders::VerifySMSSandboxPhoneNumber::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddPermission<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_permission_input::Builder,
    }
    impl<C> AddPermission<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddPermissionOutput,
            smithy_http::result::SdkError<crate::error::AddPermissionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic whose access control policy you wish to modify.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_arn(input);
            self
        }
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic_arn(input);
            self
        }
        /// <p>A unique identifier for the new policy statement.</p>
        pub fn label(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.label(input);
            self
        }
        pub fn set_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_label(input);
            self
        }
        /// <p>The account IDs of the users (principals) who will be given access to the
        /// specified actions. The users must have account, but do not need to be signed up for
        /// this service.</p>
        pub fn aws_account_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.aws_account_id(inp);
            self
        }
        pub fn set_aws_account_id(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_aws_account_id(input);
            self
        }
        /// <p>The action you want to allow for the specified principal(s).</p>
        /// <p>Valid values: Any Amazon SNS action name, for example <code>Publish</code>.</p>
        pub fn action_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.action_name(inp);
            self
        }
        pub fn set_action_name(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_action_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CheckIfPhoneNumberIsOptedOut<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::check_if_phone_number_is_opted_out_input::Builder,
    }
    impl<C> CheckIfPhoneNumberIsOptedOut<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CheckIfPhoneNumberIsOptedOutOutput,
            smithy_http::result::SdkError<crate::error::CheckIfPhoneNumberIsOptedOutError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The phone number for which you want to check the opt out status.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.phone_number(input);
            self
        }
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_phone_number(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ConfirmSubscription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::confirm_subscription_input::Builder,
    }
    impl<C> ConfirmSubscription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ConfirmSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::ConfirmSubscriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic for which you wish to confirm a subscription.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_arn(input);
            self
        }
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic_arn(input);
            self
        }
        /// <p>Short-lived token sent to an endpoint during the <code>Subscribe</code> action.</p>
        pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token(input);
            self
        }
        pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_token(input);
            self
        }
        /// <p>Disallows unauthenticated unsubscribes of the subscription. If the value of this
        /// parameter is <code>true</code> and the request has an Amazon Web Services signature, then only the topic
        /// owner and the subscription owner can unsubscribe the endpoint. The unsubscribe action
        /// requires Amazon Web Services authentication. </p>
        pub fn authenticate_on_unsubscribe(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.authenticate_on_unsubscribe(input);
            self
        }
        pub fn set_authenticate_on_unsubscribe(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authenticate_on_unsubscribe(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePlatformApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_platform_application_input::Builder,
    }
    impl<C> CreatePlatformApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePlatformApplicationOutput,
            smithy_http::result::SdkError<crate::error::CreatePlatformApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Application names must be made up of only uppercase and lowercase ASCII letters,
        /// numbers, underscores, hyphens, and periods, and must be between 1 and 256 characters
        /// long.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The following platforms are supported: ADM (Amazon Device Messaging), APNS (Apple Push
        /// Notification Service), APNS_SANDBOX, and GCM (Firebase Cloud Messaging).</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.platform(input);
            self
        }
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_platform(input);
            self
        }
        /// <p>For a list of attributes, see <a href="https://docs.aws.amazon.com/sns/latest/api/API_SetPlatformApplicationAttributes.html">SetPlatformApplicationAttributes</a>.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.attributes(k, v);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePlatformEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_platform_endpoint_input::Builder,
    }
    impl<C> CreatePlatformEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePlatformEndpointOutput,
            smithy_http::result::SdkError<crate::error::CreatePlatformEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>PlatformApplicationArn returned from CreatePlatformApplication is used to create a an
        /// endpoint.</p>
        pub fn platform_application_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.platform_application_arn(input);
            self
        }
        pub fn set_platform_application_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_platform_application_arn(input);
            self
        }
        /// <p>Unique identifier created by the notification service for an app on a device. The
        /// specific name for Token will vary, depending on which notification service is being
        /// used. For example, when using APNS as the notification service, you need the device
        /// token. Alternatively, when using GCM (Firebase Cloud Messaging) or ADM, the device token
        /// equivalent is called the registration ID.</p>
        pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token(input);
            self
        }
        pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_token(input);
            self
        }
        /// <p>Arbitrary user data to associate with the endpoint. Amazon SNS does not use this data. The
        /// data must be in UTF-8 format and less than 2KB.</p>
        pub fn custom_user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.custom_user_data(input);
            self
        }
        pub fn set_custom_user_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_custom_user_data(input);
            self
        }
        /// <p>For a list of attributes, see <a href="https://docs.aws.amazon.com/sns/latest/api/API_SetEndpointAttributes.html">SetEndpointAttributes</a>.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.attributes(k, v);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSMSSandboxPhoneNumber<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_sms_sandbox_phone_number_input::Builder,
    }
    impl<C> CreateSMSSandboxPhoneNumber<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSmsSandboxPhoneNumberOutput,
            smithy_http::result::SdkError<crate::error::CreateSMSSandboxPhoneNumberError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The destination phone number to verify. On verification, Amazon SNS adds this phone number
        /// to the list of verified phone numbers that you can send SMS messages to.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.phone_number(input);
            self
        }
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_phone_number(input);
            self
        }
        /// <p>The language to use for sending the OTP. The default value is
        /// <code>en-US</code>.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCodeString) -> Self {
            self.inner = self.inner.language_code(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCodeString>,
        ) -> Self {
            self.inner = self.inner.set_language_code(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTopic<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_topic_input::Builder,
    }
    impl<C> CreateTopic<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTopicOutput,
            smithy_http::result::SdkError<crate::error::CreateTopicError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the topic you want to create.</p>
        /// <p>Constraints: Topic names must be made up of only uppercase and lowercase ASCII
        /// letters, numbers, underscores, and hyphens, and must be between 1 and 256 characters
        /// long.</p>
        /// <p>For a FIFO (first-in-first-out) topic, the name must end with the <code>.fifo</code>
        /// suffix. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A map of attributes with their corresponding values.</p>
        /// <p>The following lists the names, descriptions, and values of the special request
        /// parameters that the <code>CreateTopic</code> action uses:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DeliveryPolicy</code> – The policy that defines how Amazon SNS retries
        /// failed deliveries to HTTP/S endpoints.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DisplayName</code> – The display name to use for a topic with SMS
        /// subscriptions.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FifoTopic</code> – Set to true to create a FIFO topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Policy</code> – The policy that defines who can access your
        /// topic. By default, only the topic owner can publish or subscribe to the
        /// topic.</p>
        /// </li>
        /// </ul>
        /// <p>The following attribute applies only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html">server-side
        /// encryption</a>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>KmsMasterKeyId</code> – The ID of an Amazon Web Services managed customer master
        /// key (CMK) for Amazon SNS or a custom CMK. For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms">Key
        /// Terms</a>. For more examples, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters">KeyId</a> in the <i>Key Management Service API
        /// Reference</i>. </p>
        /// </li>
        /// </ul>
        /// <p>The following attributes apply only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html">FIFO topics</a>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>FifoTopic</code> – When this is set to <code>true</code>, a FIFO
        /// topic is created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ContentBasedDeduplication</code> – Enables content-based deduplication for
        /// FIFO topics.</p>
        /// <ul>
        /// <li>
        /// <p>By default, <code>ContentBasedDeduplication</code> is set to <code>false</code>.
        /// If you create a FIFO topic and this attribute is <code>false</code>, you must
        /// specify a value for the <code>MessageDeduplicationId</code> parameter for the
        /// <a href="https://docs.aws.amazon.com/sns/latest/api/API_Publish.html">Publish</a> action. </p>
        /// </li>
        /// <li>
        /// <p>When you set <code>ContentBasedDeduplication</code> to <code>true</code>,
        /// Amazon SNS uses a SHA-256 hash to generate the <code>MessageDeduplicationId</code> using
        /// the body of the message (but not the attributes of the message).</p>
        /// <p>(Optional) To override the generated value, you can specify a value
        /// for the <code>MessageDeduplicationId</code> parameter for the <code>Publish</code>
        /// action.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.attributes(k, v);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
        /// <p>The list of tags to add to a new topic.</p>
        /// <note>
        /// <p>To be able to tag a topic on creation, you must have the
        /// <code>sns:CreateTopic</code> and <code>sns:TagResource</code>
        /// permissions.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_endpoint_input::Builder,
    }
    impl<C> DeleteEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteEndpointOutput,
            smithy_http::result::SdkError<crate::error::DeleteEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>EndpointArn of endpoint to delete.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_arn(input);
            self
        }
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_endpoint_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePlatformApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_platform_application_input::Builder,
    }
    impl<C> DeletePlatformApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePlatformApplicationOutput,
            smithy_http::result::SdkError<crate::error::DeletePlatformApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>PlatformApplicationArn of platform application object to delete.</p>
        pub fn platform_application_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.platform_application_arn(input);
            self
        }
        pub fn set_platform_application_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_platform_application_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSMSSandboxPhoneNumber<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_sms_sandbox_phone_number_input::Builder,
    }
    impl<C> DeleteSMSSandboxPhoneNumber<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSmsSandboxPhoneNumberOutput,
            smithy_http::result::SdkError<crate::error::DeleteSMSSandboxPhoneNumberError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The destination phone number to delete.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.phone_number(input);
            self
        }
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_phone_number(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTopic<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_topic_input::Builder,
    }
    impl<C> DeleteTopic<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTopicOutput,
            smithy_http::result::SdkError<crate::error::DeleteTopicError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic you want to delete.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_arn(input);
            self
        }
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetEndpointAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_endpoint_attributes_input::Builder,
    }
    impl<C> GetEndpointAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetEndpointAttributesOutput,
            smithy_http::result::SdkError<crate::error::GetEndpointAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>EndpointArn for GetEndpointAttributes input.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_arn(input);
            self
        }
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_endpoint_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPlatformApplicationAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_platform_application_attributes_input::Builder,
    }
    impl<C> GetPlatformApplicationAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPlatformApplicationAttributesOutput,
            smithy_http::result::SdkError<crate::error::GetPlatformApplicationAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>PlatformApplicationArn for GetPlatformApplicationAttributesInput.</p>
        pub fn platform_application_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.platform_application_arn(input);
            self
        }
        pub fn set_platform_application_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_platform_application_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSMSAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_sms_attributes_input::Builder,
    }
    impl<C> GetSMSAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSmsAttributesOutput,
            smithy_http::result::SdkError<crate::error::GetSMSAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of the individual attribute names, such as <code>MonthlySpendLimit</code>, for
        /// which you want values.</p>
        /// <p>For all attribute names, see <a href="https://docs.aws.amazon.com/sns/latest/api/API_SetSMSAttributes.html">SetSMSAttributes</a>.</p>
        /// <p>If you don't use this parameter, Amazon SNS returns all SMS attributes.</p>
        pub fn attributes(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.attributes(inp);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSMSSandboxAccountStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_sms_sandbox_account_status_input::Builder,
    }
    impl<C> GetSMSSandboxAccountStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSmsSandboxAccountStatusOutput,
            smithy_http::result::SdkError<crate::error::GetSMSSandboxAccountStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSubscriptionAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_subscription_attributes_input::Builder,
    }
    impl<C> GetSubscriptionAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSubscriptionAttributesOutput,
            smithy_http::result::SdkError<crate::error::GetSubscriptionAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the subscription whose properties you want to get.</p>
        pub fn subscription_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subscription_arn(input);
            self
        }
        pub fn set_subscription_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subscription_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTopicAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_topic_attributes_input::Builder,
    }
    impl<C> GetTopicAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTopicAttributesOutput,
            smithy_http::result::SdkError<crate::error::GetTopicAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic whose properties you want to get.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_arn(input);
            self
        }
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListEndpointsByPlatformApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_endpoints_by_platform_application_input::Builder,
    }
    impl<C> ListEndpointsByPlatformApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListEndpointsByPlatformApplicationOutput,
            smithy_http::result::SdkError<crate::error::ListEndpointsByPlatformApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>PlatformApplicationArn for ListEndpointsByPlatformApplicationInput action.</p>
        pub fn platform_application_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.platform_application_arn(input);
            self
        }
        pub fn set_platform_application_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_platform_application_arn(input);
            self
        }
        /// <p>NextToken string is used when calling ListEndpointsByPlatformApplication action to
        /// retrieve additional records that are available after the first page results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOriginationNumbers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_origination_numbers_input::Builder,
    }
    impl<C> ListOriginationNumbers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOriginationNumbersOutput,
            smithy_http::result::SdkError<crate::error::ListOriginationNumbersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Token that the previous <code>ListOriginationNumbers</code> request returns.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of origination numbers to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPhoneNumbersOptedOut<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_phone_numbers_opted_out_input::Builder,
    }
    impl<C> ListPhoneNumbersOptedOut<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPhoneNumbersOptedOutOutput,
            smithy_http::result::SdkError<crate::error::ListPhoneNumbersOptedOutError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A <code>NextToken</code> string is used when you call the
        /// <code>ListPhoneNumbersOptedOut</code> action to retrieve additional records that are
        /// available after the first page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPlatformApplications<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_platform_applications_input::Builder,
    }
    impl<C> ListPlatformApplications<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPlatformApplicationsOutput,
            smithy_http::result::SdkError<crate::error::ListPlatformApplicationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>NextToken string is used when calling ListPlatformApplications action to retrieve
        /// additional records that are available after the first page results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSMSSandboxPhoneNumbers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_sms_sandbox_phone_numbers_input::Builder,
    }
    impl<C> ListSMSSandboxPhoneNumbers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSmsSandboxPhoneNumbersOutput,
            smithy_http::result::SdkError<crate::error::ListSMSSandboxPhoneNumbersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Token that the previous <code>ListSMSSandboxPhoneNumbersInput</code> request
        /// returns.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of phone numbers to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSubscriptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_subscriptions_input::Builder,
    }
    impl<C> ListSubscriptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSubscriptionsOutput,
            smithy_http::result::SdkError<crate::error::ListSubscriptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Token returned by the previous <code>ListSubscriptions</code> request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSubscriptionsByTopic<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_subscriptions_by_topic_input::Builder,
    }
    impl<C> ListSubscriptionsByTopic<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSubscriptionsByTopicOutput,
            smithy_http::result::SdkError<crate::error::ListSubscriptionsByTopicError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic for which you wish to find subscriptions.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_arn(input);
            self
        }
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic_arn(input);
            self
        }
        /// <p>Token returned by the previous <code>ListSubscriptionsByTopic</code> request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic for which to list tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTopics<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_topics_input::Builder,
    }
    impl<C> ListTopics<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTopicsOutput,
            smithy_http::result::SdkError<crate::error::ListTopicsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Token returned by the previous <code>ListTopics</code> request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct OptInPhoneNumber<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::opt_in_phone_number_input::Builder,
    }
    impl<C> OptInPhoneNumber<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::OptInPhoneNumberOutput,
            smithy_http::result::SdkError<crate::error::OptInPhoneNumberError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The phone number to opt in. Use E.164 format.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.phone_number(input);
            self
        }
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_phone_number(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct Publish<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::publish_input::Builder,
    }
    impl<C> Publish<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PublishOutput,
            smithy_http::result::SdkError<crate::error::PublishError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The topic you want to publish to.</p>
        /// <p>If you don't specify a value for the <code>TopicArn</code> parameter, you must specify
        /// a value for the <code>PhoneNumber</code> or <code>TargetArn</code> parameters.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_arn(input);
            self
        }
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic_arn(input);
            self
        }
        /// <p>If you don't specify a value for the <code>TargetArn</code> parameter, you must
        /// specify a value for the <code>PhoneNumber</code> or <code>TopicArn</code>
        /// parameters.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_arn(input);
            self
        }
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_arn(input);
            self
        }
        /// <p>The phone number to which you want to deliver an SMS message. Use E.164 format.</p>
        /// <p>If you don't specify a value for the <code>PhoneNumber</code> parameter, you must
        /// specify a value for the <code>TargetArn</code> or <code>TopicArn</code>
        /// parameters.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.phone_number(input);
            self
        }
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_phone_number(input);
            self
        }
        /// <p>The message you want to send.</p>
        /// <p>If you are publishing to a topic and you want to send the same message to all
        /// transport protocols, include the text of the message as a String value. If you want to
        /// send different messages for each transport protocol, set the value of the
        /// <code>MessageStructure</code> parameter to <code>json</code> and use a JSON object
        /// for the <code>Message</code> parameter.
        /// </p>
        /// <p></p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>With the exception of SMS, messages must be UTF-8 encoded strings and at most
        /// 256 KB in size (262,144 bytes, not 262,144 characters).</p>
        /// </li>
        /// <li>
        /// <p>For SMS, each message can contain up to 140 characters. This character limit
        /// depends on the encoding schema. For example, an SMS message can contain 160 GSM
        /// characters, 140 ASCII characters, or 70 UCS-2 characters.</p>
        /// <p>If you publish a message that exceeds this size limit, Amazon SNS sends the message
        /// as multiple messages, each fitting within the size limit. Messages aren't
        /// truncated mid-word but are cut off at whole-word boundaries.</p>
        /// <p>The total size limit for a single SMS <code>Publish</code> action is 1,600
        /// characters.</p>
        /// </li>
        /// </ul>
        /// <p>JSON-specific constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Keys in the JSON object that correspond to supported transport protocols must
        /// have simple JSON string values.</p>
        /// </li>
        /// <li>
        /// <p>The values will be parsed (unescaped) before they are used in outgoing
        /// messages.</p>
        /// </li>
        /// <li>
        /// <p>Outbound notifications are JSON encoded (meaning that the characters will be
        /// reescaped for sending).</p>
        /// </li>
        /// <li>
        /// <p>Values have a minimum length of 0 (the empty string, "", is allowed).</p>
        /// </li>
        /// <li>
        /// <p>Values have a maximum length bounded by the overall message size (so,
        /// including multiple protocols may limit message sizes).</p>
        /// </li>
        /// <li>
        /// <p>Non-string values will cause the key to be ignored.</p>
        /// </li>
        /// <li>
        /// <p>Keys that do not correspond to supported transport protocols are
        /// ignored.</p>
        /// </li>
        /// <li>
        /// <p>Duplicate keys are not allowed.</p>
        /// </li>
        /// <li>
        /// <p>Failure to parse or validate any key or value in the message will cause the
        /// <code>Publish</code> call to return an error (no partial delivery).</p>
        /// </li>
        /// </ul>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.message(input);
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_message(input);
            self
        }
        /// <p>Optional parameter to be used as the "Subject" line when the message is delivered to
        /// email endpoints. This field will also be included, if present, in the standard JSON
        /// messages delivered to other endpoints.</p>
        /// <p>Constraints: Subjects must be ASCII text that begins with a letter, number, or
        /// punctuation mark; must not include line breaks or control characters; and must be less
        /// than 100 characters long.</p>
        pub fn subject(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subject(input);
            self
        }
        pub fn set_subject(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subject(input);
            self
        }
        /// <p>Set <code>MessageStructure</code> to <code>json</code> if you want to send a different
        /// message for each protocol. For example, using one publish action, you can send a short
        /// message to your SMS subscribers and a longer message to your email subscribers. If you
        /// set <code>MessageStructure</code> to <code>json</code>, the value of the
        /// <code>Message</code> parameter must: </p>
        /// <ul>
        /// <li>
        /// <p>be a syntactically valid JSON object; and</p>
        /// </li>
        /// <li>
        /// <p>contain at least a top-level JSON key of "default" with a value that is a
        /// string.</p>
        /// </li>
        /// </ul>
        /// <p>You can define other top-level keys that define the message you want to send to a
        /// specific transport protocol (e.g., "http").</p>
        /// <p>Valid value: <code>json</code>
        /// </p>
        pub fn message_structure(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.message_structure(input);
            self
        }
        pub fn set_message_structure(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_message_structure(input);
            self
        }
        /// <p>Message attributes for Publish action.</p>
        pub fn message_attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::MessageAttributeValue>,
        ) -> Self {
            self.inner = self.inner.message_attributes(k, v);
            self
        }
        pub fn set_message_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::MessageAttributeValue>,
            >,
        ) -> Self {
            self.inner = self.inner.set_message_attributes(input);
            self
        }
        /// <p>This parameter applies only to FIFO (first-in-first-out) topics. The
        /// <code>MessageDeduplicationId</code> can contain up to 128 alphanumeric characters
        /// (a-z, A-Z, 0-9) and punctuation
        /// <code>(!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~)</code>.</p>
        /// <p>Every message must have a unique <code>MessageDeduplicationId</code>, which is a token
        /// used for deduplication of sent messages. If a message with a particular
        /// <code>MessageDeduplicationId</code> is sent successfully, any message sent with the
        /// same <code>MessageDeduplicationId</code> during the 5-minute deduplication interval is
        /// treated as a duplicate. </p>
        /// <p>If the topic has <code>ContentBasedDeduplication</code> set, the system generates a
        /// <code>MessageDeduplicationId</code> based on the contents of the message. Your
        /// <code>MessageDeduplicationId</code> overrides the generated one.</p>
        pub fn message_deduplication_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.message_deduplication_id(input);
            self
        }
        pub fn set_message_deduplication_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_message_deduplication_id(input);
            self
        }
        /// <p>This parameter applies only to FIFO (first-in-first-out) topics. The
        /// <code>MessageGroupId</code> can contain up to 128 alphanumeric characters (a-z, A-Z,
        /// 0-9) and punctuation <code>(!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~)</code>.</p>
        /// <p>The <code>MessageGroupId</code> is a tag that specifies that a message belongs to a
        /// specific message group. Messages that belong to the same message group are processed in
        /// a FIFO manner (however, messages in different message groups might be processed out of
        /// order). Every message must include a <code>MessageGroupId</code>.</p>
        pub fn message_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.message_group_id(input);
            self
        }
        pub fn set_message_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_message_group_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemovePermission<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_permission_input::Builder,
    }
    impl<C> RemovePermission<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemovePermissionOutput,
            smithy_http::result::SdkError<crate::error::RemovePermissionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic whose access control policy you wish to modify.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_arn(input);
            self
        }
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic_arn(input);
            self
        }
        /// <p>The unique label of the statement you want to remove.</p>
        pub fn label(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.label(input);
            self
        }
        pub fn set_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_label(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetEndpointAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_endpoint_attributes_input::Builder,
    }
    impl<C> SetEndpointAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetEndpointAttributesOutput,
            smithy_http::result::SdkError<crate::error::SetEndpointAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>EndpointArn used for SetEndpointAttributes action.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_arn(input);
            self
        }
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_endpoint_arn(input);
            self
        }
        /// <p>A map of the endpoint attributes. Attributes in this map include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CustomUserData</code> – arbitrary user data to associate with the
        /// endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and
        /// less than 2KB.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Enabled</code> – flag that enables/disables delivery to the
        /// endpoint. Amazon SNS will set this to false when a notification service indicates to
        /// Amazon SNS that the endpoint is invalid. Users can set it back to true, typically
        /// after updating Token.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Token</code> – device token, also referred to as a registration id,
        /// for an app and mobile device. This is returned from the notification service
        /// when an app and mobile device are registered with the notification
        /// service.</p>
        /// </li>
        /// </ul>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.attributes(k, v);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetPlatformApplicationAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_platform_application_attributes_input::Builder,
    }
    impl<C> SetPlatformApplicationAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetPlatformApplicationAttributesOutput,
            smithy_http::result::SdkError<crate::error::SetPlatformApplicationAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>PlatformApplicationArn for SetPlatformApplicationAttributes action.</p>
        pub fn platform_application_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.platform_application_arn(input);
            self
        }
        pub fn set_platform_application_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_platform_application_arn(input);
            self
        }
        /// <p>A map of the platform application attributes. Attributes in this map include the
        /// following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>PlatformCredential</code> – The credential received from the
        /// notification service. For <code>APNS</code> and <code>APNS_SANDBOX</code>,
        /// <code>PlatformCredential</code> is <code>private key</code>. For
        /// <code>GCM</code> (Firebase Cloud Messaging), <code>PlatformCredential</code>
        /// is <code>API key</code>. For <code>ADM</code>, <code>PlatformCredential</code>
        /// is <code>client secret</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PlatformPrincipal</code> – The principal received from the
        /// notification service. For <code>APNS</code> and <code>APNS_SANDBOX</code>,
        /// <code>PlatformPrincipal</code> is <code>SSL certificate</code>. For
        /// <code>GCM</code> (Firebase Cloud Messaging), there is no
        /// <code>PlatformPrincipal</code>. For <code>ADM</code>,
        /// <code>PlatformPrincipal</code> is <code>client id</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EventEndpointCreated</code> – Topic ARN to which
        /// <code>EndpointCreated</code> event notifications are sent.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EventEndpointDeleted</code> – Topic ARN to which
        /// <code>EndpointDeleted</code> event notifications are sent.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EventEndpointUpdated</code> – Topic ARN to which
        /// <code>EndpointUpdate</code> event notifications are sent.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EventDeliveryFailure</code> – Topic ARN to which
        /// <code>DeliveryFailure</code> event notifications are sent upon Direct
        /// Publish delivery failure (permanent) to one of the application's
        /// endpoints.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SuccessFeedbackRoleArn</code> – IAM role ARN used to give Amazon SNS
        /// write access to use CloudWatch Logs on your behalf.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FailureFeedbackRoleArn</code> – IAM role ARN used to give Amazon SNS
        /// write access to use CloudWatch Logs on your behalf.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SuccessFeedbackSampleRate</code> – Sample rate percentage (0-100)
        /// of successfully delivered messages.</p>
        /// </li>
        /// </ul>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.attributes(k, v);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetSMSAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_sms_attributes_input::Builder,
    }
    impl<C> SetSMSAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetSmsAttributesOutput,
            smithy_http::result::SdkError<crate::error::SetSMSAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The default settings for sending SMS messages from your account. You can set values
        /// for the following attribute names:</p>
        /// <p>
        /// <code>MonthlySpendLimit</code> – The maximum amount in USD that you are willing to spend
        /// each month to send SMS messages. When Amazon SNS determines that sending an SMS message would
        /// incur a cost that exceeds this limit, it stops sending SMS messages within
        /// minutes.</p>
        /// <important>
        /// <p>Amazon SNS stops sending SMS messages within minutes of the limit being crossed. During
        /// that interval, if you continue to send SMS messages, you will incur costs that
        /// exceed your limit.</p>
        /// </important>
        /// <p>By default, the spend limit is set to the maximum allowed by Amazon SNS. If you want to
        /// raise the limit, submit an <a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-sns">SNS Limit Increase case</a>. For <b>New limit
        /// value</b>, enter your desired monthly spend limit. In the <b>Use Case Description</b> field, explain that you are requesting
        /// an SMS monthly spend limit increase.</p>
        /// <p>
        /// <code>DeliveryStatusIAMRole</code> – The ARN of the IAM role that allows Amazon SNS to write
        /// logs about SMS deliveries in CloudWatch Logs. For each SMS message that you send, Amazon SNS
        /// writes a log that includes the message price, the success or failure status, the reason
        /// for failure (if the message failed), the message dwell time, and other
        /// information.</p>
        /// <p>
        /// <code>DeliveryStatusSuccessSamplingRate</code> – The percentage of successful SMS
        /// deliveries for which Amazon SNS will write logs in CloudWatch Logs. The value can be an
        /// integer from 0 - 100. For example, to write logs only for failed deliveries, set this
        /// value to <code>0</code>. To write logs for 10% of your successful deliveries, set it to
        /// <code>10</code>.</p>
        /// <p>
        /// <code>DefaultSenderID</code> – A string, such as your business brand, that is displayed
        /// as the sender on the receiving device. Support for sender IDs varies by country. The
        /// sender ID can be 1 - 11 alphanumeric characters, and it must contain at least one
        /// letter.</p>
        /// <p>
        /// <code>DefaultSMSType</code> – The type of SMS message that you will send by default. You
        /// can assign the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Promotional</code> – (Default) Noncritical messages, such as marketing
        /// messages. Amazon SNS optimizes the message delivery to incur the lowest cost.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Transactional</code> – Critical messages that support customer
        /// transactions, such as one-time passcodes for multi-factor authentication. Amazon
        /// SNS optimizes the message delivery to achieve the highest reliability.</p>
        /// </li>
        /// </ul>
        /// <p>
        /// <code>UsageReportS3Bucket</code> – The name of the Amazon S3 bucket to receive daily SMS
        /// usage reports from Amazon SNS. Each day, Amazon SNS will deliver a usage report as a CSV file to
        /// the bucket. The report includes the following information for each SMS message that was
        /// successfully delivered by your account:</p>
        /// <ul>
        /// <li>
        /// <p>Time that the message was published (in UTC)</p>
        /// </li>
        /// <li>
        /// <p>Message ID</p>
        /// </li>
        /// <li>
        /// <p>Destination phone number</p>
        /// </li>
        /// <li>
        /// <p>Message type</p>
        /// </li>
        /// <li>
        /// <p>Delivery status</p>
        /// </li>
        /// <li>
        /// <p>Message price (in USD)</p>
        /// </li>
        /// <li>
        /// <p>Part number (a message is split into multiple parts if it is too long for a
        /// single message)</p>
        /// </li>
        /// <li>
        /// <p>Total number of parts</p>
        /// </li>
        /// </ul>
        /// <p>To receive the report, the bucket must have a policy that allows the Amazon SNS service
        /// principal to perform the <code>s3:PutObject</code> and <code>s3:GetBucketLocation</code>
        /// actions.</p>
        /// <p>For an example bucket policy and usage report, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sms_stats.html">Monitoring SMS Activity</a> in the
        /// <i>Amazon SNS Developer Guide</i>.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.attributes(k, v);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetSubscriptionAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_subscription_attributes_input::Builder,
    }
    impl<C> SetSubscriptionAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetSubscriptionAttributesOutput,
            smithy_http::result::SdkError<crate::error::SetSubscriptionAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the subscription to modify.</p>
        pub fn subscription_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subscription_arn(input);
            self
        }
        pub fn set_subscription_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subscription_arn(input);
            self
        }
        /// <p>A map of attributes with their corresponding values.</p>
        /// <p>The following lists the names, descriptions, and values of the special request
        /// parameters that this action uses:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DeliveryPolicy</code> – The policy that defines how Amazon SNS retries
        /// failed deliveries to HTTP/S endpoints.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FilterPolicy</code> – The simple JSON object that lets your
        /// subscriber receive only a subset of messages, rather than receiving every
        /// message published to the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RawMessageDelivery</code> – When set to <code>true</code>,
        /// enables raw message delivery to Amazon SQS or HTTP/S endpoints. This eliminates the
        /// need for the endpoints to process JSON formatting, which is otherwise created
        /// for Amazon SNS metadata.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RedrivePolicy</code> – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue.
        /// Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable)
        /// or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held
        /// in the dead-letter queue for further analysis or reprocessing.</p>
        /// </li>
        /// </ul>
        /// <p>The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SubscriptionRoleArn</code> – The ARN of the IAM role that has the following:</p>
        /// <ul>
        /// <li>
        /// <p>Permission to write to the Kinesis Data Firehose delivery stream</p>
        /// </li>
        /// <li>
        /// <p>Amazon SNS listed as a trusted entity</p>
        /// </li>
        /// </ul>
        /// <p>Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions.
        /// For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html">Fanout
        /// to Kinesis Data Firehose delivery streams</a> in the <i>Amazon SNS Developer Guide</i>.</p>
        /// </li>
        /// </ul>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.attribute_name(input);
            self
        }
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_attribute_name(input);
            self
        }
        /// <p>The new value for the attribute in JSON format.</p>
        pub fn attribute_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.attribute_value(input);
            self
        }
        pub fn set_attribute_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_attribute_value(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetTopicAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_topic_attributes_input::Builder,
    }
    impl<C> SetTopicAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetTopicAttributesOutput,
            smithy_http::result::SdkError<crate::error::SetTopicAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic to modify.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_arn(input);
            self
        }
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic_arn(input);
            self
        }
        /// <p>A map of attributes with their corresponding values.</p>
        /// <p>The following lists the names, descriptions, and values of the special request
        /// parameters that the <code>SetTopicAttributes</code> action uses:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DeliveryPolicy</code> – The policy that defines how Amazon SNS retries
        /// failed deliveries to HTTP/S endpoints.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DisplayName</code> – The display name to use for a topic with SMS
        /// subscriptions.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Policy</code> – The policy that defines who can access your
        /// topic. By default, only the topic owner can publish or subscribe to the
        /// topic.</p>
        /// </li>
        /// </ul>
        /// <p>The following attribute applies only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html">server-side-encryption</a>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>KmsMasterKeyId</code> – The ID of an Amazon Web Services managed customer master
        /// key (CMK) for Amazon SNS or a custom CMK. For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms">Key
        /// Terms</a>. For more examples, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters">KeyId</a> in the <i>Key Management Service API
        /// Reference</i>. </p>
        /// </li>
        /// </ul>
        /// <p>The following attribute applies only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html">FIFO topics</a>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ContentBasedDeduplication</code> – Enables content-based deduplication for
        /// FIFO topics.</p>
        /// <ul>
        /// <li>
        /// <p>By default, <code>ContentBasedDeduplication</code> is set to <code>false</code>.
        /// If you create a FIFO topic and this attribute is <code>false</code>, you must
        /// specify a value for the <code>MessageDeduplicationId</code> parameter for the
        /// <a href="https://docs.aws.amazon.com/sns/latest/api/API_Publish.html">Publish</a> action. </p>
        /// </li>
        /// <li>
        /// <p>When you set <code>ContentBasedDeduplication</code> to <code>true</code>,
        /// Amazon SNS uses a SHA-256 hash to generate the <code>MessageDeduplicationId</code> using
        /// the body of the message (but not the attributes of the message).</p>
        /// <p>(Optional) To override the generated value, you can specify a value
        /// for the <code>MessageDeduplicationId</code> parameter for the <code>Publish</code>
        /// action.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.attribute_name(input);
            self
        }
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_attribute_name(input);
            self
        }
        /// <p>The new value for the attribute.</p>
        pub fn attribute_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.attribute_value(input);
            self
        }
        pub fn set_attribute_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_attribute_value(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct Subscribe<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::subscribe_input::Builder,
    }
    impl<C> Subscribe<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SubscribeOutput,
            smithy_http::result::SdkError<crate::error::SubscribeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic you want to subscribe to.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_arn(input);
            self
        }
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic_arn(input);
            self
        }
        /// <p>The protocol that you want to use. Supported protocols include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>http</code> – delivery of JSON-encoded message via HTTP
        /// POST</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>https</code> – delivery of JSON-encoded message via HTTPS
        /// POST</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>email</code> – delivery of message via SMTP</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>email-json</code> – delivery of JSON-encoded message via
        /// SMTP</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sms</code> – delivery of message via SMS</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sqs</code> – delivery of JSON-encoded message to an Amazon SQS
        /// queue</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>application</code> – delivery of JSON-encoded message to an
        /// EndpointArn for a mobile app and device</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lambda</code> – delivery of JSON-encoded message to an Lambda
        /// function</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>firehose</code> – delivery of JSON-encoded message to an Amazon
        /// Kinesis Data Firehose delivery stream.</p>
        /// </li>
        /// </ul>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// <p>The endpoint that you want to receive notifications. Endpoints vary by
        /// protocol:</p>
        /// <ul>
        /// <li>
        /// <p>For the <code>http</code> protocol, the (public) endpoint is a URL beginning
        /// with <code>http://</code>.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>https</code> protocol, the (public) endpoint is a URL beginning
        /// with <code>https://</code>.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>email</code> protocol, the endpoint is an email address.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>email-json</code> protocol, the endpoint is an email
        /// address.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>sms</code> protocol, the endpoint is a phone number of an
        /// SMS-enabled device.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>sqs</code> protocol, the endpoint is the ARN of an Amazon SQS
        /// queue.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>application</code> protocol, the endpoint is the EndpointArn of
        /// a mobile app and device.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>lambda</code> protocol, the endpoint is the ARN of an Lambda
        /// function.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>firehose</code> protocol, the endpoint is the ARN of an Amazon
        /// Kinesis Data Firehose delivery stream.</p>
        /// </li>
        /// </ul>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint(input);
            self
        }
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_endpoint(input);
            self
        }
        /// <p>A map of attributes with their corresponding values.</p>
        /// <p>The following lists the names, descriptions, and values of the special request
        /// parameters that the <code>Subscribe</code> action uses:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DeliveryPolicy</code> – The policy that defines how Amazon SNS retries
        /// failed deliveries to HTTP/S endpoints.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FilterPolicy</code> – The simple JSON object that lets your
        /// subscriber receive only a subset of messages, rather than receiving every
        /// message published to the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RawMessageDelivery</code> – When set to <code>true</code>,
        /// enables raw message delivery to Amazon SQS or HTTP/S endpoints. This eliminates the
        /// need for the endpoints to process JSON formatting, which is otherwise created
        /// for Amazon SNS metadata.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RedrivePolicy</code> – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue.
        /// Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable)
        /// or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held
        /// in the dead-letter queue for further analysis or reprocessing.</p>
        /// </li>
        /// </ul>
        /// <p>The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SubscriptionRoleArn</code> – The ARN of the IAM role that has the following:</p>
        /// <ul>
        /// <li>
        /// <p>Permission to write to the Kinesis Data Firehose delivery stream</p>
        /// </li>
        /// <li>
        /// <p>Amazon SNS listed as a trusted entity</p>
        /// </li>
        /// </ul>
        /// <p>Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions.
        /// For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html">Fanout
        /// to Kinesis Data Firehose delivery streams</a> in the <i>Amazon SNS Developer Guide</i>.</p>
        /// </li>
        /// </ul>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.attributes(k, v);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
        /// <p>Sets whether the response from the <code>Subscribe</code> request includes the
        /// subscription ARN, even if the subscription is not yet confirmed.</p>
        /// <p>If you set this parameter to <code>true</code>, the response includes the ARN in all
        /// cases, even if the subscription is not yet confirmed. In addition to the ARN for
        /// confirmed subscriptions, the response also includes the <code>pending
        /// subscription</code> ARN value for subscriptions that aren't yet confirmed. A
        /// subscription becomes confirmed when the subscriber calls the
        /// <code>ConfirmSubscription</code> action with a confirmation token.</p>
        /// <p></p>
        /// <p>The default value is <code>false</code>.</p>
        pub fn return_subscription_arn(mut self, input: bool) -> Self {
            self.inner = self.inner.return_subscription_arn(input);
            self
        }
        pub fn set_return_subscription_arn(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_return_subscription_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic to which to add tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tags to be added to the specified topic. A tag consists of a required key and an
        /// optional value.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct Unsubscribe<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::unsubscribe_input::Builder,
    }
    impl<C> Unsubscribe<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UnsubscribeOutput,
            smithy_http::result::SdkError<crate::error::UnsubscribeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the subscription to be deleted.</p>
        pub fn subscription_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subscription_arn(input);
            self
        }
        pub fn set_subscription_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subscription_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic from which to remove tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The list of tag keys to remove from the specified topic.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct VerifySMSSandboxPhoneNumber<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::verify_sms_sandbox_phone_number_input::Builder,
    }
    impl<C> VerifySMSSandboxPhoneNumber<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::VerifySmsSandboxPhoneNumberOutput,
            smithy_http::result::SdkError<crate::error::VerifySMSSandboxPhoneNumberError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The destination phone number to verify.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.phone_number(input);
            self
        }
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_phone_number(input);
            self
        }
        /// <p>The OTP sent to the destination number from the
        /// <code>CreateSMSSandBoxPhoneNumber</code> call.</p>
        pub fn one_time_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.one_time_password(input);
            self
        }
        pub fn set_one_time_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_one_time_password(input);
            self
        }
    }
}
