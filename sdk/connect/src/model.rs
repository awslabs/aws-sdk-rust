// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains information about the phone configuration settings for a user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserPhoneConfig {
    /// <p>The phone type.</p>
    #[doc(hidden)]
    pub phone_type: std::option::Option<crate::model::PhoneType>,
    /// <p>The Auto accept setting.</p>
    #[doc(hidden)]
    pub auto_accept: bool,
    /// <p>The After Call Work (ACW) timeout setting, in seconds.</p> <note>
    /// <p>When returned by a <code>SearchUsers</code> call, <code>AfterContactWorkTimeLimit</code> is returned in milliseconds. </p>
    /// </note>
    #[doc(hidden)]
    pub after_contact_work_time_limit: i32,
    /// <p>The phone number for the user's desk phone.</p>
    #[doc(hidden)]
    pub desk_phone_number: std::option::Option<std::string::String>,
}
impl UserPhoneConfig {
    /// <p>The phone type.</p>
    pub fn phone_type(&self) -> std::option::Option<&crate::model::PhoneType> {
        self.phone_type.as_ref()
    }
    /// <p>The Auto accept setting.</p>
    pub fn auto_accept(&self) -> bool {
        self.auto_accept
    }
    /// <p>The After Call Work (ACW) timeout setting, in seconds.</p> <note>
    /// <p>When returned by a <code>SearchUsers</code> call, <code>AfterContactWorkTimeLimit</code> is returned in milliseconds. </p>
    /// </note>
    pub fn after_contact_work_time_limit(&self) -> i32 {
        self.after_contact_work_time_limit
    }
    /// <p>The phone number for the user's desk phone.</p>
    pub fn desk_phone_number(&self) -> std::option::Option<&str> {
        self.desk_phone_number.as_deref()
    }
}
/// See [`UserPhoneConfig`](crate::model::UserPhoneConfig).
pub mod user_phone_config {

    /// A builder for [`UserPhoneConfig`](crate::model::UserPhoneConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_type: std::option::Option<crate::model::PhoneType>,
        pub(crate) auto_accept: std::option::Option<bool>,
        pub(crate) after_contact_work_time_limit: std::option::Option<i32>,
        pub(crate) desk_phone_number: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The phone type.</p>
        pub fn phone_type(mut self, input: crate::model::PhoneType) -> Self {
            self.phone_type = Some(input);
            self
        }
        /// <p>The phone type.</p>
        pub fn set_phone_type(
            mut self,
            input: std::option::Option<crate::model::PhoneType>,
        ) -> Self {
            self.phone_type = input;
            self
        }
        /// <p>The Auto accept setting.</p>
        pub fn auto_accept(mut self, input: bool) -> Self {
            self.auto_accept = Some(input);
            self
        }
        /// <p>The Auto accept setting.</p>
        pub fn set_auto_accept(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_accept = input;
            self
        }
        /// <p>The After Call Work (ACW) timeout setting, in seconds.</p> <note>
        /// <p>When returned by a <code>SearchUsers</code> call, <code>AfterContactWorkTimeLimit</code> is returned in milliseconds. </p>
        /// </note>
        pub fn after_contact_work_time_limit(mut self, input: i32) -> Self {
            self.after_contact_work_time_limit = Some(input);
            self
        }
        /// <p>The After Call Work (ACW) timeout setting, in seconds.</p> <note>
        /// <p>When returned by a <code>SearchUsers</code> call, <code>AfterContactWorkTimeLimit</code> is returned in milliseconds. </p>
        /// </note>
        pub fn set_after_contact_work_time_limit(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.after_contact_work_time_limit = input;
            self
        }
        /// <p>The phone number for the user's desk phone.</p>
        pub fn desk_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.desk_phone_number = Some(input.into());
            self
        }
        /// <p>The phone number for the user's desk phone.</p>
        pub fn set_desk_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.desk_phone_number = input;
            self
        }
        /// Consumes the builder and constructs a [`UserPhoneConfig`](crate::model::UserPhoneConfig).
        pub fn build(self) -> crate::model::UserPhoneConfig {
            crate::model::UserPhoneConfig {
                phone_type: self.phone_type,
                auto_accept: self.auto_accept.unwrap_or_default(),
                after_contact_work_time_limit: self
                    .after_contact_work_time_limit
                    .unwrap_or_default(),
                desk_phone_number: self.desk_phone_number,
            }
        }
    }
}
impl UserPhoneConfig {
    /// Creates a new builder-style object to manufacture [`UserPhoneConfig`](crate::model::UserPhoneConfig).
    pub fn builder() -> crate::model::user_phone_config::Builder {
        crate::model::user_phone_config::Builder::default()
    }
}

/// When writing a match expression against `PhoneType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let phonetype = unimplemented!();
/// match phonetype {
///     PhoneType::DeskPhone => { /* ... */ },
///     PhoneType::SoftPhone => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `phonetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PhoneType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PhoneType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PhoneType::NewFeature` is defined.
/// Specifically, when `phonetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PhoneType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneType {
    #[allow(missing_docs)] // documentation missing in model
    DeskPhone,
    #[allow(missing_docs)] // documentation missing in model
    SoftPhone,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PhoneType {
    fn from(s: &str) -> Self {
        match s {
            "DESK_PHONE" => PhoneType::DeskPhone,
            "SOFT_PHONE" => PhoneType::SoftPhone,
            other => PhoneType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PhoneType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneType::from(s))
    }
}
impl PhoneType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneType::DeskPhone => "DESK_PHONE",
            PhoneType::SoftPhone => "SOFT_PHONE",
            PhoneType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DESK_PHONE", "SOFT_PHONE"]
    }
}
impl AsRef<str> for PhoneType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the identity of a user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserIdentityInfo {
    /// <p>The first name. This is required if you are using Amazon Connect or SAML for identity management.</p>
    #[doc(hidden)]
    pub first_name: std::option::Option<std::string::String>,
    /// <p>The last name. This is required if you are using Amazon Connect or SAML for identity management.</p>
    #[doc(hidden)]
    pub last_name: std::option::Option<std::string::String>,
    /// <p>The email address. If you are using SAML for identity management and include this parameter, an error is returned.</p>
    #[doc(hidden)]
    pub email: std::option::Option<std::string::String>,
    /// <p>The user's secondary email address. If you provide a secondary email, the user receives email notifications - other than password reset notifications - to this email address instead of to their primary email address.</p>
    /// <p>Pattern: <code>(?=^.{0,265}$)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}</code> </p>
    #[doc(hidden)]
    pub secondary_email: std::option::Option<std::string::String>,
    /// <p>The user's mobile number.</p>
    #[doc(hidden)]
    pub mobile: std::option::Option<std::string::String>,
}
impl UserIdentityInfo {
    /// <p>The first name. This is required if you are using Amazon Connect or SAML for identity management.</p>
    pub fn first_name(&self) -> std::option::Option<&str> {
        self.first_name.as_deref()
    }
    /// <p>The last name. This is required if you are using Amazon Connect or SAML for identity management.</p>
    pub fn last_name(&self) -> std::option::Option<&str> {
        self.last_name.as_deref()
    }
    /// <p>The email address. If you are using SAML for identity management and include this parameter, an error is returned.</p>
    pub fn email(&self) -> std::option::Option<&str> {
        self.email.as_deref()
    }
    /// <p>The user's secondary email address. If you provide a secondary email, the user receives email notifications - other than password reset notifications - to this email address instead of to their primary email address.</p>
    /// <p>Pattern: <code>(?=^.{0,265}$)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}</code> </p>
    pub fn secondary_email(&self) -> std::option::Option<&str> {
        self.secondary_email.as_deref()
    }
    /// <p>The user's mobile number.</p>
    pub fn mobile(&self) -> std::option::Option<&str> {
        self.mobile.as_deref()
    }
}
/// See [`UserIdentityInfo`](crate::model::UserIdentityInfo).
pub mod user_identity_info {

    /// A builder for [`UserIdentityInfo`](crate::model::UserIdentityInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) first_name: std::option::Option<std::string::String>,
        pub(crate) last_name: std::option::Option<std::string::String>,
        pub(crate) email: std::option::Option<std::string::String>,
        pub(crate) secondary_email: std::option::Option<std::string::String>,
        pub(crate) mobile: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The first name. This is required if you are using Amazon Connect or SAML for identity management.</p>
        pub fn first_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_name = Some(input.into());
            self
        }
        /// <p>The first name. This is required if you are using Amazon Connect or SAML for identity management.</p>
        pub fn set_first_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.first_name = input;
            self
        }
        /// <p>The last name. This is required if you are using Amazon Connect or SAML for identity management.</p>
        pub fn last_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_name = Some(input.into());
            self
        }
        /// <p>The last name. This is required if you are using Amazon Connect or SAML for identity management.</p>
        pub fn set_last_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_name = input;
            self
        }
        /// <p>The email address. If you are using SAML for identity management and include this parameter, an error is returned.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.email = Some(input.into());
            self
        }
        /// <p>The email address. If you are using SAML for identity management and include this parameter, an error is returned.</p>
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.email = input;
            self
        }
        /// <p>The user's secondary email address. If you provide a secondary email, the user receives email notifications - other than password reset notifications - to this email address instead of to their primary email address.</p>
        /// <p>Pattern: <code>(?=^.{0,265}$)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}</code> </p>
        pub fn secondary_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.secondary_email = Some(input.into());
            self
        }
        /// <p>The user's secondary email address. If you provide a secondary email, the user receives email notifications - other than password reset notifications - to this email address instead of to their primary email address.</p>
        /// <p>Pattern: <code>(?=^.{0,265}$)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}</code> </p>
        pub fn set_secondary_email(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.secondary_email = input;
            self
        }
        /// <p>The user's mobile number.</p>
        pub fn mobile(mut self, input: impl Into<std::string::String>) -> Self {
            self.mobile = Some(input.into());
            self
        }
        /// <p>The user's mobile number.</p>
        pub fn set_mobile(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mobile = input;
            self
        }
        /// Consumes the builder and constructs a [`UserIdentityInfo`](crate::model::UserIdentityInfo).
        pub fn build(self) -> crate::model::UserIdentityInfo {
            crate::model::UserIdentityInfo {
                first_name: self.first_name,
                last_name: self.last_name,
                email: self.email,
                secondary_email: self.secondary_email,
                mobile: self.mobile,
            }
        }
    }
}
impl UserIdentityInfo {
    /// Creates a new builder-style object to manufacture [`UserIdentityInfo`](crate::model::UserIdentityInfo).
    pub fn builder() -> crate::model::user_identity_info::Builder {
        crate::model::user_identity_info::Builder::default()
    }
}

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::Contact => { /* ... */ },
///     ResourceType::ContactFlow => { /* ... */ },
///     ResourceType::HierarchyGroup => { /* ... */ },
///     ResourceType::HierarchyLevel => { /* ... */ },
///     ResourceType::Instance => { /* ... */ },
///     ResourceType::Participant => { /* ... */ },
///     ResourceType::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Contact,
    #[allow(missing_docs)] // documentation missing in model
    ContactFlow,
    #[allow(missing_docs)] // documentation missing in model
    HierarchyGroup,
    #[allow(missing_docs)] // documentation missing in model
    HierarchyLevel,
    #[allow(missing_docs)] // documentation missing in model
    Instance,
    #[allow(missing_docs)] // documentation missing in model
    Participant,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "CONTACT" => ResourceType::Contact,
            "CONTACT_FLOW" => ResourceType::ContactFlow,
            "HIERARCHY_GROUP" => ResourceType::HierarchyGroup,
            "HIERARCHY_LEVEL" => ResourceType::HierarchyLevel,
            "INSTANCE" => ResourceType::Instance,
            "PARTICIPANT" => ResourceType::Participant,
            "USER" => ResourceType::User,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Contact => "CONTACT",
            ResourceType::ContactFlow => "CONTACT_FLOW",
            ResourceType::HierarchyGroup => "HIERARCHY_GROUP",
            ResourceType::HierarchyLevel => "HIERARCHY_LEVEL",
            ResourceType::Instance => "INSTANCE",
            ResourceType::Participant => "PARTICIPANT",
            ResourceType::User => "USER",
            ResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CONTACT",
            "CONTACT_FLOW",
            "HIERARCHY_GROUP",
            "HIERARCHY_LEVEL",
            "INSTANCE",
            "PARTICIPANT",
            "USER",
        ]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the level hierarchy to update.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HierarchyStructureUpdate {
    /// <p>The update for level one.</p>
    #[doc(hidden)]
    pub level_one: std::option::Option<crate::model::HierarchyLevelUpdate>,
    /// <p>The update for level two.</p>
    #[doc(hidden)]
    pub level_two: std::option::Option<crate::model::HierarchyLevelUpdate>,
    /// <p>The update for level three.</p>
    #[doc(hidden)]
    pub level_three: std::option::Option<crate::model::HierarchyLevelUpdate>,
    /// <p>The update for level four.</p>
    #[doc(hidden)]
    pub level_four: std::option::Option<crate::model::HierarchyLevelUpdate>,
    /// <p>The update for level five.</p>
    #[doc(hidden)]
    pub level_five: std::option::Option<crate::model::HierarchyLevelUpdate>,
}
impl HierarchyStructureUpdate {
    /// <p>The update for level one.</p>
    pub fn level_one(&self) -> std::option::Option<&crate::model::HierarchyLevelUpdate> {
        self.level_one.as_ref()
    }
    /// <p>The update for level two.</p>
    pub fn level_two(&self) -> std::option::Option<&crate::model::HierarchyLevelUpdate> {
        self.level_two.as_ref()
    }
    /// <p>The update for level three.</p>
    pub fn level_three(&self) -> std::option::Option<&crate::model::HierarchyLevelUpdate> {
        self.level_three.as_ref()
    }
    /// <p>The update for level four.</p>
    pub fn level_four(&self) -> std::option::Option<&crate::model::HierarchyLevelUpdate> {
        self.level_four.as_ref()
    }
    /// <p>The update for level five.</p>
    pub fn level_five(&self) -> std::option::Option<&crate::model::HierarchyLevelUpdate> {
        self.level_five.as_ref()
    }
}
/// See [`HierarchyStructureUpdate`](crate::model::HierarchyStructureUpdate).
pub mod hierarchy_structure_update {

    /// A builder for [`HierarchyStructureUpdate`](crate::model::HierarchyStructureUpdate).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) level_one: std::option::Option<crate::model::HierarchyLevelUpdate>,
        pub(crate) level_two: std::option::Option<crate::model::HierarchyLevelUpdate>,
        pub(crate) level_three: std::option::Option<crate::model::HierarchyLevelUpdate>,
        pub(crate) level_four: std::option::Option<crate::model::HierarchyLevelUpdate>,
        pub(crate) level_five: std::option::Option<crate::model::HierarchyLevelUpdate>,
    }
    impl Builder {
        /// <p>The update for level one.</p>
        pub fn level_one(mut self, input: crate::model::HierarchyLevelUpdate) -> Self {
            self.level_one = Some(input);
            self
        }
        /// <p>The update for level one.</p>
        pub fn set_level_one(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevelUpdate>,
        ) -> Self {
            self.level_one = input;
            self
        }
        /// <p>The update for level two.</p>
        pub fn level_two(mut self, input: crate::model::HierarchyLevelUpdate) -> Self {
            self.level_two = Some(input);
            self
        }
        /// <p>The update for level two.</p>
        pub fn set_level_two(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevelUpdate>,
        ) -> Self {
            self.level_two = input;
            self
        }
        /// <p>The update for level three.</p>
        pub fn level_three(mut self, input: crate::model::HierarchyLevelUpdate) -> Self {
            self.level_three = Some(input);
            self
        }
        /// <p>The update for level three.</p>
        pub fn set_level_three(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevelUpdate>,
        ) -> Self {
            self.level_three = input;
            self
        }
        /// <p>The update for level four.</p>
        pub fn level_four(mut self, input: crate::model::HierarchyLevelUpdate) -> Self {
            self.level_four = Some(input);
            self
        }
        /// <p>The update for level four.</p>
        pub fn set_level_four(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevelUpdate>,
        ) -> Self {
            self.level_four = input;
            self
        }
        /// <p>The update for level five.</p>
        pub fn level_five(mut self, input: crate::model::HierarchyLevelUpdate) -> Self {
            self.level_five = Some(input);
            self
        }
        /// <p>The update for level five.</p>
        pub fn set_level_five(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevelUpdate>,
        ) -> Self {
            self.level_five = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyStructureUpdate`](crate::model::HierarchyStructureUpdate).
        pub fn build(self) -> crate::model::HierarchyStructureUpdate {
            crate::model::HierarchyStructureUpdate {
                level_one: self.level_one,
                level_two: self.level_two,
                level_three: self.level_three,
                level_four: self.level_four,
                level_five: self.level_five,
            }
        }
    }
}
impl HierarchyStructureUpdate {
    /// Creates a new builder-style object to manufacture [`HierarchyStructureUpdate`](crate::model::HierarchyStructureUpdate).
    pub fn builder() -> crate::model::hierarchy_structure_update::Builder {
        crate::model::hierarchy_structure_update::Builder::default()
    }
}

/// <p>Contains information about the hierarchy level to update.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HierarchyLevelUpdate {
    /// <p>The name of the user hierarchy level. Must not be more than 50 characters.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl HierarchyLevelUpdate {
    /// <p>The name of the user hierarchy level. Must not be more than 50 characters.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`HierarchyLevelUpdate`](crate::model::HierarchyLevelUpdate).
pub mod hierarchy_level_update {

    /// A builder for [`HierarchyLevelUpdate`](crate::model::HierarchyLevelUpdate).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user hierarchy level. Must not be more than 50 characters.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the user hierarchy level. Must not be more than 50 characters.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyLevelUpdate`](crate::model::HierarchyLevelUpdate).
        pub fn build(self) -> crate::model::HierarchyLevelUpdate {
            crate::model::HierarchyLevelUpdate { name: self.name }
        }
    }
}
impl HierarchyLevelUpdate {
    /// Creates a new builder-style object to manufacture [`HierarchyLevelUpdate`](crate::model::HierarchyLevelUpdate).
    pub fn builder() -> crate::model::hierarchy_level_update::Builder {
        crate::model::hierarchy_level_update::Builder::default()
    }
}

/// <p>The distribution of traffic between the instance and its replicas.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TelephonyConfig {
    /// <p>Information about traffic distributions.</p>
    #[doc(hidden)]
    pub distributions: std::option::Option<std::vec::Vec<crate::model::Distribution>>,
}
impl TelephonyConfig {
    /// <p>Information about traffic distributions.</p>
    pub fn distributions(&self) -> std::option::Option<&[crate::model::Distribution]> {
        self.distributions.as_deref()
    }
}
/// See [`TelephonyConfig`](crate::model::TelephonyConfig).
pub mod telephony_config {

    /// A builder for [`TelephonyConfig`](crate::model::TelephonyConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) distributions: std::option::Option<std::vec::Vec<crate::model::Distribution>>,
    }
    impl Builder {
        /// Appends an item to `distributions`.
        ///
        /// To override the contents of this collection use [`set_distributions`](Self::set_distributions).
        ///
        /// <p>Information about traffic distributions.</p>
        pub fn distributions(mut self, input: crate::model::Distribution) -> Self {
            let mut v = self.distributions.unwrap_or_default();
            v.push(input);
            self.distributions = Some(v);
            self
        }
        /// <p>Information about traffic distributions.</p>
        pub fn set_distributions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Distribution>>,
        ) -> Self {
            self.distributions = input;
            self
        }
        /// Consumes the builder and constructs a [`TelephonyConfig`](crate::model::TelephonyConfig).
        pub fn build(self) -> crate::model::TelephonyConfig {
            crate::model::TelephonyConfig {
                distributions: self.distributions,
            }
        }
    }
}
impl TelephonyConfig {
    /// Creates a new builder-style object to manufacture [`TelephonyConfig`](crate::model::TelephonyConfig).
    pub fn builder() -> crate::model::telephony_config::Builder {
        crate::model::telephony_config::Builder::default()
    }
}

/// <p>Information about a traffic distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Distribution {
    /// <p>The Amazon Web Services Region where the traffic is distributed.</p>
    #[doc(hidden)]
    pub region: std::option::Option<std::string::String>,
    /// <p>The percentage of the traffic that is distributed, in increments of 10.</p>
    #[doc(hidden)]
    pub percentage: i32,
}
impl Distribution {
    /// <p>The Amazon Web Services Region where the traffic is distributed.</p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
    /// <p>The percentage of the traffic that is distributed, in increments of 10.</p>
    pub fn percentage(&self) -> i32 {
        self.percentage
    }
}
/// See [`Distribution`](crate::model::Distribution).
pub mod distribution {

    /// A builder for [`Distribution`](crate::model::Distribution).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) percentage: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Web Services Region where the traffic is distributed.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region where the traffic is distributed.</p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>The percentage of the traffic that is distributed, in increments of 10.</p>
        pub fn percentage(mut self, input: i32) -> Self {
            self.percentage = Some(input);
            self
        }
        /// <p>The percentage of the traffic that is distributed, in increments of 10.</p>
        pub fn set_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.percentage = input;
            self
        }
        /// Consumes the builder and constructs a [`Distribution`](crate::model::Distribution).
        pub fn build(self) -> crate::model::Distribution {
            crate::model::Distribution {
                region: self.region,
                percentage: self.percentage.unwrap_or_default(),
            }
        }
    }
}
impl Distribution {
    /// Creates a new builder-style object to manufacture [`Distribution`](crate::model::Distribution).
    pub fn builder() -> crate::model::distribution::Builder {
        crate::model::distribution::Builder::default()
    }
}

/// <p>Contains information about why a property is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyValidationExceptionProperty {
    /// <p>The full property path.</p>
    #[doc(hidden)]
    pub property_path: std::option::Option<std::string::String>,
    /// <p>Why the property is not valid.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::PropertyValidationExceptionReason>,
    /// <p>A message describing why the property is not valid.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl PropertyValidationExceptionProperty {
    /// <p>The full property path.</p>
    pub fn property_path(&self) -> std::option::Option<&str> {
        self.property_path.as_deref()
    }
    /// <p>Why the property is not valid.</p>
    pub fn reason(&self) -> std::option::Option<&crate::model::PropertyValidationExceptionReason> {
        self.reason.as_ref()
    }
    /// <p>A message describing why the property is not valid.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`PropertyValidationExceptionProperty`](crate::model::PropertyValidationExceptionProperty).
pub mod property_validation_exception_property {

    /// A builder for [`PropertyValidationExceptionProperty`](crate::model::PropertyValidationExceptionProperty).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_path: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<crate::model::PropertyValidationExceptionReason>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The full property path.</p>
        pub fn property_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_path = Some(input.into());
            self
        }
        /// <p>The full property path.</p>
        pub fn set_property_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_path = input;
            self
        }
        /// <p>Why the property is not valid.</p>
        pub fn reason(mut self, input: crate::model::PropertyValidationExceptionReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>Why the property is not valid.</p>
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::PropertyValidationExceptionReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// <p>A message describing why the property is not valid.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing why the property is not valid.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyValidationExceptionProperty`](crate::model::PropertyValidationExceptionProperty).
        pub fn build(self) -> crate::model::PropertyValidationExceptionProperty {
            crate::model::PropertyValidationExceptionProperty {
                property_path: self.property_path,
                reason: self.reason,
                message: self.message,
            }
        }
    }
}
impl PropertyValidationExceptionProperty {
    /// Creates a new builder-style object to manufacture [`PropertyValidationExceptionProperty`](crate::model::PropertyValidationExceptionProperty).
    pub fn builder() -> crate::model::property_validation_exception_property::Builder {
        crate::model::property_validation_exception_property::Builder::default()
    }
}

/// When writing a match expression against `PropertyValidationExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let propertyvalidationexceptionreason = unimplemented!();
/// match propertyvalidationexceptionreason {
///     PropertyValidationExceptionReason::InvalidFormat => { /* ... */ },
///     PropertyValidationExceptionReason::NotSupported => { /* ... */ },
///     PropertyValidationExceptionReason::ReferencedResourceNotFound => { /* ... */ },
///     PropertyValidationExceptionReason::RequiredPropertyMissing => { /* ... */ },
///     PropertyValidationExceptionReason::ResourceNameAlreadyExists => { /* ... */ },
///     PropertyValidationExceptionReason::UniqueConstraintViolated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `propertyvalidationexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PropertyValidationExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PropertyValidationExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PropertyValidationExceptionReason::NewFeature` is defined.
/// Specifically, when `propertyvalidationexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PropertyValidationExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PropertyValidationExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    InvalidFormat,
    #[allow(missing_docs)] // documentation missing in model
    NotSupported,
    #[allow(missing_docs)] // documentation missing in model
    ReferencedResourceNotFound,
    #[allow(missing_docs)] // documentation missing in model
    RequiredPropertyMissing,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNameAlreadyExists,
    #[allow(missing_docs)] // documentation missing in model
    UniqueConstraintViolated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PropertyValidationExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "INVALID_FORMAT" => PropertyValidationExceptionReason::InvalidFormat,
            "NOT_SUPPORTED" => PropertyValidationExceptionReason::NotSupported,
            "REFERENCED_RESOURCE_NOT_FOUND" => {
                PropertyValidationExceptionReason::ReferencedResourceNotFound
            }
            "REQUIRED_PROPERTY_MISSING" => {
                PropertyValidationExceptionReason::RequiredPropertyMissing
            }
            "RESOURCE_NAME_ALREADY_EXISTS" => {
                PropertyValidationExceptionReason::ResourceNameAlreadyExists
            }
            "UNIQUE_CONSTRAINT_VIOLATED" => {
                PropertyValidationExceptionReason::UniqueConstraintViolated
            }
            other => PropertyValidationExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PropertyValidationExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PropertyValidationExceptionReason::from(s))
    }
}
impl PropertyValidationExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PropertyValidationExceptionReason::InvalidFormat => "INVALID_FORMAT",
            PropertyValidationExceptionReason::NotSupported => "NOT_SUPPORTED",
            PropertyValidationExceptionReason::ReferencedResourceNotFound => {
                "REFERENCED_RESOURCE_NOT_FOUND"
            }
            PropertyValidationExceptionReason::RequiredPropertyMissing => {
                "REQUIRED_PROPERTY_MISSING"
            }
            PropertyValidationExceptionReason::ResourceNameAlreadyExists => {
                "RESOURCE_NAME_ALREADY_EXISTS"
            }
            PropertyValidationExceptionReason::UniqueConstraintViolated => {
                "UNIQUE_CONSTRAINT_VIOLATED"
            }
            PropertyValidationExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "INVALID_FORMAT",
            "NOT_SUPPORTED",
            "REFERENCED_RESOURCE_NOT_FOUND",
            "REQUIRED_PROPERTY_MISSING",
            "RESOURCE_NAME_ALREADY_EXISTS",
            "UNIQUE_CONSTRAINT_VIOLATED",
        ]
    }
}
impl AsRef<str> for PropertyValidationExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TaskTemplateStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tasktemplatestatus = unimplemented!();
/// match tasktemplatestatus {
///     TaskTemplateStatus::Active => { /* ... */ },
///     TaskTemplateStatus::Inactive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tasktemplatestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TaskTemplateStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TaskTemplateStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TaskTemplateStatus::NewFeature` is defined.
/// Specifically, when `tasktemplatestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TaskTemplateStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskTemplateStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TaskTemplateStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => TaskTemplateStatus::Active,
            "INACTIVE" => TaskTemplateStatus::Inactive,
            other => {
                TaskTemplateStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TaskTemplateStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TaskTemplateStatus::from(s))
    }
}
impl TaskTemplateStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TaskTemplateStatus::Active => "ACTIVE",
            TaskTemplateStatus::Inactive => "INACTIVE",
            TaskTemplateStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "INACTIVE"]
    }
}
impl AsRef<str> for TaskTemplateStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a single task template field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskTemplateField {
    /// <p>The unique identifier for the field.</p>
    #[doc(hidden)]
    pub id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
    /// <p>The description of the field.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Indicates the type of field.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::TaskTemplateFieldType>,
    /// <p>A list of options for a single select field.</p>
    #[doc(hidden)]
    pub single_select_options: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl TaskTemplateField {
    /// <p>The unique identifier for the field.</p>
    pub fn id(&self) -> std::option::Option<&crate::model::TaskTemplateFieldIdentifier> {
        self.id.as_ref()
    }
    /// <p>The description of the field.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Indicates the type of field.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::TaskTemplateFieldType> {
        self.r#type.as_ref()
    }
    /// <p>A list of options for a single select field.</p>
    pub fn single_select_options(&self) -> std::option::Option<&[std::string::String]> {
        self.single_select_options.as_deref()
    }
}
/// See [`TaskTemplateField`](crate::model::TaskTemplateField).
pub mod task_template_field {

    /// A builder for [`TaskTemplateField`](crate::model::TaskTemplateField).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::TaskTemplateFieldType>,
        pub(crate) single_select_options: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The unique identifier for the field.</p>
        pub fn id(mut self, input: crate::model::TaskTemplateFieldIdentifier) -> Self {
            self.id = Some(input);
            self
        }
        /// <p>The unique identifier for the field.</p>
        pub fn set_id(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        ) -> Self {
            self.id = input;
            self
        }
        /// <p>The description of the field.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the field.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Indicates the type of field.</p>
        pub fn r#type(mut self, input: crate::model::TaskTemplateFieldType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Indicates the type of field.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateFieldType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `single_select_options`.
        ///
        /// To override the contents of this collection use [`set_single_select_options`](Self::set_single_select_options).
        ///
        /// <p>A list of options for a single select field.</p>
        pub fn single_select_options(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.single_select_options.unwrap_or_default();
            v.push(input.into());
            self.single_select_options = Some(v);
            self
        }
        /// <p>A list of options for a single select field.</p>
        pub fn set_single_select_options(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.single_select_options = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskTemplateField`](crate::model::TaskTemplateField).
        pub fn build(self) -> crate::model::TaskTemplateField {
            crate::model::TaskTemplateField {
                id: self.id,
                description: self.description,
                r#type: self.r#type,
                single_select_options: self.single_select_options,
            }
        }
    }
}
impl TaskTemplateField {
    /// Creates a new builder-style object to manufacture [`TaskTemplateField`](crate::model::TaskTemplateField).
    pub fn builder() -> crate::model::task_template_field::Builder {
        crate::model::task_template_field::Builder::default()
    }
}

/// When writing a match expression against `TaskTemplateFieldType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tasktemplatefieldtype = unimplemented!();
/// match tasktemplatefieldtype {
///     TaskTemplateFieldType::Boolean => { /* ... */ },
///     TaskTemplateFieldType::DateTime => { /* ... */ },
///     TaskTemplateFieldType::Description => { /* ... */ },
///     TaskTemplateFieldType::Email => { /* ... */ },
///     TaskTemplateFieldType::Name => { /* ... */ },
///     TaskTemplateFieldType::Number => { /* ... */ },
///     TaskTemplateFieldType::QuickConnect => { /* ... */ },
///     TaskTemplateFieldType::ScheduledTime => { /* ... */ },
///     TaskTemplateFieldType::SingleSelect => { /* ... */ },
///     TaskTemplateFieldType::Text => { /* ... */ },
///     TaskTemplateFieldType::TextArea => { /* ... */ },
///     TaskTemplateFieldType::Url => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tasktemplatefieldtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TaskTemplateFieldType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TaskTemplateFieldType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TaskTemplateFieldType::NewFeature` is defined.
/// Specifically, when `tasktemplatefieldtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TaskTemplateFieldType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskTemplateFieldType {
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    DateTime,
    #[allow(missing_docs)] // documentation missing in model
    Description,
    #[allow(missing_docs)] // documentation missing in model
    Email,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    Number,
    #[allow(missing_docs)] // documentation missing in model
    QuickConnect,
    #[allow(missing_docs)] // documentation missing in model
    ScheduledTime,
    #[allow(missing_docs)] // documentation missing in model
    SingleSelect,
    #[allow(missing_docs)] // documentation missing in model
    Text,
    #[allow(missing_docs)] // documentation missing in model
    TextArea,
    #[allow(missing_docs)] // documentation missing in model
    Url,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TaskTemplateFieldType {
    fn from(s: &str) -> Self {
        match s {
            "BOOLEAN" => TaskTemplateFieldType::Boolean,
            "DATE_TIME" => TaskTemplateFieldType::DateTime,
            "DESCRIPTION" => TaskTemplateFieldType::Description,
            "EMAIL" => TaskTemplateFieldType::Email,
            "NAME" => TaskTemplateFieldType::Name,
            "NUMBER" => TaskTemplateFieldType::Number,
            "QUICK_CONNECT" => TaskTemplateFieldType::QuickConnect,
            "SCHEDULED_TIME" => TaskTemplateFieldType::ScheduledTime,
            "SINGLE_SELECT" => TaskTemplateFieldType::SingleSelect,
            "TEXT" => TaskTemplateFieldType::Text,
            "TEXT_AREA" => TaskTemplateFieldType::TextArea,
            "URL" => TaskTemplateFieldType::Url,
            other => {
                TaskTemplateFieldType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TaskTemplateFieldType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TaskTemplateFieldType::from(s))
    }
}
impl TaskTemplateFieldType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TaskTemplateFieldType::Boolean => "BOOLEAN",
            TaskTemplateFieldType::DateTime => "DATE_TIME",
            TaskTemplateFieldType::Description => "DESCRIPTION",
            TaskTemplateFieldType::Email => "EMAIL",
            TaskTemplateFieldType::Name => "NAME",
            TaskTemplateFieldType::Number => "NUMBER",
            TaskTemplateFieldType::QuickConnect => "QUICK_CONNECT",
            TaskTemplateFieldType::ScheduledTime => "SCHEDULED_TIME",
            TaskTemplateFieldType::SingleSelect => "SINGLE_SELECT",
            TaskTemplateFieldType::Text => "TEXT",
            TaskTemplateFieldType::TextArea => "TEXT_AREA",
            TaskTemplateFieldType::Url => "URL",
            TaskTemplateFieldType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BOOLEAN",
            "DATE_TIME",
            "DESCRIPTION",
            "EMAIL",
            "NAME",
            "NUMBER",
            "QUICK_CONNECT",
            "SCHEDULED_TIME",
            "SINGLE_SELECT",
            "TEXT",
            "TEXT_AREA",
            "URL",
        ]
    }
}
impl AsRef<str> for TaskTemplateFieldType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The identifier of the task template field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskTemplateFieldIdentifier {
    /// <p>The name of the task template field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl TaskTemplateFieldIdentifier {
    /// <p>The name of the task template field.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`TaskTemplateFieldIdentifier`](crate::model::TaskTemplateFieldIdentifier).
pub mod task_template_field_identifier {

    /// A builder for [`TaskTemplateFieldIdentifier`](crate::model::TaskTemplateFieldIdentifier).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the task template field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the task template field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskTemplateFieldIdentifier`](crate::model::TaskTemplateFieldIdentifier).
        pub fn build(self) -> crate::model::TaskTemplateFieldIdentifier {
            crate::model::TaskTemplateFieldIdentifier { name: self.name }
        }
    }
}
impl TaskTemplateFieldIdentifier {
    /// Creates a new builder-style object to manufacture [`TaskTemplateFieldIdentifier`](crate::model::TaskTemplateFieldIdentifier).
    pub fn builder() -> crate::model::task_template_field_identifier::Builder {
        crate::model::task_template_field_identifier::Builder::default()
    }
}

/// <p>Describes default values for fields on a template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskTemplateDefaults {
    /// <p>Default value for the field.</p>
    #[doc(hidden)]
    pub default_field_values:
        std::option::Option<std::vec::Vec<crate::model::TaskTemplateDefaultFieldValue>>,
}
impl TaskTemplateDefaults {
    /// <p>Default value for the field.</p>
    pub fn default_field_values(
        &self,
    ) -> std::option::Option<&[crate::model::TaskTemplateDefaultFieldValue]> {
        self.default_field_values.as_deref()
    }
}
/// See [`TaskTemplateDefaults`](crate::model::TaskTemplateDefaults).
pub mod task_template_defaults {

    /// A builder for [`TaskTemplateDefaults`](crate::model::TaskTemplateDefaults).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_field_values:
            std::option::Option<std::vec::Vec<crate::model::TaskTemplateDefaultFieldValue>>,
    }
    impl Builder {
        /// Appends an item to `default_field_values`.
        ///
        /// To override the contents of this collection use [`set_default_field_values`](Self::set_default_field_values).
        ///
        /// <p>Default value for the field.</p>
        pub fn default_field_values(
            mut self,
            input: crate::model::TaskTemplateDefaultFieldValue,
        ) -> Self {
            let mut v = self.default_field_values.unwrap_or_default();
            v.push(input);
            self.default_field_values = Some(v);
            self
        }
        /// <p>Default value for the field.</p>
        pub fn set_default_field_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TaskTemplateDefaultFieldValue>>,
        ) -> Self {
            self.default_field_values = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskTemplateDefaults`](crate::model::TaskTemplateDefaults).
        pub fn build(self) -> crate::model::TaskTemplateDefaults {
            crate::model::TaskTemplateDefaults {
                default_field_values: self.default_field_values,
            }
        }
    }
}
impl TaskTemplateDefaults {
    /// Creates a new builder-style object to manufacture [`TaskTemplateDefaults`](crate::model::TaskTemplateDefaults).
    pub fn builder() -> crate::model::task_template_defaults::Builder {
        crate::model::task_template_defaults::Builder::default()
    }
}

/// <p>Describes a default field and its corresponding value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskTemplateDefaultFieldValue {
    /// <p>Identifier of a field. </p>
    #[doc(hidden)]
    pub id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
    /// <p>Default value for the field.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<std::string::String>,
}
impl TaskTemplateDefaultFieldValue {
    /// <p>Identifier of a field. </p>
    pub fn id(&self) -> std::option::Option<&crate::model::TaskTemplateFieldIdentifier> {
        self.id.as_ref()
    }
    /// <p>Default value for the field.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
}
/// See [`TaskTemplateDefaultFieldValue`](crate::model::TaskTemplateDefaultFieldValue).
pub mod task_template_default_field_value {

    /// A builder for [`TaskTemplateDefaultFieldValue`](crate::model::TaskTemplateDefaultFieldValue).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        pub(crate) default_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifier of a field. </p>
        pub fn id(mut self, input: crate::model::TaskTemplateFieldIdentifier) -> Self {
            self.id = Some(input);
            self
        }
        /// <p>Identifier of a field. </p>
        pub fn set_id(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        ) -> Self {
            self.id = input;
            self
        }
        /// <p>Default value for the field.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>Default value for the field.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskTemplateDefaultFieldValue`](crate::model::TaskTemplateDefaultFieldValue).
        pub fn build(self) -> crate::model::TaskTemplateDefaultFieldValue {
            crate::model::TaskTemplateDefaultFieldValue {
                id: self.id,
                default_value: self.default_value,
            }
        }
    }
}
impl TaskTemplateDefaultFieldValue {
    /// Creates a new builder-style object to manufacture [`TaskTemplateDefaultFieldValue`](crate::model::TaskTemplateDefaultFieldValue).
    pub fn builder() -> crate::model::task_template_default_field_value::Builder {
        crate::model::task_template_default_field_value::Builder::default()
    }
}

/// <p>Describes constraints that apply to the template fields.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskTemplateConstraints {
    /// <p>Lists the fields that are required to be filled by agents.</p>
    #[doc(hidden)]
    pub required_fields: std::option::Option<std::vec::Vec<crate::model::RequiredFieldInfo>>,
    /// <p>Lists the fields that are read-only to agents, and cannot be edited.</p>
    #[doc(hidden)]
    pub read_only_fields: std::option::Option<std::vec::Vec<crate::model::ReadOnlyFieldInfo>>,
    /// <p>Lists the fields that are invisible to agents.</p>
    #[doc(hidden)]
    pub invisible_fields: std::option::Option<std::vec::Vec<crate::model::InvisibleFieldInfo>>,
}
impl TaskTemplateConstraints {
    /// <p>Lists the fields that are required to be filled by agents.</p>
    pub fn required_fields(&self) -> std::option::Option<&[crate::model::RequiredFieldInfo]> {
        self.required_fields.as_deref()
    }
    /// <p>Lists the fields that are read-only to agents, and cannot be edited.</p>
    pub fn read_only_fields(&self) -> std::option::Option<&[crate::model::ReadOnlyFieldInfo]> {
        self.read_only_fields.as_deref()
    }
    /// <p>Lists the fields that are invisible to agents.</p>
    pub fn invisible_fields(&self) -> std::option::Option<&[crate::model::InvisibleFieldInfo]> {
        self.invisible_fields.as_deref()
    }
}
/// See [`TaskTemplateConstraints`](crate::model::TaskTemplateConstraints).
pub mod task_template_constraints {

    /// A builder for [`TaskTemplateConstraints`](crate::model::TaskTemplateConstraints).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) required_fields:
            std::option::Option<std::vec::Vec<crate::model::RequiredFieldInfo>>,
        pub(crate) read_only_fields:
            std::option::Option<std::vec::Vec<crate::model::ReadOnlyFieldInfo>>,
        pub(crate) invisible_fields:
            std::option::Option<std::vec::Vec<crate::model::InvisibleFieldInfo>>,
    }
    impl Builder {
        /// Appends an item to `required_fields`.
        ///
        /// To override the contents of this collection use [`set_required_fields`](Self::set_required_fields).
        ///
        /// <p>Lists the fields that are required to be filled by agents.</p>
        pub fn required_fields(mut self, input: crate::model::RequiredFieldInfo) -> Self {
            let mut v = self.required_fields.unwrap_or_default();
            v.push(input);
            self.required_fields = Some(v);
            self
        }
        /// <p>Lists the fields that are required to be filled by agents.</p>
        pub fn set_required_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RequiredFieldInfo>>,
        ) -> Self {
            self.required_fields = input;
            self
        }
        /// Appends an item to `read_only_fields`.
        ///
        /// To override the contents of this collection use [`set_read_only_fields`](Self::set_read_only_fields).
        ///
        /// <p>Lists the fields that are read-only to agents, and cannot be edited.</p>
        pub fn read_only_fields(mut self, input: crate::model::ReadOnlyFieldInfo) -> Self {
            let mut v = self.read_only_fields.unwrap_or_default();
            v.push(input);
            self.read_only_fields = Some(v);
            self
        }
        /// <p>Lists the fields that are read-only to agents, and cannot be edited.</p>
        pub fn set_read_only_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReadOnlyFieldInfo>>,
        ) -> Self {
            self.read_only_fields = input;
            self
        }
        /// Appends an item to `invisible_fields`.
        ///
        /// To override the contents of this collection use [`set_invisible_fields`](Self::set_invisible_fields).
        ///
        /// <p>Lists the fields that are invisible to agents.</p>
        pub fn invisible_fields(mut self, input: crate::model::InvisibleFieldInfo) -> Self {
            let mut v = self.invisible_fields.unwrap_or_default();
            v.push(input);
            self.invisible_fields = Some(v);
            self
        }
        /// <p>Lists the fields that are invisible to agents.</p>
        pub fn set_invisible_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InvisibleFieldInfo>>,
        ) -> Self {
            self.invisible_fields = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskTemplateConstraints`](crate::model::TaskTemplateConstraints).
        pub fn build(self) -> crate::model::TaskTemplateConstraints {
            crate::model::TaskTemplateConstraints {
                required_fields: self.required_fields,
                read_only_fields: self.read_only_fields,
                invisible_fields: self.invisible_fields,
            }
        }
    }
}
impl TaskTemplateConstraints {
    /// Creates a new builder-style object to manufacture [`TaskTemplateConstraints`](crate::model::TaskTemplateConstraints).
    pub fn builder() -> crate::model::task_template_constraints::Builder {
        crate::model::task_template_constraints::Builder::default()
    }
}

/// <p>A field that is invisible to an agent.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvisibleFieldInfo {
    /// <p>Identifier of the invisible field.</p>
    #[doc(hidden)]
    pub id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
}
impl InvisibleFieldInfo {
    /// <p>Identifier of the invisible field.</p>
    pub fn id(&self) -> std::option::Option<&crate::model::TaskTemplateFieldIdentifier> {
        self.id.as_ref()
    }
}
/// See [`InvisibleFieldInfo`](crate::model::InvisibleFieldInfo).
pub mod invisible_field_info {

    /// A builder for [`InvisibleFieldInfo`](crate::model::InvisibleFieldInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
    }
    impl Builder {
        /// <p>Identifier of the invisible field.</p>
        pub fn id(mut self, input: crate::model::TaskTemplateFieldIdentifier) -> Self {
            self.id = Some(input);
            self
        }
        /// <p>Identifier of the invisible field.</p>
        pub fn set_id(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        ) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`InvisibleFieldInfo`](crate::model::InvisibleFieldInfo).
        pub fn build(self) -> crate::model::InvisibleFieldInfo {
            crate::model::InvisibleFieldInfo { id: self.id }
        }
    }
}
impl InvisibleFieldInfo {
    /// Creates a new builder-style object to manufacture [`InvisibleFieldInfo`](crate::model::InvisibleFieldInfo).
    pub fn builder() -> crate::model::invisible_field_info::Builder {
        crate::model::invisible_field_info::Builder::default()
    }
}

/// <p>Indicates a field that is read-only to an agent.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReadOnlyFieldInfo {
    /// <p>Identifier of the read-only field.</p>
    #[doc(hidden)]
    pub id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
}
impl ReadOnlyFieldInfo {
    /// <p>Identifier of the read-only field.</p>
    pub fn id(&self) -> std::option::Option<&crate::model::TaskTemplateFieldIdentifier> {
        self.id.as_ref()
    }
}
/// See [`ReadOnlyFieldInfo`](crate::model::ReadOnlyFieldInfo).
pub mod read_only_field_info {

    /// A builder for [`ReadOnlyFieldInfo`](crate::model::ReadOnlyFieldInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
    }
    impl Builder {
        /// <p>Identifier of the read-only field.</p>
        pub fn id(mut self, input: crate::model::TaskTemplateFieldIdentifier) -> Self {
            self.id = Some(input);
            self
        }
        /// <p>Identifier of the read-only field.</p>
        pub fn set_id(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        ) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`ReadOnlyFieldInfo`](crate::model::ReadOnlyFieldInfo).
        pub fn build(self) -> crate::model::ReadOnlyFieldInfo {
            crate::model::ReadOnlyFieldInfo { id: self.id }
        }
    }
}
impl ReadOnlyFieldInfo {
    /// Creates a new builder-style object to manufacture [`ReadOnlyFieldInfo`](crate::model::ReadOnlyFieldInfo).
    pub fn builder() -> crate::model::read_only_field_info::Builder {
        crate::model::read_only_field_info::Builder::default()
    }
}

/// <p>Information about a required field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RequiredFieldInfo {
    /// <p>The unique identifier for the field.</p>
    #[doc(hidden)]
    pub id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
}
impl RequiredFieldInfo {
    /// <p>The unique identifier for the field.</p>
    pub fn id(&self) -> std::option::Option<&crate::model::TaskTemplateFieldIdentifier> {
        self.id.as_ref()
    }
}
/// See [`RequiredFieldInfo`](crate::model::RequiredFieldInfo).
pub mod required_field_info {

    /// A builder for [`RequiredFieldInfo`](crate::model::RequiredFieldInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
    }
    impl Builder {
        /// <p>The unique identifier for the field.</p>
        pub fn id(mut self, input: crate::model::TaskTemplateFieldIdentifier) -> Self {
            self.id = Some(input);
            self
        }
        /// <p>The unique identifier for the field.</p>
        pub fn set_id(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        ) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`RequiredFieldInfo`](crate::model::RequiredFieldInfo).
        pub fn build(self) -> crate::model::RequiredFieldInfo {
            crate::model::RequiredFieldInfo { id: self.id }
        }
    }
}
impl RequiredFieldInfo {
    /// Creates a new builder-style object to manufacture [`RequiredFieldInfo`](crate::model::RequiredFieldInfo).
    pub fn builder() -> crate::model::required_field_info::Builder {
        crate::model::required_field_info::Builder::default()
    }
}

/// When writing a match expression against `RulePublishStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let rulepublishstatus = unimplemented!();
/// match rulepublishstatus {
///     RulePublishStatus::Draft => { /* ... */ },
///     RulePublishStatus::Published => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `rulepublishstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RulePublishStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RulePublishStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RulePublishStatus::NewFeature` is defined.
/// Specifically, when `rulepublishstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RulePublishStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RulePublishStatus {
    #[allow(missing_docs)] // documentation missing in model
    Draft,
    #[allow(missing_docs)] // documentation missing in model
    Published,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RulePublishStatus {
    fn from(s: &str) -> Self {
        match s {
            "DRAFT" => RulePublishStatus::Draft,
            "PUBLISHED" => RulePublishStatus::Published,
            other => {
                RulePublishStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for RulePublishStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RulePublishStatus::from(s))
    }
}
impl RulePublishStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RulePublishStatus::Draft => "DRAFT",
            RulePublishStatus::Published => "PUBLISHED",
            RulePublishStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DRAFT", "PUBLISHED"]
    }
}
impl AsRef<str> for RulePublishStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the action to be performed when a rule is triggered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RuleAction {
    /// <p>The type of action that creates a rule.</p>
    #[doc(hidden)]
    pub action_type: std::option::Option<crate::model::ActionType>,
    /// <p>Information about the task action. This field is required if <code>TriggerEventSource</code> is one of the following values: <code>OnZendeskTicketCreate</code> | <code>OnZendeskTicketStatusUpdate</code> | <code>OnSalesforceCaseCreate</code> </p>
    #[doc(hidden)]
    pub task_action: std::option::Option<crate::model::TaskActionDefinition>,
    /// <p>Information about the EventBridge action.</p>
    #[doc(hidden)]
    pub event_bridge_action: std::option::Option<crate::model::EventBridgeActionDefinition>,
    /// <p>Information about the contact category action.</p>
    #[doc(hidden)]
    pub assign_contact_category_action:
        std::option::Option<crate::model::AssignContactCategoryActionDefinition>,
    /// <p>Information about the send notification action.</p>
    #[doc(hidden)]
    pub send_notification_action:
        std::option::Option<crate::model::SendNotificationActionDefinition>,
}
impl RuleAction {
    /// <p>The type of action that creates a rule.</p>
    pub fn action_type(&self) -> std::option::Option<&crate::model::ActionType> {
        self.action_type.as_ref()
    }
    /// <p>Information about the task action. This field is required if <code>TriggerEventSource</code> is one of the following values: <code>OnZendeskTicketCreate</code> | <code>OnZendeskTicketStatusUpdate</code> | <code>OnSalesforceCaseCreate</code> </p>
    pub fn task_action(&self) -> std::option::Option<&crate::model::TaskActionDefinition> {
        self.task_action.as_ref()
    }
    /// <p>Information about the EventBridge action.</p>
    pub fn event_bridge_action(
        &self,
    ) -> std::option::Option<&crate::model::EventBridgeActionDefinition> {
        self.event_bridge_action.as_ref()
    }
    /// <p>Information about the contact category action.</p>
    pub fn assign_contact_category_action(
        &self,
    ) -> std::option::Option<&crate::model::AssignContactCategoryActionDefinition> {
        self.assign_contact_category_action.as_ref()
    }
    /// <p>Information about the send notification action.</p>
    pub fn send_notification_action(
        &self,
    ) -> std::option::Option<&crate::model::SendNotificationActionDefinition> {
        self.send_notification_action.as_ref()
    }
}
/// See [`RuleAction`](crate::model::RuleAction).
pub mod rule_action {

    /// A builder for [`RuleAction`](crate::model::RuleAction).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_type: std::option::Option<crate::model::ActionType>,
        pub(crate) task_action: std::option::Option<crate::model::TaskActionDefinition>,
        pub(crate) event_bridge_action:
            std::option::Option<crate::model::EventBridgeActionDefinition>,
        pub(crate) assign_contact_category_action:
            std::option::Option<crate::model::AssignContactCategoryActionDefinition>,
        pub(crate) send_notification_action:
            std::option::Option<crate::model::SendNotificationActionDefinition>,
    }
    impl Builder {
        /// <p>The type of action that creates a rule.</p>
        pub fn action_type(mut self, input: crate::model::ActionType) -> Self {
            self.action_type = Some(input);
            self
        }
        /// <p>The type of action that creates a rule.</p>
        pub fn set_action_type(
            mut self,
            input: std::option::Option<crate::model::ActionType>,
        ) -> Self {
            self.action_type = input;
            self
        }
        /// <p>Information about the task action. This field is required if <code>TriggerEventSource</code> is one of the following values: <code>OnZendeskTicketCreate</code> | <code>OnZendeskTicketStatusUpdate</code> | <code>OnSalesforceCaseCreate</code> </p>
        pub fn task_action(mut self, input: crate::model::TaskActionDefinition) -> Self {
            self.task_action = Some(input);
            self
        }
        /// <p>Information about the task action. This field is required if <code>TriggerEventSource</code> is one of the following values: <code>OnZendeskTicketCreate</code> | <code>OnZendeskTicketStatusUpdate</code> | <code>OnSalesforceCaseCreate</code> </p>
        pub fn set_task_action(
            mut self,
            input: std::option::Option<crate::model::TaskActionDefinition>,
        ) -> Self {
            self.task_action = input;
            self
        }
        /// <p>Information about the EventBridge action.</p>
        pub fn event_bridge_action(
            mut self,
            input: crate::model::EventBridgeActionDefinition,
        ) -> Self {
            self.event_bridge_action = Some(input);
            self
        }
        /// <p>Information about the EventBridge action.</p>
        pub fn set_event_bridge_action(
            mut self,
            input: std::option::Option<crate::model::EventBridgeActionDefinition>,
        ) -> Self {
            self.event_bridge_action = input;
            self
        }
        /// <p>Information about the contact category action.</p>
        pub fn assign_contact_category_action(
            mut self,
            input: crate::model::AssignContactCategoryActionDefinition,
        ) -> Self {
            self.assign_contact_category_action = Some(input);
            self
        }
        /// <p>Information about the contact category action.</p>
        pub fn set_assign_contact_category_action(
            mut self,
            input: std::option::Option<crate::model::AssignContactCategoryActionDefinition>,
        ) -> Self {
            self.assign_contact_category_action = input;
            self
        }
        /// <p>Information about the send notification action.</p>
        pub fn send_notification_action(
            mut self,
            input: crate::model::SendNotificationActionDefinition,
        ) -> Self {
            self.send_notification_action = Some(input);
            self
        }
        /// <p>Information about the send notification action.</p>
        pub fn set_send_notification_action(
            mut self,
            input: std::option::Option<crate::model::SendNotificationActionDefinition>,
        ) -> Self {
            self.send_notification_action = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleAction`](crate::model::RuleAction).
        pub fn build(self) -> crate::model::RuleAction {
            crate::model::RuleAction {
                action_type: self.action_type,
                task_action: self.task_action,
                event_bridge_action: self.event_bridge_action,
                assign_contact_category_action: self.assign_contact_category_action,
                send_notification_action: self.send_notification_action,
            }
        }
    }
}
impl RuleAction {
    /// Creates a new builder-style object to manufacture [`RuleAction`](crate::model::RuleAction).
    pub fn builder() -> crate::model::rule_action::Builder {
        crate::model::rule_action::Builder::default()
    }
}

/// <p>Information about the send notification action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SendNotificationActionDefinition {
    /// <p>Notification delivery method.</p>
    #[doc(hidden)]
    pub delivery_method: std::option::Option<crate::model::NotificationDeliveryType>,
    /// <p>The subject of the email if the delivery method is <code>EMAIL</code>. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
    #[doc(hidden)]
    pub subject: std::option::Option<std::string::String>,
    /// <p>Notification content. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>Content type format.</p>
    #[doc(hidden)]
    pub content_type: std::option::Option<crate::model::NotificationContentType>,
    /// <p>Notification recipient.</p>
    #[doc(hidden)]
    pub recipient: std::option::Option<crate::model::NotificationRecipientType>,
}
impl SendNotificationActionDefinition {
    /// <p>Notification delivery method.</p>
    pub fn delivery_method(&self) -> std::option::Option<&crate::model::NotificationDeliveryType> {
        self.delivery_method.as_ref()
    }
    /// <p>The subject of the email if the delivery method is <code>EMAIL</code>. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
    pub fn subject(&self) -> std::option::Option<&str> {
        self.subject.as_deref()
    }
    /// <p>Notification content. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>Content type format.</p>
    pub fn content_type(&self) -> std::option::Option<&crate::model::NotificationContentType> {
        self.content_type.as_ref()
    }
    /// <p>Notification recipient.</p>
    pub fn recipient(&self) -> std::option::Option<&crate::model::NotificationRecipientType> {
        self.recipient.as_ref()
    }
}
/// See [`SendNotificationActionDefinition`](crate::model::SendNotificationActionDefinition).
pub mod send_notification_action_definition {

    /// A builder for [`SendNotificationActionDefinition`](crate::model::SendNotificationActionDefinition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delivery_method: std::option::Option<crate::model::NotificationDeliveryType>,
        pub(crate) subject: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<crate::model::NotificationContentType>,
        pub(crate) recipient: std::option::Option<crate::model::NotificationRecipientType>,
    }
    impl Builder {
        /// <p>Notification delivery method.</p>
        pub fn delivery_method(mut self, input: crate::model::NotificationDeliveryType) -> Self {
            self.delivery_method = Some(input);
            self
        }
        /// <p>Notification delivery method.</p>
        pub fn set_delivery_method(
            mut self,
            input: std::option::Option<crate::model::NotificationDeliveryType>,
        ) -> Self {
            self.delivery_method = input;
            self
        }
        /// <p>The subject of the email if the delivery method is <code>EMAIL</code>. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
        pub fn subject(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject = Some(input.into());
            self
        }
        /// <p>The subject of the email if the delivery method is <code>EMAIL</code>. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
        pub fn set_subject(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject = input;
            self
        }
        /// <p>Notification content. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>Notification content. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>Content type format.</p>
        pub fn content_type(mut self, input: crate::model::NotificationContentType) -> Self {
            self.content_type = Some(input);
            self
        }
        /// <p>Content type format.</p>
        pub fn set_content_type(
            mut self,
            input: std::option::Option<crate::model::NotificationContentType>,
        ) -> Self {
            self.content_type = input;
            self
        }
        /// <p>Notification recipient.</p>
        pub fn recipient(mut self, input: crate::model::NotificationRecipientType) -> Self {
            self.recipient = Some(input);
            self
        }
        /// <p>Notification recipient.</p>
        pub fn set_recipient(
            mut self,
            input: std::option::Option<crate::model::NotificationRecipientType>,
        ) -> Self {
            self.recipient = input;
            self
        }
        /// Consumes the builder and constructs a [`SendNotificationActionDefinition`](crate::model::SendNotificationActionDefinition).
        pub fn build(self) -> crate::model::SendNotificationActionDefinition {
            crate::model::SendNotificationActionDefinition {
                delivery_method: self.delivery_method,
                subject: self.subject,
                content: self.content,
                content_type: self.content_type,
                recipient: self.recipient,
            }
        }
    }
}
impl SendNotificationActionDefinition {
    /// Creates a new builder-style object to manufacture [`SendNotificationActionDefinition`](crate::model::SendNotificationActionDefinition).
    pub fn builder() -> crate::model::send_notification_action_definition::Builder {
        crate::model::send_notification_action_definition::Builder::default()
    }
}

/// <p>The type of notification recipient.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NotificationRecipientType {
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }. Amazon Connect users with the specified tags will be notified.</p>
    #[doc(hidden)]
    pub user_tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A list of user IDs.</p>
    #[doc(hidden)]
    pub user_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl NotificationRecipientType {
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }. Amazon Connect users with the specified tags will be notified.</p>
    pub fn user_tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.user_tags.as_ref()
    }
    /// <p>A list of user IDs.</p>
    pub fn user_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.user_ids.as_deref()
    }
}
/// See [`NotificationRecipientType`](crate::model::NotificationRecipientType).
pub mod notification_recipient_type {

    /// A builder for [`NotificationRecipientType`](crate::model::NotificationRecipientType).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) user_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Adds a key-value pair to `user_tags`.
        ///
        /// To override the contents of this collection use [`set_user_tags`](Self::set_user_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }. Amazon Connect users with the specified tags will be notified.</p>
        pub fn user_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.user_tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.user_tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }. Amazon Connect users with the specified tags will be notified.</p>
        pub fn set_user_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.user_tags = input;
            self
        }
        /// Appends an item to `user_ids`.
        ///
        /// To override the contents of this collection use [`set_user_ids`](Self::set_user_ids).
        ///
        /// <p>A list of user IDs.</p>
        pub fn user_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.user_ids.unwrap_or_default();
            v.push(input.into());
            self.user_ids = Some(v);
            self
        }
        /// <p>A list of user IDs.</p>
        pub fn set_user_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.user_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`NotificationRecipientType`](crate::model::NotificationRecipientType).
        pub fn build(self) -> crate::model::NotificationRecipientType {
            crate::model::NotificationRecipientType {
                user_tags: self.user_tags,
                user_ids: self.user_ids,
            }
        }
    }
}
impl NotificationRecipientType {
    /// Creates a new builder-style object to manufacture [`NotificationRecipientType`](crate::model::NotificationRecipientType).
    pub fn builder() -> crate::model::notification_recipient_type::Builder {
        crate::model::notification_recipient_type::Builder::default()
    }
}

/// When writing a match expression against `NotificationContentType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let notificationcontenttype = unimplemented!();
/// match notificationcontenttype {
///     NotificationContentType::PlainText => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `notificationcontenttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NotificationContentType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NotificationContentType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NotificationContentType::NewFeature` is defined.
/// Specifically, when `notificationcontenttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NotificationContentType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotificationContentType {
    #[allow(missing_docs)] // documentation missing in model
    PlainText,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NotificationContentType {
    fn from(s: &str) -> Self {
        match s {
            "PLAIN_TEXT" => NotificationContentType::PlainText,
            other => NotificationContentType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for NotificationContentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotificationContentType::from(s))
    }
}
impl NotificationContentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotificationContentType::PlainText => "PLAIN_TEXT",
            NotificationContentType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PLAIN_TEXT"]
    }
}
impl AsRef<str> for NotificationContentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `NotificationDeliveryType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let notificationdeliverytype = unimplemented!();
/// match notificationdeliverytype {
///     NotificationDeliveryType::Email => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `notificationdeliverytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NotificationDeliveryType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NotificationDeliveryType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NotificationDeliveryType::NewFeature` is defined.
/// Specifically, when `notificationdeliverytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NotificationDeliveryType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotificationDeliveryType {
    #[allow(missing_docs)] // documentation missing in model
    Email,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NotificationDeliveryType {
    fn from(s: &str) -> Self {
        match s {
            "EMAIL" => NotificationDeliveryType::Email,
            other => NotificationDeliveryType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for NotificationDeliveryType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotificationDeliveryType::from(s))
    }
}
impl NotificationDeliveryType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotificationDeliveryType::Email => "EMAIL",
            NotificationDeliveryType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EMAIL"]
    }
}
impl AsRef<str> for NotificationDeliveryType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>This action must be set if <code>TriggerEventSource</code> is one of the following values: <code>OnPostCallAnalysisAvailable</code> | <code>OnRealTimeCallAnalysisAvailable</code> | <code>OnPostChatAnalysisAvailable</code>. Contact is categorized using the rule name.</p>
/// <p> <code>RuleName</code> is used as <code>ContactCategory</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssignContactCategoryActionDefinition {}
/// See [`AssignContactCategoryActionDefinition`](crate::model::AssignContactCategoryActionDefinition).
pub mod assign_contact_category_action_definition {

    /// A builder for [`AssignContactCategoryActionDefinition`](crate::model::AssignContactCategoryActionDefinition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`AssignContactCategoryActionDefinition`](crate::model::AssignContactCategoryActionDefinition).
        pub fn build(self) -> crate::model::AssignContactCategoryActionDefinition {
            crate::model::AssignContactCategoryActionDefinition {}
        }
    }
}
impl AssignContactCategoryActionDefinition {
    /// Creates a new builder-style object to manufacture [`AssignContactCategoryActionDefinition`](crate::model::AssignContactCategoryActionDefinition).
    pub fn builder() -> crate::model::assign_contact_category_action_definition::Builder {
        crate::model::assign_contact_category_action_definition::Builder::default()
    }
}

/// <p>The EventBridge action definition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventBridgeActionDefinition {
    /// <p>The name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl EventBridgeActionDefinition {
    /// <p>The name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`EventBridgeActionDefinition`](crate::model::EventBridgeActionDefinition).
pub mod event_bridge_action_definition {

    /// A builder for [`EventBridgeActionDefinition`](crate::model::EventBridgeActionDefinition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`EventBridgeActionDefinition`](crate::model::EventBridgeActionDefinition).
        pub fn build(self) -> crate::model::EventBridgeActionDefinition {
            crate::model::EventBridgeActionDefinition { name: self.name }
        }
    }
}
impl EventBridgeActionDefinition {
    /// Creates a new builder-style object to manufacture [`EventBridgeActionDefinition`](crate::model::EventBridgeActionDefinition).
    pub fn builder() -> crate::model::event_bridge_action_definition::Builder {
        crate::model::event_bridge_action_definition::Builder::default()
    }
}

/// <p>Information about the task action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskActionDefinition {
    /// <p>The name. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow.</p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
    /// <p>Information about the reference when the <code>referenceType</code> is <code>URL</code>. Otherwise, null. (Supports variable injection in the <code>Value</code> field.)</p>
    #[doc(hidden)]
    pub references: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::Reference>,
    >,
}
impl TaskActionDefinition {
    /// <p>The name. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The identifier of the flow.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
    /// <p>Information about the reference when the <code>referenceType</code> is <code>URL</code>. Otherwise, null. (Supports variable injection in the <code>Value</code> field.)</p>
    pub fn references(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, crate::model::Reference>>
    {
        self.references.as_ref()
    }
}
/// See [`TaskActionDefinition`](crate::model::TaskActionDefinition).
pub mod task_action_definition {

    /// A builder for [`TaskActionDefinition`](crate::model::TaskActionDefinition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
        pub(crate) references: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::Reference>,
        >,
    }
    impl Builder {
        /// <p>The name. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description. Supports variable injection. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath reference</a> in the <i>Amazon Connect Administrators Guide</i>.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// Adds a key-value pair to `references`.
        ///
        /// To override the contents of this collection use [`set_references`](Self::set_references).
        ///
        /// <p>Information about the reference when the <code>referenceType</code> is <code>URL</code>. Otherwise, null. (Supports variable injection in the <code>Value</code> field.)</p>
        pub fn references(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::Reference,
        ) -> Self {
            let mut hash_map = self.references.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.references = Some(hash_map);
            self
        }
        /// <p>Information about the reference when the <code>referenceType</code> is <code>URL</code>. Otherwise, null. (Supports variable injection in the <code>Value</code> field.)</p>
        pub fn set_references(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::Reference>,
            >,
        ) -> Self {
            self.references = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskActionDefinition`](crate::model::TaskActionDefinition).
        pub fn build(self) -> crate::model::TaskActionDefinition {
            crate::model::TaskActionDefinition {
                name: self.name,
                description: self.description,
                contact_flow_id: self.contact_flow_id,
                references: self.references,
            }
        }
    }
}
impl TaskActionDefinition {
    /// Creates a new builder-style object to manufacture [`TaskActionDefinition`](crate::model::TaskActionDefinition).
    pub fn builder() -> crate::model::task_action_definition::Builder {
        crate::model::task_action_definition::Builder::default()
    }
}

/// <p>Well-formed data on a contact, used by agents to complete a contact request. You can have up to 4,096 UTF-8 bytes across all references for a contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Reference {
    /// <p>A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The type of the reference. <code>DATE</code> must be of type Epoch timestamp. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ReferenceType>,
}
impl Reference {
    /// <p>A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The type of the reference. <code>DATE</code> must be of type Epoch timestamp. </p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ReferenceType> {
        self.r#type.as_ref()
    }
}
/// See [`Reference`](crate::model::Reference).
pub mod reference {

    /// A builder for [`Reference`](crate::model::Reference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ReferenceType>,
    }
    impl Builder {
        /// <p>A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The type of the reference. <code>DATE</code> must be of type Epoch timestamp. </p>
        pub fn r#type(mut self, input: crate::model::ReferenceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the reference. <code>DATE</code> must be of type Epoch timestamp. </p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ReferenceType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`Reference`](crate::model::Reference).
        pub fn build(self) -> crate::model::Reference {
            crate::model::Reference {
                value: self.value,
                r#type: self.r#type,
            }
        }
    }
}
impl Reference {
    /// Creates a new builder-style object to manufacture [`Reference`](crate::model::Reference).
    pub fn builder() -> crate::model::reference::Builder {
        crate::model::reference::Builder::default()
    }
}

/// When writing a match expression against `ReferenceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let referencetype = unimplemented!();
/// match referencetype {
///     ReferenceType::Attachment => { /* ... */ },
///     ReferenceType::Date => { /* ... */ },
///     ReferenceType::Email => { /* ... */ },
///     ReferenceType::Number => { /* ... */ },
///     ReferenceType::String => { /* ... */ },
///     ReferenceType::Url => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `referencetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReferenceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReferenceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReferenceType::NewFeature` is defined.
/// Specifically, when `referencetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReferenceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReferenceType {
    #[allow(missing_docs)] // documentation missing in model
    Attachment,
    #[allow(missing_docs)] // documentation missing in model
    Date,
    #[allow(missing_docs)] // documentation missing in model
    Email,
    #[allow(missing_docs)] // documentation missing in model
    Number,
    #[allow(missing_docs)] // documentation missing in model
    String,
    #[allow(missing_docs)] // documentation missing in model
    Url,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReferenceType {
    fn from(s: &str) -> Self {
        match s {
            "ATTACHMENT" => ReferenceType::Attachment,
            "DATE" => ReferenceType::Date,
            "EMAIL" => ReferenceType::Email,
            "NUMBER" => ReferenceType::Number,
            "STRING" => ReferenceType::String,
            "URL" => ReferenceType::Url,
            other => ReferenceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ReferenceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReferenceType::from(s))
    }
}
impl ReferenceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReferenceType::Attachment => "ATTACHMENT",
            ReferenceType::Date => "DATE",
            ReferenceType::Email => "EMAIL",
            ReferenceType::Number => "NUMBER",
            ReferenceType::String => "STRING",
            ReferenceType::Url => "URL",
            ReferenceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ATTACHMENT", "DATE", "EMAIL", "NUMBER", "STRING", "URL"]
    }
}
impl AsRef<str> for ReferenceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ActionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let actiontype = unimplemented!();
/// match actiontype {
///     ActionType::AssignContactCategory => { /* ... */ },
///     ActionType::CreateTask => { /* ... */ },
///     ActionType::GenerateEventbridgeEvent => { /* ... */ },
///     ActionType::SendNotification => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `actiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ActionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ActionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ActionType::NewFeature` is defined.
/// Specifically, when `actiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ActionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ActionType {
    #[allow(missing_docs)] // documentation missing in model
    AssignContactCategory,
    #[allow(missing_docs)] // documentation missing in model
    CreateTask,
    #[allow(missing_docs)] // documentation missing in model
    GenerateEventbridgeEvent,
    #[allow(missing_docs)] // documentation missing in model
    SendNotification,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ActionType {
    fn from(s: &str) -> Self {
        match s {
            "ASSIGN_CONTACT_CATEGORY" => ActionType::AssignContactCategory,
            "CREATE_TASK" => ActionType::CreateTask,
            "GENERATE_EVENTBRIDGE_EVENT" => ActionType::GenerateEventbridgeEvent,
            "SEND_NOTIFICATION" => ActionType::SendNotification,
            other => ActionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ActionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ActionType::from(s))
    }
}
impl ActionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ActionType::AssignContactCategory => "ASSIGN_CONTACT_CATEGORY",
            ActionType::CreateTask => "CREATE_TASK",
            ActionType::GenerateEventbridgeEvent => "GENERATE_EVENTBRIDGE_EVENT",
            ActionType::SendNotification => "SEND_NOTIFICATION",
            ActionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ASSIGN_CONTACT_CATEGORY",
            "CREATE_TASK",
            "GENERATE_EVENTBRIDGE_EVENT",
            "SEND_NOTIFICATION",
        ]
    }
}
impl AsRef<str> for ActionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the queue and channel for which priority and delay can be set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RoutingProfileQueueConfig {
    /// <p>Contains information about a queue resource.</p>
    #[doc(hidden)]
    pub queue_reference: std::option::Option<crate::model::RoutingProfileQueueReference>,
    /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
    #[doc(hidden)]
    pub priority: std::option::Option<i32>,
    /// <p>The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    #[doc(hidden)]
    pub delay: std::option::Option<i32>,
}
impl RoutingProfileQueueConfig {
    /// <p>Contains information about a queue resource.</p>
    pub fn queue_reference(
        &self,
    ) -> std::option::Option<&crate::model::RoutingProfileQueueReference> {
        self.queue_reference.as_ref()
    }
    /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
    pub fn priority(&self) -> std::option::Option<i32> {
        self.priority
    }
    /// <p>The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub fn delay(&self) -> std::option::Option<i32> {
        self.delay
    }
}
/// See [`RoutingProfileQueueConfig`](crate::model::RoutingProfileQueueConfig).
pub mod routing_profile_queue_config {

    /// A builder for [`RoutingProfileQueueConfig`](crate::model::RoutingProfileQueueConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queue_reference: std::option::Option<crate::model::RoutingProfileQueueReference>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) delay: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Contains information about a queue resource.</p>
        pub fn queue_reference(
            mut self,
            input: crate::model::RoutingProfileQueueReference,
        ) -> Self {
            self.queue_reference = Some(input);
            self
        }
        /// <p>Contains information about a queue resource.</p>
        pub fn set_queue_reference(
            mut self,
            input: std::option::Option<crate::model::RoutingProfileQueueReference>,
        ) -> Self {
            self.queue_reference = input;
            self
        }
        /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn delay(mut self, input: i32) -> Self {
            self.delay = Some(input);
            self
        }
        /// <p>The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn set_delay(mut self, input: std::option::Option<i32>) -> Self {
            self.delay = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfileQueueConfig`](crate::model::RoutingProfileQueueConfig).
        pub fn build(self) -> crate::model::RoutingProfileQueueConfig {
            crate::model::RoutingProfileQueueConfig {
                queue_reference: self.queue_reference,
                priority: self.priority,
                delay: self.delay,
            }
        }
    }
}
impl RoutingProfileQueueConfig {
    /// Creates a new builder-style object to manufacture [`RoutingProfileQueueConfig`](crate::model::RoutingProfileQueueConfig).
    pub fn builder() -> crate::model::routing_profile_queue_config::Builder {
        crate::model::routing_profile_queue_config::Builder::default()
    }
}

/// <p>Contains the channel and queue identifier for a routing profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RoutingProfileQueueReference {
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
    #[doc(hidden)]
    pub channel: std::option::Option<crate::model::Channel>,
}
impl RoutingProfileQueueReference {
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
    pub fn channel(&self) -> std::option::Option<&crate::model::Channel> {
        self.channel.as_ref()
    }
}
/// See [`RoutingProfileQueueReference`](crate::model::RoutingProfileQueueReference).
pub mod routing_profile_queue_reference {

    /// A builder for [`RoutingProfileQueueReference`](crate::model::RoutingProfileQueueReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) channel: std::option::Option<crate::model::Channel>,
    }
    impl Builder {
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
        pub fn channel(mut self, input: crate::model::Channel) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
        pub fn set_channel(mut self, input: std::option::Option<crate::model::Channel>) -> Self {
            self.channel = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfileQueueReference`](crate::model::RoutingProfileQueueReference).
        pub fn build(self) -> crate::model::RoutingProfileQueueReference {
            crate::model::RoutingProfileQueueReference {
                queue_id: self.queue_id,
                channel: self.channel,
            }
        }
    }
}
impl RoutingProfileQueueReference {
    /// Creates a new builder-style object to manufacture [`RoutingProfileQueueReference`](crate::model::RoutingProfileQueueReference).
    pub fn builder() -> crate::model::routing_profile_queue_reference::Builder {
        crate::model::routing_profile_queue_reference::Builder::default()
    }
}

/// When writing a match expression against `Channel`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let channel = unimplemented!();
/// match channel {
///     Channel::Chat => { /* ... */ },
///     Channel::Task => { /* ... */ },
///     Channel::Voice => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `channel` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Channel::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Channel::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Channel::NewFeature` is defined.
/// Specifically, when `channel` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Channel::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Channel {
    #[allow(missing_docs)] // documentation missing in model
    Chat,
    #[allow(missing_docs)] // documentation missing in model
    Task,
    #[allow(missing_docs)] // documentation missing in model
    Voice,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Channel {
    fn from(s: &str) -> Self {
        match s {
            "CHAT" => Channel::Chat,
            "TASK" => Channel::Task,
            "VOICE" => Channel::Voice,
            other => Channel::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Channel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Channel::from(s))
    }
}
impl Channel {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Channel::Chat => "CHAT",
            Channel::Task => "TASK",
            Channel::Voice => "VOICE",
            Channel::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CHAT", "TASK", "VOICE"]
    }
}
impl AsRef<str> for Channel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about which channels are supported, and how many contacts an agent can have on a channel simultaneously.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MediaConcurrency {
    /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
    #[doc(hidden)]
    pub channel: std::option::Option<crate::model::Channel>,
    /// <p>The number of contacts an agent can have on a channel simultaneously.</p>
    /// <p>Valid Range for <code>VOICE</code>: Minimum value of 1. Maximum value of 1.</p>
    /// <p>Valid Range for <code>CHAT</code>: Minimum value of 1. Maximum value of 10.</p>
    /// <p>Valid Range for <code>TASK</code>: Minimum value of 1. Maximum value of 10.</p>
    #[doc(hidden)]
    pub concurrency: i32,
}
impl MediaConcurrency {
    /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
    pub fn channel(&self) -> std::option::Option<&crate::model::Channel> {
        self.channel.as_ref()
    }
    /// <p>The number of contacts an agent can have on a channel simultaneously.</p>
    /// <p>Valid Range for <code>VOICE</code>: Minimum value of 1. Maximum value of 1.</p>
    /// <p>Valid Range for <code>CHAT</code>: Minimum value of 1. Maximum value of 10.</p>
    /// <p>Valid Range for <code>TASK</code>: Minimum value of 1. Maximum value of 10.</p>
    pub fn concurrency(&self) -> i32 {
        self.concurrency
    }
}
/// See [`MediaConcurrency`](crate::model::MediaConcurrency).
pub mod media_concurrency {

    /// A builder for [`MediaConcurrency`](crate::model::MediaConcurrency).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel: std::option::Option<crate::model::Channel>,
        pub(crate) concurrency: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
        pub fn channel(mut self, input: crate::model::Channel) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
        pub fn set_channel(mut self, input: std::option::Option<crate::model::Channel>) -> Self {
            self.channel = input;
            self
        }
        /// <p>The number of contacts an agent can have on a channel simultaneously.</p>
        /// <p>Valid Range for <code>VOICE</code>: Minimum value of 1. Maximum value of 1.</p>
        /// <p>Valid Range for <code>CHAT</code>: Minimum value of 1. Maximum value of 10.</p>
        /// <p>Valid Range for <code>TASK</code>: Minimum value of 1. Maximum value of 10.</p>
        pub fn concurrency(mut self, input: i32) -> Self {
            self.concurrency = Some(input);
            self
        }
        /// <p>The number of contacts an agent can have on a channel simultaneously.</p>
        /// <p>Valid Range for <code>VOICE</code>: Minimum value of 1. Maximum value of 1.</p>
        /// <p>Valid Range for <code>CHAT</code>: Minimum value of 1. Maximum value of 10.</p>
        /// <p>Valid Range for <code>TASK</code>: Minimum value of 1. Maximum value of 10.</p>
        pub fn set_concurrency(mut self, input: std::option::Option<i32>) -> Self {
            self.concurrency = input;
            self
        }
        /// Consumes the builder and constructs a [`MediaConcurrency`](crate::model::MediaConcurrency).
        pub fn build(self) -> crate::model::MediaConcurrency {
            crate::model::MediaConcurrency {
                channel: self.channel,
                concurrency: self.concurrency.unwrap_or_default(),
            }
        }
    }
}
impl MediaConcurrency {
    /// Creates a new builder-style object to manufacture [`MediaConcurrency`](crate::model::MediaConcurrency).
    pub fn builder() -> crate::model::media_concurrency::Builder {
        crate::model::media_concurrency::Builder::default()
    }
}

/// <p>Contains configuration settings for a quick connect.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QuickConnectConfig {
    /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE). </p>
    #[doc(hidden)]
    pub quick_connect_type: std::option::Option<crate::model::QuickConnectType>,
    /// <p>The user configuration. This is required only if QuickConnectType is USER.</p>
    #[doc(hidden)]
    pub user_config: std::option::Option<crate::model::UserQuickConnectConfig>,
    /// <p>The queue configuration. This is required only if QuickConnectType is QUEUE.</p>
    #[doc(hidden)]
    pub queue_config: std::option::Option<crate::model::QueueQuickConnectConfig>,
    /// <p>The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.</p>
    #[doc(hidden)]
    pub phone_config: std::option::Option<crate::model::PhoneNumberQuickConnectConfig>,
}
impl QuickConnectConfig {
    /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE). </p>
    pub fn quick_connect_type(&self) -> std::option::Option<&crate::model::QuickConnectType> {
        self.quick_connect_type.as_ref()
    }
    /// <p>The user configuration. This is required only if QuickConnectType is USER.</p>
    pub fn user_config(&self) -> std::option::Option<&crate::model::UserQuickConnectConfig> {
        self.user_config.as_ref()
    }
    /// <p>The queue configuration. This is required only if QuickConnectType is QUEUE.</p>
    pub fn queue_config(&self) -> std::option::Option<&crate::model::QueueQuickConnectConfig> {
        self.queue_config.as_ref()
    }
    /// <p>The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.</p>
    pub fn phone_config(
        &self,
    ) -> std::option::Option<&crate::model::PhoneNumberQuickConnectConfig> {
        self.phone_config.as_ref()
    }
}
/// See [`QuickConnectConfig`](crate::model::QuickConnectConfig).
pub mod quick_connect_config {

    /// A builder for [`QuickConnectConfig`](crate::model::QuickConnectConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) quick_connect_type: std::option::Option<crate::model::QuickConnectType>,
        pub(crate) user_config: std::option::Option<crate::model::UserQuickConnectConfig>,
        pub(crate) queue_config: std::option::Option<crate::model::QueueQuickConnectConfig>,
        pub(crate) phone_config: std::option::Option<crate::model::PhoneNumberQuickConnectConfig>,
    }
    impl Builder {
        /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE). </p>
        pub fn quick_connect_type(mut self, input: crate::model::QuickConnectType) -> Self {
            self.quick_connect_type = Some(input);
            self
        }
        /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE). </p>
        pub fn set_quick_connect_type(
            mut self,
            input: std::option::Option<crate::model::QuickConnectType>,
        ) -> Self {
            self.quick_connect_type = input;
            self
        }
        /// <p>The user configuration. This is required only if QuickConnectType is USER.</p>
        pub fn user_config(mut self, input: crate::model::UserQuickConnectConfig) -> Self {
            self.user_config = Some(input);
            self
        }
        /// <p>The user configuration. This is required only if QuickConnectType is USER.</p>
        pub fn set_user_config(
            mut self,
            input: std::option::Option<crate::model::UserQuickConnectConfig>,
        ) -> Self {
            self.user_config = input;
            self
        }
        /// <p>The queue configuration. This is required only if QuickConnectType is QUEUE.</p>
        pub fn queue_config(mut self, input: crate::model::QueueQuickConnectConfig) -> Self {
            self.queue_config = Some(input);
            self
        }
        /// <p>The queue configuration. This is required only if QuickConnectType is QUEUE.</p>
        pub fn set_queue_config(
            mut self,
            input: std::option::Option<crate::model::QueueQuickConnectConfig>,
        ) -> Self {
            self.queue_config = input;
            self
        }
        /// <p>The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.</p>
        pub fn phone_config(mut self, input: crate::model::PhoneNumberQuickConnectConfig) -> Self {
            self.phone_config = Some(input);
            self
        }
        /// <p>The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.</p>
        pub fn set_phone_config(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberQuickConnectConfig>,
        ) -> Self {
            self.phone_config = input;
            self
        }
        /// Consumes the builder and constructs a [`QuickConnectConfig`](crate::model::QuickConnectConfig).
        pub fn build(self) -> crate::model::QuickConnectConfig {
            crate::model::QuickConnectConfig {
                quick_connect_type: self.quick_connect_type,
                user_config: self.user_config,
                queue_config: self.queue_config,
                phone_config: self.phone_config,
            }
        }
    }
}
impl QuickConnectConfig {
    /// Creates a new builder-style object to manufacture [`QuickConnectConfig`](crate::model::QuickConnectConfig).
    pub fn builder() -> crate::model::quick_connect_config::Builder {
        crate::model::quick_connect_config::Builder::default()
    }
}

/// <p>Contains information about a phone number for a quick connect.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PhoneNumberQuickConnectConfig {
    /// <p>The phone number in E.164 format.</p>
    #[doc(hidden)]
    pub phone_number: std::option::Option<std::string::String>,
}
impl PhoneNumberQuickConnectConfig {
    /// <p>The phone number in E.164 format.</p>
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
}
/// See [`PhoneNumberQuickConnectConfig`](crate::model::PhoneNumberQuickConnectConfig).
pub mod phone_number_quick_connect_config {

    /// A builder for [`PhoneNumberQuickConnectConfig`](crate::model::PhoneNumberQuickConnectConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The phone number in E.164 format.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>The phone number in E.164 format.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// Consumes the builder and constructs a [`PhoneNumberQuickConnectConfig`](crate::model::PhoneNumberQuickConnectConfig).
        pub fn build(self) -> crate::model::PhoneNumberQuickConnectConfig {
            crate::model::PhoneNumberQuickConnectConfig {
                phone_number: self.phone_number,
            }
        }
    }
}
impl PhoneNumberQuickConnectConfig {
    /// Creates a new builder-style object to manufacture [`PhoneNumberQuickConnectConfig`](crate::model::PhoneNumberQuickConnectConfig).
    pub fn builder() -> crate::model::phone_number_quick_connect_config::Builder {
        crate::model::phone_number_quick_connect_config::Builder::default()
    }
}

/// <p>Contains information about a queue for a quick connect. The flow must be of type Transfer to Queue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueueQuickConnectConfig {
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow.</p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
}
impl QueueQuickConnectConfig {
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The identifier of the flow.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
}
/// See [`QueueQuickConnectConfig`](crate::model::QueueQuickConnectConfig).
pub mod queue_quick_connect_config {

    /// A builder for [`QueueQuickConnectConfig`](crate::model::QueueQuickConnectConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// Consumes the builder and constructs a [`QueueQuickConnectConfig`](crate::model::QueueQuickConnectConfig).
        pub fn build(self) -> crate::model::QueueQuickConnectConfig {
            crate::model::QueueQuickConnectConfig {
                queue_id: self.queue_id,
                contact_flow_id: self.contact_flow_id,
            }
        }
    }
}
impl QueueQuickConnectConfig {
    /// Creates a new builder-style object to manufacture [`QueueQuickConnectConfig`](crate::model::QueueQuickConnectConfig).
    pub fn builder() -> crate::model::queue_quick_connect_config::Builder {
        crate::model::queue_quick_connect_config::Builder::default()
    }
}

/// <p>Contains information about the quick connect configuration settings for a user. The contact flow must be of type Transfer to Agent.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserQuickConnectConfig {
    /// <p>The identifier of the user.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow.</p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
}
impl UserQuickConnectConfig {
    /// <p>The identifier of the user.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The identifier of the flow.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
}
/// See [`UserQuickConnectConfig`](crate::model::UserQuickConnectConfig).
pub mod user_quick_connect_config {

    /// A builder for [`UserQuickConnectConfig`](crate::model::UserQuickConnectConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the user.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UserQuickConnectConfig`](crate::model::UserQuickConnectConfig).
        pub fn build(self) -> crate::model::UserQuickConnectConfig {
            crate::model::UserQuickConnectConfig {
                user_id: self.user_id,
                contact_flow_id: self.contact_flow_id,
            }
        }
    }
}
impl UserQuickConnectConfig {
    /// Creates a new builder-style object to manufacture [`UserQuickConnectConfig`](crate::model::UserQuickConnectConfig).
    pub fn builder() -> crate::model::user_quick_connect_config::Builder {
        crate::model::user_quick_connect_config::Builder::default()
    }
}

/// When writing a match expression against `QuickConnectType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let quickconnecttype = unimplemented!();
/// match quickconnecttype {
///     QuickConnectType::PhoneNumber => { /* ... */ },
///     QuickConnectType::Queue => { /* ... */ },
///     QuickConnectType::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `quickconnecttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QuickConnectType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QuickConnectType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QuickConnectType::NewFeature` is defined.
/// Specifically, when `quickconnecttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QuickConnectType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QuickConnectType {
    #[allow(missing_docs)] // documentation missing in model
    PhoneNumber,
    #[allow(missing_docs)] // documentation missing in model
    Queue,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for QuickConnectType {
    fn from(s: &str) -> Self {
        match s {
            "PHONE_NUMBER" => QuickConnectType::PhoneNumber,
            "QUEUE" => QuickConnectType::Queue,
            "USER" => QuickConnectType::User,
            other => QuickConnectType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for QuickConnectType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QuickConnectType::from(s))
    }
}
impl QuickConnectType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QuickConnectType::PhoneNumber => "PHONE_NUMBER",
            QuickConnectType::Queue => "QUEUE",
            QuickConnectType::User => "USER",
            QuickConnectType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PHONE_NUMBER", "QUEUE", "USER"]
    }
}
impl AsRef<str> for QuickConnectType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `QueueStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let queuestatus = unimplemented!();
/// match queuestatus {
///     QueueStatus::Disabled => { /* ... */ },
///     QueueStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `queuestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QueueStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QueueStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QueueStatus::NewFeature` is defined.
/// Specifically, when `queuestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QueueStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueueStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for QueueStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => QueueStatus::Disabled,
            "ENABLED" => QueueStatus::Enabled,
            other => QueueStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for QueueStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueueStatus::from(s))
    }
}
impl QueueStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueueStatus::Disabled => "DISABLED",
            QueueStatus::Enabled => "ENABLED",
            QueueStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for QueueStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OutboundCallerConfig {
    /// <p>The caller ID name.</p>
    #[doc(hidden)]
    pub outbound_caller_id_name: std::option::Option<std::string::String>,
    /// <p>The caller ID number.</p>
    #[doc(hidden)]
    pub outbound_caller_id_number_id: std::option::Option<std::string::String>,
    /// <p>The outbound whisper flow to be used during an outbound call.</p>
    #[doc(hidden)]
    pub outbound_flow_id: std::option::Option<std::string::String>,
}
impl OutboundCallerConfig {
    /// <p>The caller ID name.</p>
    pub fn outbound_caller_id_name(&self) -> std::option::Option<&str> {
        self.outbound_caller_id_name.as_deref()
    }
    /// <p>The caller ID number.</p>
    pub fn outbound_caller_id_number_id(&self) -> std::option::Option<&str> {
        self.outbound_caller_id_number_id.as_deref()
    }
    /// <p>The outbound whisper flow to be used during an outbound call.</p>
    pub fn outbound_flow_id(&self) -> std::option::Option<&str> {
        self.outbound_flow_id.as_deref()
    }
}
/// See [`OutboundCallerConfig`](crate::model::OutboundCallerConfig).
pub mod outbound_caller_config {

    /// A builder for [`OutboundCallerConfig`](crate::model::OutboundCallerConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) outbound_caller_id_name: std::option::Option<std::string::String>,
        pub(crate) outbound_caller_id_number_id: std::option::Option<std::string::String>,
        pub(crate) outbound_flow_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The caller ID name.</p>
        pub fn outbound_caller_id_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.outbound_caller_id_name = Some(input.into());
            self
        }
        /// <p>The caller ID name.</p>
        pub fn set_outbound_caller_id_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.outbound_caller_id_name = input;
            self
        }
        /// <p>The caller ID number.</p>
        pub fn outbound_caller_id_number_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.outbound_caller_id_number_id = Some(input.into());
            self
        }
        /// <p>The caller ID number.</p>
        pub fn set_outbound_caller_id_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.outbound_caller_id_number_id = input;
            self
        }
        /// <p>The outbound whisper flow to be used during an outbound call.</p>
        pub fn outbound_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.outbound_flow_id = Some(input.into());
            self
        }
        /// <p>The outbound whisper flow to be used during an outbound call.</p>
        pub fn set_outbound_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.outbound_flow_id = input;
            self
        }
        /// Consumes the builder and constructs a [`OutboundCallerConfig`](crate::model::OutboundCallerConfig).
        pub fn build(self) -> crate::model::OutboundCallerConfig {
            crate::model::OutboundCallerConfig {
                outbound_caller_id_name: self.outbound_caller_id_name,
                outbound_caller_id_number_id: self.outbound_caller_id_number_id,
                outbound_flow_id: self.outbound_flow_id,
            }
        }
    }
}
impl OutboundCallerConfig {
    /// Creates a new builder-style object to manufacture [`OutboundCallerConfig`](crate::model::OutboundCallerConfig).
    pub fn builder() -> crate::model::outbound_caller_config::Builder {
        crate::model::outbound_caller_config::Builder::default()
    }
}

/// <p>Configuration information for the chat participant role.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum UpdateParticipantRoleConfigChannelInfo {
    /// <p>Configuration information for the chat participant role.</p>
    Chat(crate::model::ChatParticipantRoleConfig),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl UpdateParticipantRoleConfigChannelInfo {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`Chat`](crate::model::UpdateParticipantRoleConfigChannelInfo::Chat), extracting the inner [`ChatParticipantRoleConfig`](crate::model::ChatParticipantRoleConfig).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_chat(&self) -> std::result::Result<&crate::model::ChatParticipantRoleConfig, &Self> {
        if let UpdateParticipantRoleConfigChannelInfo::Chat(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Chat`](crate::model::UpdateParticipantRoleConfigChannelInfo::Chat).
    pub fn is_chat(&self) -> bool {
        self.as_chat().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Configuration information for the chat participant role.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChatParticipantRoleConfig {
    /// <p>A list of participant timers. You can specify any unique combination of role and timer type. Duplicate entries error out the request with a 400.</p>
    #[doc(hidden)]
    pub participant_timer_config_list:
        std::option::Option<std::vec::Vec<crate::model::ParticipantTimerConfiguration>>,
}
impl ChatParticipantRoleConfig {
    /// <p>A list of participant timers. You can specify any unique combination of role and timer type. Duplicate entries error out the request with a 400.</p>
    pub fn participant_timer_config_list(
        &self,
    ) -> std::option::Option<&[crate::model::ParticipantTimerConfiguration]> {
        self.participant_timer_config_list.as_deref()
    }
}
/// See [`ChatParticipantRoleConfig`](crate::model::ChatParticipantRoleConfig).
pub mod chat_participant_role_config {

    /// A builder for [`ChatParticipantRoleConfig`](crate::model::ChatParticipantRoleConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) participant_timer_config_list:
            std::option::Option<std::vec::Vec<crate::model::ParticipantTimerConfiguration>>,
    }
    impl Builder {
        /// Appends an item to `participant_timer_config_list`.
        ///
        /// To override the contents of this collection use [`set_participant_timer_config_list`](Self::set_participant_timer_config_list).
        ///
        /// <p>A list of participant timers. You can specify any unique combination of role and timer type. Duplicate entries error out the request with a 400.</p>
        pub fn participant_timer_config_list(
            mut self,
            input: crate::model::ParticipantTimerConfiguration,
        ) -> Self {
            let mut v = self.participant_timer_config_list.unwrap_or_default();
            v.push(input);
            self.participant_timer_config_list = Some(v);
            self
        }
        /// <p>A list of participant timers. You can specify any unique combination of role and timer type. Duplicate entries error out the request with a 400.</p>
        pub fn set_participant_timer_config_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParticipantTimerConfiguration>>,
        ) -> Self {
            self.participant_timer_config_list = input;
            self
        }
        /// Consumes the builder and constructs a [`ChatParticipantRoleConfig`](crate::model::ChatParticipantRoleConfig).
        pub fn build(self) -> crate::model::ChatParticipantRoleConfig {
            crate::model::ChatParticipantRoleConfig {
                participant_timer_config_list: self.participant_timer_config_list,
            }
        }
    }
}
impl ChatParticipantRoleConfig {
    /// Creates a new builder-style object to manufacture [`ChatParticipantRoleConfig`](crate::model::ChatParticipantRoleConfig).
    pub fn builder() -> crate::model::chat_participant_role_config::Builder {
        crate::model::chat_participant_role_config::Builder::default()
    }
}

/// <p>Configuration information for the timer. After the timer configuration is set, it persists for the duration of the chat. It persists across new contacts in the chain, for example, transfer contacts.</p>
/// <p>For more information about how chat timeouts work, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/setup-chat-timeouts.html">Set up chat timeouts for human participants</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParticipantTimerConfiguration {
    /// <p>The role of the participant in the chat conversation.</p>
    #[doc(hidden)]
    pub participant_role: std::option::Option<crate::model::TimerEligibleParticipantRoles>,
    /// <p>The type of timer. <code>IDLE</code> indicates the timer applies for considering a human chat participant as idle. <code>DISCONNECT_NONCUSTOMER</code> indicates the timer applies to automatically disconnecting a chat participant due to idleness.</p>
    #[doc(hidden)]
    pub timer_type: std::option::Option<crate::model::ParticipantTimerType>,
    /// <p>The value of the timer. Either the timer action (Unset to delete the timer), or the duration of the timer in minutes. Only one value can be set.</p>
    #[doc(hidden)]
    pub timer_value: std::option::Option<crate::model::ParticipantTimerValue>,
}
impl ParticipantTimerConfiguration {
    /// <p>The role of the participant in the chat conversation.</p>
    pub fn participant_role(
        &self,
    ) -> std::option::Option<&crate::model::TimerEligibleParticipantRoles> {
        self.participant_role.as_ref()
    }
    /// <p>The type of timer. <code>IDLE</code> indicates the timer applies for considering a human chat participant as idle. <code>DISCONNECT_NONCUSTOMER</code> indicates the timer applies to automatically disconnecting a chat participant due to idleness.</p>
    pub fn timer_type(&self) -> std::option::Option<&crate::model::ParticipantTimerType> {
        self.timer_type.as_ref()
    }
    /// <p>The value of the timer. Either the timer action (Unset to delete the timer), or the duration of the timer in minutes. Only one value can be set.</p>
    pub fn timer_value(&self) -> std::option::Option<&crate::model::ParticipantTimerValue> {
        self.timer_value.as_ref()
    }
}
/// See [`ParticipantTimerConfiguration`](crate::model::ParticipantTimerConfiguration).
pub mod participant_timer_configuration {

    /// A builder for [`ParticipantTimerConfiguration`](crate::model::ParticipantTimerConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) participant_role:
            std::option::Option<crate::model::TimerEligibleParticipantRoles>,
        pub(crate) timer_type: std::option::Option<crate::model::ParticipantTimerType>,
        pub(crate) timer_value: std::option::Option<crate::model::ParticipantTimerValue>,
    }
    impl Builder {
        /// <p>The role of the participant in the chat conversation.</p>
        pub fn participant_role(
            mut self,
            input: crate::model::TimerEligibleParticipantRoles,
        ) -> Self {
            self.participant_role = Some(input);
            self
        }
        /// <p>The role of the participant in the chat conversation.</p>
        pub fn set_participant_role(
            mut self,
            input: std::option::Option<crate::model::TimerEligibleParticipantRoles>,
        ) -> Self {
            self.participant_role = input;
            self
        }
        /// <p>The type of timer. <code>IDLE</code> indicates the timer applies for considering a human chat participant as idle. <code>DISCONNECT_NONCUSTOMER</code> indicates the timer applies to automatically disconnecting a chat participant due to idleness.</p>
        pub fn timer_type(mut self, input: crate::model::ParticipantTimerType) -> Self {
            self.timer_type = Some(input);
            self
        }
        /// <p>The type of timer. <code>IDLE</code> indicates the timer applies for considering a human chat participant as idle. <code>DISCONNECT_NONCUSTOMER</code> indicates the timer applies to automatically disconnecting a chat participant due to idleness.</p>
        pub fn set_timer_type(
            mut self,
            input: std::option::Option<crate::model::ParticipantTimerType>,
        ) -> Self {
            self.timer_type = input;
            self
        }
        /// <p>The value of the timer. Either the timer action (Unset to delete the timer), or the duration of the timer in minutes. Only one value can be set.</p>
        pub fn timer_value(mut self, input: crate::model::ParticipantTimerValue) -> Self {
            self.timer_value = Some(input);
            self
        }
        /// <p>The value of the timer. Either the timer action (Unset to delete the timer), or the duration of the timer in minutes. Only one value can be set.</p>
        pub fn set_timer_value(
            mut self,
            input: std::option::Option<crate::model::ParticipantTimerValue>,
        ) -> Self {
            self.timer_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ParticipantTimerConfiguration`](crate::model::ParticipantTimerConfiguration).
        pub fn build(self) -> crate::model::ParticipantTimerConfiguration {
            crate::model::ParticipantTimerConfiguration {
                participant_role: self.participant_role,
                timer_type: self.timer_type,
                timer_value: self.timer_value,
            }
        }
    }
}
impl ParticipantTimerConfiguration {
    /// Creates a new builder-style object to manufacture [`ParticipantTimerConfiguration`](crate::model::ParticipantTimerConfiguration).
    pub fn builder() -> crate::model::participant_timer_configuration::Builder {
        crate::model::participant_timer_configuration::Builder::default()
    }
}

/// <p>The value of the timer. Either the timer action (<code>Unset</code> to delete the timer), or the duration of the timer in minutes. Only one value can be set.</p>
/// <p>For more information about how chat timeouts work, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/setup-chat-timeouts.html">Set up chat timeouts for human participants</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ParticipantTimerValue {
    /// <p>The timer action. Currently only one value is allowed: <code>Unset</code>. It deletes a timer.</p>
    ParticipantTimerAction(crate::model::ParticipantTimerAction),
    /// <p>The duration of a timer, in minutes. </p>
    ParticipantTimerDurationInMinutes(i32),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ParticipantTimerValue {
    /// Tries to convert the enum instance into [`ParticipantTimerAction`](crate::model::ParticipantTimerValue::ParticipantTimerAction), extracting the inner [`ParticipantTimerAction`](crate::model::ParticipantTimerAction).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_participant_timer_action(
        &self,
    ) -> std::result::Result<&crate::model::ParticipantTimerAction, &Self> {
        if let ParticipantTimerValue::ParticipantTimerAction(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ParticipantTimerAction`](crate::model::ParticipantTimerValue::ParticipantTimerAction).
    pub fn is_participant_timer_action(&self) -> bool {
        self.as_participant_timer_action().is_ok()
    }
    /// Tries to convert the enum instance into [`ParticipantTimerDurationInMinutes`](crate::model::ParticipantTimerValue::ParticipantTimerDurationInMinutes), extracting the inner [`i32`](i32).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_participant_timer_duration_in_minutes(&self) -> std::result::Result<&i32, &Self> {
        if let ParticipantTimerValue::ParticipantTimerDurationInMinutes(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ParticipantTimerDurationInMinutes`](crate::model::ParticipantTimerValue::ParticipantTimerDurationInMinutes).
    pub fn is_participant_timer_duration_in_minutes(&self) -> bool {
        self.as_participant_timer_duration_in_minutes().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// When writing a match expression against `ParticipantTimerAction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let participanttimeraction = unimplemented!();
/// match participanttimeraction {
///     ParticipantTimerAction::Unset => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `participanttimeraction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ParticipantTimerAction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ParticipantTimerAction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ParticipantTimerAction::NewFeature` is defined.
/// Specifically, when `participanttimeraction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ParticipantTimerAction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParticipantTimerAction {
    #[allow(missing_docs)] // documentation missing in model
    Unset,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ParticipantTimerAction {
    fn from(s: &str) -> Self {
        match s {
            "Unset" => ParticipantTimerAction::Unset,
            other => {
                ParticipantTimerAction::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ParticipantTimerAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ParticipantTimerAction::from(s))
    }
}
impl ParticipantTimerAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ParticipantTimerAction::Unset => "Unset",
            ParticipantTimerAction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Unset"]
    }
}
impl AsRef<str> for ParticipantTimerAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ParticipantTimerType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let participanttimertype = unimplemented!();
/// match participanttimertype {
///     ParticipantTimerType::DisconnectNoncustomer => { /* ... */ },
///     ParticipantTimerType::Idle => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `participanttimertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ParticipantTimerType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ParticipantTimerType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ParticipantTimerType::NewFeature` is defined.
/// Specifically, when `participanttimertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ParticipantTimerType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParticipantTimerType {
    #[allow(missing_docs)] // documentation missing in model
    DisconnectNoncustomer,
    #[allow(missing_docs)] // documentation missing in model
    Idle,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ParticipantTimerType {
    fn from(s: &str) -> Self {
        match s {
            "DISCONNECT_NONCUSTOMER" => ParticipantTimerType::DisconnectNoncustomer,
            "IDLE" => ParticipantTimerType::Idle,
            other => {
                ParticipantTimerType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ParticipantTimerType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ParticipantTimerType::from(s))
    }
}
impl ParticipantTimerType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ParticipantTimerType::DisconnectNoncustomer => "DISCONNECT_NONCUSTOMER",
            ParticipantTimerType::Idle => "IDLE",
            ParticipantTimerType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISCONNECT_NONCUSTOMER", "IDLE"]
    }
}
impl AsRef<str> for ParticipantTimerType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TimerEligibleParticipantRoles`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let timereligibleparticipantroles = unimplemented!();
/// match timereligibleparticipantroles {
///     TimerEligibleParticipantRoles::Agent => { /* ... */ },
///     TimerEligibleParticipantRoles::Customer => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `timereligibleparticipantroles` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TimerEligibleParticipantRoles::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TimerEligibleParticipantRoles::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TimerEligibleParticipantRoles::NewFeature` is defined.
/// Specifically, when `timereligibleparticipantroles` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TimerEligibleParticipantRoles::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TimerEligibleParticipantRoles {
    #[allow(missing_docs)] // documentation missing in model
    Agent,
    #[allow(missing_docs)] // documentation missing in model
    Customer,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TimerEligibleParticipantRoles {
    fn from(s: &str) -> Self {
        match s {
            "AGENT" => TimerEligibleParticipantRoles::Agent,
            "CUSTOMER" => TimerEligibleParticipantRoles::Customer,
            other => TimerEligibleParticipantRoles::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for TimerEligibleParticipantRoles {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TimerEligibleParticipantRoles::from(s))
    }
}
impl TimerEligibleParticipantRoles {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TimerEligibleParticipantRoles::Agent => "AGENT",
            TimerEligibleParticipantRoles::Customer => "CUSTOMER",
            TimerEligibleParticipantRoles::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AGENT", "CUSTOMER"]
    }
}
impl AsRef<str> for TimerEligibleParticipantRoles {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The storage configuration for the instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceStorageConfig {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    #[doc(hidden)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>A valid storage type.</p>
    #[doc(hidden)]
    pub storage_type: std::option::Option<crate::model::StorageType>,
    /// <p>The S3 bucket configuration.</p>
    #[doc(hidden)]
    pub s3_config: std::option::Option<crate::model::S3Config>,
    /// <p>The configuration of the Kinesis video stream.</p>
    #[doc(hidden)]
    pub kinesis_video_stream_config: std::option::Option<crate::model::KinesisVideoStreamConfig>,
    /// <p>The configuration of the Kinesis data stream.</p>
    #[doc(hidden)]
    pub kinesis_stream_config: std::option::Option<crate::model::KinesisStreamConfig>,
    /// <p>The configuration of the Kinesis Firehose delivery stream.</p>
    #[doc(hidden)]
    pub kinesis_firehose_config: std::option::Option<crate::model::KinesisFirehoseConfig>,
}
impl InstanceStorageConfig {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    pub fn association_id(&self) -> std::option::Option<&str> {
        self.association_id.as_deref()
    }
    /// <p>A valid storage type.</p>
    pub fn storage_type(&self) -> std::option::Option<&crate::model::StorageType> {
        self.storage_type.as_ref()
    }
    /// <p>The S3 bucket configuration.</p>
    pub fn s3_config(&self) -> std::option::Option<&crate::model::S3Config> {
        self.s3_config.as_ref()
    }
    /// <p>The configuration of the Kinesis video stream.</p>
    pub fn kinesis_video_stream_config(
        &self,
    ) -> std::option::Option<&crate::model::KinesisVideoStreamConfig> {
        self.kinesis_video_stream_config.as_ref()
    }
    /// <p>The configuration of the Kinesis data stream.</p>
    pub fn kinesis_stream_config(&self) -> std::option::Option<&crate::model::KinesisStreamConfig> {
        self.kinesis_stream_config.as_ref()
    }
    /// <p>The configuration of the Kinesis Firehose delivery stream.</p>
    pub fn kinesis_firehose_config(
        &self,
    ) -> std::option::Option<&crate::model::KinesisFirehoseConfig> {
        self.kinesis_firehose_config.as_ref()
    }
}
/// See [`InstanceStorageConfig`](crate::model::InstanceStorageConfig).
pub mod instance_storage_config {

    /// A builder for [`InstanceStorageConfig`](crate::model::InstanceStorageConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) storage_type: std::option::Option<crate::model::StorageType>,
        pub(crate) s3_config: std::option::Option<crate::model::S3Config>,
        pub(crate) kinesis_video_stream_config:
            std::option::Option<crate::model::KinesisVideoStreamConfig>,
        pub(crate) kinesis_stream_config: std::option::Option<crate::model::KinesisStreamConfig>,
        pub(crate) kinesis_firehose_config:
            std::option::Option<crate::model::KinesisFirehoseConfig>,
    }
    impl Builder {
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>A valid storage type.</p>
        pub fn storage_type(mut self, input: crate::model::StorageType) -> Self {
            self.storage_type = Some(input);
            self
        }
        /// <p>A valid storage type.</p>
        pub fn set_storage_type(
            mut self,
            input: std::option::Option<crate::model::StorageType>,
        ) -> Self {
            self.storage_type = input;
            self
        }
        /// <p>The S3 bucket configuration.</p>
        pub fn s3_config(mut self, input: crate::model::S3Config) -> Self {
            self.s3_config = Some(input);
            self
        }
        /// <p>The S3 bucket configuration.</p>
        pub fn set_s3_config(mut self, input: std::option::Option<crate::model::S3Config>) -> Self {
            self.s3_config = input;
            self
        }
        /// <p>The configuration of the Kinesis video stream.</p>
        pub fn kinesis_video_stream_config(
            mut self,
            input: crate::model::KinesisVideoStreamConfig,
        ) -> Self {
            self.kinesis_video_stream_config = Some(input);
            self
        }
        /// <p>The configuration of the Kinesis video stream.</p>
        pub fn set_kinesis_video_stream_config(
            mut self,
            input: std::option::Option<crate::model::KinesisVideoStreamConfig>,
        ) -> Self {
            self.kinesis_video_stream_config = input;
            self
        }
        /// <p>The configuration of the Kinesis data stream.</p>
        pub fn kinesis_stream_config(mut self, input: crate::model::KinesisStreamConfig) -> Self {
            self.kinesis_stream_config = Some(input);
            self
        }
        /// <p>The configuration of the Kinesis data stream.</p>
        pub fn set_kinesis_stream_config(
            mut self,
            input: std::option::Option<crate::model::KinesisStreamConfig>,
        ) -> Self {
            self.kinesis_stream_config = input;
            self
        }
        /// <p>The configuration of the Kinesis Firehose delivery stream.</p>
        pub fn kinesis_firehose_config(
            mut self,
            input: crate::model::KinesisFirehoseConfig,
        ) -> Self {
            self.kinesis_firehose_config = Some(input);
            self
        }
        /// <p>The configuration of the Kinesis Firehose delivery stream.</p>
        pub fn set_kinesis_firehose_config(
            mut self,
            input: std::option::Option<crate::model::KinesisFirehoseConfig>,
        ) -> Self {
            self.kinesis_firehose_config = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceStorageConfig`](crate::model::InstanceStorageConfig).
        pub fn build(self) -> crate::model::InstanceStorageConfig {
            crate::model::InstanceStorageConfig {
                association_id: self.association_id,
                storage_type: self.storage_type,
                s3_config: self.s3_config,
                kinesis_video_stream_config: self.kinesis_video_stream_config,
                kinesis_stream_config: self.kinesis_stream_config,
                kinesis_firehose_config: self.kinesis_firehose_config,
            }
        }
    }
}
impl InstanceStorageConfig {
    /// Creates a new builder-style object to manufacture [`InstanceStorageConfig`](crate::model::InstanceStorageConfig).
    pub fn builder() -> crate::model::instance_storage_config::Builder {
        crate::model::instance_storage_config::Builder::default()
    }
}

/// <p>Configuration information of a Kinesis Data Firehose delivery stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KinesisFirehoseConfig {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    #[doc(hidden)]
    pub firehose_arn: std::option::Option<std::string::String>,
}
impl KinesisFirehoseConfig {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    pub fn firehose_arn(&self) -> std::option::Option<&str> {
        self.firehose_arn.as_deref()
    }
}
/// See [`KinesisFirehoseConfig`](crate::model::KinesisFirehoseConfig).
pub mod kinesis_firehose_config {

    /// A builder for [`KinesisFirehoseConfig`](crate::model::KinesisFirehoseConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firehose_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
        pub fn firehose_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firehose_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
        pub fn set_firehose_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firehose_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisFirehoseConfig`](crate::model::KinesisFirehoseConfig).
        pub fn build(self) -> crate::model::KinesisFirehoseConfig {
            crate::model::KinesisFirehoseConfig {
                firehose_arn: self.firehose_arn,
            }
        }
    }
}
impl KinesisFirehoseConfig {
    /// Creates a new builder-style object to manufacture [`KinesisFirehoseConfig`](crate::model::KinesisFirehoseConfig).
    pub fn builder() -> crate::model::kinesis_firehose_config::Builder {
        crate::model::kinesis_firehose_config::Builder::default()
    }
}

/// <p>Configuration information of a Kinesis data stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KinesisStreamConfig {
    /// <p>The Amazon Resource Name (ARN) of the data stream.</p>
    #[doc(hidden)]
    pub stream_arn: std::option::Option<std::string::String>,
}
impl KinesisStreamConfig {
    /// <p>The Amazon Resource Name (ARN) of the data stream.</p>
    pub fn stream_arn(&self) -> std::option::Option<&str> {
        self.stream_arn.as_deref()
    }
}
/// See [`KinesisStreamConfig`](crate::model::KinesisStreamConfig).
pub mod kinesis_stream_config {

    /// A builder for [`KinesisStreamConfig`](crate::model::KinesisStreamConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the data stream.</p>
        pub fn stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the data stream.</p>
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisStreamConfig`](crate::model::KinesisStreamConfig).
        pub fn build(self) -> crate::model::KinesisStreamConfig {
            crate::model::KinesisStreamConfig {
                stream_arn: self.stream_arn,
            }
        }
    }
}
impl KinesisStreamConfig {
    /// Creates a new builder-style object to manufacture [`KinesisStreamConfig`](crate::model::KinesisStreamConfig).
    pub fn builder() -> crate::model::kinesis_stream_config::Builder {
        crate::model::kinesis_stream_config::Builder::default()
    }
}

/// <p>Configuration information of a Kinesis video stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KinesisVideoStreamConfig {
    /// <p>The prefix of the video stream.</p>
    #[doc(hidden)]
    pub prefix: std::option::Option<std::string::String>,
    /// <p>The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.</p>
    /// <p>The default value is 0, indicating that the stream does not persist data.</p>
    #[doc(hidden)]
    pub retention_period_hours: i32,
    /// <p>The encryption configuration.</p>
    #[doc(hidden)]
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,
}
impl KinesisVideoStreamConfig {
    /// <p>The prefix of the video stream.</p>
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
    /// <p>The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.</p>
    /// <p>The default value is 0, indicating that the stream does not persist data.</p>
    pub fn retention_period_hours(&self) -> i32 {
        self.retention_period_hours
    }
    /// <p>The encryption configuration.</p>
    pub fn encryption_config(&self) -> std::option::Option<&crate::model::EncryptionConfig> {
        self.encryption_config.as_ref()
    }
}
/// See [`KinesisVideoStreamConfig`](crate::model::KinesisVideoStreamConfig).
pub mod kinesis_video_stream_config {

    /// A builder for [`KinesisVideoStreamConfig`](crate::model::KinesisVideoStreamConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) retention_period_hours: std::option::Option<i32>,
        pub(crate) encryption_config: std::option::Option<crate::model::EncryptionConfig>,
    }
    impl Builder {
        /// <p>The prefix of the video stream.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        /// <p>The prefix of the video stream.</p>
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.</p>
        /// <p>The default value is 0, indicating that the stream does not persist data.</p>
        pub fn retention_period_hours(mut self, input: i32) -> Self {
            self.retention_period_hours = Some(input);
            self
        }
        /// <p>The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.</p>
        /// <p>The default value is 0, indicating that the stream does not persist data.</p>
        pub fn set_retention_period_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.retention_period_hours = input;
            self
        }
        /// <p>The encryption configuration.</p>
        pub fn encryption_config(mut self, input: crate::model::EncryptionConfig) -> Self {
            self.encryption_config = Some(input);
            self
        }
        /// <p>The encryption configuration.</p>
        pub fn set_encryption_config(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfig>,
        ) -> Self {
            self.encryption_config = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisVideoStreamConfig`](crate::model::KinesisVideoStreamConfig).
        pub fn build(self) -> crate::model::KinesisVideoStreamConfig {
            crate::model::KinesisVideoStreamConfig {
                prefix: self.prefix,
                retention_period_hours: self.retention_period_hours.unwrap_or_default(),
                encryption_config: self.encryption_config,
            }
        }
    }
}
impl KinesisVideoStreamConfig {
    /// Creates a new builder-style object to manufacture [`KinesisVideoStreamConfig`](crate::model::KinesisVideoStreamConfig).
    pub fn builder() -> crate::model::kinesis_video_stream_config::Builder {
        crate::model::kinesis_video_stream_config::Builder::default()
    }
}

/// <p>The encryption configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionConfig {
    /// <p>The type of encryption.</p>
    #[doc(hidden)]
    pub encryption_type: std::option::Option<crate::model::EncryptionType>,
    /// <p>The full ARN of the encryption key. </p> <note>
    /// <p>Be sure to provide the full ARN of the encryption key, not just the ID.</p>
    /// </note>
    #[doc(hidden)]
    pub key_id: std::option::Option<std::string::String>,
}
impl EncryptionConfig {
    /// <p>The type of encryption.</p>
    pub fn encryption_type(&self) -> std::option::Option<&crate::model::EncryptionType> {
        self.encryption_type.as_ref()
    }
    /// <p>The full ARN of the encryption key. </p> <note>
    /// <p>Be sure to provide the full ARN of the encryption key, not just the ID.</p>
    /// </note>
    pub fn key_id(&self) -> std::option::Option<&str> {
        self.key_id.as_deref()
    }
}
/// See [`EncryptionConfig`](crate::model::EncryptionConfig).
pub mod encryption_config {

    /// A builder for [`EncryptionConfig`](crate::model::EncryptionConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_type: std::option::Option<crate::model::EncryptionType>,
        pub(crate) key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of encryption.</p>
        pub fn encryption_type(mut self, input: crate::model::EncryptionType) -> Self {
            self.encryption_type = Some(input);
            self
        }
        /// <p>The type of encryption.</p>
        pub fn set_encryption_type(
            mut self,
            input: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.encryption_type = input;
            self
        }
        /// <p>The full ARN of the encryption key. </p> <note>
        /// <p>Be sure to provide the full ARN of the encryption key, not just the ID.</p>
        /// </note>
        pub fn key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_id = Some(input.into());
            self
        }
        /// <p>The full ARN of the encryption key. </p> <note>
        /// <p>Be sure to provide the full ARN of the encryption key, not just the ID.</p>
        /// </note>
        pub fn set_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionConfig`](crate::model::EncryptionConfig).
        pub fn build(self) -> crate::model::EncryptionConfig {
            crate::model::EncryptionConfig {
                encryption_type: self.encryption_type,
                key_id: self.key_id,
            }
        }
    }
}
impl EncryptionConfig {
    /// Creates a new builder-style object to manufacture [`EncryptionConfig`](crate::model::EncryptionConfig).
    pub fn builder() -> crate::model::encryption_config::Builder {
        crate::model::encryption_config::Builder::default()
    }
}

/// When writing a match expression against `EncryptionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let encryptiontype = unimplemented!();
/// match encryptiontype {
///     EncryptionType::Kms => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `encryptiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EncryptionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EncryptionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EncryptionType::NewFeature` is defined.
/// Specifically, when `encryptiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EncryptionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EncryptionType {
    #[allow(missing_docs)] // documentation missing in model
    Kms,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EncryptionType {
    fn from(s: &str) -> Self {
        match s {
            "KMS" => EncryptionType::Kms,
            other => EncryptionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EncryptionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EncryptionType::from(s))
    }
}
impl EncryptionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EncryptionType::Kms => "KMS",
            EncryptionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["KMS"]
    }
}
impl AsRef<str> for EncryptionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the Amazon Simple Storage Service (Amazon S3) storage type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Config {
    /// <p>The S3 bucket name.</p>
    #[doc(hidden)]
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>The S3 bucket prefix.</p>
    #[doc(hidden)]
    pub bucket_prefix: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 encryption configuration.</p>
    #[doc(hidden)]
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,
}
impl S3Config {
    /// <p>The S3 bucket name.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
    /// <p>The S3 bucket prefix.</p>
    pub fn bucket_prefix(&self) -> std::option::Option<&str> {
        self.bucket_prefix.as_deref()
    }
    /// <p>The Amazon S3 encryption configuration.</p>
    pub fn encryption_config(&self) -> std::option::Option<&crate::model::EncryptionConfig> {
        self.encryption_config.as_ref()
    }
}
/// See [`S3Config`](crate::model::S3Config).
pub mod s3_config {

    /// A builder for [`S3Config`](crate::model::S3Config).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) bucket_prefix: std::option::Option<std::string::String>,
        pub(crate) encryption_config: std::option::Option<crate::model::EncryptionConfig>,
    }
    impl Builder {
        /// <p>The S3 bucket name.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The S3 bucket name.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// <p>The S3 bucket prefix.</p>
        pub fn bucket_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_prefix = Some(input.into());
            self
        }
        /// <p>The S3 bucket prefix.</p>
        pub fn set_bucket_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.bucket_prefix = input;
            self
        }
        /// <p>The Amazon S3 encryption configuration.</p>
        pub fn encryption_config(mut self, input: crate::model::EncryptionConfig) -> Self {
            self.encryption_config = Some(input);
            self
        }
        /// <p>The Amazon S3 encryption configuration.</p>
        pub fn set_encryption_config(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfig>,
        ) -> Self {
            self.encryption_config = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Config`](crate::model::S3Config).
        pub fn build(self) -> crate::model::S3Config {
            crate::model::S3Config {
                bucket_name: self.bucket_name,
                bucket_prefix: self.bucket_prefix,
                encryption_config: self.encryption_config,
            }
        }
    }
}
impl S3Config {
    /// Creates a new builder-style object to manufacture [`S3Config`](crate::model::S3Config).
    pub fn builder() -> crate::model::s3_config::Builder {
        crate::model::s3_config::Builder::default()
    }
}

/// When writing a match expression against `StorageType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let storagetype = unimplemented!();
/// match storagetype {
///     StorageType::KinesisFirehose => { /* ... */ },
///     StorageType::KinesisStream => { /* ... */ },
///     StorageType::KinesisVideoStream => { /* ... */ },
///     StorageType::S3 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `storagetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StorageType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StorageType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StorageType::NewFeature` is defined.
/// Specifically, when `storagetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StorageType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StorageType {
    #[allow(missing_docs)] // documentation missing in model
    KinesisFirehose,
    #[allow(missing_docs)] // documentation missing in model
    KinesisStream,
    #[allow(missing_docs)] // documentation missing in model
    KinesisVideoStream,
    #[allow(missing_docs)] // documentation missing in model
    S3,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StorageType {
    fn from(s: &str) -> Self {
        match s {
            "KINESIS_FIREHOSE" => StorageType::KinesisFirehose,
            "KINESIS_STREAM" => StorageType::KinesisStream,
            "KINESIS_VIDEO_STREAM" => StorageType::KinesisVideoStream,
            "S3" => StorageType::S3,
            other => StorageType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StorageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StorageType::from(s))
    }
}
impl StorageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StorageType::KinesisFirehose => "KINESIS_FIREHOSE",
            StorageType::KinesisStream => "KINESIS_STREAM",
            StorageType::KinesisVideoStream => "KINESIS_VIDEO_STREAM",
            StorageType::S3 => "S3",
            StorageType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "KINESIS_FIREHOSE",
            "KINESIS_STREAM",
            "KINESIS_VIDEO_STREAM",
            "S3",
        ]
    }
}
impl AsRef<str> for StorageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `InstanceStorageResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let instancestorageresourcetype = unimplemented!();
/// match instancestorageresourcetype {
///     InstanceStorageResourceType::AgentEvents => { /* ... */ },
///     InstanceStorageResourceType::CallRecordings => { /* ... */ },
///     InstanceStorageResourceType::ChatTranscripts => { /* ... */ },
///     InstanceStorageResourceType::ContactTraceRecords => { /* ... */ },
///     InstanceStorageResourceType::MediaStreams => { /* ... */ },
///     InstanceStorageResourceType::RealTimeContactAnalysisSegments => { /* ... */ },
///     InstanceStorageResourceType::ScheduledReports => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `instancestorageresourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InstanceStorageResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InstanceStorageResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InstanceStorageResourceType::NewFeature` is defined.
/// Specifically, when `instancestorageresourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InstanceStorageResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceStorageResourceType {
    #[allow(missing_docs)] // documentation missing in model
    AgentEvents,
    #[allow(missing_docs)] // documentation missing in model
    CallRecordings,
    #[allow(missing_docs)] // documentation missing in model
    ChatTranscripts,
    #[allow(missing_docs)] // documentation missing in model
    ContactTraceRecords,
    #[allow(missing_docs)] // documentation missing in model
    MediaStreams,
    #[allow(missing_docs)] // documentation missing in model
    RealTimeContactAnalysisSegments,
    #[allow(missing_docs)] // documentation missing in model
    ScheduledReports,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InstanceStorageResourceType {
    fn from(s: &str) -> Self {
        match s {
            "AGENT_EVENTS" => InstanceStorageResourceType::AgentEvents,
            "CALL_RECORDINGS" => InstanceStorageResourceType::CallRecordings,
            "CHAT_TRANSCRIPTS" => InstanceStorageResourceType::ChatTranscripts,
            "CONTACT_TRACE_RECORDS" => InstanceStorageResourceType::ContactTraceRecords,
            "MEDIA_STREAMS" => InstanceStorageResourceType::MediaStreams,
            "REAL_TIME_CONTACT_ANALYSIS_SEGMENTS" => {
                InstanceStorageResourceType::RealTimeContactAnalysisSegments
            }
            "SCHEDULED_REPORTS" => InstanceStorageResourceType::ScheduledReports,
            other => InstanceStorageResourceType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for InstanceStorageResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceStorageResourceType::from(s))
    }
}
impl InstanceStorageResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InstanceStorageResourceType::AgentEvents => "AGENT_EVENTS",
            InstanceStorageResourceType::CallRecordings => "CALL_RECORDINGS",
            InstanceStorageResourceType::ChatTranscripts => "CHAT_TRANSCRIPTS",
            InstanceStorageResourceType::ContactTraceRecords => "CONTACT_TRACE_RECORDS",
            InstanceStorageResourceType::MediaStreams => "MEDIA_STREAMS",
            InstanceStorageResourceType::RealTimeContactAnalysisSegments => {
                "REAL_TIME_CONTACT_ANALYSIS_SEGMENTS"
            }
            InstanceStorageResourceType::ScheduledReports => "SCHEDULED_REPORTS",
            InstanceStorageResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AGENT_EVENTS",
            "CALL_RECORDINGS",
            "CHAT_TRANSCRIPTS",
            "CONTACT_TRACE_RECORDS",
            "MEDIA_STREAMS",
            "REAL_TIME_CONTACT_ANALYSIS_SEGMENTS",
            "SCHEDULED_REPORTS",
        ]
    }
}
impl AsRef<str> for InstanceStorageResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `InstanceAttributeType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let instanceattributetype = unimplemented!();
/// match instanceattributetype {
///     InstanceAttributeType::AutoResolveBestVoices => { /* ... */ },
///     InstanceAttributeType::ContactflowLogs => { /* ... */ },
///     InstanceAttributeType::ContactLens => { /* ... */ },
///     InstanceAttributeType::EarlyMedia => { /* ... */ },
///     InstanceAttributeType::EnhancedContactMonitoring => { /* ... */ },
///     InstanceAttributeType::HighVolumeOutbound => { /* ... */ },
///     InstanceAttributeType::InboundCalls => { /* ... */ },
///     InstanceAttributeType::MultiPartyConference => { /* ... */ },
///     InstanceAttributeType::OutboundCalls => { /* ... */ },
///     InstanceAttributeType::UseCustomTtsVoices => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `instanceattributetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InstanceAttributeType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InstanceAttributeType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InstanceAttributeType::NewFeature` is defined.
/// Specifically, when `instanceattributetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InstanceAttributeType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceAttributeType {
    #[allow(missing_docs)] // documentation missing in model
    AutoResolveBestVoices,
    #[allow(missing_docs)] // documentation missing in model
    ContactflowLogs,
    #[allow(missing_docs)] // documentation missing in model
    ContactLens,
    #[allow(missing_docs)] // documentation missing in model
    EarlyMedia,
    #[allow(missing_docs)] // documentation missing in model
    EnhancedContactMonitoring,
    #[allow(missing_docs)] // documentation missing in model
    HighVolumeOutbound,
    #[allow(missing_docs)] // documentation missing in model
    InboundCalls,
    #[allow(missing_docs)] // documentation missing in model
    MultiPartyConference,
    #[allow(missing_docs)] // documentation missing in model
    OutboundCalls,
    #[allow(missing_docs)] // documentation missing in model
    UseCustomTtsVoices,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InstanceAttributeType {
    fn from(s: &str) -> Self {
        match s {
            "AUTO_RESOLVE_BEST_VOICES" => InstanceAttributeType::AutoResolveBestVoices,
            "CONTACTFLOW_LOGS" => InstanceAttributeType::ContactflowLogs,
            "CONTACT_LENS" => InstanceAttributeType::ContactLens,
            "EARLY_MEDIA" => InstanceAttributeType::EarlyMedia,
            "ENHANCED_CONTACT_MONITORING" => InstanceAttributeType::EnhancedContactMonitoring,
            "HIGH_VOLUME_OUTBOUND" => InstanceAttributeType::HighVolumeOutbound,
            "INBOUND_CALLS" => InstanceAttributeType::InboundCalls,
            "MULTI_PARTY_CONFERENCE" => InstanceAttributeType::MultiPartyConference,
            "OUTBOUND_CALLS" => InstanceAttributeType::OutboundCalls,
            "USE_CUSTOM_TTS_VOICES" => InstanceAttributeType::UseCustomTtsVoices,
            other => {
                InstanceAttributeType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for InstanceAttributeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceAttributeType::from(s))
    }
}
impl InstanceAttributeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InstanceAttributeType::AutoResolveBestVoices => "AUTO_RESOLVE_BEST_VOICES",
            InstanceAttributeType::ContactflowLogs => "CONTACTFLOW_LOGS",
            InstanceAttributeType::ContactLens => "CONTACT_LENS",
            InstanceAttributeType::EarlyMedia => "EARLY_MEDIA",
            InstanceAttributeType::EnhancedContactMonitoring => "ENHANCED_CONTACT_MONITORING",
            InstanceAttributeType::HighVolumeOutbound => "HIGH_VOLUME_OUTBOUND",
            InstanceAttributeType::InboundCalls => "INBOUND_CALLS",
            InstanceAttributeType::MultiPartyConference => "MULTI_PARTY_CONFERENCE",
            InstanceAttributeType::OutboundCalls => "OUTBOUND_CALLS",
            InstanceAttributeType::UseCustomTtsVoices => "USE_CUSTOM_TTS_VOICES",
            InstanceAttributeType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AUTO_RESOLVE_BEST_VOICES",
            "CONTACTFLOW_LOGS",
            "CONTACT_LENS",
            "EARLY_MEDIA",
            "ENHANCED_CONTACT_MONITORING",
            "HIGH_VOLUME_OUTBOUND",
            "INBOUND_CALLS",
            "MULTI_PARTY_CONFERENCE",
            "OUTBOUND_CALLS",
            "USE_CUSTOM_TTS_VOICES",
        ]
    }
}
impl AsRef<str> for InstanceAttributeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the hours of operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HoursOfOperationConfig {
    /// <p>The day that the hours of operation applies to.</p>
    #[doc(hidden)]
    pub day: std::option::Option<crate::model::HoursOfOperationDays>,
    /// <p>The start time that your contact center opens.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<crate::model::HoursOfOperationTimeSlice>,
    /// <p>The end time that your contact center closes.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<crate::model::HoursOfOperationTimeSlice>,
}
impl HoursOfOperationConfig {
    /// <p>The day that the hours of operation applies to.</p>
    pub fn day(&self) -> std::option::Option<&crate::model::HoursOfOperationDays> {
        self.day.as_ref()
    }
    /// <p>The start time that your contact center opens.</p>
    pub fn start_time(&self) -> std::option::Option<&crate::model::HoursOfOperationTimeSlice> {
        self.start_time.as_ref()
    }
    /// <p>The end time that your contact center closes.</p>
    pub fn end_time(&self) -> std::option::Option<&crate::model::HoursOfOperationTimeSlice> {
        self.end_time.as_ref()
    }
}
/// See [`HoursOfOperationConfig`](crate::model::HoursOfOperationConfig).
pub mod hours_of_operation_config {

    /// A builder for [`HoursOfOperationConfig`](crate::model::HoursOfOperationConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) day: std::option::Option<crate::model::HoursOfOperationDays>,
        pub(crate) start_time: std::option::Option<crate::model::HoursOfOperationTimeSlice>,
        pub(crate) end_time: std::option::Option<crate::model::HoursOfOperationTimeSlice>,
    }
    impl Builder {
        /// <p>The day that the hours of operation applies to.</p>
        pub fn day(mut self, input: crate::model::HoursOfOperationDays) -> Self {
            self.day = Some(input);
            self
        }
        /// <p>The day that the hours of operation applies to.</p>
        pub fn set_day(
            mut self,
            input: std::option::Option<crate::model::HoursOfOperationDays>,
        ) -> Self {
            self.day = input;
            self
        }
        /// <p>The start time that your contact center opens.</p>
        pub fn start_time(mut self, input: crate::model::HoursOfOperationTimeSlice) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time that your contact center opens.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<crate::model::HoursOfOperationTimeSlice>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time that your contact center closes.</p>
        pub fn end_time(mut self, input: crate::model::HoursOfOperationTimeSlice) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time that your contact center closes.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<crate::model::HoursOfOperationTimeSlice>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`HoursOfOperationConfig`](crate::model::HoursOfOperationConfig).
        pub fn build(self) -> crate::model::HoursOfOperationConfig {
            crate::model::HoursOfOperationConfig {
                day: self.day,
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}
impl HoursOfOperationConfig {
    /// Creates a new builder-style object to manufacture [`HoursOfOperationConfig`](crate::model::HoursOfOperationConfig).
    pub fn builder() -> crate::model::hours_of_operation_config::Builder {
        crate::model::hours_of_operation_config::Builder::default()
    }
}

/// <p>The start time or end time for an hours of operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HoursOfOperationTimeSlice {
    /// <p>The hours.</p>
    #[doc(hidden)]
    pub hours: std::option::Option<i32>,
    /// <p>The minutes.</p>
    #[doc(hidden)]
    pub minutes: std::option::Option<i32>,
}
impl HoursOfOperationTimeSlice {
    /// <p>The hours.</p>
    pub fn hours(&self) -> std::option::Option<i32> {
        self.hours
    }
    /// <p>The minutes.</p>
    pub fn minutes(&self) -> std::option::Option<i32> {
        self.minutes
    }
}
/// See [`HoursOfOperationTimeSlice`](crate::model::HoursOfOperationTimeSlice).
pub mod hours_of_operation_time_slice {

    /// A builder for [`HoursOfOperationTimeSlice`](crate::model::HoursOfOperationTimeSlice).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hours: std::option::Option<i32>,
        pub(crate) minutes: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The hours.</p>
        pub fn hours(mut self, input: i32) -> Self {
            self.hours = Some(input);
            self
        }
        /// <p>The hours.</p>
        pub fn set_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.hours = input;
            self
        }
        /// <p>The minutes.</p>
        pub fn minutes(mut self, input: i32) -> Self {
            self.minutes = Some(input);
            self
        }
        /// <p>The minutes.</p>
        pub fn set_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.minutes = input;
            self
        }
        /// Consumes the builder and constructs a [`HoursOfOperationTimeSlice`](crate::model::HoursOfOperationTimeSlice).
        pub fn build(self) -> crate::model::HoursOfOperationTimeSlice {
            crate::model::HoursOfOperationTimeSlice {
                hours: self.hours,
                minutes: self.minutes,
            }
        }
    }
}
impl HoursOfOperationTimeSlice {
    /// Creates a new builder-style object to manufacture [`HoursOfOperationTimeSlice`](crate::model::HoursOfOperationTimeSlice).
    pub fn builder() -> crate::model::hours_of_operation_time_slice::Builder {
        crate::model::hours_of_operation_time_slice::Builder::default()
    }
}

/// When writing a match expression against `HoursOfOperationDays`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let hoursofoperationdays = unimplemented!();
/// match hoursofoperationdays {
///     HoursOfOperationDays::Friday => { /* ... */ },
///     HoursOfOperationDays::Monday => { /* ... */ },
///     HoursOfOperationDays::Saturday => { /* ... */ },
///     HoursOfOperationDays::Sunday => { /* ... */ },
///     HoursOfOperationDays::Thursday => { /* ... */ },
///     HoursOfOperationDays::Tuesday => { /* ... */ },
///     HoursOfOperationDays::Wednesday => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `hoursofoperationdays` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HoursOfOperationDays::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HoursOfOperationDays::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HoursOfOperationDays::NewFeature` is defined.
/// Specifically, when `hoursofoperationdays` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HoursOfOperationDays::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HoursOfOperationDays {
    #[allow(missing_docs)] // documentation missing in model
    Friday,
    #[allow(missing_docs)] // documentation missing in model
    Monday,
    #[allow(missing_docs)] // documentation missing in model
    Saturday,
    #[allow(missing_docs)] // documentation missing in model
    Sunday,
    #[allow(missing_docs)] // documentation missing in model
    Thursday,
    #[allow(missing_docs)] // documentation missing in model
    Tuesday,
    #[allow(missing_docs)] // documentation missing in model
    Wednesday,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HoursOfOperationDays {
    fn from(s: &str) -> Self {
        match s {
            "FRIDAY" => HoursOfOperationDays::Friday,
            "MONDAY" => HoursOfOperationDays::Monday,
            "SATURDAY" => HoursOfOperationDays::Saturday,
            "SUNDAY" => HoursOfOperationDays::Sunday,
            "THURSDAY" => HoursOfOperationDays::Thursday,
            "TUESDAY" => HoursOfOperationDays::Tuesday,
            "WEDNESDAY" => HoursOfOperationDays::Wednesday,
            other => {
                HoursOfOperationDays::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for HoursOfOperationDays {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HoursOfOperationDays::from(s))
    }
}
impl HoursOfOperationDays {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HoursOfOperationDays::Friday => "FRIDAY",
            HoursOfOperationDays::Monday => "MONDAY",
            HoursOfOperationDays::Saturday => "SATURDAY",
            HoursOfOperationDays::Sunday => "SUNDAY",
            HoursOfOperationDays::Thursday => "THURSDAY",
            HoursOfOperationDays::Tuesday => "TUESDAY",
            HoursOfOperationDays::Wednesday => "WEDNESDAY",
            HoursOfOperationDays::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "FRIDAY",
            "MONDAY",
            "SATURDAY",
            "SUNDAY",
            "THURSDAY",
            "TUESDAY",
            "WEDNESDAY",
        ]
    }
}
impl AsRef<str> for HoursOfOperationDays {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ContactFlowModuleState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let contactflowmodulestate = unimplemented!();
/// match contactflowmodulestate {
///     ContactFlowModuleState::Active => { /* ... */ },
///     ContactFlowModuleState::Archived => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `contactflowmodulestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ContactFlowModuleState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ContactFlowModuleState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ContactFlowModuleState::NewFeature` is defined.
/// Specifically, when `contactflowmodulestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ContactFlowModuleState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContactFlowModuleState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Archived,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ContactFlowModuleState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ContactFlowModuleState::Active,
            "ARCHIVED" => ContactFlowModuleState::Archived,
            other => {
                ContactFlowModuleState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ContactFlowModuleState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContactFlowModuleState::from(s))
    }
}
impl ContactFlowModuleState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContactFlowModuleState::Active => "ACTIVE",
            ContactFlowModuleState::Archived => "ARCHIVED",
            ContactFlowModuleState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "ARCHIVED"]
    }
}
impl AsRef<str> for ContactFlowModuleState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a problem detail.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProblemDetail {
    /// <p>The problem detail's message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ProblemDetail {
    /// <p>The problem detail's message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ProblemDetail`](crate::model::ProblemDetail).
pub mod problem_detail {

    /// A builder for [`ProblemDetail`](crate::model::ProblemDetail).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The problem detail's message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The problem detail's message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ProblemDetail`](crate::model::ProblemDetail).
        pub fn build(self) -> crate::model::ProblemDetail {
            crate::model::ProblemDetail {
                message: self.message,
            }
        }
    }
}
impl ProblemDetail {
    /// Creates a new builder-style object to manufacture [`ProblemDetail`](crate::model::ProblemDetail).
    pub fn builder() -> crate::model::problem_detail::Builder {
        crate::model::problem_detail::Builder::default()
    }
}

/// When writing a match expression against `ContactFlowState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let contactflowstate = unimplemented!();
/// match contactflowstate {
///     ContactFlowState::Active => { /* ... */ },
///     ContactFlowState::Archived => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `contactflowstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ContactFlowState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ContactFlowState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ContactFlowState::NewFeature` is defined.
/// Specifically, when `contactflowstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ContactFlowState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContactFlowState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Archived,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ContactFlowState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ContactFlowState::Active,
            "ARCHIVED" => ContactFlowState::Archived,
            other => ContactFlowState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ContactFlowState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContactFlowState::from(s))
    }
}
impl ContactFlowState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContactFlowState::Active => "ACTIVE",
            ContactFlowState::Archived => "ARCHIVED",
            ContactFlowState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "ARCHIVED"]
    }
}
impl AsRef<str> for ContactFlowState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AgentStatusState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let agentstatusstate = unimplemented!();
/// match agentstatusstate {
///     AgentStatusState::Disabled => { /* ... */ },
///     AgentStatusState::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `agentstatusstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AgentStatusState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AgentStatusState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AgentStatusState::NewFeature` is defined.
/// Specifically, when `agentstatusstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AgentStatusState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AgentStatusState {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AgentStatusState {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => AgentStatusState::Disabled,
            "ENABLED" => AgentStatusState::Enabled,
            other => AgentStatusState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AgentStatusState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AgentStatusState::from(s))
    }
}
impl AgentStatusState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AgentStatusState::Disabled => "DISABLED",
            AgentStatusState::Enabled => "ENABLED",
            AgentStatusState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for AgentStatusState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TrafficType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let traffictype = unimplemented!();
/// match traffictype {
///     TrafficType::Campaign => { /* ... */ },
///     TrafficType::General => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `traffictype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TrafficType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TrafficType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TrafficType::NewFeature` is defined.
/// Specifically, when `traffictype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TrafficType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrafficType {
    #[allow(missing_docs)] // documentation missing in model
    Campaign,
    #[allow(missing_docs)] // documentation missing in model
    General,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TrafficType {
    fn from(s: &str) -> Self {
        match s {
            "CAMPAIGN" => TrafficType::Campaign,
            "GENERAL" => TrafficType::General,
            other => TrafficType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TrafficType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrafficType::from(s))
    }
}
impl TrafficType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TrafficType::Campaign => "CAMPAIGN",
            TrafficType::General => "GENERAL",
            TrafficType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CAMPAIGN", "GENERAL"]
    }
}
impl AsRef<str> for TrafficType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration of the answering machine detection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnswerMachineDetectionConfig {
    /// <p>The flag to indicate if answer machine detection analysis needs to be performed for a voice call. If set to <code>true</code>, <code>TrafficType</code> must be set as <code>CAMPAIGN</code>. </p>
    #[doc(hidden)]
    pub enable_answer_machine_detection: bool,
    /// <p>Wait for the answering machine prompt.</p>
    #[doc(hidden)]
    pub await_answer_machine_prompt: bool,
}
impl AnswerMachineDetectionConfig {
    /// <p>The flag to indicate if answer machine detection analysis needs to be performed for a voice call. If set to <code>true</code>, <code>TrafficType</code> must be set as <code>CAMPAIGN</code>. </p>
    pub fn enable_answer_machine_detection(&self) -> bool {
        self.enable_answer_machine_detection
    }
    /// <p>Wait for the answering machine prompt.</p>
    pub fn await_answer_machine_prompt(&self) -> bool {
        self.await_answer_machine_prompt
    }
}
/// See [`AnswerMachineDetectionConfig`](crate::model::AnswerMachineDetectionConfig).
pub mod answer_machine_detection_config {

    /// A builder for [`AnswerMachineDetectionConfig`](crate::model::AnswerMachineDetectionConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_answer_machine_detection: std::option::Option<bool>,
        pub(crate) await_answer_machine_prompt: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The flag to indicate if answer machine detection analysis needs to be performed for a voice call. If set to <code>true</code>, <code>TrafficType</code> must be set as <code>CAMPAIGN</code>. </p>
        pub fn enable_answer_machine_detection(mut self, input: bool) -> Self {
            self.enable_answer_machine_detection = Some(input);
            self
        }
        /// <p>The flag to indicate if answer machine detection analysis needs to be performed for a voice call. If set to <code>true</code>, <code>TrafficType</code> must be set as <code>CAMPAIGN</code>. </p>
        pub fn set_enable_answer_machine_detection(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_answer_machine_detection = input;
            self
        }
        /// <p>Wait for the answering machine prompt.</p>
        pub fn await_answer_machine_prompt(mut self, input: bool) -> Self {
            self.await_answer_machine_prompt = Some(input);
            self
        }
        /// <p>Wait for the answering machine prompt.</p>
        pub fn set_await_answer_machine_prompt(mut self, input: std::option::Option<bool>) -> Self {
            self.await_answer_machine_prompt = input;
            self
        }
        /// Consumes the builder and constructs a [`AnswerMachineDetectionConfig`](crate::model::AnswerMachineDetectionConfig).
        pub fn build(self) -> crate::model::AnswerMachineDetectionConfig {
            crate::model::AnswerMachineDetectionConfig {
                enable_answer_machine_detection: self
                    .enable_answer_machine_detection
                    .unwrap_or_default(),
                await_answer_machine_prompt: self.await_answer_machine_prompt.unwrap_or_default(),
            }
        }
    }
}
impl AnswerMachineDetectionConfig {
    /// Creates a new builder-style object to manufacture [`AnswerMachineDetectionConfig`](crate::model::AnswerMachineDetectionConfig).
    pub fn builder() -> crate::model::answer_machine_detection_config::Builder {
        crate::model::answer_machine_detection_config::Builder::default()
    }
}

/// <p>The streaming configuration, such as the Amazon SNS streaming endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChatStreamingConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon Resource Name (ARN) of the streaming endpoint that is used to publish real-time message streaming for chat conversations.</p>
    #[doc(hidden)]
    pub streaming_endpoint_arn: std::option::Option<std::string::String>,
}
impl ChatStreamingConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon Resource Name (ARN) of the streaming endpoint that is used to publish real-time message streaming for chat conversations.</p>
    pub fn streaming_endpoint_arn(&self) -> std::option::Option<&str> {
        self.streaming_endpoint_arn.as_deref()
    }
}
/// See [`ChatStreamingConfiguration`](crate::model::ChatStreamingConfiguration).
pub mod chat_streaming_configuration {

    /// A builder for [`ChatStreamingConfiguration`](crate::model::ChatStreamingConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) streaming_endpoint_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon Resource Name (ARN) of the streaming endpoint that is used to publish real-time message streaming for chat conversations.</p>
        pub fn streaming_endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.streaming_endpoint_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon Resource Name (ARN) of the streaming endpoint that is used to publish real-time message streaming for chat conversations.</p>
        pub fn set_streaming_endpoint_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.streaming_endpoint_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ChatStreamingConfiguration`](crate::model::ChatStreamingConfiguration).
        pub fn build(self) -> crate::model::ChatStreamingConfiguration {
            crate::model::ChatStreamingConfiguration {
                streaming_endpoint_arn: self.streaming_endpoint_arn,
            }
        }
    }
}
impl ChatStreamingConfiguration {
    /// Creates a new builder-style object to manufacture [`ChatStreamingConfiguration`](crate::model::ChatStreamingConfiguration).
    pub fn builder() -> crate::model::chat_streaming_configuration::Builder {
        crate::model::chat_streaming_configuration::Builder::default()
    }
}

/// <p>Contains information about the recording configuration settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VoiceRecordingConfiguration {
    /// <p>Identifies which track is being recorded.</p>
    #[doc(hidden)]
    pub voice_recording_track: std::option::Option<crate::model::VoiceRecordingTrack>,
}
impl VoiceRecordingConfiguration {
    /// <p>Identifies which track is being recorded.</p>
    pub fn voice_recording_track(&self) -> std::option::Option<&crate::model::VoiceRecordingTrack> {
        self.voice_recording_track.as_ref()
    }
}
/// See [`VoiceRecordingConfiguration`](crate::model::VoiceRecordingConfiguration).
pub mod voice_recording_configuration {

    /// A builder for [`VoiceRecordingConfiguration`](crate::model::VoiceRecordingConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_recording_track: std::option::Option<crate::model::VoiceRecordingTrack>,
    }
    impl Builder {
        /// <p>Identifies which track is being recorded.</p>
        pub fn voice_recording_track(mut self, input: crate::model::VoiceRecordingTrack) -> Self {
            self.voice_recording_track = Some(input);
            self
        }
        /// <p>Identifies which track is being recorded.</p>
        pub fn set_voice_recording_track(
            mut self,
            input: std::option::Option<crate::model::VoiceRecordingTrack>,
        ) -> Self {
            self.voice_recording_track = input;
            self
        }
        /// Consumes the builder and constructs a [`VoiceRecordingConfiguration`](crate::model::VoiceRecordingConfiguration).
        pub fn build(self) -> crate::model::VoiceRecordingConfiguration {
            crate::model::VoiceRecordingConfiguration {
                voice_recording_track: self.voice_recording_track,
            }
        }
    }
}
impl VoiceRecordingConfiguration {
    /// Creates a new builder-style object to manufacture [`VoiceRecordingConfiguration`](crate::model::VoiceRecordingConfiguration).
    pub fn builder() -> crate::model::voice_recording_configuration::Builder {
        crate::model::voice_recording_configuration::Builder::default()
    }
}

/// When writing a match expression against `VoiceRecordingTrack`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let voicerecordingtrack = unimplemented!();
/// match voicerecordingtrack {
///     VoiceRecordingTrack::All => { /* ... */ },
///     VoiceRecordingTrack::FromAgent => { /* ... */ },
///     VoiceRecordingTrack::ToAgent => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `voicerecordingtrack` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VoiceRecordingTrack::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VoiceRecordingTrack::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VoiceRecordingTrack::NewFeature` is defined.
/// Specifically, when `voicerecordingtrack` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VoiceRecordingTrack::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VoiceRecordingTrack {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    FromAgent,
    #[allow(missing_docs)] // documentation missing in model
    ToAgent,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VoiceRecordingTrack {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => VoiceRecordingTrack::All,
            "FROM_AGENT" => VoiceRecordingTrack::FromAgent,
            "TO_AGENT" => VoiceRecordingTrack::ToAgent,
            other => {
                VoiceRecordingTrack::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for VoiceRecordingTrack {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VoiceRecordingTrack::from(s))
    }
}
impl VoiceRecordingTrack {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VoiceRecordingTrack::All => "ALL",
            VoiceRecordingTrack::FromAgent => "FROM_AGENT",
            VoiceRecordingTrack::ToAgent => "TO_AGENT",
            VoiceRecordingTrack::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "FROM_AGENT", "TO_AGENT"]
    }
}
impl AsRef<str> for VoiceRecordingTrack {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Enable persistent chats. For more information about enabling persistent chat, and for example use cases and how to configure for them, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html">Enable persistent chat</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PersistentChat {
    /// <p>The contactId that is used for rehydration depends on the rehydration type. RehydrationType is required for persistent chat. </p>
    /// <ul>
    /// <li> <p> <code>ENTIRE_PAST_SESSION</code>: Rehydrates a chat from the most recently terminated past chat contact of the specified past ended chat session. To use this type, provide the <code>initialContactId</code> of the past ended chat session in the <code>sourceContactId</code> field. In this type, Amazon Connect determines the most recent chat contact on the specified chat session that has ended, and uses it to start a persistent chat. </p> </li>
    /// <li> <p> <code>FROM_SEGMENT</code>: Rehydrates a chat from the past chat contact that is specified in the <code>sourceContactId</code> field. </p> </li>
    /// </ul>
    /// <p>The actual contactId used for rehydration is provided in the response of this API. </p>
    #[doc(hidden)]
    pub rehydration_type: std::option::Option<crate::model::RehydrationType>,
    /// <p>The contactId from which a persistent chat session must be started.</p>
    #[doc(hidden)]
    pub source_contact_id: std::option::Option<std::string::String>,
}
impl PersistentChat {
    /// <p>The contactId that is used for rehydration depends on the rehydration type. RehydrationType is required for persistent chat. </p>
    /// <ul>
    /// <li> <p> <code>ENTIRE_PAST_SESSION</code>: Rehydrates a chat from the most recently terminated past chat contact of the specified past ended chat session. To use this type, provide the <code>initialContactId</code> of the past ended chat session in the <code>sourceContactId</code> field. In this type, Amazon Connect determines the most recent chat contact on the specified chat session that has ended, and uses it to start a persistent chat. </p> </li>
    /// <li> <p> <code>FROM_SEGMENT</code>: Rehydrates a chat from the past chat contact that is specified in the <code>sourceContactId</code> field. </p> </li>
    /// </ul>
    /// <p>The actual contactId used for rehydration is provided in the response of this API. </p>
    pub fn rehydration_type(&self) -> std::option::Option<&crate::model::RehydrationType> {
        self.rehydration_type.as_ref()
    }
    /// <p>The contactId from which a persistent chat session must be started.</p>
    pub fn source_contact_id(&self) -> std::option::Option<&str> {
        self.source_contact_id.as_deref()
    }
}
/// See [`PersistentChat`](crate::model::PersistentChat).
pub mod persistent_chat {

    /// A builder for [`PersistentChat`](crate::model::PersistentChat).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rehydration_type: std::option::Option<crate::model::RehydrationType>,
        pub(crate) source_contact_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The contactId that is used for rehydration depends on the rehydration type. RehydrationType is required for persistent chat. </p>
        /// <ul>
        /// <li> <p> <code>ENTIRE_PAST_SESSION</code>: Rehydrates a chat from the most recently terminated past chat contact of the specified past ended chat session. To use this type, provide the <code>initialContactId</code> of the past ended chat session in the <code>sourceContactId</code> field. In this type, Amazon Connect determines the most recent chat contact on the specified chat session that has ended, and uses it to start a persistent chat. </p> </li>
        /// <li> <p> <code>FROM_SEGMENT</code>: Rehydrates a chat from the past chat contact that is specified in the <code>sourceContactId</code> field. </p> </li>
        /// </ul>
        /// <p>The actual contactId used for rehydration is provided in the response of this API. </p>
        pub fn rehydration_type(mut self, input: crate::model::RehydrationType) -> Self {
            self.rehydration_type = Some(input);
            self
        }
        /// <p>The contactId that is used for rehydration depends on the rehydration type. RehydrationType is required for persistent chat. </p>
        /// <ul>
        /// <li> <p> <code>ENTIRE_PAST_SESSION</code>: Rehydrates a chat from the most recently terminated past chat contact of the specified past ended chat session. To use this type, provide the <code>initialContactId</code> of the past ended chat session in the <code>sourceContactId</code> field. In this type, Amazon Connect determines the most recent chat contact on the specified chat session that has ended, and uses it to start a persistent chat. </p> </li>
        /// <li> <p> <code>FROM_SEGMENT</code>: Rehydrates a chat from the past chat contact that is specified in the <code>sourceContactId</code> field. </p> </li>
        /// </ul>
        /// <p>The actual contactId used for rehydration is provided in the response of this API. </p>
        pub fn set_rehydration_type(
            mut self,
            input: std::option::Option<crate::model::RehydrationType>,
        ) -> Self {
            self.rehydration_type = input;
            self
        }
        /// <p>The contactId from which a persistent chat session must be started.</p>
        pub fn source_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_contact_id = Some(input.into());
            self
        }
        /// <p>The contactId from which a persistent chat session must be started.</p>
        pub fn set_source_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_contact_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PersistentChat`](crate::model::PersistentChat).
        pub fn build(self) -> crate::model::PersistentChat {
            crate::model::PersistentChat {
                rehydration_type: self.rehydration_type,
                source_contact_id: self.source_contact_id,
            }
        }
    }
}
impl PersistentChat {
    /// Creates a new builder-style object to manufacture [`PersistentChat`](crate::model::PersistentChat).
    pub fn builder() -> crate::model::persistent_chat::Builder {
        crate::model::persistent_chat::Builder::default()
    }
}

/// When writing a match expression against `RehydrationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let rehydrationtype = unimplemented!();
/// match rehydrationtype {
///     RehydrationType::EntirePastSession => { /* ... */ },
///     RehydrationType::FromSegment => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `rehydrationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RehydrationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RehydrationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RehydrationType::NewFeature` is defined.
/// Specifically, when `rehydrationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RehydrationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RehydrationType {
    #[allow(missing_docs)] // documentation missing in model
    EntirePastSession,
    #[allow(missing_docs)] // documentation missing in model
    FromSegment,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RehydrationType {
    fn from(s: &str) -> Self {
        match s {
            "ENTIRE_PAST_SESSION" => RehydrationType::EntirePastSession,
            "FROM_SEGMENT" => RehydrationType::FromSegment,
            other => RehydrationType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RehydrationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RehydrationType::from(s))
    }
}
impl RehydrationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RehydrationType::EntirePastSession => "ENTIRE_PAST_SESSION",
            RehydrationType::FromSegment => "FROM_SEGMENT",
            RehydrationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ENTIRE_PAST_SESSION", "FROM_SEGMENT"]
    }
}
impl AsRef<str> for RehydrationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A chat message.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChatMessage {
    /// <p>The type of the content. Supported types are <code>text/plain</code>, <code>text/markdown</code>, and <code>application/json</code>.</p>
    #[doc(hidden)]
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The content of the chat message. </p>
    /// <ul>
    /// <li> <p>For <code>text/plain</code> and <code>text/markdown</code>, the Length Constraints are Minimum of 1, Maximum of 1024. </p> </li>
    /// <li> <p>For <code>application/json</code>, the Length Constraints are Minimum of 1, Maximum of 12000. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
}
impl ChatMessage {
    /// <p>The type of the content. Supported types are <code>text/plain</code>, <code>text/markdown</code>, and <code>application/json</code>.</p>
    pub fn content_type(&self) -> std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p>The content of the chat message. </p>
    /// <ul>
    /// <li> <p>For <code>text/plain</code> and <code>text/markdown</code>, the Length Constraints are Minimum of 1, Maximum of 1024. </p> </li>
    /// <li> <p>For <code>application/json</code>, the Length Constraints are Minimum of 1, Maximum of 12000. </p> </li>
    /// </ul>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
}
/// See [`ChatMessage`](crate::model::ChatMessage).
pub mod chat_message {

    /// A builder for [`ChatMessage`](crate::model::ChatMessage).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the content. Supported types are <code>text/plain</code>, <code>text/markdown</code>, and <code>application/json</code>.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        /// <p>The type of the content. Supported types are <code>text/plain</code>, <code>text/markdown</code>, and <code>application/json</code>.</p>
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The content of the chat message. </p>
        /// <ul>
        /// <li> <p>For <code>text/plain</code> and <code>text/markdown</code>, the Length Constraints are Minimum of 1, Maximum of 1024. </p> </li>
        /// <li> <p>For <code>application/json</code>, the Length Constraints are Minimum of 1, Maximum of 12000. </p> </li>
        /// </ul>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the chat message. </p>
        /// <ul>
        /// <li> <p>For <code>text/plain</code> and <code>text/markdown</code>, the Length Constraints are Minimum of 1, Maximum of 1024. </p> </li>
        /// <li> <p>For <code>application/json</code>, the Length Constraints are Minimum of 1, Maximum of 12000. </p> </li>
        /// </ul>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`ChatMessage`](crate::model::ChatMessage).
        pub fn build(self) -> crate::model::ChatMessage {
            crate::model::ChatMessage {
                content_type: self.content_type,
                content: self.content,
            }
        }
    }
}
impl ChatMessage {
    /// Creates a new builder-style object to manufacture [`ChatMessage`](crate::model::ChatMessage).
    pub fn builder() -> crate::model::chat_message::Builder {
        crate::model::chat_message::Builder::default()
    }
}

/// <p>The customer's details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParticipantDetails {
    /// <p>Display name of the participant.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
}
impl ParticipantDetails {
    /// <p>Display name of the participant.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
}
/// See [`ParticipantDetails`](crate::model::ParticipantDetails).
pub mod participant_details {

    /// A builder for [`ParticipantDetails`](crate::model::ParticipantDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Display name of the participant.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>Display name of the participant.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ParticipantDetails`](crate::model::ParticipantDetails).
        pub fn build(self) -> crate::model::ParticipantDetails {
            crate::model::ParticipantDetails {
                display_name: self.display_name,
            }
        }
    }
}
impl ParticipantDetails {
    /// Creates a new builder-style object to manufacture [`ParticipantDetails`](crate::model::ParticipantDetails).
    pub fn builder() -> crate::model::participant_details::Builder {
        crate::model::participant_details::Builder::default()
    }
}

/// <p>Contains summary information about the custom vocabulary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VocabularySummary {
    /// <p>A unique name of the custom vocabulary.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier of the custom vocabulary.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
    /// <p>The current state of the custom vocabulary.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::VocabularyState>,
    /// <p>The timestamp when the custom vocabulary was last modified.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The reason why the custom vocabulary was not created.</p>
    #[doc(hidden)]
    pub failure_reason: std::option::Option<std::string::String>,
}
impl VocabularySummary {
    /// <p>A unique name of the custom vocabulary.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier of the custom vocabulary.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::VocabularyLanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The current state of the custom vocabulary.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::VocabularyState> {
        self.state.as_ref()
    }
    /// <p>The timestamp when the custom vocabulary was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The reason why the custom vocabulary was not created.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
}
/// See [`VocabularySummary`](crate::model::VocabularySummary).
pub mod vocabulary_summary {

    /// A builder for [`VocabularySummary`](crate::model::VocabularySummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
        pub(crate) state: std::option::Option<crate::model::VocabularyState>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn language_code(mut self, input: crate::model::VocabularyLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::VocabularyLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The current state of the custom vocabulary.</p>
        pub fn state(mut self, input: crate::model::VocabularyState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the custom vocabulary.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The timestamp when the custom vocabulary was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp when the custom vocabulary was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The reason why the custom vocabulary was not created.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason why the custom vocabulary was not created.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`VocabularySummary`](crate::model::VocabularySummary).
        pub fn build(self) -> crate::model::VocabularySummary {
            crate::model::VocabularySummary {
                name: self.name,
                id: self.id,
                arn: self.arn,
                language_code: self.language_code,
                state: self.state,
                last_modified_time: self.last_modified_time,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl VocabularySummary {
    /// Creates a new builder-style object to manufacture [`VocabularySummary`](crate::model::VocabularySummary).
    pub fn builder() -> crate::model::vocabulary_summary::Builder {
        crate::model::vocabulary_summary::Builder::default()
    }
}

/// When writing a match expression against `VocabularyState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let vocabularystate = unimplemented!();
/// match vocabularystate {
///     VocabularyState::Active => { /* ... */ },
///     VocabularyState::CreationFailed => { /* ... */ },
///     VocabularyState::CreationInProgress => { /* ... */ },
///     VocabularyState::DeleteInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `vocabularystate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VocabularyState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VocabularyState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VocabularyState::NewFeature` is defined.
/// Specifically, when `vocabularystate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VocabularyState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VocabularyState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    CreationFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreationInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VocabularyState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => VocabularyState::Active,
            "CREATION_FAILED" => VocabularyState::CreationFailed,
            "CREATION_IN_PROGRESS" => VocabularyState::CreationInProgress,
            "DELETE_IN_PROGRESS" => VocabularyState::DeleteInProgress,
            other => VocabularyState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for VocabularyState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VocabularyState::from(s))
    }
}
impl VocabularyState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VocabularyState::Active => "ACTIVE",
            VocabularyState::CreationFailed => "CREATION_FAILED",
            VocabularyState::CreationInProgress => "CREATION_IN_PROGRESS",
            VocabularyState::DeleteInProgress => "DELETE_IN_PROGRESS",
            VocabularyState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "CREATION_FAILED",
            "CREATION_IN_PROGRESS",
            "DELETE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for VocabularyState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `VocabularyLanguageCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let vocabularylanguagecode = unimplemented!();
/// match vocabularylanguagecode {
///     VocabularyLanguageCode::ArAe => { /* ... */ },
///     VocabularyLanguageCode::DeCh => { /* ... */ },
///     VocabularyLanguageCode::DeDe => { /* ... */ },
///     VocabularyLanguageCode::EnAb => { /* ... */ },
///     VocabularyLanguageCode::EnAu => { /* ... */ },
///     VocabularyLanguageCode::EnGb => { /* ... */ },
///     VocabularyLanguageCode::EnIe => { /* ... */ },
///     VocabularyLanguageCode::EnIn => { /* ... */ },
///     VocabularyLanguageCode::EnNz => { /* ... */ },
///     VocabularyLanguageCode::EnUs => { /* ... */ },
///     VocabularyLanguageCode::EnWl => { /* ... */ },
///     VocabularyLanguageCode::EnZa => { /* ... */ },
///     VocabularyLanguageCode::EsEs => { /* ... */ },
///     VocabularyLanguageCode::EsUs => { /* ... */ },
///     VocabularyLanguageCode::FrCa => { /* ... */ },
///     VocabularyLanguageCode::FrFr => { /* ... */ },
///     VocabularyLanguageCode::HiIn => { /* ... */ },
///     VocabularyLanguageCode::ItIt => { /* ... */ },
///     VocabularyLanguageCode::JaJp => { /* ... */ },
///     VocabularyLanguageCode::KoKr => { /* ... */ },
///     VocabularyLanguageCode::PtBr => { /* ... */ },
///     VocabularyLanguageCode::PtPt => { /* ... */ },
///     VocabularyLanguageCode::ZhCn => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `vocabularylanguagecode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VocabularyLanguageCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VocabularyLanguageCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VocabularyLanguageCode::NewFeature` is defined.
/// Specifically, when `vocabularylanguagecode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VocabularyLanguageCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VocabularyLanguageCode {
    #[allow(missing_docs)] // documentation missing in model
    ArAe,
    #[allow(missing_docs)] // documentation missing in model
    DeCh,
    #[allow(missing_docs)] // documentation missing in model
    DeDe,
    #[allow(missing_docs)] // documentation missing in model
    EnAb,
    #[allow(missing_docs)] // documentation missing in model
    EnAu,
    #[allow(missing_docs)] // documentation missing in model
    EnGb,
    #[allow(missing_docs)] // documentation missing in model
    EnIe,
    #[allow(missing_docs)] // documentation missing in model
    EnIn,
    #[allow(missing_docs)] // documentation missing in model
    EnNz,
    #[allow(missing_docs)] // documentation missing in model
    EnUs,
    #[allow(missing_docs)] // documentation missing in model
    EnWl,
    #[allow(missing_docs)] // documentation missing in model
    EnZa,
    #[allow(missing_docs)] // documentation missing in model
    EsEs,
    #[allow(missing_docs)] // documentation missing in model
    EsUs,
    #[allow(missing_docs)] // documentation missing in model
    FrCa,
    #[allow(missing_docs)] // documentation missing in model
    FrFr,
    #[allow(missing_docs)] // documentation missing in model
    HiIn,
    #[allow(missing_docs)] // documentation missing in model
    ItIt,
    #[allow(missing_docs)] // documentation missing in model
    JaJp,
    #[allow(missing_docs)] // documentation missing in model
    KoKr,
    #[allow(missing_docs)] // documentation missing in model
    PtBr,
    #[allow(missing_docs)] // documentation missing in model
    PtPt,
    #[allow(missing_docs)] // documentation missing in model
    ZhCn,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VocabularyLanguageCode {
    fn from(s: &str) -> Self {
        match s {
            "ar-AE" => VocabularyLanguageCode::ArAe,
            "de-CH" => VocabularyLanguageCode::DeCh,
            "de-DE" => VocabularyLanguageCode::DeDe,
            "en-AB" => VocabularyLanguageCode::EnAb,
            "en-AU" => VocabularyLanguageCode::EnAu,
            "en-GB" => VocabularyLanguageCode::EnGb,
            "en-IE" => VocabularyLanguageCode::EnIe,
            "en-IN" => VocabularyLanguageCode::EnIn,
            "en-NZ" => VocabularyLanguageCode::EnNz,
            "en-US" => VocabularyLanguageCode::EnUs,
            "en-WL" => VocabularyLanguageCode::EnWl,
            "en-ZA" => VocabularyLanguageCode::EnZa,
            "es-ES" => VocabularyLanguageCode::EsEs,
            "es-US" => VocabularyLanguageCode::EsUs,
            "fr-CA" => VocabularyLanguageCode::FrCa,
            "fr-FR" => VocabularyLanguageCode::FrFr,
            "hi-IN" => VocabularyLanguageCode::HiIn,
            "it-IT" => VocabularyLanguageCode::ItIt,
            "ja-JP" => VocabularyLanguageCode::JaJp,
            "ko-KR" => VocabularyLanguageCode::KoKr,
            "pt-BR" => VocabularyLanguageCode::PtBr,
            "pt-PT" => VocabularyLanguageCode::PtPt,
            "zh-CN" => VocabularyLanguageCode::ZhCn,
            other => {
                VocabularyLanguageCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for VocabularyLanguageCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VocabularyLanguageCode::from(s))
    }
}
impl VocabularyLanguageCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VocabularyLanguageCode::ArAe => "ar-AE",
            VocabularyLanguageCode::DeCh => "de-CH",
            VocabularyLanguageCode::DeDe => "de-DE",
            VocabularyLanguageCode::EnAb => "en-AB",
            VocabularyLanguageCode::EnAu => "en-AU",
            VocabularyLanguageCode::EnGb => "en-GB",
            VocabularyLanguageCode::EnIe => "en-IE",
            VocabularyLanguageCode::EnIn => "en-IN",
            VocabularyLanguageCode::EnNz => "en-NZ",
            VocabularyLanguageCode::EnUs => "en-US",
            VocabularyLanguageCode::EnWl => "en-WL",
            VocabularyLanguageCode::EnZa => "en-ZA",
            VocabularyLanguageCode::EsEs => "es-ES",
            VocabularyLanguageCode::EsUs => "es-US",
            VocabularyLanguageCode::FrCa => "fr-CA",
            VocabularyLanguageCode::FrFr => "fr-FR",
            VocabularyLanguageCode::HiIn => "hi-IN",
            VocabularyLanguageCode::ItIt => "it-IT",
            VocabularyLanguageCode::JaJp => "ja-JP",
            VocabularyLanguageCode::KoKr => "ko-KR",
            VocabularyLanguageCode::PtBr => "pt-BR",
            VocabularyLanguageCode::PtPt => "pt-PT",
            VocabularyLanguageCode::ZhCn => "zh-CN",
            VocabularyLanguageCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ar-AE", "de-CH", "de-DE", "en-AB", "en-AU", "en-GB", "en-IE", "en-IN", "en-NZ",
            "en-US", "en-WL", "en-ZA", "es-ES", "es-US", "fr-CA", "fr-FR", "hi-IN", "it-IT",
            "ja-JP", "ko-KR", "pt-BR", "pt-PT", "zh-CN",
        ]
    }
}
impl AsRef<str> for VocabularyLanguageCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the returned users.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserSearchSummary {
    /// <p>The Amazon Resource Name (ARN) of the user.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The directory identifier of the user.</p>
    #[doc(hidden)]
    pub directory_user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the user's hierarchy group.</p>
    #[doc(hidden)]
    pub hierarchy_group_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the user's summary.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The user's first name and last name.</p>
    #[doc(hidden)]
    pub identity_info: std::option::Option<crate::model::UserIdentityInfoLite>,
    /// <p>Contains information about the phone configuration settings for a user.</p>
    #[doc(hidden)]
    pub phone_config: std::option::Option<crate::model::UserPhoneConfig>,
    /// <p>The identifier of the user's routing profile.</p>
    #[doc(hidden)]
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The identifiers of the user's security profiles.</p>
    #[doc(hidden)]
    pub security_profile_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name of the user.</p>
    #[doc(hidden)]
    pub username: std::option::Option<std::string::String>,
}
impl UserSearchSummary {
    /// <p>The Amazon Resource Name (ARN) of the user.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The directory identifier of the user.</p>
    pub fn directory_user_id(&self) -> std::option::Option<&str> {
        self.directory_user_id.as_deref()
    }
    /// <p>The identifier of the user's hierarchy group.</p>
    pub fn hierarchy_group_id(&self) -> std::option::Option<&str> {
        self.hierarchy_group_id.as_deref()
    }
    /// <p>The identifier of the user's summary.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The user's first name and last name.</p>
    pub fn identity_info(&self) -> std::option::Option<&crate::model::UserIdentityInfoLite> {
        self.identity_info.as_ref()
    }
    /// <p>Contains information about the phone configuration settings for a user.</p>
    pub fn phone_config(&self) -> std::option::Option<&crate::model::UserPhoneConfig> {
        self.phone_config.as_ref()
    }
    /// <p>The identifier of the user's routing profile.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The identifiers of the user's security profiles.</p>
    pub fn security_profile_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_profile_ids.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The name of the user.</p>
    pub fn username(&self) -> std::option::Option<&str> {
        self.username.as_deref()
    }
}
/// See [`UserSearchSummary`](crate::model::UserSearchSummary).
pub mod user_search_summary {

    /// A builder for [`UserSearchSummary`](crate::model::UserSearchSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) directory_user_id: std::option::Option<std::string::String>,
        pub(crate) hierarchy_group_id: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) identity_info: std::option::Option<crate::model::UserIdentityInfoLite>,
        pub(crate) phone_config: std::option::Option<crate::model::UserPhoneConfig>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) security_profile_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) username: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the user.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The directory identifier of the user.</p>
        pub fn directory_user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_user_id = Some(input.into());
            self
        }
        /// <p>The directory identifier of the user.</p>
        pub fn set_directory_user_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.directory_user_id = input;
            self
        }
        /// <p>The identifier of the user's hierarchy group.</p>
        pub fn hierarchy_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user's hierarchy group.</p>
        pub fn set_hierarchy_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hierarchy_group_id = input;
            self
        }
        /// <p>The identifier of the user's summary.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the user's summary.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The user's first name and last name.</p>
        pub fn identity_info(mut self, input: crate::model::UserIdentityInfoLite) -> Self {
            self.identity_info = Some(input);
            self
        }
        /// <p>The user's first name and last name.</p>
        pub fn set_identity_info(
            mut self,
            input: std::option::Option<crate::model::UserIdentityInfoLite>,
        ) -> Self {
            self.identity_info = input;
            self
        }
        /// <p>Contains information about the phone configuration settings for a user.</p>
        pub fn phone_config(mut self, input: crate::model::UserPhoneConfig) -> Self {
            self.phone_config = Some(input);
            self
        }
        /// <p>Contains information about the phone configuration settings for a user.</p>
        pub fn set_phone_config(
            mut self,
            input: std::option::Option<crate::model::UserPhoneConfig>,
        ) -> Self {
            self.phone_config = input;
            self
        }
        /// <p>The identifier of the user's routing profile.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user's routing profile.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// Appends an item to `security_profile_ids`.
        ///
        /// To override the contents of this collection use [`set_security_profile_ids`](Self::set_security_profile_ids).
        ///
        /// <p>The identifiers of the user's security profiles.</p>
        pub fn security_profile_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_profile_ids.unwrap_or_default();
            v.push(input.into());
            self.security_profile_ids = Some(v);
            self
        }
        /// <p>The identifiers of the user's security profiles.</p>
        pub fn set_security_profile_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_profile_ids = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The name of the user.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        /// <p>The name of the user.</p>
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input;
            self
        }
        /// Consumes the builder and constructs a [`UserSearchSummary`](crate::model::UserSearchSummary).
        pub fn build(self) -> crate::model::UserSearchSummary {
            crate::model::UserSearchSummary {
                arn: self.arn,
                directory_user_id: self.directory_user_id,
                hierarchy_group_id: self.hierarchy_group_id,
                id: self.id,
                identity_info: self.identity_info,
                phone_config: self.phone_config,
                routing_profile_id: self.routing_profile_id,
                security_profile_ids: self.security_profile_ids,
                tags: self.tags,
                username: self.username,
            }
        }
    }
}
impl UserSearchSummary {
    /// Creates a new builder-style object to manufacture [`UserSearchSummary`](crate::model::UserSearchSummary).
    pub fn builder() -> crate::model::user_search_summary::Builder {
        crate::model::user_search_summary::Builder::default()
    }
}

/// <p>The user's first name and last name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserIdentityInfoLite {
    /// <p>The user's first name.</p>
    #[doc(hidden)]
    pub first_name: std::option::Option<std::string::String>,
    /// <p>The user's last name.</p>
    #[doc(hidden)]
    pub last_name: std::option::Option<std::string::String>,
}
impl UserIdentityInfoLite {
    /// <p>The user's first name.</p>
    pub fn first_name(&self) -> std::option::Option<&str> {
        self.first_name.as_deref()
    }
    /// <p>The user's last name.</p>
    pub fn last_name(&self) -> std::option::Option<&str> {
        self.last_name.as_deref()
    }
}
/// See [`UserIdentityInfoLite`](crate::model::UserIdentityInfoLite).
pub mod user_identity_info_lite {

    /// A builder for [`UserIdentityInfoLite`](crate::model::UserIdentityInfoLite).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) first_name: std::option::Option<std::string::String>,
        pub(crate) last_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The user's first name.</p>
        pub fn first_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_name = Some(input.into());
            self
        }
        /// <p>The user's first name.</p>
        pub fn set_first_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.first_name = input;
            self
        }
        /// <p>The user's last name.</p>
        pub fn last_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_name = Some(input.into());
            self
        }
        /// <p>The user's last name.</p>
        pub fn set_last_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UserIdentityInfoLite`](crate::model::UserIdentityInfoLite).
        pub fn build(self) -> crate::model::UserIdentityInfoLite {
            crate::model::UserIdentityInfoLite {
                first_name: self.first_name,
                last_name: self.last_name,
            }
        }
    }
}
impl UserIdentityInfoLite {
    /// Creates a new builder-style object to manufacture [`UserIdentityInfoLite`](crate::model::UserIdentityInfoLite).
    pub fn builder() -> crate::model::user_identity_info_lite::Builder {
        crate::model::user_identity_info_lite::Builder::default()
    }
}

/// <p>The search criteria to be used to return users.</p> <note>
/// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserSearchCriteria {
    /// <p>A list of conditions which would be applied together with an <code>OR</code> condition.</p>
    #[doc(hidden)]
    pub or_conditions: std::option::Option<std::vec::Vec<crate::model::UserSearchCriteria>>,
    /// <p>A list of conditions which would be applied together with an <code>AND</code> condition. </p>
    #[doc(hidden)]
    pub and_conditions: std::option::Option<std::vec::Vec<crate::model::UserSearchCriteria>>,
    /// <p>A leaf node condition which can be used to specify a string condition.</p>
    #[doc(hidden)]
    pub string_condition: std::option::Option<crate::model::StringCondition>,
    /// <p>A leaf node condition which can be used to specify a hierarchy group condition.</p>
    #[doc(hidden)]
    pub hierarchy_group_condition: std::option::Option<crate::model::HierarchyGroupCondition>,
}
impl UserSearchCriteria {
    /// <p>A list of conditions which would be applied together with an <code>OR</code> condition.</p>
    pub fn or_conditions(&self) -> std::option::Option<&[crate::model::UserSearchCriteria]> {
        self.or_conditions.as_deref()
    }
    /// <p>A list of conditions which would be applied together with an <code>AND</code> condition. </p>
    pub fn and_conditions(&self) -> std::option::Option<&[crate::model::UserSearchCriteria]> {
        self.and_conditions.as_deref()
    }
    /// <p>A leaf node condition which can be used to specify a string condition.</p>
    pub fn string_condition(&self) -> std::option::Option<&crate::model::StringCondition> {
        self.string_condition.as_ref()
    }
    /// <p>A leaf node condition which can be used to specify a hierarchy group condition.</p>
    pub fn hierarchy_group_condition(
        &self,
    ) -> std::option::Option<&crate::model::HierarchyGroupCondition> {
        self.hierarchy_group_condition.as_ref()
    }
}
/// See [`UserSearchCriteria`](crate::model::UserSearchCriteria).
pub mod user_search_criteria {

    /// A builder for [`UserSearchCriteria`](crate::model::UserSearchCriteria).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) or_conditions:
            std::option::Option<std::vec::Vec<crate::model::UserSearchCriteria>>,
        pub(crate) and_conditions:
            std::option::Option<std::vec::Vec<crate::model::UserSearchCriteria>>,
        pub(crate) string_condition: std::option::Option<crate::model::StringCondition>,
        pub(crate) hierarchy_group_condition:
            std::option::Option<crate::model::HierarchyGroupCondition>,
    }
    impl Builder {
        /// Appends an item to `or_conditions`.
        ///
        /// To override the contents of this collection use [`set_or_conditions`](Self::set_or_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an <code>OR</code> condition.</p>
        pub fn or_conditions(mut self, input: crate::model::UserSearchCriteria) -> Self {
            let mut v = self.or_conditions.unwrap_or_default();
            v.push(input);
            self.or_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an <code>OR</code> condition.</p>
        pub fn set_or_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UserSearchCriteria>>,
        ) -> Self {
            self.or_conditions = input;
            self
        }
        /// Appends an item to `and_conditions`.
        ///
        /// To override the contents of this collection use [`set_and_conditions`](Self::set_and_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an <code>AND</code> condition. </p>
        pub fn and_conditions(mut self, input: crate::model::UserSearchCriteria) -> Self {
            let mut v = self.and_conditions.unwrap_or_default();
            v.push(input);
            self.and_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an <code>AND</code> condition. </p>
        pub fn set_and_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UserSearchCriteria>>,
        ) -> Self {
            self.and_conditions = input;
            self
        }
        /// <p>A leaf node condition which can be used to specify a string condition.</p>
        pub fn string_condition(mut self, input: crate::model::StringCondition) -> Self {
            self.string_condition = Some(input);
            self
        }
        /// <p>A leaf node condition which can be used to specify a string condition.</p>
        pub fn set_string_condition(
            mut self,
            input: std::option::Option<crate::model::StringCondition>,
        ) -> Self {
            self.string_condition = input;
            self
        }
        /// <p>A leaf node condition which can be used to specify a hierarchy group condition.</p>
        pub fn hierarchy_group_condition(
            mut self,
            input: crate::model::HierarchyGroupCondition,
        ) -> Self {
            self.hierarchy_group_condition = Some(input);
            self
        }
        /// <p>A leaf node condition which can be used to specify a hierarchy group condition.</p>
        pub fn set_hierarchy_group_condition(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupCondition>,
        ) -> Self {
            self.hierarchy_group_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`UserSearchCriteria`](crate::model::UserSearchCriteria).
        pub fn build(self) -> crate::model::UserSearchCriteria {
            crate::model::UserSearchCriteria {
                or_conditions: self.or_conditions,
                and_conditions: self.and_conditions,
                string_condition: self.string_condition,
                hierarchy_group_condition: self.hierarchy_group_condition,
            }
        }
    }
}
impl UserSearchCriteria {
    /// Creates a new builder-style object to manufacture [`UserSearchCriteria`](crate::model::UserSearchCriteria).
    pub fn builder() -> crate::model::user_search_criteria::Builder {
        crate::model::user_search_criteria::Builder::default()
    }
}

/// <p>A leaf node condition which can be used to specify a hierarchy group condition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HierarchyGroupCondition {
    /// <p>The value in the hierarchy group condition.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The type of hierarchy group match.</p>
    #[doc(hidden)]
    pub hierarchy_group_match_type: std::option::Option<crate::model::HierarchyGroupMatchType>,
}
impl HierarchyGroupCondition {
    /// <p>The value in the hierarchy group condition.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The type of hierarchy group match.</p>
    pub fn hierarchy_group_match_type(
        &self,
    ) -> std::option::Option<&crate::model::HierarchyGroupMatchType> {
        self.hierarchy_group_match_type.as_ref()
    }
}
/// See [`HierarchyGroupCondition`](crate::model::HierarchyGroupCondition).
pub mod hierarchy_group_condition {

    /// A builder for [`HierarchyGroupCondition`](crate::model::HierarchyGroupCondition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) hierarchy_group_match_type:
            std::option::Option<crate::model::HierarchyGroupMatchType>,
    }
    impl Builder {
        /// <p>The value in the hierarchy group condition.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value in the hierarchy group condition.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The type of hierarchy group match.</p>
        pub fn hierarchy_group_match_type(
            mut self,
            input: crate::model::HierarchyGroupMatchType,
        ) -> Self {
            self.hierarchy_group_match_type = Some(input);
            self
        }
        /// <p>The type of hierarchy group match.</p>
        pub fn set_hierarchy_group_match_type(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupMatchType>,
        ) -> Self {
            self.hierarchy_group_match_type = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyGroupCondition`](crate::model::HierarchyGroupCondition).
        pub fn build(self) -> crate::model::HierarchyGroupCondition {
            crate::model::HierarchyGroupCondition {
                value: self.value,
                hierarchy_group_match_type: self.hierarchy_group_match_type,
            }
        }
    }
}
impl HierarchyGroupCondition {
    /// Creates a new builder-style object to manufacture [`HierarchyGroupCondition`](crate::model::HierarchyGroupCondition).
    pub fn builder() -> crate::model::hierarchy_group_condition::Builder {
        crate::model::hierarchy_group_condition::Builder::default()
    }
}

/// When writing a match expression against `HierarchyGroupMatchType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let hierarchygroupmatchtype = unimplemented!();
/// match hierarchygroupmatchtype {
///     HierarchyGroupMatchType::Exact => { /* ... */ },
///     HierarchyGroupMatchType::WithChildGroups => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `hierarchygroupmatchtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HierarchyGroupMatchType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HierarchyGroupMatchType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HierarchyGroupMatchType::NewFeature` is defined.
/// Specifically, when `hierarchygroupmatchtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HierarchyGroupMatchType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HierarchyGroupMatchType {
    #[allow(missing_docs)] // documentation missing in model
    Exact,
    #[allow(missing_docs)] // documentation missing in model
    WithChildGroups,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HierarchyGroupMatchType {
    fn from(s: &str) -> Self {
        match s {
            "EXACT" => HierarchyGroupMatchType::Exact,
            "WITH_CHILD_GROUPS" => HierarchyGroupMatchType::WithChildGroups,
            other => HierarchyGroupMatchType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for HierarchyGroupMatchType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HierarchyGroupMatchType::from(s))
    }
}
impl HierarchyGroupMatchType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HierarchyGroupMatchType::Exact => "EXACT",
            HierarchyGroupMatchType::WithChildGroups => "WITH_CHILD_GROUPS",
            HierarchyGroupMatchType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EXACT", "WITH_CHILD_GROUPS"]
    }
}
impl AsRef<str> for HierarchyGroupMatchType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A leaf node condition which can be used to specify a string condition. </p> <note>
/// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StringCondition {
    /// <p>The name of the field in the string condition.</p>
    #[doc(hidden)]
    pub field_name: std::option::Option<std::string::String>,
    /// <p>The value of the string.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The type of comparison to be made when evaluating the string condition.</p>
    #[doc(hidden)]
    pub comparison_type: std::option::Option<crate::model::StringComparisonType>,
}
impl StringCondition {
    /// <p>The name of the field in the string condition.</p>
    pub fn field_name(&self) -> std::option::Option<&str> {
        self.field_name.as_deref()
    }
    /// <p>The value of the string.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The type of comparison to be made when evaluating the string condition.</p>
    pub fn comparison_type(&self) -> std::option::Option<&crate::model::StringComparisonType> {
        self.comparison_type.as_ref()
    }
}
/// See [`StringCondition`](crate::model::StringCondition).
pub mod string_condition {

    /// A builder for [`StringCondition`](crate::model::StringCondition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) comparison_type: std::option::Option<crate::model::StringComparisonType>,
    }
    impl Builder {
        /// <p>The name of the field in the string condition.</p>
        pub fn field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_name = Some(input.into());
            self
        }
        /// <p>The name of the field in the string condition.</p>
        pub fn set_field_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_name = input;
            self
        }
        /// <p>The value of the string.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the string.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The type of comparison to be made when evaluating the string condition.</p>
        pub fn comparison_type(mut self, input: crate::model::StringComparisonType) -> Self {
            self.comparison_type = Some(input);
            self
        }
        /// <p>The type of comparison to be made when evaluating the string condition.</p>
        pub fn set_comparison_type(
            mut self,
            input: std::option::Option<crate::model::StringComparisonType>,
        ) -> Self {
            self.comparison_type = input;
            self
        }
        /// Consumes the builder and constructs a [`StringCondition`](crate::model::StringCondition).
        pub fn build(self) -> crate::model::StringCondition {
            crate::model::StringCondition {
                field_name: self.field_name,
                value: self.value,
                comparison_type: self.comparison_type,
            }
        }
    }
}
impl StringCondition {
    /// Creates a new builder-style object to manufacture [`StringCondition`](crate::model::StringCondition).
    pub fn builder() -> crate::model::string_condition::Builder {
        crate::model::string_condition::Builder::default()
    }
}

/// When writing a match expression against `StringComparisonType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let stringcomparisontype = unimplemented!();
/// match stringcomparisontype {
///     StringComparisonType::Contains => { /* ... */ },
///     StringComparisonType::Exact => { /* ... */ },
///     StringComparisonType::StartsWith => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `stringcomparisontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StringComparisonType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StringComparisonType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StringComparisonType::NewFeature` is defined.
/// Specifically, when `stringcomparisontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StringComparisonType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StringComparisonType {
    #[allow(missing_docs)] // documentation missing in model
    Contains,
    #[allow(missing_docs)] // documentation missing in model
    Exact,
    #[allow(missing_docs)] // documentation missing in model
    StartsWith,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StringComparisonType {
    fn from(s: &str) -> Self {
        match s {
            "CONTAINS" => StringComparisonType::Contains,
            "EXACT" => StringComparisonType::Exact,
            "STARTS_WITH" => StringComparisonType::StartsWith,
            other => {
                StringComparisonType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for StringComparisonType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StringComparisonType::from(s))
    }
}
impl StringComparisonType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StringComparisonType::Contains => "CONTAINS",
            StringComparisonType::Exact => "EXACT",
            StringComparisonType::StartsWith => "STARTS_WITH",
            StringComparisonType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CONTAINS", "EXACT", "STARTS_WITH"]
    }
}
impl AsRef<str> for StringComparisonType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Filters to be applied to search results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserSearchFilter {
    /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
    /// <ul>
    /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
    /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub tag_filter: std::option::Option<crate::model::ControlPlaneTagFilter>,
}
impl UserSearchFilter {
    /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
    /// <ul>
    /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
    /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
    /// </ul>
    pub fn tag_filter(&self) -> std::option::Option<&crate::model::ControlPlaneTagFilter> {
        self.tag_filter.as_ref()
    }
}
/// See [`UserSearchFilter`](crate::model::UserSearchFilter).
pub mod user_search_filter {

    /// A builder for [`UserSearchFilter`](crate::model::UserSearchFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tag_filter: std::option::Option<crate::model::ControlPlaneTagFilter>,
    }
    impl Builder {
        /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
        /// <ul>
        /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
        /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
        /// </ul>
        pub fn tag_filter(mut self, input: crate::model::ControlPlaneTagFilter) -> Self {
            self.tag_filter = Some(input);
            self
        }
        /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
        /// <ul>
        /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
        /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
        /// </ul>
        pub fn set_tag_filter(
            mut self,
            input: std::option::Option<crate::model::ControlPlaneTagFilter>,
        ) -> Self {
            self.tag_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`UserSearchFilter`](crate::model::UserSearchFilter).
        pub fn build(self) -> crate::model::UserSearchFilter {
            crate::model::UserSearchFilter {
                tag_filter: self.tag_filter,
            }
        }
    }
}
impl UserSearchFilter {
    /// Creates a new builder-style object to manufacture [`UserSearchFilter`](crate::model::UserSearchFilter).
    pub fn builder() -> crate::model::user_search_filter::Builder {
        crate::model::user_search_filter::Builder::default()
    }
}

/// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
/// <ul>
/// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
/// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ControlPlaneTagFilter {
    /// <p>A list of conditions which would be applied together with an <code>OR</code> condition. </p>
    #[doc(hidden)]
    pub or_conditions:
        std::option::Option<std::vec::Vec<std::vec::Vec<crate::model::TagCondition>>>,
    /// <p>A list of conditions which would be applied together with an <code>AND</code> condition.</p>
    #[doc(hidden)]
    pub and_conditions: std::option::Option<std::vec::Vec<crate::model::TagCondition>>,
    /// <p>A leaf node condition which can be used to specify a tag condition. </p>
    #[doc(hidden)]
    pub tag_condition: std::option::Option<crate::model::TagCondition>,
}
impl ControlPlaneTagFilter {
    /// <p>A list of conditions which would be applied together with an <code>OR</code> condition. </p>
    pub fn or_conditions(
        &self,
    ) -> std::option::Option<&[std::vec::Vec<crate::model::TagCondition>]> {
        self.or_conditions.as_deref()
    }
    /// <p>A list of conditions which would be applied together with an <code>AND</code> condition.</p>
    pub fn and_conditions(&self) -> std::option::Option<&[crate::model::TagCondition]> {
        self.and_conditions.as_deref()
    }
    /// <p>A leaf node condition which can be used to specify a tag condition. </p>
    pub fn tag_condition(&self) -> std::option::Option<&crate::model::TagCondition> {
        self.tag_condition.as_ref()
    }
}
/// See [`ControlPlaneTagFilter`](crate::model::ControlPlaneTagFilter).
pub mod control_plane_tag_filter {

    /// A builder for [`ControlPlaneTagFilter`](crate::model::ControlPlaneTagFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) or_conditions:
            std::option::Option<std::vec::Vec<std::vec::Vec<crate::model::TagCondition>>>,
        pub(crate) and_conditions: std::option::Option<std::vec::Vec<crate::model::TagCondition>>,
        pub(crate) tag_condition: std::option::Option<crate::model::TagCondition>,
    }
    impl Builder {
        /// Appends an item to `or_conditions`.
        ///
        /// To override the contents of this collection use [`set_or_conditions`](Self::set_or_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an <code>OR</code> condition. </p>
        pub fn or_conditions(mut self, input: std::vec::Vec<crate::model::TagCondition>) -> Self {
            let mut v = self.or_conditions.unwrap_or_default();
            v.push(input);
            self.or_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an <code>OR</code> condition. </p>
        pub fn set_or_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<crate::model::TagCondition>>>,
        ) -> Self {
            self.or_conditions = input;
            self
        }
        /// Appends an item to `and_conditions`.
        ///
        /// To override the contents of this collection use [`set_and_conditions`](Self::set_and_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an <code>AND</code> condition.</p>
        pub fn and_conditions(mut self, input: crate::model::TagCondition) -> Self {
            let mut v = self.and_conditions.unwrap_or_default();
            v.push(input);
            self.and_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an <code>AND</code> condition.</p>
        pub fn set_and_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagCondition>>,
        ) -> Self {
            self.and_conditions = input;
            self
        }
        /// <p>A leaf node condition which can be used to specify a tag condition. </p>
        pub fn tag_condition(mut self, input: crate::model::TagCondition) -> Self {
            self.tag_condition = Some(input);
            self
        }
        /// <p>A leaf node condition which can be used to specify a tag condition. </p>
        pub fn set_tag_condition(
            mut self,
            input: std::option::Option<crate::model::TagCondition>,
        ) -> Self {
            self.tag_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`ControlPlaneTagFilter`](crate::model::ControlPlaneTagFilter).
        pub fn build(self) -> crate::model::ControlPlaneTagFilter {
            crate::model::ControlPlaneTagFilter {
                or_conditions: self.or_conditions,
                and_conditions: self.and_conditions,
                tag_condition: self.tag_condition,
            }
        }
    }
}
impl ControlPlaneTagFilter {
    /// Creates a new builder-style object to manufacture [`ControlPlaneTagFilter`](crate::model::ControlPlaneTagFilter).
    pub fn builder() -> crate::model::control_plane_tag_filter::Builder {
        crate::model::control_plane_tag_filter::Builder::default()
    }
}

/// <p>A leaf node condition which can be used to specify a tag condition, for example, <code>HAVE BPO = 123</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagCondition {
    /// <p>The tag key in the tag condition.</p>
    #[doc(hidden)]
    pub tag_key: std::option::Option<std::string::String>,
    /// <p>The tag value in the tag condition.</p>
    #[doc(hidden)]
    pub tag_value: std::option::Option<std::string::String>,
}
impl TagCondition {
    /// <p>The tag key in the tag condition.</p>
    pub fn tag_key(&self) -> std::option::Option<&str> {
        self.tag_key.as_deref()
    }
    /// <p>The tag value in the tag condition.</p>
    pub fn tag_value(&self) -> std::option::Option<&str> {
        self.tag_value.as_deref()
    }
}
/// See [`TagCondition`](crate::model::TagCondition).
pub mod tag_condition {

    /// A builder for [`TagCondition`](crate::model::TagCondition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tag_key: std::option::Option<std::string::String>,
        pub(crate) tag_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag key in the tag condition.</p>
        pub fn tag_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_key = Some(input.into());
            self
        }
        /// <p>The tag key in the tag condition.</p>
        pub fn set_tag_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tag_key = input;
            self
        }
        /// <p>The tag value in the tag condition.</p>
        pub fn tag_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_value = Some(input.into());
            self
        }
        /// <p>The tag value in the tag condition.</p>
        pub fn set_tag_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tag_value = input;
            self
        }
        /// Consumes the builder and constructs a [`TagCondition`](crate::model::TagCondition).
        pub fn build(self) -> crate::model::TagCondition {
            crate::model::TagCondition {
                tag_key: self.tag_key,
                tag_value: self.tag_value,
            }
        }
    }
}
impl TagCondition {
    /// Creates a new builder-style object to manufacture [`TagCondition`](crate::model::TagCondition).
    pub fn builder() -> crate::model::tag_condition::Builder {
        crate::model::tag_condition::Builder::default()
    }
}

/// <p>Information about the returned security profiles.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SecurityProfileSearchSummary {
    /// <p>The identifier of the security profile.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The organization resource identifier.</p>
    #[doc(hidden)]
    pub organization_resource_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the security profile.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the security profile.</p>
    #[doc(hidden)]
    pub security_profile_name: std::option::Option<std::string::String>,
    /// <p>The description of the security profile.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl SecurityProfileSearchSummary {
    /// <p>The identifier of the security profile.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The organization resource identifier.</p>
    pub fn organization_resource_id(&self) -> std::option::Option<&str> {
        self.organization_resource_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the security profile.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the security profile.</p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
    /// <p>The description of the security profile.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`SecurityProfileSearchSummary`](crate::model::SecurityProfileSearchSummary).
pub mod security_profile_search_summary {

    /// A builder for [`SecurityProfileSearchSummary`](crate::model::SecurityProfileSearchSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) organization_resource_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the security profile.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the security profile.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The organization resource identifier.</p>
        pub fn organization_resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.organization_resource_id = Some(input.into());
            self
        }
        /// <p>The organization resource identifier.</p>
        pub fn set_organization_resource_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_resource_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the security profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the security profile.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the security profile.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p>The name of the security profile.</p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// <p>The description of the security profile.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the security profile.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityProfileSearchSummary`](crate::model::SecurityProfileSearchSummary).
        pub fn build(self) -> crate::model::SecurityProfileSearchSummary {
            crate::model::SecurityProfileSearchSummary {
                id: self.id,
                organization_resource_id: self.organization_resource_id,
                arn: self.arn,
                security_profile_name: self.security_profile_name,
                description: self.description,
                tags: self.tags,
            }
        }
    }
}
impl SecurityProfileSearchSummary {
    /// Creates a new builder-style object to manufacture [`SecurityProfileSearchSummary`](crate::model::SecurityProfileSearchSummary).
    pub fn builder() -> crate::model::security_profile_search_summary::Builder {
        crate::model::security_profile_search_summary::Builder::default()
    }
}

/// <p>Filters to be applied to search results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SecurityProfilesSearchFilter {
    /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
    /// <ul>
    /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
    /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub tag_filter: std::option::Option<crate::model::ControlPlaneTagFilter>,
}
impl SecurityProfilesSearchFilter {
    /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
    /// <ul>
    /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
    /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
    /// </ul>
    pub fn tag_filter(&self) -> std::option::Option<&crate::model::ControlPlaneTagFilter> {
        self.tag_filter.as_ref()
    }
}
/// See [`SecurityProfilesSearchFilter`](crate::model::SecurityProfilesSearchFilter).
pub mod security_profiles_search_filter {

    /// A builder for [`SecurityProfilesSearchFilter`](crate::model::SecurityProfilesSearchFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tag_filter: std::option::Option<crate::model::ControlPlaneTagFilter>,
    }
    impl Builder {
        /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
        /// <ul>
        /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
        /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
        /// </ul>
        pub fn tag_filter(mut self, input: crate::model::ControlPlaneTagFilter) -> Self {
            self.tag_filter = Some(input);
            self
        }
        /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
        /// <ul>
        /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
        /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
        /// </ul>
        pub fn set_tag_filter(
            mut self,
            input: std::option::Option<crate::model::ControlPlaneTagFilter>,
        ) -> Self {
            self.tag_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityProfilesSearchFilter`](crate::model::SecurityProfilesSearchFilter).
        pub fn build(self) -> crate::model::SecurityProfilesSearchFilter {
            crate::model::SecurityProfilesSearchFilter {
                tag_filter: self.tag_filter,
            }
        }
    }
}
impl SecurityProfilesSearchFilter {
    /// Creates a new builder-style object to manufacture [`SecurityProfilesSearchFilter`](crate::model::SecurityProfilesSearchFilter).
    pub fn builder() -> crate::model::security_profiles_search_filter::Builder {
        crate::model::security_profiles_search_filter::Builder::default()
    }
}

/// <p>The search criteria to be used to return security profiles.</p> <note>
/// <p>The <code>name</code> field support "contains" queries with a minimum of 2 characters and maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SecurityProfileSearchCriteria {
    /// <p>A list of conditions which would be applied together with an OR condition.</p>
    #[doc(hidden)]
    pub or_conditions:
        std::option::Option<std::vec::Vec<crate::model::SecurityProfileSearchCriteria>>,
    /// <p>A list of conditions which would be applied together with an AND condition.</p>
    #[doc(hidden)]
    pub and_conditions:
        std::option::Option<std::vec::Vec<crate::model::SecurityProfileSearchCriteria>>,
    /// <p>A leaf node condition which can be used to specify a string condition. </p> <note>
    /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
    /// </note>
    #[doc(hidden)]
    pub string_condition: std::option::Option<crate::model::StringCondition>,
}
impl SecurityProfileSearchCriteria {
    /// <p>A list of conditions which would be applied together with an OR condition.</p>
    pub fn or_conditions(
        &self,
    ) -> std::option::Option<&[crate::model::SecurityProfileSearchCriteria]> {
        self.or_conditions.as_deref()
    }
    /// <p>A list of conditions which would be applied together with an AND condition.</p>
    pub fn and_conditions(
        &self,
    ) -> std::option::Option<&[crate::model::SecurityProfileSearchCriteria]> {
        self.and_conditions.as_deref()
    }
    /// <p>A leaf node condition which can be used to specify a string condition. </p> <note>
    /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
    /// </note>
    pub fn string_condition(&self) -> std::option::Option<&crate::model::StringCondition> {
        self.string_condition.as_ref()
    }
}
/// See [`SecurityProfileSearchCriteria`](crate::model::SecurityProfileSearchCriteria).
pub mod security_profile_search_criteria {

    /// A builder for [`SecurityProfileSearchCriteria`](crate::model::SecurityProfileSearchCriteria).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) or_conditions:
            std::option::Option<std::vec::Vec<crate::model::SecurityProfileSearchCriteria>>,
        pub(crate) and_conditions:
            std::option::Option<std::vec::Vec<crate::model::SecurityProfileSearchCriteria>>,
        pub(crate) string_condition: std::option::Option<crate::model::StringCondition>,
    }
    impl Builder {
        /// Appends an item to `or_conditions`.
        ///
        /// To override the contents of this collection use [`set_or_conditions`](Self::set_or_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an OR condition.</p>
        pub fn or_conditions(mut self, input: crate::model::SecurityProfileSearchCriteria) -> Self {
            let mut v = self.or_conditions.unwrap_or_default();
            v.push(input);
            self.or_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an OR condition.</p>
        pub fn set_or_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SecurityProfileSearchCriteria>>,
        ) -> Self {
            self.or_conditions = input;
            self
        }
        /// Appends an item to `and_conditions`.
        ///
        /// To override the contents of this collection use [`set_and_conditions`](Self::set_and_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an AND condition.</p>
        pub fn and_conditions(
            mut self,
            input: crate::model::SecurityProfileSearchCriteria,
        ) -> Self {
            let mut v = self.and_conditions.unwrap_or_default();
            v.push(input);
            self.and_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an AND condition.</p>
        pub fn set_and_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SecurityProfileSearchCriteria>>,
        ) -> Self {
            self.and_conditions = input;
            self
        }
        /// <p>A leaf node condition which can be used to specify a string condition. </p> <note>
        /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
        /// </note>
        pub fn string_condition(mut self, input: crate::model::StringCondition) -> Self {
            self.string_condition = Some(input);
            self
        }
        /// <p>A leaf node condition which can be used to specify a string condition. </p> <note>
        /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
        /// </note>
        pub fn set_string_condition(
            mut self,
            input: std::option::Option<crate::model::StringCondition>,
        ) -> Self {
            self.string_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityProfileSearchCriteria`](crate::model::SecurityProfileSearchCriteria).
        pub fn build(self) -> crate::model::SecurityProfileSearchCriteria {
            crate::model::SecurityProfileSearchCriteria {
                or_conditions: self.or_conditions,
                and_conditions: self.and_conditions,
                string_condition: self.string_condition,
            }
        }
    }
}
impl SecurityProfileSearchCriteria {
    /// Creates a new builder-style object to manufacture [`SecurityProfileSearchCriteria`](crate::model::SecurityProfileSearchCriteria).
    pub fn builder() -> crate::model::security_profile_search_criteria::Builder {
        crate::model::security_profile_search_criteria::Builder::default()
    }
}

/// <p>Contains information about a routing profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RoutingProfile {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the routing profile.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    #[doc(hidden)]
    pub routing_profile_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the routing profile.</p>
    #[doc(hidden)]
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The description of the routing profile.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
    #[doc(hidden)]
    pub media_concurrencies: std::option::Option<std::vec::Vec<crate::model::MediaConcurrency>>,
    /// <p>The identifier of the default outbound queue for this routing profile.</p>
    #[doc(hidden)]
    pub default_outbound_queue_id: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The number of associated queues in routing profile.</p>
    #[doc(hidden)]
    pub number_of_associated_queues: std::option::Option<i64>,
    /// <p>The number of associated users in routing profile.</p>
    #[doc(hidden)]
    pub number_of_associated_users: std::option::Option<i64>,
}
impl RoutingProfile {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the routing profile.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    pub fn routing_profile_arn(&self) -> std::option::Option<&str> {
        self.routing_profile_arn.as_deref()
    }
    /// <p>The identifier of the routing profile.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The description of the routing profile.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
    pub fn media_concurrencies(&self) -> std::option::Option<&[crate::model::MediaConcurrency]> {
        self.media_concurrencies.as_deref()
    }
    /// <p>The identifier of the default outbound queue for this routing profile.</p>
    pub fn default_outbound_queue_id(&self) -> std::option::Option<&str> {
        self.default_outbound_queue_id.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The number of associated queues in routing profile.</p>
    pub fn number_of_associated_queues(&self) -> std::option::Option<i64> {
        self.number_of_associated_queues
    }
    /// <p>The number of associated users in routing profile.</p>
    pub fn number_of_associated_users(&self) -> std::option::Option<i64> {
        self.number_of_associated_users
    }
}
/// See [`RoutingProfile`](crate::model::RoutingProfile).
pub mod routing_profile {

    /// A builder for [`RoutingProfile`](crate::model::RoutingProfile).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) routing_profile_arn: std::option::Option<std::string::String>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) media_concurrencies:
            std::option::Option<std::vec::Vec<crate::model::MediaConcurrency>>,
        pub(crate) default_outbound_queue_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) number_of_associated_queues: std::option::Option<i64>,
        pub(crate) number_of_associated_users: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the routing profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the routing profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
        pub fn routing_profile_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
        pub fn set_routing_profile_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_arn = input;
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// <p>The description of the routing profile.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the routing profile.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `media_concurrencies`.
        ///
        /// To override the contents of this collection use [`set_media_concurrencies`](Self::set_media_concurrencies).
        ///
        /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
        pub fn media_concurrencies(mut self, input: crate::model::MediaConcurrency) -> Self {
            let mut v = self.media_concurrencies.unwrap_or_default();
            v.push(input);
            self.media_concurrencies = Some(v);
            self
        }
        /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
        pub fn set_media_concurrencies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MediaConcurrency>>,
        ) -> Self {
            self.media_concurrencies = input;
            self
        }
        /// <p>The identifier of the default outbound queue for this routing profile.</p>
        pub fn default_outbound_queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_outbound_queue_id = Some(input.into());
            self
        }
        /// <p>The identifier of the default outbound queue for this routing profile.</p>
        pub fn set_default_outbound_queue_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_outbound_queue_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The number of associated queues in routing profile.</p>
        pub fn number_of_associated_queues(mut self, input: i64) -> Self {
            self.number_of_associated_queues = Some(input);
            self
        }
        /// <p>The number of associated queues in routing profile.</p>
        pub fn set_number_of_associated_queues(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_associated_queues = input;
            self
        }
        /// <p>The number of associated users in routing profile.</p>
        pub fn number_of_associated_users(mut self, input: i64) -> Self {
            self.number_of_associated_users = Some(input);
            self
        }
        /// <p>The number of associated users in routing profile.</p>
        pub fn set_number_of_associated_users(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_associated_users = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfile`](crate::model::RoutingProfile).
        pub fn build(self) -> crate::model::RoutingProfile {
            crate::model::RoutingProfile {
                instance_id: self.instance_id,
                name: self.name,
                routing_profile_arn: self.routing_profile_arn,
                routing_profile_id: self.routing_profile_id,
                description: self.description,
                media_concurrencies: self.media_concurrencies,
                default_outbound_queue_id: self.default_outbound_queue_id,
                tags: self.tags,
                number_of_associated_queues: self.number_of_associated_queues,
                number_of_associated_users: self.number_of_associated_users,
            }
        }
    }
}
impl RoutingProfile {
    /// Creates a new builder-style object to manufacture [`RoutingProfile`](crate::model::RoutingProfile).
    pub fn builder() -> crate::model::routing_profile::Builder {
        crate::model::routing_profile::Builder::default()
    }
}

/// <p>The search criteria to be used to return routing profiles.</p> <note>
/// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RoutingProfileSearchCriteria {
    /// <p>A list of conditions which would be applied together with an OR condition.</p>
    #[doc(hidden)]
    pub or_conditions:
        std::option::Option<std::vec::Vec<crate::model::RoutingProfileSearchCriteria>>,
    /// <p>A list of conditions which would be applied together with an AND condition.</p>
    #[doc(hidden)]
    pub and_conditions:
        std::option::Option<std::vec::Vec<crate::model::RoutingProfileSearchCriteria>>,
    /// <p>A leaf node condition which can be used to specify a string condition. </p> <note>
    /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
    /// </note>
    #[doc(hidden)]
    pub string_condition: std::option::Option<crate::model::StringCondition>,
}
impl RoutingProfileSearchCriteria {
    /// <p>A list of conditions which would be applied together with an OR condition.</p>
    pub fn or_conditions(
        &self,
    ) -> std::option::Option<&[crate::model::RoutingProfileSearchCriteria]> {
        self.or_conditions.as_deref()
    }
    /// <p>A list of conditions which would be applied together with an AND condition.</p>
    pub fn and_conditions(
        &self,
    ) -> std::option::Option<&[crate::model::RoutingProfileSearchCriteria]> {
        self.and_conditions.as_deref()
    }
    /// <p>A leaf node condition which can be used to specify a string condition. </p> <note>
    /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
    /// </note>
    pub fn string_condition(&self) -> std::option::Option<&crate::model::StringCondition> {
        self.string_condition.as_ref()
    }
}
/// See [`RoutingProfileSearchCriteria`](crate::model::RoutingProfileSearchCriteria).
pub mod routing_profile_search_criteria {

    /// A builder for [`RoutingProfileSearchCriteria`](crate::model::RoutingProfileSearchCriteria).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) or_conditions:
            std::option::Option<std::vec::Vec<crate::model::RoutingProfileSearchCriteria>>,
        pub(crate) and_conditions:
            std::option::Option<std::vec::Vec<crate::model::RoutingProfileSearchCriteria>>,
        pub(crate) string_condition: std::option::Option<crate::model::StringCondition>,
    }
    impl Builder {
        /// Appends an item to `or_conditions`.
        ///
        /// To override the contents of this collection use [`set_or_conditions`](Self::set_or_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an OR condition.</p>
        pub fn or_conditions(mut self, input: crate::model::RoutingProfileSearchCriteria) -> Self {
            let mut v = self.or_conditions.unwrap_or_default();
            v.push(input);
            self.or_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an OR condition.</p>
        pub fn set_or_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RoutingProfileSearchCriteria>>,
        ) -> Self {
            self.or_conditions = input;
            self
        }
        /// Appends an item to `and_conditions`.
        ///
        /// To override the contents of this collection use [`set_and_conditions`](Self::set_and_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an AND condition.</p>
        pub fn and_conditions(mut self, input: crate::model::RoutingProfileSearchCriteria) -> Self {
            let mut v = self.and_conditions.unwrap_or_default();
            v.push(input);
            self.and_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an AND condition.</p>
        pub fn set_and_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RoutingProfileSearchCriteria>>,
        ) -> Self {
            self.and_conditions = input;
            self
        }
        /// <p>A leaf node condition which can be used to specify a string condition. </p> <note>
        /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
        /// </note>
        pub fn string_condition(mut self, input: crate::model::StringCondition) -> Self {
            self.string_condition = Some(input);
            self
        }
        /// <p>A leaf node condition which can be used to specify a string condition. </p> <note>
        /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
        /// </note>
        pub fn set_string_condition(
            mut self,
            input: std::option::Option<crate::model::StringCondition>,
        ) -> Self {
            self.string_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfileSearchCriteria`](crate::model::RoutingProfileSearchCriteria).
        pub fn build(self) -> crate::model::RoutingProfileSearchCriteria {
            crate::model::RoutingProfileSearchCriteria {
                or_conditions: self.or_conditions,
                and_conditions: self.and_conditions,
                string_condition: self.string_condition,
            }
        }
    }
}
impl RoutingProfileSearchCriteria {
    /// Creates a new builder-style object to manufacture [`RoutingProfileSearchCriteria`](crate::model::RoutingProfileSearchCriteria).
    pub fn builder() -> crate::model::routing_profile_search_criteria::Builder {
        crate::model::routing_profile_search_criteria::Builder::default()
    }
}

/// <p>Filters to be applied to search results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RoutingProfileSearchFilter {
    /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
    /// <ul>
    /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
    /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub tag_filter: std::option::Option<crate::model::ControlPlaneTagFilter>,
}
impl RoutingProfileSearchFilter {
    /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
    /// <ul>
    /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
    /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
    /// </ul>
    pub fn tag_filter(&self) -> std::option::Option<&crate::model::ControlPlaneTagFilter> {
        self.tag_filter.as_ref()
    }
}
/// See [`RoutingProfileSearchFilter`](crate::model::RoutingProfileSearchFilter).
pub mod routing_profile_search_filter {

    /// A builder for [`RoutingProfileSearchFilter`](crate::model::RoutingProfileSearchFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tag_filter: std::option::Option<crate::model::ControlPlaneTagFilter>,
    }
    impl Builder {
        /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
        /// <ul>
        /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
        /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
        /// </ul>
        pub fn tag_filter(mut self, input: crate::model::ControlPlaneTagFilter) -> Self {
            self.tag_filter = Some(input);
            self
        }
        /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
        /// <ul>
        /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
        /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
        /// </ul>
        pub fn set_tag_filter(
            mut self,
            input: std::option::Option<crate::model::ControlPlaneTagFilter>,
        ) -> Self {
            self.tag_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfileSearchFilter`](crate::model::RoutingProfileSearchFilter).
        pub fn build(self) -> crate::model::RoutingProfileSearchFilter {
            crate::model::RoutingProfileSearchFilter {
                tag_filter: self.tag_filter,
            }
        }
    }
}
impl RoutingProfileSearchFilter {
    /// Creates a new builder-style object to manufacture [`RoutingProfileSearchFilter`](crate::model::RoutingProfileSearchFilter).
    pub fn builder() -> crate::model::routing_profile_search_filter::Builder {
        crate::model::routing_profile_search_filter::Builder::default()
    }
}

/// <p>Contains information about a queue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Queue {
    /// <p>The name of the queue.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the queue.</p>
    #[doc(hidden)]
    pub queue_arn: std::option::Option<std::string::String>,
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The description of the queue.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
    #[doc(hidden)]
    pub outbound_caller_config: std::option::Option<crate::model::OutboundCallerConfig>,
    /// <p>The identifier for the hours of operation.</p>
    #[doc(hidden)]
    pub hours_of_operation_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
    #[doc(hidden)]
    pub max_contacts: std::option::Option<i32>,
    /// <p>The status of the queue.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::QueueStatus>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Queue {
    /// <p>The name of the queue.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the queue.</p>
    pub fn queue_arn(&self) -> std::option::Option<&str> {
        self.queue_arn.as_deref()
    }
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The description of the queue.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
    pub fn outbound_caller_config(
        &self,
    ) -> std::option::Option<&crate::model::OutboundCallerConfig> {
        self.outbound_caller_config.as_ref()
    }
    /// <p>The identifier for the hours of operation.</p>
    pub fn hours_of_operation_id(&self) -> std::option::Option<&str> {
        self.hours_of_operation_id.as_deref()
    }
    /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
    pub fn max_contacts(&self) -> std::option::Option<i32> {
        self.max_contacts
    }
    /// <p>The status of the queue.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::QueueStatus> {
        self.status.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`Queue`](crate::model::Queue).
pub mod queue {

    /// A builder for [`Queue`](crate::model::Queue).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) queue_arn: std::option::Option<std::string::String>,
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) outbound_caller_config: std::option::Option<crate::model::OutboundCallerConfig>,
        pub(crate) hours_of_operation_id: std::option::Option<std::string::String>,
        pub(crate) max_contacts: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::QueueStatus>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the queue.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the queue.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the queue.</p>
        pub fn queue_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the queue.</p>
        pub fn set_queue_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_arn = input;
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The description of the queue.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the queue.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
        pub fn outbound_caller_config(mut self, input: crate::model::OutboundCallerConfig) -> Self {
            self.outbound_caller_config = Some(input);
            self
        }
        /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
        pub fn set_outbound_caller_config(
            mut self,
            input: std::option::Option<crate::model::OutboundCallerConfig>,
        ) -> Self {
            self.outbound_caller_config = input;
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn hours_of_operation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hours_of_operation_id = Some(input.into());
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn set_hours_of_operation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hours_of_operation_id = input;
            self
        }
        /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
        pub fn max_contacts(mut self, input: i32) -> Self {
            self.max_contacts = Some(input);
            self
        }
        /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
        pub fn set_max_contacts(mut self, input: std::option::Option<i32>) -> Self {
            self.max_contacts = input;
            self
        }
        /// <p>The status of the queue.</p>
        pub fn status(mut self, input: crate::model::QueueStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the queue.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::QueueStatus>) -> Self {
            self.status = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Queue`](crate::model::Queue).
        pub fn build(self) -> crate::model::Queue {
            crate::model::Queue {
                name: self.name,
                queue_arn: self.queue_arn,
                queue_id: self.queue_id,
                description: self.description,
                outbound_caller_config: self.outbound_caller_config,
                hours_of_operation_id: self.hours_of_operation_id,
                max_contacts: self.max_contacts,
                status: self.status,
                tags: self.tags,
            }
        }
    }
}
impl Queue {
    /// Creates a new builder-style object to manufacture [`Queue`](crate::model::Queue).
    pub fn builder() -> crate::model::queue::Builder {
        crate::model::queue::Builder::default()
    }
}

/// <p>The search criteria to be used to return queues.</p> <note>
/// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueueSearchCriteria {
    /// <p>A list of conditions which would be applied together with an OR condition.</p>
    #[doc(hidden)]
    pub or_conditions: std::option::Option<std::vec::Vec<crate::model::QueueSearchCriteria>>,
    /// <p>A list of conditions which would be applied together with an AND condition.</p>
    #[doc(hidden)]
    pub and_conditions: std::option::Option<std::vec::Vec<crate::model::QueueSearchCriteria>>,
    /// <p>A leaf node condition which can be used to specify a string condition. </p> <note>
    /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
    /// </note>
    #[doc(hidden)]
    pub string_condition: std::option::Option<crate::model::StringCondition>,
    /// <p>The type of queue.</p>
    #[doc(hidden)]
    pub queue_type_condition: std::option::Option<crate::model::SearchableQueueType>,
}
impl QueueSearchCriteria {
    /// <p>A list of conditions which would be applied together with an OR condition.</p>
    pub fn or_conditions(&self) -> std::option::Option<&[crate::model::QueueSearchCriteria]> {
        self.or_conditions.as_deref()
    }
    /// <p>A list of conditions which would be applied together with an AND condition.</p>
    pub fn and_conditions(&self) -> std::option::Option<&[crate::model::QueueSearchCriteria]> {
        self.and_conditions.as_deref()
    }
    /// <p>A leaf node condition which can be used to specify a string condition. </p> <note>
    /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
    /// </note>
    pub fn string_condition(&self) -> std::option::Option<&crate::model::StringCondition> {
        self.string_condition.as_ref()
    }
    /// <p>The type of queue.</p>
    pub fn queue_type_condition(&self) -> std::option::Option<&crate::model::SearchableQueueType> {
        self.queue_type_condition.as_ref()
    }
}
/// See [`QueueSearchCriteria`](crate::model::QueueSearchCriteria).
pub mod queue_search_criteria {

    /// A builder for [`QueueSearchCriteria`](crate::model::QueueSearchCriteria).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) or_conditions:
            std::option::Option<std::vec::Vec<crate::model::QueueSearchCriteria>>,
        pub(crate) and_conditions:
            std::option::Option<std::vec::Vec<crate::model::QueueSearchCriteria>>,
        pub(crate) string_condition: std::option::Option<crate::model::StringCondition>,
        pub(crate) queue_type_condition: std::option::Option<crate::model::SearchableQueueType>,
    }
    impl Builder {
        /// Appends an item to `or_conditions`.
        ///
        /// To override the contents of this collection use [`set_or_conditions`](Self::set_or_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an OR condition.</p>
        pub fn or_conditions(mut self, input: crate::model::QueueSearchCriteria) -> Self {
            let mut v = self.or_conditions.unwrap_or_default();
            v.push(input);
            self.or_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an OR condition.</p>
        pub fn set_or_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::QueueSearchCriteria>>,
        ) -> Self {
            self.or_conditions = input;
            self
        }
        /// Appends an item to `and_conditions`.
        ///
        /// To override the contents of this collection use [`set_and_conditions`](Self::set_and_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an AND condition.</p>
        pub fn and_conditions(mut self, input: crate::model::QueueSearchCriteria) -> Self {
            let mut v = self.and_conditions.unwrap_or_default();
            v.push(input);
            self.and_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an AND condition.</p>
        pub fn set_and_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::QueueSearchCriteria>>,
        ) -> Self {
            self.and_conditions = input;
            self
        }
        /// <p>A leaf node condition which can be used to specify a string condition. </p> <note>
        /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
        /// </note>
        pub fn string_condition(mut self, input: crate::model::StringCondition) -> Self {
            self.string_condition = Some(input);
            self
        }
        /// <p>A leaf node condition which can be used to specify a string condition. </p> <note>
        /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
        /// </note>
        pub fn set_string_condition(
            mut self,
            input: std::option::Option<crate::model::StringCondition>,
        ) -> Self {
            self.string_condition = input;
            self
        }
        /// <p>The type of queue.</p>
        pub fn queue_type_condition(mut self, input: crate::model::SearchableQueueType) -> Self {
            self.queue_type_condition = Some(input);
            self
        }
        /// <p>The type of queue.</p>
        pub fn set_queue_type_condition(
            mut self,
            input: std::option::Option<crate::model::SearchableQueueType>,
        ) -> Self {
            self.queue_type_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`QueueSearchCriteria`](crate::model::QueueSearchCriteria).
        pub fn build(self) -> crate::model::QueueSearchCriteria {
            crate::model::QueueSearchCriteria {
                or_conditions: self.or_conditions,
                and_conditions: self.and_conditions,
                string_condition: self.string_condition,
                queue_type_condition: self.queue_type_condition,
            }
        }
    }
}
impl QueueSearchCriteria {
    /// Creates a new builder-style object to manufacture [`QueueSearchCriteria`](crate::model::QueueSearchCriteria).
    pub fn builder() -> crate::model::queue_search_criteria::Builder {
        crate::model::queue_search_criteria::Builder::default()
    }
}

/// When writing a match expression against `SearchableQueueType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let searchablequeuetype = unimplemented!();
/// match searchablequeuetype {
///     SearchableQueueType::Standard => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `searchablequeuetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SearchableQueueType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SearchableQueueType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SearchableQueueType::NewFeature` is defined.
/// Specifically, when `searchablequeuetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SearchableQueueType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SearchableQueueType {
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SearchableQueueType {
    fn from(s: &str) -> Self {
        match s {
            "STANDARD" => SearchableQueueType::Standard,
            other => {
                SearchableQueueType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SearchableQueueType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SearchableQueueType::from(s))
    }
}
impl SearchableQueueType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SearchableQueueType::Standard => "STANDARD",
            SearchableQueueType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["STANDARD"]
    }
}
impl AsRef<str> for SearchableQueueType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Filters to be applied to search results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueueSearchFilter {
    /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
    /// <ul>
    /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
    /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub tag_filter: std::option::Option<crate::model::ControlPlaneTagFilter>,
}
impl QueueSearchFilter {
    /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
    /// <ul>
    /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
    /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
    /// </ul>
    pub fn tag_filter(&self) -> std::option::Option<&crate::model::ControlPlaneTagFilter> {
        self.tag_filter.as_ref()
    }
}
/// See [`QueueSearchFilter`](crate::model::QueueSearchFilter).
pub mod queue_search_filter {

    /// A builder for [`QueueSearchFilter`](crate::model::QueueSearchFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tag_filter: std::option::Option<crate::model::ControlPlaneTagFilter>,
    }
    impl Builder {
        /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
        /// <ul>
        /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
        /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
        /// </ul>
        pub fn tag_filter(mut self, input: crate::model::ControlPlaneTagFilter) -> Self {
            self.tag_filter = Some(input);
            self
        }
        /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
        /// <ul>
        /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
        /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
        /// </ul>
        pub fn set_tag_filter(
            mut self,
            input: std::option::Option<crate::model::ControlPlaneTagFilter>,
        ) -> Self {
            self.tag_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`QueueSearchFilter`](crate::model::QueueSearchFilter).
        pub fn build(self) -> crate::model::QueueSearchFilter {
            crate::model::QueueSearchFilter {
                tag_filter: self.tag_filter,
            }
        }
    }
}
impl QueueSearchFilter {
    /// Creates a new builder-style object to manufacture [`QueueSearchFilter`](crate::model::QueueSearchFilter).
    pub fn builder() -> crate::model::queue_search_filter::Builder {
        crate::model::queue_search_filter::Builder::default()
    }
}

/// <p>Information about available phone numbers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AvailableNumberSummary {
    /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    #[doc(hidden)]
    pub phone_number: std::option::Option<std::string::String>,
    /// <p>The ISO country code.</p>
    #[doc(hidden)]
    pub phone_number_country_code: std::option::Option<crate::model::PhoneNumberCountryCode>,
    /// <p>The type of phone number.</p>
    #[doc(hidden)]
    pub phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
}
impl AvailableNumberSummary {
    /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
    /// <p>The ISO country code.</p>
    pub fn phone_number_country_code(
        &self,
    ) -> std::option::Option<&crate::model::PhoneNumberCountryCode> {
        self.phone_number_country_code.as_ref()
    }
    /// <p>The type of phone number.</p>
    pub fn phone_number_type(&self) -> std::option::Option<&crate::model::PhoneNumberType> {
        self.phone_number_type.as_ref()
    }
}
/// See [`AvailableNumberSummary`](crate::model::AvailableNumberSummary).
pub mod available_number_summary {

    /// A builder for [`AvailableNumberSummary`](crate::model::AvailableNumberSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) phone_number_country_code:
            std::option::Option<crate::model::PhoneNumberCountryCode>,
        pub(crate) phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
    }
    impl Builder {
        /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// <p>The ISO country code.</p>
        pub fn phone_number_country_code(
            mut self,
            input: crate::model::PhoneNumberCountryCode,
        ) -> Self {
            self.phone_number_country_code = Some(input);
            self
        }
        /// <p>The ISO country code.</p>
        pub fn set_phone_number_country_code(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberCountryCode>,
        ) -> Self {
            self.phone_number_country_code = input;
            self
        }
        /// <p>The type of phone number.</p>
        pub fn phone_number_type(mut self, input: crate::model::PhoneNumberType) -> Self {
            self.phone_number_type = Some(input);
            self
        }
        /// <p>The type of phone number.</p>
        pub fn set_phone_number_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberType>,
        ) -> Self {
            self.phone_number_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AvailableNumberSummary`](crate::model::AvailableNumberSummary).
        pub fn build(self) -> crate::model::AvailableNumberSummary {
            crate::model::AvailableNumberSummary {
                phone_number: self.phone_number,
                phone_number_country_code: self.phone_number_country_code,
                phone_number_type: self.phone_number_type,
            }
        }
    }
}
impl AvailableNumberSummary {
    /// Creates a new builder-style object to manufacture [`AvailableNumberSummary`](crate::model::AvailableNumberSummary).
    pub fn builder() -> crate::model::available_number_summary::Builder {
        crate::model::available_number_summary::Builder::default()
    }
}

/// When writing a match expression against `PhoneNumberType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let phonenumbertype = unimplemented!();
/// match phonenumbertype {
///     PhoneNumberType::Did => { /* ... */ },
///     PhoneNumberType::TollFree => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `phonenumbertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PhoneNumberType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PhoneNumberType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PhoneNumberType::NewFeature` is defined.
/// Specifically, when `phonenumbertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PhoneNumberType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneNumberType {
    #[allow(missing_docs)] // documentation missing in model
    Did,
    #[allow(missing_docs)] // documentation missing in model
    TollFree,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PhoneNumberType {
    fn from(s: &str) -> Self {
        match s {
            "DID" => PhoneNumberType::Did,
            "TOLL_FREE" => PhoneNumberType::TollFree,
            other => PhoneNumberType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PhoneNumberType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneNumberType::from(s))
    }
}
impl PhoneNumberType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneNumberType::Did => "DID",
            PhoneNumberType::TollFree => "TOLL_FREE",
            PhoneNumberType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DID", "TOLL_FREE"]
    }
}
impl AsRef<str> for PhoneNumberType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PhoneNumberCountryCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let phonenumbercountrycode = unimplemented!();
/// match phonenumbercountrycode {
///     PhoneNumberCountryCode::Ad => { /* ... */ },
///     PhoneNumberCountryCode::Ae => { /* ... */ },
///     PhoneNumberCountryCode::Af => { /* ... */ },
///     PhoneNumberCountryCode::Ag => { /* ... */ },
///     PhoneNumberCountryCode::Ai => { /* ... */ },
///     PhoneNumberCountryCode::Al => { /* ... */ },
///     PhoneNumberCountryCode::Am => { /* ... */ },
///     PhoneNumberCountryCode::An => { /* ... */ },
///     PhoneNumberCountryCode::Ao => { /* ... */ },
///     PhoneNumberCountryCode::Aq => { /* ... */ },
///     PhoneNumberCountryCode::Ar => { /* ... */ },
///     PhoneNumberCountryCode::As => { /* ... */ },
///     PhoneNumberCountryCode::At => { /* ... */ },
///     PhoneNumberCountryCode::Au => { /* ... */ },
///     PhoneNumberCountryCode::Aw => { /* ... */ },
///     PhoneNumberCountryCode::Az => { /* ... */ },
///     PhoneNumberCountryCode::Ba => { /* ... */ },
///     PhoneNumberCountryCode::Bb => { /* ... */ },
///     PhoneNumberCountryCode::Bd => { /* ... */ },
///     PhoneNumberCountryCode::Be => { /* ... */ },
///     PhoneNumberCountryCode::Bf => { /* ... */ },
///     PhoneNumberCountryCode::Bg => { /* ... */ },
///     PhoneNumberCountryCode::Bh => { /* ... */ },
///     PhoneNumberCountryCode::Bi => { /* ... */ },
///     PhoneNumberCountryCode::Bj => { /* ... */ },
///     PhoneNumberCountryCode::Bl => { /* ... */ },
///     PhoneNumberCountryCode::Bm => { /* ... */ },
///     PhoneNumberCountryCode::Bn => { /* ... */ },
///     PhoneNumberCountryCode::Bo => { /* ... */ },
///     PhoneNumberCountryCode::Br => { /* ... */ },
///     PhoneNumberCountryCode::Bs => { /* ... */ },
///     PhoneNumberCountryCode::Bt => { /* ... */ },
///     PhoneNumberCountryCode::Bw => { /* ... */ },
///     PhoneNumberCountryCode::By => { /* ... */ },
///     PhoneNumberCountryCode::Bz => { /* ... */ },
///     PhoneNumberCountryCode::Ca => { /* ... */ },
///     PhoneNumberCountryCode::Cc => { /* ... */ },
///     PhoneNumberCountryCode::Cd => { /* ... */ },
///     PhoneNumberCountryCode::Cf => { /* ... */ },
///     PhoneNumberCountryCode::Cg => { /* ... */ },
///     PhoneNumberCountryCode::Ch => { /* ... */ },
///     PhoneNumberCountryCode::Ci => { /* ... */ },
///     PhoneNumberCountryCode::Ck => { /* ... */ },
///     PhoneNumberCountryCode::Cl => { /* ... */ },
///     PhoneNumberCountryCode::Cm => { /* ... */ },
///     PhoneNumberCountryCode::Cn => { /* ... */ },
///     PhoneNumberCountryCode::Co => { /* ... */ },
///     PhoneNumberCountryCode::Cr => { /* ... */ },
///     PhoneNumberCountryCode::Cu => { /* ... */ },
///     PhoneNumberCountryCode::Cv => { /* ... */ },
///     PhoneNumberCountryCode::Cw => { /* ... */ },
///     PhoneNumberCountryCode::Cx => { /* ... */ },
///     PhoneNumberCountryCode::Cy => { /* ... */ },
///     PhoneNumberCountryCode::Cz => { /* ... */ },
///     PhoneNumberCountryCode::De => { /* ... */ },
///     PhoneNumberCountryCode::Dj => { /* ... */ },
///     PhoneNumberCountryCode::Dk => { /* ... */ },
///     PhoneNumberCountryCode::Dm => { /* ... */ },
///     PhoneNumberCountryCode::Do => { /* ... */ },
///     PhoneNumberCountryCode::Dz => { /* ... */ },
///     PhoneNumberCountryCode::Ec => { /* ... */ },
///     PhoneNumberCountryCode::Ee => { /* ... */ },
///     PhoneNumberCountryCode::Eg => { /* ... */ },
///     PhoneNumberCountryCode::Eh => { /* ... */ },
///     PhoneNumberCountryCode::Er => { /* ... */ },
///     PhoneNumberCountryCode::Es => { /* ... */ },
///     PhoneNumberCountryCode::Et => { /* ... */ },
///     PhoneNumberCountryCode::Fi => { /* ... */ },
///     PhoneNumberCountryCode::Fj => { /* ... */ },
///     PhoneNumberCountryCode::Fk => { /* ... */ },
///     PhoneNumberCountryCode::Fm => { /* ... */ },
///     PhoneNumberCountryCode::Fo => { /* ... */ },
///     PhoneNumberCountryCode::Fr => { /* ... */ },
///     PhoneNumberCountryCode::Ga => { /* ... */ },
///     PhoneNumberCountryCode::Gb => { /* ... */ },
///     PhoneNumberCountryCode::Gd => { /* ... */ },
///     PhoneNumberCountryCode::Ge => { /* ... */ },
///     PhoneNumberCountryCode::Gg => { /* ... */ },
///     PhoneNumberCountryCode::Gh => { /* ... */ },
///     PhoneNumberCountryCode::Gi => { /* ... */ },
///     PhoneNumberCountryCode::Gl => { /* ... */ },
///     PhoneNumberCountryCode::Gm => { /* ... */ },
///     PhoneNumberCountryCode::Gn => { /* ... */ },
///     PhoneNumberCountryCode::Gq => { /* ... */ },
///     PhoneNumberCountryCode::Gr => { /* ... */ },
///     PhoneNumberCountryCode::Gt => { /* ... */ },
///     PhoneNumberCountryCode::Gu => { /* ... */ },
///     PhoneNumberCountryCode::Gw => { /* ... */ },
///     PhoneNumberCountryCode::Gy => { /* ... */ },
///     PhoneNumberCountryCode::Hk => { /* ... */ },
///     PhoneNumberCountryCode::Hn => { /* ... */ },
///     PhoneNumberCountryCode::Hr => { /* ... */ },
///     PhoneNumberCountryCode::Ht => { /* ... */ },
///     PhoneNumberCountryCode::Hu => { /* ... */ },
///     PhoneNumberCountryCode::Id => { /* ... */ },
///     PhoneNumberCountryCode::Ie => { /* ... */ },
///     PhoneNumberCountryCode::Il => { /* ... */ },
///     PhoneNumberCountryCode::Im => { /* ... */ },
///     PhoneNumberCountryCode::In => { /* ... */ },
///     PhoneNumberCountryCode::Io => { /* ... */ },
///     PhoneNumberCountryCode::Iq => { /* ... */ },
///     PhoneNumberCountryCode::Ir => { /* ... */ },
///     PhoneNumberCountryCode::Is => { /* ... */ },
///     PhoneNumberCountryCode::It => { /* ... */ },
///     PhoneNumberCountryCode::Je => { /* ... */ },
///     PhoneNumberCountryCode::Jm => { /* ... */ },
///     PhoneNumberCountryCode::Jo => { /* ... */ },
///     PhoneNumberCountryCode::Jp => { /* ... */ },
///     PhoneNumberCountryCode::Ke => { /* ... */ },
///     PhoneNumberCountryCode::Kg => { /* ... */ },
///     PhoneNumberCountryCode::Kh => { /* ... */ },
///     PhoneNumberCountryCode::Ki => { /* ... */ },
///     PhoneNumberCountryCode::Km => { /* ... */ },
///     PhoneNumberCountryCode::Kn => { /* ... */ },
///     PhoneNumberCountryCode::Kp => { /* ... */ },
///     PhoneNumberCountryCode::Kr => { /* ... */ },
///     PhoneNumberCountryCode::Kw => { /* ... */ },
///     PhoneNumberCountryCode::Ky => { /* ... */ },
///     PhoneNumberCountryCode::Kz => { /* ... */ },
///     PhoneNumberCountryCode::La => { /* ... */ },
///     PhoneNumberCountryCode::Lb => { /* ... */ },
///     PhoneNumberCountryCode::Lc => { /* ... */ },
///     PhoneNumberCountryCode::Li => { /* ... */ },
///     PhoneNumberCountryCode::Lk => { /* ... */ },
///     PhoneNumberCountryCode::Lr => { /* ... */ },
///     PhoneNumberCountryCode::Ls => { /* ... */ },
///     PhoneNumberCountryCode::Lt => { /* ... */ },
///     PhoneNumberCountryCode::Lu => { /* ... */ },
///     PhoneNumberCountryCode::Lv => { /* ... */ },
///     PhoneNumberCountryCode::Ly => { /* ... */ },
///     PhoneNumberCountryCode::Ma => { /* ... */ },
///     PhoneNumberCountryCode::Mc => { /* ... */ },
///     PhoneNumberCountryCode::Md => { /* ... */ },
///     PhoneNumberCountryCode::Me => { /* ... */ },
///     PhoneNumberCountryCode::Mf => { /* ... */ },
///     PhoneNumberCountryCode::Mg => { /* ... */ },
///     PhoneNumberCountryCode::Mh => { /* ... */ },
///     PhoneNumberCountryCode::Mk => { /* ... */ },
///     PhoneNumberCountryCode::Ml => { /* ... */ },
///     PhoneNumberCountryCode::Mm => { /* ... */ },
///     PhoneNumberCountryCode::Mn => { /* ... */ },
///     PhoneNumberCountryCode::Mo => { /* ... */ },
///     PhoneNumberCountryCode::Mp => { /* ... */ },
///     PhoneNumberCountryCode::Mr => { /* ... */ },
///     PhoneNumberCountryCode::Ms => { /* ... */ },
///     PhoneNumberCountryCode::Mt => { /* ... */ },
///     PhoneNumberCountryCode::Mu => { /* ... */ },
///     PhoneNumberCountryCode::Mv => { /* ... */ },
///     PhoneNumberCountryCode::Mw => { /* ... */ },
///     PhoneNumberCountryCode::Mx => { /* ... */ },
///     PhoneNumberCountryCode::My => { /* ... */ },
///     PhoneNumberCountryCode::Mz => { /* ... */ },
///     PhoneNumberCountryCode::Na => { /* ... */ },
///     PhoneNumberCountryCode::Nc => { /* ... */ },
///     PhoneNumberCountryCode::Ne => { /* ... */ },
///     PhoneNumberCountryCode::Ng => { /* ... */ },
///     PhoneNumberCountryCode::Ni => { /* ... */ },
///     PhoneNumberCountryCode::Nl => { /* ... */ },
///     PhoneNumberCountryCode::No => { /* ... */ },
///     PhoneNumberCountryCode::Np => { /* ... */ },
///     PhoneNumberCountryCode::Nr => { /* ... */ },
///     PhoneNumberCountryCode::Nu => { /* ... */ },
///     PhoneNumberCountryCode::Nz => { /* ... */ },
///     PhoneNumberCountryCode::Om => { /* ... */ },
///     PhoneNumberCountryCode::Pa => { /* ... */ },
///     PhoneNumberCountryCode::Pe => { /* ... */ },
///     PhoneNumberCountryCode::Pf => { /* ... */ },
///     PhoneNumberCountryCode::Pg => { /* ... */ },
///     PhoneNumberCountryCode::Ph => { /* ... */ },
///     PhoneNumberCountryCode::Pk => { /* ... */ },
///     PhoneNumberCountryCode::Pl => { /* ... */ },
///     PhoneNumberCountryCode::Pm => { /* ... */ },
///     PhoneNumberCountryCode::Pn => { /* ... */ },
///     PhoneNumberCountryCode::Pr => { /* ... */ },
///     PhoneNumberCountryCode::Pt => { /* ... */ },
///     PhoneNumberCountryCode::Pw => { /* ... */ },
///     PhoneNumberCountryCode::Py => { /* ... */ },
///     PhoneNumberCountryCode::Qa => { /* ... */ },
///     PhoneNumberCountryCode::Re => { /* ... */ },
///     PhoneNumberCountryCode::Ro => { /* ... */ },
///     PhoneNumberCountryCode::Rs => { /* ... */ },
///     PhoneNumberCountryCode::Ru => { /* ... */ },
///     PhoneNumberCountryCode::Rw => { /* ... */ },
///     PhoneNumberCountryCode::Sa => { /* ... */ },
///     PhoneNumberCountryCode::Sb => { /* ... */ },
///     PhoneNumberCountryCode::Sc => { /* ... */ },
///     PhoneNumberCountryCode::Sd => { /* ... */ },
///     PhoneNumberCountryCode::Se => { /* ... */ },
///     PhoneNumberCountryCode::Sg => { /* ... */ },
///     PhoneNumberCountryCode::Sh => { /* ... */ },
///     PhoneNumberCountryCode::Si => { /* ... */ },
///     PhoneNumberCountryCode::Sj => { /* ... */ },
///     PhoneNumberCountryCode::Sk => { /* ... */ },
///     PhoneNumberCountryCode::Sl => { /* ... */ },
///     PhoneNumberCountryCode::Sm => { /* ... */ },
///     PhoneNumberCountryCode::Sn => { /* ... */ },
///     PhoneNumberCountryCode::So => { /* ... */ },
///     PhoneNumberCountryCode::Sr => { /* ... */ },
///     PhoneNumberCountryCode::St => { /* ... */ },
///     PhoneNumberCountryCode::Sv => { /* ... */ },
///     PhoneNumberCountryCode::Sx => { /* ... */ },
///     PhoneNumberCountryCode::Sy => { /* ... */ },
///     PhoneNumberCountryCode::Sz => { /* ... */ },
///     PhoneNumberCountryCode::Tc => { /* ... */ },
///     PhoneNumberCountryCode::Td => { /* ... */ },
///     PhoneNumberCountryCode::Tg => { /* ... */ },
///     PhoneNumberCountryCode::Th => { /* ... */ },
///     PhoneNumberCountryCode::Tj => { /* ... */ },
///     PhoneNumberCountryCode::Tk => { /* ... */ },
///     PhoneNumberCountryCode::Tl => { /* ... */ },
///     PhoneNumberCountryCode::Tm => { /* ... */ },
///     PhoneNumberCountryCode::Tn => { /* ... */ },
///     PhoneNumberCountryCode::To => { /* ... */ },
///     PhoneNumberCountryCode::Tr => { /* ... */ },
///     PhoneNumberCountryCode::Tt => { /* ... */ },
///     PhoneNumberCountryCode::Tv => { /* ... */ },
///     PhoneNumberCountryCode::Tw => { /* ... */ },
///     PhoneNumberCountryCode::Tz => { /* ... */ },
///     PhoneNumberCountryCode::Ua => { /* ... */ },
///     PhoneNumberCountryCode::Ug => { /* ... */ },
///     PhoneNumberCountryCode::Us => { /* ... */ },
///     PhoneNumberCountryCode::Uy => { /* ... */ },
///     PhoneNumberCountryCode::Uz => { /* ... */ },
///     PhoneNumberCountryCode::Va => { /* ... */ },
///     PhoneNumberCountryCode::Vc => { /* ... */ },
///     PhoneNumberCountryCode::Ve => { /* ... */ },
///     PhoneNumberCountryCode::Vg => { /* ... */ },
///     PhoneNumberCountryCode::Vi => { /* ... */ },
///     PhoneNumberCountryCode::Vn => { /* ... */ },
///     PhoneNumberCountryCode::Vu => { /* ... */ },
///     PhoneNumberCountryCode::Wf => { /* ... */ },
///     PhoneNumberCountryCode::Ws => { /* ... */ },
///     PhoneNumberCountryCode::Ye => { /* ... */ },
///     PhoneNumberCountryCode::Yt => { /* ... */ },
///     PhoneNumberCountryCode::Za => { /* ... */ },
///     PhoneNumberCountryCode::Zm => { /* ... */ },
///     PhoneNumberCountryCode::Zw => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `phonenumbercountrycode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PhoneNumberCountryCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PhoneNumberCountryCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PhoneNumberCountryCode::NewFeature` is defined.
/// Specifically, when `phonenumbercountrycode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PhoneNumberCountryCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneNumberCountryCode {
    #[allow(missing_docs)] // documentation missing in model
    Ad,
    #[allow(missing_docs)] // documentation missing in model
    Ae,
    #[allow(missing_docs)] // documentation missing in model
    Af,
    #[allow(missing_docs)] // documentation missing in model
    Ag,
    #[allow(missing_docs)] // documentation missing in model
    Ai,
    #[allow(missing_docs)] // documentation missing in model
    Al,
    #[allow(missing_docs)] // documentation missing in model
    Am,
    #[allow(missing_docs)] // documentation missing in model
    An,
    #[allow(missing_docs)] // documentation missing in model
    Ao,
    #[allow(missing_docs)] // documentation missing in model
    Aq,
    #[allow(missing_docs)] // documentation missing in model
    Ar,
    #[allow(missing_docs)] // documentation missing in model
    As,
    #[allow(missing_docs)] // documentation missing in model
    At,
    #[allow(missing_docs)] // documentation missing in model
    Au,
    #[allow(missing_docs)] // documentation missing in model
    Aw,
    #[allow(missing_docs)] // documentation missing in model
    Az,
    #[allow(missing_docs)] // documentation missing in model
    Ba,
    #[allow(missing_docs)] // documentation missing in model
    Bb,
    #[allow(missing_docs)] // documentation missing in model
    Bd,
    #[allow(missing_docs)] // documentation missing in model
    Be,
    #[allow(missing_docs)] // documentation missing in model
    Bf,
    #[allow(missing_docs)] // documentation missing in model
    Bg,
    #[allow(missing_docs)] // documentation missing in model
    Bh,
    #[allow(missing_docs)] // documentation missing in model
    Bi,
    #[allow(missing_docs)] // documentation missing in model
    Bj,
    #[allow(missing_docs)] // documentation missing in model
    Bl,
    #[allow(missing_docs)] // documentation missing in model
    Bm,
    #[allow(missing_docs)] // documentation missing in model
    Bn,
    #[allow(missing_docs)] // documentation missing in model
    Bo,
    #[allow(missing_docs)] // documentation missing in model
    Br,
    #[allow(missing_docs)] // documentation missing in model
    Bs,
    #[allow(missing_docs)] // documentation missing in model
    Bt,
    #[allow(missing_docs)] // documentation missing in model
    Bw,
    #[allow(missing_docs)] // documentation missing in model
    By,
    #[allow(missing_docs)] // documentation missing in model
    Bz,
    #[allow(missing_docs)] // documentation missing in model
    Ca,
    #[allow(missing_docs)] // documentation missing in model
    Cc,
    #[allow(missing_docs)] // documentation missing in model
    Cd,
    #[allow(missing_docs)] // documentation missing in model
    Cf,
    #[allow(missing_docs)] // documentation missing in model
    Cg,
    #[allow(missing_docs)] // documentation missing in model
    Ch,
    #[allow(missing_docs)] // documentation missing in model
    Ci,
    #[allow(missing_docs)] // documentation missing in model
    Ck,
    #[allow(missing_docs)] // documentation missing in model
    Cl,
    #[allow(missing_docs)] // documentation missing in model
    Cm,
    #[allow(missing_docs)] // documentation missing in model
    Cn,
    #[allow(missing_docs)] // documentation missing in model
    Co,
    #[allow(missing_docs)] // documentation missing in model
    Cr,
    #[allow(missing_docs)] // documentation missing in model
    Cu,
    #[allow(missing_docs)] // documentation missing in model
    Cv,
    #[allow(missing_docs)] // documentation missing in model
    Cw,
    #[allow(missing_docs)] // documentation missing in model
    Cx,
    #[allow(missing_docs)] // documentation missing in model
    Cy,
    #[allow(missing_docs)] // documentation missing in model
    Cz,
    #[allow(missing_docs)] // documentation missing in model
    De,
    #[allow(missing_docs)] // documentation missing in model
    Dj,
    #[allow(missing_docs)] // documentation missing in model
    Dk,
    #[allow(missing_docs)] // documentation missing in model
    Dm,
    #[allow(missing_docs)] // documentation missing in model
    Do,
    #[allow(missing_docs)] // documentation missing in model
    Dz,
    #[allow(missing_docs)] // documentation missing in model
    Ec,
    #[allow(missing_docs)] // documentation missing in model
    Ee,
    #[allow(missing_docs)] // documentation missing in model
    Eg,
    #[allow(missing_docs)] // documentation missing in model
    Eh,
    #[allow(missing_docs)] // documentation missing in model
    Er,
    #[allow(missing_docs)] // documentation missing in model
    Es,
    #[allow(missing_docs)] // documentation missing in model
    Et,
    #[allow(missing_docs)] // documentation missing in model
    Fi,
    #[allow(missing_docs)] // documentation missing in model
    Fj,
    #[allow(missing_docs)] // documentation missing in model
    Fk,
    #[allow(missing_docs)] // documentation missing in model
    Fm,
    #[allow(missing_docs)] // documentation missing in model
    Fo,
    #[allow(missing_docs)] // documentation missing in model
    Fr,
    #[allow(missing_docs)] // documentation missing in model
    Ga,
    #[allow(missing_docs)] // documentation missing in model
    Gb,
    #[allow(missing_docs)] // documentation missing in model
    Gd,
    #[allow(missing_docs)] // documentation missing in model
    Ge,
    #[allow(missing_docs)] // documentation missing in model
    Gg,
    #[allow(missing_docs)] // documentation missing in model
    Gh,
    #[allow(missing_docs)] // documentation missing in model
    Gi,
    #[allow(missing_docs)] // documentation missing in model
    Gl,
    #[allow(missing_docs)] // documentation missing in model
    Gm,
    #[allow(missing_docs)] // documentation missing in model
    Gn,
    #[allow(missing_docs)] // documentation missing in model
    Gq,
    #[allow(missing_docs)] // documentation missing in model
    Gr,
    #[allow(missing_docs)] // documentation missing in model
    Gt,
    #[allow(missing_docs)] // documentation missing in model
    Gu,
    #[allow(missing_docs)] // documentation missing in model
    Gw,
    #[allow(missing_docs)] // documentation missing in model
    Gy,
    #[allow(missing_docs)] // documentation missing in model
    Hk,
    #[allow(missing_docs)] // documentation missing in model
    Hn,
    #[allow(missing_docs)] // documentation missing in model
    Hr,
    #[allow(missing_docs)] // documentation missing in model
    Ht,
    #[allow(missing_docs)] // documentation missing in model
    Hu,
    #[allow(missing_docs)] // documentation missing in model
    Id,
    #[allow(missing_docs)] // documentation missing in model
    Ie,
    #[allow(missing_docs)] // documentation missing in model
    Il,
    #[allow(missing_docs)] // documentation missing in model
    Im,
    #[allow(missing_docs)] // documentation missing in model
    In,
    #[allow(missing_docs)] // documentation missing in model
    Io,
    #[allow(missing_docs)] // documentation missing in model
    Iq,
    #[allow(missing_docs)] // documentation missing in model
    Ir,
    #[allow(missing_docs)] // documentation missing in model
    Is,
    #[allow(missing_docs)] // documentation missing in model
    It,
    #[allow(missing_docs)] // documentation missing in model
    Je,
    #[allow(missing_docs)] // documentation missing in model
    Jm,
    #[allow(missing_docs)] // documentation missing in model
    Jo,
    #[allow(missing_docs)] // documentation missing in model
    Jp,
    #[allow(missing_docs)] // documentation missing in model
    Ke,
    #[allow(missing_docs)] // documentation missing in model
    Kg,
    #[allow(missing_docs)] // documentation missing in model
    Kh,
    #[allow(missing_docs)] // documentation missing in model
    Ki,
    #[allow(missing_docs)] // documentation missing in model
    Km,
    #[allow(missing_docs)] // documentation missing in model
    Kn,
    #[allow(missing_docs)] // documentation missing in model
    Kp,
    #[allow(missing_docs)] // documentation missing in model
    Kr,
    #[allow(missing_docs)] // documentation missing in model
    Kw,
    #[allow(missing_docs)] // documentation missing in model
    Ky,
    #[allow(missing_docs)] // documentation missing in model
    Kz,
    #[allow(missing_docs)] // documentation missing in model
    La,
    #[allow(missing_docs)] // documentation missing in model
    Lb,
    #[allow(missing_docs)] // documentation missing in model
    Lc,
    #[allow(missing_docs)] // documentation missing in model
    Li,
    #[allow(missing_docs)] // documentation missing in model
    Lk,
    #[allow(missing_docs)] // documentation missing in model
    Lr,
    #[allow(missing_docs)] // documentation missing in model
    Ls,
    #[allow(missing_docs)] // documentation missing in model
    Lt,
    #[allow(missing_docs)] // documentation missing in model
    Lu,
    #[allow(missing_docs)] // documentation missing in model
    Lv,
    #[allow(missing_docs)] // documentation missing in model
    Ly,
    #[allow(missing_docs)] // documentation missing in model
    Ma,
    #[allow(missing_docs)] // documentation missing in model
    Mc,
    #[allow(missing_docs)] // documentation missing in model
    Md,
    #[allow(missing_docs)] // documentation missing in model
    Me,
    #[allow(missing_docs)] // documentation missing in model
    Mf,
    #[allow(missing_docs)] // documentation missing in model
    Mg,
    #[allow(missing_docs)] // documentation missing in model
    Mh,
    #[allow(missing_docs)] // documentation missing in model
    Mk,
    #[allow(missing_docs)] // documentation missing in model
    Ml,
    #[allow(missing_docs)] // documentation missing in model
    Mm,
    #[allow(missing_docs)] // documentation missing in model
    Mn,
    #[allow(missing_docs)] // documentation missing in model
    Mo,
    #[allow(missing_docs)] // documentation missing in model
    Mp,
    #[allow(missing_docs)] // documentation missing in model
    Mr,
    #[allow(missing_docs)] // documentation missing in model
    Ms,
    #[allow(missing_docs)] // documentation missing in model
    Mt,
    #[allow(missing_docs)] // documentation missing in model
    Mu,
    #[allow(missing_docs)] // documentation missing in model
    Mv,
    #[allow(missing_docs)] // documentation missing in model
    Mw,
    #[allow(missing_docs)] // documentation missing in model
    Mx,
    #[allow(missing_docs)] // documentation missing in model
    My,
    #[allow(missing_docs)] // documentation missing in model
    Mz,
    #[allow(missing_docs)] // documentation missing in model
    Na,
    #[allow(missing_docs)] // documentation missing in model
    Nc,
    #[allow(missing_docs)] // documentation missing in model
    Ne,
    #[allow(missing_docs)] // documentation missing in model
    Ng,
    #[allow(missing_docs)] // documentation missing in model
    Ni,
    #[allow(missing_docs)] // documentation missing in model
    Nl,
    #[allow(missing_docs)] // documentation missing in model
    No,
    #[allow(missing_docs)] // documentation missing in model
    Np,
    #[allow(missing_docs)] // documentation missing in model
    Nr,
    #[allow(missing_docs)] // documentation missing in model
    Nu,
    #[allow(missing_docs)] // documentation missing in model
    Nz,
    #[allow(missing_docs)] // documentation missing in model
    Om,
    #[allow(missing_docs)] // documentation missing in model
    Pa,
    #[allow(missing_docs)] // documentation missing in model
    Pe,
    #[allow(missing_docs)] // documentation missing in model
    Pf,
    #[allow(missing_docs)] // documentation missing in model
    Pg,
    #[allow(missing_docs)] // documentation missing in model
    Ph,
    #[allow(missing_docs)] // documentation missing in model
    Pk,
    #[allow(missing_docs)] // documentation missing in model
    Pl,
    #[allow(missing_docs)] // documentation missing in model
    Pm,
    #[allow(missing_docs)] // documentation missing in model
    Pn,
    #[allow(missing_docs)] // documentation missing in model
    Pr,
    #[allow(missing_docs)] // documentation missing in model
    Pt,
    #[allow(missing_docs)] // documentation missing in model
    Pw,
    #[allow(missing_docs)] // documentation missing in model
    Py,
    #[allow(missing_docs)] // documentation missing in model
    Qa,
    #[allow(missing_docs)] // documentation missing in model
    Re,
    #[allow(missing_docs)] // documentation missing in model
    Ro,
    #[allow(missing_docs)] // documentation missing in model
    Rs,
    #[allow(missing_docs)] // documentation missing in model
    Ru,
    #[allow(missing_docs)] // documentation missing in model
    Rw,
    #[allow(missing_docs)] // documentation missing in model
    Sa,
    #[allow(missing_docs)] // documentation missing in model
    Sb,
    #[allow(missing_docs)] // documentation missing in model
    Sc,
    #[allow(missing_docs)] // documentation missing in model
    Sd,
    #[allow(missing_docs)] // documentation missing in model
    Se,
    #[allow(missing_docs)] // documentation missing in model
    Sg,
    #[allow(missing_docs)] // documentation missing in model
    Sh,
    #[allow(missing_docs)] // documentation missing in model
    Si,
    #[allow(missing_docs)] // documentation missing in model
    Sj,
    #[allow(missing_docs)] // documentation missing in model
    Sk,
    #[allow(missing_docs)] // documentation missing in model
    Sl,
    #[allow(missing_docs)] // documentation missing in model
    Sm,
    #[allow(missing_docs)] // documentation missing in model
    Sn,
    #[allow(missing_docs)] // documentation missing in model
    So,
    #[allow(missing_docs)] // documentation missing in model
    Sr,
    #[allow(missing_docs)] // documentation missing in model
    St,
    #[allow(missing_docs)] // documentation missing in model
    Sv,
    #[allow(missing_docs)] // documentation missing in model
    Sx,
    #[allow(missing_docs)] // documentation missing in model
    Sy,
    #[allow(missing_docs)] // documentation missing in model
    Sz,
    #[allow(missing_docs)] // documentation missing in model
    Tc,
    #[allow(missing_docs)] // documentation missing in model
    Td,
    #[allow(missing_docs)] // documentation missing in model
    Tg,
    #[allow(missing_docs)] // documentation missing in model
    Th,
    #[allow(missing_docs)] // documentation missing in model
    Tj,
    #[allow(missing_docs)] // documentation missing in model
    Tk,
    #[allow(missing_docs)] // documentation missing in model
    Tl,
    #[allow(missing_docs)] // documentation missing in model
    Tm,
    #[allow(missing_docs)] // documentation missing in model
    Tn,
    #[allow(missing_docs)] // documentation missing in model
    To,
    #[allow(missing_docs)] // documentation missing in model
    Tr,
    #[allow(missing_docs)] // documentation missing in model
    Tt,
    #[allow(missing_docs)] // documentation missing in model
    Tv,
    #[allow(missing_docs)] // documentation missing in model
    Tw,
    #[allow(missing_docs)] // documentation missing in model
    Tz,
    #[allow(missing_docs)] // documentation missing in model
    Ua,
    #[allow(missing_docs)] // documentation missing in model
    Ug,
    #[allow(missing_docs)] // documentation missing in model
    Us,
    #[allow(missing_docs)] // documentation missing in model
    Uy,
    #[allow(missing_docs)] // documentation missing in model
    Uz,
    #[allow(missing_docs)] // documentation missing in model
    Va,
    #[allow(missing_docs)] // documentation missing in model
    Vc,
    #[allow(missing_docs)] // documentation missing in model
    Ve,
    #[allow(missing_docs)] // documentation missing in model
    Vg,
    #[allow(missing_docs)] // documentation missing in model
    Vi,
    #[allow(missing_docs)] // documentation missing in model
    Vn,
    #[allow(missing_docs)] // documentation missing in model
    Vu,
    #[allow(missing_docs)] // documentation missing in model
    Wf,
    #[allow(missing_docs)] // documentation missing in model
    Ws,
    #[allow(missing_docs)] // documentation missing in model
    Ye,
    #[allow(missing_docs)] // documentation missing in model
    Yt,
    #[allow(missing_docs)] // documentation missing in model
    Za,
    #[allow(missing_docs)] // documentation missing in model
    Zm,
    #[allow(missing_docs)] // documentation missing in model
    Zw,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PhoneNumberCountryCode {
    fn from(s: &str) -> Self {
        match s {
            "AD" => PhoneNumberCountryCode::Ad,
            "AE" => PhoneNumberCountryCode::Ae,
            "AF" => PhoneNumberCountryCode::Af,
            "AG" => PhoneNumberCountryCode::Ag,
            "AI" => PhoneNumberCountryCode::Ai,
            "AL" => PhoneNumberCountryCode::Al,
            "AM" => PhoneNumberCountryCode::Am,
            "AN" => PhoneNumberCountryCode::An,
            "AO" => PhoneNumberCountryCode::Ao,
            "AQ" => PhoneNumberCountryCode::Aq,
            "AR" => PhoneNumberCountryCode::Ar,
            "AS" => PhoneNumberCountryCode::As,
            "AT" => PhoneNumberCountryCode::At,
            "AU" => PhoneNumberCountryCode::Au,
            "AW" => PhoneNumberCountryCode::Aw,
            "AZ" => PhoneNumberCountryCode::Az,
            "BA" => PhoneNumberCountryCode::Ba,
            "BB" => PhoneNumberCountryCode::Bb,
            "BD" => PhoneNumberCountryCode::Bd,
            "BE" => PhoneNumberCountryCode::Be,
            "BF" => PhoneNumberCountryCode::Bf,
            "BG" => PhoneNumberCountryCode::Bg,
            "BH" => PhoneNumberCountryCode::Bh,
            "BI" => PhoneNumberCountryCode::Bi,
            "BJ" => PhoneNumberCountryCode::Bj,
            "BL" => PhoneNumberCountryCode::Bl,
            "BM" => PhoneNumberCountryCode::Bm,
            "BN" => PhoneNumberCountryCode::Bn,
            "BO" => PhoneNumberCountryCode::Bo,
            "BR" => PhoneNumberCountryCode::Br,
            "BS" => PhoneNumberCountryCode::Bs,
            "BT" => PhoneNumberCountryCode::Bt,
            "BW" => PhoneNumberCountryCode::Bw,
            "BY" => PhoneNumberCountryCode::By,
            "BZ" => PhoneNumberCountryCode::Bz,
            "CA" => PhoneNumberCountryCode::Ca,
            "CC" => PhoneNumberCountryCode::Cc,
            "CD" => PhoneNumberCountryCode::Cd,
            "CF" => PhoneNumberCountryCode::Cf,
            "CG" => PhoneNumberCountryCode::Cg,
            "CH" => PhoneNumberCountryCode::Ch,
            "CI" => PhoneNumberCountryCode::Ci,
            "CK" => PhoneNumberCountryCode::Ck,
            "CL" => PhoneNumberCountryCode::Cl,
            "CM" => PhoneNumberCountryCode::Cm,
            "CN" => PhoneNumberCountryCode::Cn,
            "CO" => PhoneNumberCountryCode::Co,
            "CR" => PhoneNumberCountryCode::Cr,
            "CU" => PhoneNumberCountryCode::Cu,
            "CV" => PhoneNumberCountryCode::Cv,
            "CW" => PhoneNumberCountryCode::Cw,
            "CX" => PhoneNumberCountryCode::Cx,
            "CY" => PhoneNumberCountryCode::Cy,
            "CZ" => PhoneNumberCountryCode::Cz,
            "DE" => PhoneNumberCountryCode::De,
            "DJ" => PhoneNumberCountryCode::Dj,
            "DK" => PhoneNumberCountryCode::Dk,
            "DM" => PhoneNumberCountryCode::Dm,
            "DO" => PhoneNumberCountryCode::Do,
            "DZ" => PhoneNumberCountryCode::Dz,
            "EC" => PhoneNumberCountryCode::Ec,
            "EE" => PhoneNumberCountryCode::Ee,
            "EG" => PhoneNumberCountryCode::Eg,
            "EH" => PhoneNumberCountryCode::Eh,
            "ER" => PhoneNumberCountryCode::Er,
            "ES" => PhoneNumberCountryCode::Es,
            "ET" => PhoneNumberCountryCode::Et,
            "FI" => PhoneNumberCountryCode::Fi,
            "FJ" => PhoneNumberCountryCode::Fj,
            "FK" => PhoneNumberCountryCode::Fk,
            "FM" => PhoneNumberCountryCode::Fm,
            "FO" => PhoneNumberCountryCode::Fo,
            "FR" => PhoneNumberCountryCode::Fr,
            "GA" => PhoneNumberCountryCode::Ga,
            "GB" => PhoneNumberCountryCode::Gb,
            "GD" => PhoneNumberCountryCode::Gd,
            "GE" => PhoneNumberCountryCode::Ge,
            "GG" => PhoneNumberCountryCode::Gg,
            "GH" => PhoneNumberCountryCode::Gh,
            "GI" => PhoneNumberCountryCode::Gi,
            "GL" => PhoneNumberCountryCode::Gl,
            "GM" => PhoneNumberCountryCode::Gm,
            "GN" => PhoneNumberCountryCode::Gn,
            "GQ" => PhoneNumberCountryCode::Gq,
            "GR" => PhoneNumberCountryCode::Gr,
            "GT" => PhoneNumberCountryCode::Gt,
            "GU" => PhoneNumberCountryCode::Gu,
            "GW" => PhoneNumberCountryCode::Gw,
            "GY" => PhoneNumberCountryCode::Gy,
            "HK" => PhoneNumberCountryCode::Hk,
            "HN" => PhoneNumberCountryCode::Hn,
            "HR" => PhoneNumberCountryCode::Hr,
            "HT" => PhoneNumberCountryCode::Ht,
            "HU" => PhoneNumberCountryCode::Hu,
            "ID" => PhoneNumberCountryCode::Id,
            "IE" => PhoneNumberCountryCode::Ie,
            "IL" => PhoneNumberCountryCode::Il,
            "IM" => PhoneNumberCountryCode::Im,
            "IN" => PhoneNumberCountryCode::In,
            "IO" => PhoneNumberCountryCode::Io,
            "IQ" => PhoneNumberCountryCode::Iq,
            "IR" => PhoneNumberCountryCode::Ir,
            "IS" => PhoneNumberCountryCode::Is,
            "IT" => PhoneNumberCountryCode::It,
            "JE" => PhoneNumberCountryCode::Je,
            "JM" => PhoneNumberCountryCode::Jm,
            "JO" => PhoneNumberCountryCode::Jo,
            "JP" => PhoneNumberCountryCode::Jp,
            "KE" => PhoneNumberCountryCode::Ke,
            "KG" => PhoneNumberCountryCode::Kg,
            "KH" => PhoneNumberCountryCode::Kh,
            "KI" => PhoneNumberCountryCode::Ki,
            "KM" => PhoneNumberCountryCode::Km,
            "KN" => PhoneNumberCountryCode::Kn,
            "KP" => PhoneNumberCountryCode::Kp,
            "KR" => PhoneNumberCountryCode::Kr,
            "KW" => PhoneNumberCountryCode::Kw,
            "KY" => PhoneNumberCountryCode::Ky,
            "KZ" => PhoneNumberCountryCode::Kz,
            "LA" => PhoneNumberCountryCode::La,
            "LB" => PhoneNumberCountryCode::Lb,
            "LC" => PhoneNumberCountryCode::Lc,
            "LI" => PhoneNumberCountryCode::Li,
            "LK" => PhoneNumberCountryCode::Lk,
            "LR" => PhoneNumberCountryCode::Lr,
            "LS" => PhoneNumberCountryCode::Ls,
            "LT" => PhoneNumberCountryCode::Lt,
            "LU" => PhoneNumberCountryCode::Lu,
            "LV" => PhoneNumberCountryCode::Lv,
            "LY" => PhoneNumberCountryCode::Ly,
            "MA" => PhoneNumberCountryCode::Ma,
            "MC" => PhoneNumberCountryCode::Mc,
            "MD" => PhoneNumberCountryCode::Md,
            "ME" => PhoneNumberCountryCode::Me,
            "MF" => PhoneNumberCountryCode::Mf,
            "MG" => PhoneNumberCountryCode::Mg,
            "MH" => PhoneNumberCountryCode::Mh,
            "MK" => PhoneNumberCountryCode::Mk,
            "ML" => PhoneNumberCountryCode::Ml,
            "MM" => PhoneNumberCountryCode::Mm,
            "MN" => PhoneNumberCountryCode::Mn,
            "MO" => PhoneNumberCountryCode::Mo,
            "MP" => PhoneNumberCountryCode::Mp,
            "MR" => PhoneNumberCountryCode::Mr,
            "MS" => PhoneNumberCountryCode::Ms,
            "MT" => PhoneNumberCountryCode::Mt,
            "MU" => PhoneNumberCountryCode::Mu,
            "MV" => PhoneNumberCountryCode::Mv,
            "MW" => PhoneNumberCountryCode::Mw,
            "MX" => PhoneNumberCountryCode::Mx,
            "MY" => PhoneNumberCountryCode::My,
            "MZ" => PhoneNumberCountryCode::Mz,
            "NA" => PhoneNumberCountryCode::Na,
            "NC" => PhoneNumberCountryCode::Nc,
            "NE" => PhoneNumberCountryCode::Ne,
            "NG" => PhoneNumberCountryCode::Ng,
            "NI" => PhoneNumberCountryCode::Ni,
            "NL" => PhoneNumberCountryCode::Nl,
            "NO" => PhoneNumberCountryCode::No,
            "NP" => PhoneNumberCountryCode::Np,
            "NR" => PhoneNumberCountryCode::Nr,
            "NU" => PhoneNumberCountryCode::Nu,
            "NZ" => PhoneNumberCountryCode::Nz,
            "OM" => PhoneNumberCountryCode::Om,
            "PA" => PhoneNumberCountryCode::Pa,
            "PE" => PhoneNumberCountryCode::Pe,
            "PF" => PhoneNumberCountryCode::Pf,
            "PG" => PhoneNumberCountryCode::Pg,
            "PH" => PhoneNumberCountryCode::Ph,
            "PK" => PhoneNumberCountryCode::Pk,
            "PL" => PhoneNumberCountryCode::Pl,
            "PM" => PhoneNumberCountryCode::Pm,
            "PN" => PhoneNumberCountryCode::Pn,
            "PR" => PhoneNumberCountryCode::Pr,
            "PT" => PhoneNumberCountryCode::Pt,
            "PW" => PhoneNumberCountryCode::Pw,
            "PY" => PhoneNumberCountryCode::Py,
            "QA" => PhoneNumberCountryCode::Qa,
            "RE" => PhoneNumberCountryCode::Re,
            "RO" => PhoneNumberCountryCode::Ro,
            "RS" => PhoneNumberCountryCode::Rs,
            "RU" => PhoneNumberCountryCode::Ru,
            "RW" => PhoneNumberCountryCode::Rw,
            "SA" => PhoneNumberCountryCode::Sa,
            "SB" => PhoneNumberCountryCode::Sb,
            "SC" => PhoneNumberCountryCode::Sc,
            "SD" => PhoneNumberCountryCode::Sd,
            "SE" => PhoneNumberCountryCode::Se,
            "SG" => PhoneNumberCountryCode::Sg,
            "SH" => PhoneNumberCountryCode::Sh,
            "SI" => PhoneNumberCountryCode::Si,
            "SJ" => PhoneNumberCountryCode::Sj,
            "SK" => PhoneNumberCountryCode::Sk,
            "SL" => PhoneNumberCountryCode::Sl,
            "SM" => PhoneNumberCountryCode::Sm,
            "SN" => PhoneNumberCountryCode::Sn,
            "SO" => PhoneNumberCountryCode::So,
            "SR" => PhoneNumberCountryCode::Sr,
            "ST" => PhoneNumberCountryCode::St,
            "SV" => PhoneNumberCountryCode::Sv,
            "SX" => PhoneNumberCountryCode::Sx,
            "SY" => PhoneNumberCountryCode::Sy,
            "SZ" => PhoneNumberCountryCode::Sz,
            "TC" => PhoneNumberCountryCode::Tc,
            "TD" => PhoneNumberCountryCode::Td,
            "TG" => PhoneNumberCountryCode::Tg,
            "TH" => PhoneNumberCountryCode::Th,
            "TJ" => PhoneNumberCountryCode::Tj,
            "TK" => PhoneNumberCountryCode::Tk,
            "TL" => PhoneNumberCountryCode::Tl,
            "TM" => PhoneNumberCountryCode::Tm,
            "TN" => PhoneNumberCountryCode::Tn,
            "TO" => PhoneNumberCountryCode::To,
            "TR" => PhoneNumberCountryCode::Tr,
            "TT" => PhoneNumberCountryCode::Tt,
            "TV" => PhoneNumberCountryCode::Tv,
            "TW" => PhoneNumberCountryCode::Tw,
            "TZ" => PhoneNumberCountryCode::Tz,
            "UA" => PhoneNumberCountryCode::Ua,
            "UG" => PhoneNumberCountryCode::Ug,
            "US" => PhoneNumberCountryCode::Us,
            "UY" => PhoneNumberCountryCode::Uy,
            "UZ" => PhoneNumberCountryCode::Uz,
            "VA" => PhoneNumberCountryCode::Va,
            "VC" => PhoneNumberCountryCode::Vc,
            "VE" => PhoneNumberCountryCode::Ve,
            "VG" => PhoneNumberCountryCode::Vg,
            "VI" => PhoneNumberCountryCode::Vi,
            "VN" => PhoneNumberCountryCode::Vn,
            "VU" => PhoneNumberCountryCode::Vu,
            "WF" => PhoneNumberCountryCode::Wf,
            "WS" => PhoneNumberCountryCode::Ws,
            "YE" => PhoneNumberCountryCode::Ye,
            "YT" => PhoneNumberCountryCode::Yt,
            "ZA" => PhoneNumberCountryCode::Za,
            "ZM" => PhoneNumberCountryCode::Zm,
            "ZW" => PhoneNumberCountryCode::Zw,
            other => {
                PhoneNumberCountryCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PhoneNumberCountryCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneNumberCountryCode::from(s))
    }
}
impl PhoneNumberCountryCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneNumberCountryCode::Ad => "AD",
            PhoneNumberCountryCode::Ae => "AE",
            PhoneNumberCountryCode::Af => "AF",
            PhoneNumberCountryCode::Ag => "AG",
            PhoneNumberCountryCode::Ai => "AI",
            PhoneNumberCountryCode::Al => "AL",
            PhoneNumberCountryCode::Am => "AM",
            PhoneNumberCountryCode::An => "AN",
            PhoneNumberCountryCode::Ao => "AO",
            PhoneNumberCountryCode::Aq => "AQ",
            PhoneNumberCountryCode::Ar => "AR",
            PhoneNumberCountryCode::As => "AS",
            PhoneNumberCountryCode::At => "AT",
            PhoneNumberCountryCode::Au => "AU",
            PhoneNumberCountryCode::Aw => "AW",
            PhoneNumberCountryCode::Az => "AZ",
            PhoneNumberCountryCode::Ba => "BA",
            PhoneNumberCountryCode::Bb => "BB",
            PhoneNumberCountryCode::Bd => "BD",
            PhoneNumberCountryCode::Be => "BE",
            PhoneNumberCountryCode::Bf => "BF",
            PhoneNumberCountryCode::Bg => "BG",
            PhoneNumberCountryCode::Bh => "BH",
            PhoneNumberCountryCode::Bi => "BI",
            PhoneNumberCountryCode::Bj => "BJ",
            PhoneNumberCountryCode::Bl => "BL",
            PhoneNumberCountryCode::Bm => "BM",
            PhoneNumberCountryCode::Bn => "BN",
            PhoneNumberCountryCode::Bo => "BO",
            PhoneNumberCountryCode::Br => "BR",
            PhoneNumberCountryCode::Bs => "BS",
            PhoneNumberCountryCode::Bt => "BT",
            PhoneNumberCountryCode::Bw => "BW",
            PhoneNumberCountryCode::By => "BY",
            PhoneNumberCountryCode::Bz => "BZ",
            PhoneNumberCountryCode::Ca => "CA",
            PhoneNumberCountryCode::Cc => "CC",
            PhoneNumberCountryCode::Cd => "CD",
            PhoneNumberCountryCode::Cf => "CF",
            PhoneNumberCountryCode::Cg => "CG",
            PhoneNumberCountryCode::Ch => "CH",
            PhoneNumberCountryCode::Ci => "CI",
            PhoneNumberCountryCode::Ck => "CK",
            PhoneNumberCountryCode::Cl => "CL",
            PhoneNumberCountryCode::Cm => "CM",
            PhoneNumberCountryCode::Cn => "CN",
            PhoneNumberCountryCode::Co => "CO",
            PhoneNumberCountryCode::Cr => "CR",
            PhoneNumberCountryCode::Cu => "CU",
            PhoneNumberCountryCode::Cv => "CV",
            PhoneNumberCountryCode::Cw => "CW",
            PhoneNumberCountryCode::Cx => "CX",
            PhoneNumberCountryCode::Cy => "CY",
            PhoneNumberCountryCode::Cz => "CZ",
            PhoneNumberCountryCode::De => "DE",
            PhoneNumberCountryCode::Dj => "DJ",
            PhoneNumberCountryCode::Dk => "DK",
            PhoneNumberCountryCode::Dm => "DM",
            PhoneNumberCountryCode::Do => "DO",
            PhoneNumberCountryCode::Dz => "DZ",
            PhoneNumberCountryCode::Ec => "EC",
            PhoneNumberCountryCode::Ee => "EE",
            PhoneNumberCountryCode::Eg => "EG",
            PhoneNumberCountryCode::Eh => "EH",
            PhoneNumberCountryCode::Er => "ER",
            PhoneNumberCountryCode::Es => "ES",
            PhoneNumberCountryCode::Et => "ET",
            PhoneNumberCountryCode::Fi => "FI",
            PhoneNumberCountryCode::Fj => "FJ",
            PhoneNumberCountryCode::Fk => "FK",
            PhoneNumberCountryCode::Fm => "FM",
            PhoneNumberCountryCode::Fo => "FO",
            PhoneNumberCountryCode::Fr => "FR",
            PhoneNumberCountryCode::Ga => "GA",
            PhoneNumberCountryCode::Gb => "GB",
            PhoneNumberCountryCode::Gd => "GD",
            PhoneNumberCountryCode::Ge => "GE",
            PhoneNumberCountryCode::Gg => "GG",
            PhoneNumberCountryCode::Gh => "GH",
            PhoneNumberCountryCode::Gi => "GI",
            PhoneNumberCountryCode::Gl => "GL",
            PhoneNumberCountryCode::Gm => "GM",
            PhoneNumberCountryCode::Gn => "GN",
            PhoneNumberCountryCode::Gq => "GQ",
            PhoneNumberCountryCode::Gr => "GR",
            PhoneNumberCountryCode::Gt => "GT",
            PhoneNumberCountryCode::Gu => "GU",
            PhoneNumberCountryCode::Gw => "GW",
            PhoneNumberCountryCode::Gy => "GY",
            PhoneNumberCountryCode::Hk => "HK",
            PhoneNumberCountryCode::Hn => "HN",
            PhoneNumberCountryCode::Hr => "HR",
            PhoneNumberCountryCode::Ht => "HT",
            PhoneNumberCountryCode::Hu => "HU",
            PhoneNumberCountryCode::Id => "ID",
            PhoneNumberCountryCode::Ie => "IE",
            PhoneNumberCountryCode::Il => "IL",
            PhoneNumberCountryCode::Im => "IM",
            PhoneNumberCountryCode::In => "IN",
            PhoneNumberCountryCode::Io => "IO",
            PhoneNumberCountryCode::Iq => "IQ",
            PhoneNumberCountryCode::Ir => "IR",
            PhoneNumberCountryCode::Is => "IS",
            PhoneNumberCountryCode::It => "IT",
            PhoneNumberCountryCode::Je => "JE",
            PhoneNumberCountryCode::Jm => "JM",
            PhoneNumberCountryCode::Jo => "JO",
            PhoneNumberCountryCode::Jp => "JP",
            PhoneNumberCountryCode::Ke => "KE",
            PhoneNumberCountryCode::Kg => "KG",
            PhoneNumberCountryCode::Kh => "KH",
            PhoneNumberCountryCode::Ki => "KI",
            PhoneNumberCountryCode::Km => "KM",
            PhoneNumberCountryCode::Kn => "KN",
            PhoneNumberCountryCode::Kp => "KP",
            PhoneNumberCountryCode::Kr => "KR",
            PhoneNumberCountryCode::Kw => "KW",
            PhoneNumberCountryCode::Ky => "KY",
            PhoneNumberCountryCode::Kz => "KZ",
            PhoneNumberCountryCode::La => "LA",
            PhoneNumberCountryCode::Lb => "LB",
            PhoneNumberCountryCode::Lc => "LC",
            PhoneNumberCountryCode::Li => "LI",
            PhoneNumberCountryCode::Lk => "LK",
            PhoneNumberCountryCode::Lr => "LR",
            PhoneNumberCountryCode::Ls => "LS",
            PhoneNumberCountryCode::Lt => "LT",
            PhoneNumberCountryCode::Lu => "LU",
            PhoneNumberCountryCode::Lv => "LV",
            PhoneNumberCountryCode::Ly => "LY",
            PhoneNumberCountryCode::Ma => "MA",
            PhoneNumberCountryCode::Mc => "MC",
            PhoneNumberCountryCode::Md => "MD",
            PhoneNumberCountryCode::Me => "ME",
            PhoneNumberCountryCode::Mf => "MF",
            PhoneNumberCountryCode::Mg => "MG",
            PhoneNumberCountryCode::Mh => "MH",
            PhoneNumberCountryCode::Mk => "MK",
            PhoneNumberCountryCode::Ml => "ML",
            PhoneNumberCountryCode::Mm => "MM",
            PhoneNumberCountryCode::Mn => "MN",
            PhoneNumberCountryCode::Mo => "MO",
            PhoneNumberCountryCode::Mp => "MP",
            PhoneNumberCountryCode::Mr => "MR",
            PhoneNumberCountryCode::Ms => "MS",
            PhoneNumberCountryCode::Mt => "MT",
            PhoneNumberCountryCode::Mu => "MU",
            PhoneNumberCountryCode::Mv => "MV",
            PhoneNumberCountryCode::Mw => "MW",
            PhoneNumberCountryCode::Mx => "MX",
            PhoneNumberCountryCode::My => "MY",
            PhoneNumberCountryCode::Mz => "MZ",
            PhoneNumberCountryCode::Na => "NA",
            PhoneNumberCountryCode::Nc => "NC",
            PhoneNumberCountryCode::Ne => "NE",
            PhoneNumberCountryCode::Ng => "NG",
            PhoneNumberCountryCode::Ni => "NI",
            PhoneNumberCountryCode::Nl => "NL",
            PhoneNumberCountryCode::No => "NO",
            PhoneNumberCountryCode::Np => "NP",
            PhoneNumberCountryCode::Nr => "NR",
            PhoneNumberCountryCode::Nu => "NU",
            PhoneNumberCountryCode::Nz => "NZ",
            PhoneNumberCountryCode::Om => "OM",
            PhoneNumberCountryCode::Pa => "PA",
            PhoneNumberCountryCode::Pe => "PE",
            PhoneNumberCountryCode::Pf => "PF",
            PhoneNumberCountryCode::Pg => "PG",
            PhoneNumberCountryCode::Ph => "PH",
            PhoneNumberCountryCode::Pk => "PK",
            PhoneNumberCountryCode::Pl => "PL",
            PhoneNumberCountryCode::Pm => "PM",
            PhoneNumberCountryCode::Pn => "PN",
            PhoneNumberCountryCode::Pr => "PR",
            PhoneNumberCountryCode::Pt => "PT",
            PhoneNumberCountryCode::Pw => "PW",
            PhoneNumberCountryCode::Py => "PY",
            PhoneNumberCountryCode::Qa => "QA",
            PhoneNumberCountryCode::Re => "RE",
            PhoneNumberCountryCode::Ro => "RO",
            PhoneNumberCountryCode::Rs => "RS",
            PhoneNumberCountryCode::Ru => "RU",
            PhoneNumberCountryCode::Rw => "RW",
            PhoneNumberCountryCode::Sa => "SA",
            PhoneNumberCountryCode::Sb => "SB",
            PhoneNumberCountryCode::Sc => "SC",
            PhoneNumberCountryCode::Sd => "SD",
            PhoneNumberCountryCode::Se => "SE",
            PhoneNumberCountryCode::Sg => "SG",
            PhoneNumberCountryCode::Sh => "SH",
            PhoneNumberCountryCode::Si => "SI",
            PhoneNumberCountryCode::Sj => "SJ",
            PhoneNumberCountryCode::Sk => "SK",
            PhoneNumberCountryCode::Sl => "SL",
            PhoneNumberCountryCode::Sm => "SM",
            PhoneNumberCountryCode::Sn => "SN",
            PhoneNumberCountryCode::So => "SO",
            PhoneNumberCountryCode::Sr => "SR",
            PhoneNumberCountryCode::St => "ST",
            PhoneNumberCountryCode::Sv => "SV",
            PhoneNumberCountryCode::Sx => "SX",
            PhoneNumberCountryCode::Sy => "SY",
            PhoneNumberCountryCode::Sz => "SZ",
            PhoneNumberCountryCode::Tc => "TC",
            PhoneNumberCountryCode::Td => "TD",
            PhoneNumberCountryCode::Tg => "TG",
            PhoneNumberCountryCode::Th => "TH",
            PhoneNumberCountryCode::Tj => "TJ",
            PhoneNumberCountryCode::Tk => "TK",
            PhoneNumberCountryCode::Tl => "TL",
            PhoneNumberCountryCode::Tm => "TM",
            PhoneNumberCountryCode::Tn => "TN",
            PhoneNumberCountryCode::To => "TO",
            PhoneNumberCountryCode::Tr => "TR",
            PhoneNumberCountryCode::Tt => "TT",
            PhoneNumberCountryCode::Tv => "TV",
            PhoneNumberCountryCode::Tw => "TW",
            PhoneNumberCountryCode::Tz => "TZ",
            PhoneNumberCountryCode::Ua => "UA",
            PhoneNumberCountryCode::Ug => "UG",
            PhoneNumberCountryCode::Us => "US",
            PhoneNumberCountryCode::Uy => "UY",
            PhoneNumberCountryCode::Uz => "UZ",
            PhoneNumberCountryCode::Va => "VA",
            PhoneNumberCountryCode::Vc => "VC",
            PhoneNumberCountryCode::Ve => "VE",
            PhoneNumberCountryCode::Vg => "VG",
            PhoneNumberCountryCode::Vi => "VI",
            PhoneNumberCountryCode::Vn => "VN",
            PhoneNumberCountryCode::Vu => "VU",
            PhoneNumberCountryCode::Wf => "WF",
            PhoneNumberCountryCode::Ws => "WS",
            PhoneNumberCountryCode::Ye => "YE",
            PhoneNumberCountryCode::Yt => "YT",
            PhoneNumberCountryCode::Za => "ZA",
            PhoneNumberCountryCode::Zm => "ZM",
            PhoneNumberCountryCode::Zw => "ZW",
            PhoneNumberCountryCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN", "AO", "AQ", "AR", "AS", "AT", "AU",
            "AW", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN",
            "BO", "BR", "BS", "BT", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI",
            "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ",
            "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK",
            "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GG", "GH", "GI", "GL", "GM", "GN", "GQ",
            "GR", "GT", "GU", "GW", "GY", "HK", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM",
            "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI",
            "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS",
            "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM",
            "MN", "MO", "MP", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC",
            "NE", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG",
            "PH", "PK", "PL", "PM", "PN", "PR", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU",
            "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN",
            "SO", "SR", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TG", "TH", "TJ", "TK", "TL",
            "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "US", "UY", "UZ", "VA",
            "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW",
        ]
    }
}
impl AsRef<str> for PhoneNumberCountryCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `MonitorCapability`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let monitorcapability = unimplemented!();
/// match monitorcapability {
///     MonitorCapability::Barge => { /* ... */ },
///     MonitorCapability::SilentMonitor => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `monitorcapability` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MonitorCapability::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MonitorCapability::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MonitorCapability::NewFeature` is defined.
/// Specifically, when `monitorcapability` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MonitorCapability::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitorCapability {
    #[allow(missing_docs)] // documentation missing in model
    Barge,
    #[allow(missing_docs)] // documentation missing in model
    SilentMonitor,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MonitorCapability {
    fn from(s: &str) -> Self {
        match s {
            "BARGE" => MonitorCapability::Barge,
            "SILENT_MONITOR" => MonitorCapability::SilentMonitor,
            other => {
                MonitorCapability::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for MonitorCapability {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitorCapability::from(s))
    }
}
impl MonitorCapability {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MonitorCapability::Barge => "BARGE",
            MonitorCapability::SilentMonitor => "SILENT_MONITOR",
            MonitorCapability::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BARGE", "SILENT_MONITOR"]
    }
}
impl AsRef<str> for MonitorCapability {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains summary information about a user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserSummary {
    /// <p>The identifier of the user account.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the user account.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Connect user name of the user account.</p>
    #[doc(hidden)]
    pub username: std::option::Option<std::string::String>,
}
impl UserSummary {
    /// <p>The identifier of the user account.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the user account.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The Amazon Connect user name of the user account.</p>
    pub fn username(&self) -> std::option::Option<&str> {
        self.username.as_deref()
    }
}
/// See [`UserSummary`](crate::model::UserSummary).
pub mod user_summary {

    /// A builder for [`UserSummary`](crate::model::UserSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) username: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the user account.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user account.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user account.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The Amazon Connect user name of the user account.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        /// <p>The Amazon Connect user name of the user account.</p>
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input;
            self
        }
        /// Consumes the builder and constructs a [`UserSummary`](crate::model::UserSummary).
        pub fn build(self) -> crate::model::UserSummary {
            crate::model::UserSummary {
                id: self.id,
                arn: self.arn,
                username: self.username,
            }
        }
    }
}
impl UserSummary {
    /// Creates a new builder-style object to manufacture [`UserSummary`](crate::model::UserSummary).
    pub fn builder() -> crate::model::user_summary::Builder {
        crate::model::user_summary::Builder::default()
    }
}

/// <p>Contains summary information about a hierarchy group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HierarchyGroupSummary {
    /// <p>The identifier of the hierarchy group.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the hierarchy group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl HierarchyGroupSummary {
    /// <p>The identifier of the hierarchy group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the hierarchy group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`HierarchyGroupSummary`](crate::model::HierarchyGroupSummary).
pub mod hierarchy_group_summary {

    /// A builder for [`HierarchyGroupSummary`](crate::model::HierarchyGroupSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the hierarchy group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the hierarchy group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the hierarchy group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hierarchy group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyGroupSummary`](crate::model::HierarchyGroupSummary).
        pub fn build(self) -> crate::model::HierarchyGroupSummary {
            crate::model::HierarchyGroupSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl HierarchyGroupSummary {
    /// Creates a new builder-style object to manufacture [`HierarchyGroupSummary`](crate::model::HierarchyGroupSummary).
    pub fn builder() -> crate::model::hierarchy_group_summary::Builder {
        crate::model::hierarchy_group_summary::Builder::default()
    }
}

/// <p>Contains the use case.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UseCase {
    /// <p>The identifier for the use case.</p>
    #[doc(hidden)]
    pub use_case_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the use case.</p>
    #[doc(hidden)]
    pub use_case_arn: std::option::Option<std::string::String>,
    /// <p>The type of use case to associate to the integration association. Each integration association can have only one of each use case type.</p>
    #[doc(hidden)]
    pub use_case_type: std::option::Option<crate::model::UseCaseType>,
}
impl UseCase {
    /// <p>The identifier for the use case.</p>
    pub fn use_case_id(&self) -> std::option::Option<&str> {
        self.use_case_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the use case.</p>
    pub fn use_case_arn(&self) -> std::option::Option<&str> {
        self.use_case_arn.as_deref()
    }
    /// <p>The type of use case to associate to the integration association. Each integration association can have only one of each use case type.</p>
    pub fn use_case_type(&self) -> std::option::Option<&crate::model::UseCaseType> {
        self.use_case_type.as_ref()
    }
}
/// See [`UseCase`](crate::model::UseCase).
pub mod use_case {

    /// A builder for [`UseCase`](crate::model::UseCase).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) use_case_id: std::option::Option<std::string::String>,
        pub(crate) use_case_arn: std::option::Option<std::string::String>,
        pub(crate) use_case_type: std::option::Option<crate::model::UseCaseType>,
    }
    impl Builder {
        /// <p>The identifier for the use case.</p>
        pub fn use_case_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.use_case_id = Some(input.into());
            self
        }
        /// <p>The identifier for the use case.</p>
        pub fn set_use_case_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.use_case_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the use case.</p>
        pub fn use_case_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.use_case_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the use case.</p>
        pub fn set_use_case_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.use_case_arn = input;
            self
        }
        /// <p>The type of use case to associate to the integration association. Each integration association can have only one of each use case type.</p>
        pub fn use_case_type(mut self, input: crate::model::UseCaseType) -> Self {
            self.use_case_type = Some(input);
            self
        }
        /// <p>The type of use case to associate to the integration association. Each integration association can have only one of each use case type.</p>
        pub fn set_use_case_type(
            mut self,
            input: std::option::Option<crate::model::UseCaseType>,
        ) -> Self {
            self.use_case_type = input;
            self
        }
        /// Consumes the builder and constructs a [`UseCase`](crate::model::UseCase).
        pub fn build(self) -> crate::model::UseCase {
            crate::model::UseCase {
                use_case_id: self.use_case_id,
                use_case_arn: self.use_case_arn,
                use_case_type: self.use_case_type,
            }
        }
    }
}
impl UseCase {
    /// Creates a new builder-style object to manufacture [`UseCase`](crate::model::UseCase).
    pub fn builder() -> crate::model::use_case::Builder {
        crate::model::use_case::Builder::default()
    }
}

/// When writing a match expression against `UseCaseType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let usecasetype = unimplemented!();
/// match usecasetype {
///     UseCaseType::ConnectCampaigns => { /* ... */ },
///     UseCaseType::RulesEvaluation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `usecasetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UseCaseType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UseCaseType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UseCaseType::NewFeature` is defined.
/// Specifically, when `usecasetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UseCaseType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UseCaseType {
    #[allow(missing_docs)] // documentation missing in model
    ConnectCampaigns,
    #[allow(missing_docs)] // documentation missing in model
    RulesEvaluation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UseCaseType {
    fn from(s: &str) -> Self {
        match s {
            "CONNECT_CAMPAIGNS" => UseCaseType::ConnectCampaigns,
            "RULES_EVALUATION" => UseCaseType::RulesEvaluation,
            other => UseCaseType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UseCaseType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UseCaseType::from(s))
    }
}
impl UseCaseType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UseCaseType::ConnectCampaigns => "CONNECT_CAMPAIGNS",
            UseCaseType::RulesEvaluation => "RULES_EVALUATION",
            UseCaseType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CONNECT_CAMPAIGNS", "RULES_EVALUATION"]
    }
}
impl AsRef<str> for UseCaseType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about traffic distribution groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TrafficDistributionGroupSummary {
    /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the traffic distribution group.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the traffic distribution group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the traffic distribution group.</p>
    #[doc(hidden)]
    pub instance_arn: std::option::Option<std::string::String>,
    /// <p>The status of the traffic distribution group. </p>
    /// <ul>
    /// <li> <p> <code>CREATION_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
    /// <li> <p> <code>ACTIVE</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has succeeded.</p> </li>
    /// <li> <p> <code>CREATION_FAILED</code> indicates that the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has failed.</p> </li>
    /// <li> <p> <code>PENDING_DELETION</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
    /// <li> <p> <code>DELETION_FAILED</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation has failed.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistributionGroup.html">UpdateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TrafficDistributionGroupStatus>,
}
impl TrafficDistributionGroupSummary {
    /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the traffic distribution group.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the traffic distribution group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the traffic distribution group.</p>
    pub fn instance_arn(&self) -> std::option::Option<&str> {
        self.instance_arn.as_deref()
    }
    /// <p>The status of the traffic distribution group. </p>
    /// <ul>
    /// <li> <p> <code>CREATION_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
    /// <li> <p> <code>ACTIVE</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has succeeded.</p> </li>
    /// <li> <p> <code>CREATION_FAILED</code> indicates that the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has failed.</p> </li>
    /// <li> <p> <code>PENDING_DELETION</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
    /// <li> <p> <code>DELETION_FAILED</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation has failed.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistributionGroup.html">UpdateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::TrafficDistributionGroupStatus> {
        self.status.as_ref()
    }
}
/// See [`TrafficDistributionGroupSummary`](crate::model::TrafficDistributionGroupSummary).
pub mod traffic_distribution_group_summary {

    /// A builder for [`TrafficDistributionGroupSummary`](crate::model::TrafficDistributionGroupSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) instance_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TrafficDistributionGroupStatus>,
    }
    impl Builder {
        /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the traffic distribution group.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the traffic distribution group.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the traffic distribution group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the traffic distribution group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the traffic distribution group.</p>
        pub fn instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the traffic distribution group.</p>
        pub fn set_instance_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_arn = input;
            self
        }
        /// <p>The status of the traffic distribution group. </p>
        /// <ul>
        /// <li> <p> <code>CREATION_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
        /// <li> <p> <code>ACTIVE</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has succeeded.</p> </li>
        /// <li> <p> <code>CREATION_FAILED</code> indicates that the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has failed.</p> </li>
        /// <li> <p> <code>PENDING_DELETION</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
        /// <li> <p> <code>DELETION_FAILED</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation has failed.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistributionGroup.html">UpdateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::TrafficDistributionGroupStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the traffic distribution group. </p>
        /// <ul>
        /// <li> <p> <code>CREATION_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
        /// <li> <p> <code>ACTIVE</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has succeeded.</p> </li>
        /// <li> <p> <code>CREATION_FAILED</code> indicates that the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has failed.</p> </li>
        /// <li> <p> <code>PENDING_DELETION</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
        /// <li> <p> <code>DELETION_FAILED</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation has failed.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistributionGroup.html">UpdateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TrafficDistributionGroupStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`TrafficDistributionGroupSummary`](crate::model::TrafficDistributionGroupSummary).
        pub fn build(self) -> crate::model::TrafficDistributionGroupSummary {
            crate::model::TrafficDistributionGroupSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                instance_arn: self.instance_arn,
                status: self.status,
            }
        }
    }
}
impl TrafficDistributionGroupSummary {
    /// Creates a new builder-style object to manufacture [`TrafficDistributionGroupSummary`](crate::model::TrafficDistributionGroupSummary).
    pub fn builder() -> crate::model::traffic_distribution_group_summary::Builder {
        crate::model::traffic_distribution_group_summary::Builder::default()
    }
}

/// When writing a match expression against `TrafficDistributionGroupStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let trafficdistributiongroupstatus = unimplemented!();
/// match trafficdistributiongroupstatus {
///     TrafficDistributionGroupStatus::Active => { /* ... */ },
///     TrafficDistributionGroupStatus::CreationFailed => { /* ... */ },
///     TrafficDistributionGroupStatus::CreationInProgress => { /* ... */ },
///     TrafficDistributionGroupStatus::DeletionFailed => { /* ... */ },
///     TrafficDistributionGroupStatus::PendingDeletion => { /* ... */ },
///     TrafficDistributionGroupStatus::UpdateInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `trafficdistributiongroupstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TrafficDistributionGroupStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TrafficDistributionGroupStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TrafficDistributionGroupStatus::NewFeature` is defined.
/// Specifically, when `trafficdistributiongroupstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TrafficDistributionGroupStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrafficDistributionGroupStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    CreationFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreationInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DeletionFailed,
    #[allow(missing_docs)] // documentation missing in model
    PendingDeletion,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TrafficDistributionGroupStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => TrafficDistributionGroupStatus::Active,
            "CREATION_FAILED" => TrafficDistributionGroupStatus::CreationFailed,
            "CREATION_IN_PROGRESS" => TrafficDistributionGroupStatus::CreationInProgress,
            "DELETION_FAILED" => TrafficDistributionGroupStatus::DeletionFailed,
            "PENDING_DELETION" => TrafficDistributionGroupStatus::PendingDeletion,
            "UPDATE_IN_PROGRESS" => TrafficDistributionGroupStatus::UpdateInProgress,
            other => TrafficDistributionGroupStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for TrafficDistributionGroupStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrafficDistributionGroupStatus::from(s))
    }
}
impl TrafficDistributionGroupStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TrafficDistributionGroupStatus::Active => "ACTIVE",
            TrafficDistributionGroupStatus::CreationFailed => "CREATION_FAILED",
            TrafficDistributionGroupStatus::CreationInProgress => "CREATION_IN_PROGRESS",
            TrafficDistributionGroupStatus::DeletionFailed => "DELETION_FAILED",
            TrafficDistributionGroupStatus::PendingDeletion => "PENDING_DELETION",
            TrafficDistributionGroupStatus::UpdateInProgress => "UPDATE_IN_PROGRESS",
            TrafficDistributionGroupStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "CREATION_FAILED",
            "CREATION_IN_PROGRESS",
            "DELETION_FAILED",
            "PENDING_DELETION",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for TrafficDistributionGroupStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains summary information about the task template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskTemplateMetadata {
    /// <p>A unique identifier for the task template.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the task template.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the task template.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the task template.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TaskTemplateStatus>,
    /// <p>The timestamp when the task template was last modified.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp when the task template was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl TaskTemplateMetadata {
    /// <p>A unique identifier for the task template.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the task template.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the task template.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the task template.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TaskTemplateStatus> {
        self.status.as_ref()
    }
    /// <p>The timestamp when the task template was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The timestamp when the task template was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
}
/// See [`TaskTemplateMetadata`](crate::model::TaskTemplateMetadata).
pub mod task_template_metadata {

    /// A builder for [`TaskTemplateMetadata`](crate::model::TaskTemplateMetadata).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TaskTemplateStatus>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>A unique identifier for the task template.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the task template.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the task template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the task template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the task template.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the task template.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the task template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the task template.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
        pub fn status(mut self, input: crate::model::TaskTemplateStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The timestamp when the task template was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp when the task template was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The timestamp when the task template was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The timestamp when the task template was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskTemplateMetadata`](crate::model::TaskTemplateMetadata).
        pub fn build(self) -> crate::model::TaskTemplateMetadata {
            crate::model::TaskTemplateMetadata {
                id: self.id,
                arn: self.arn,
                name: self.name,
                description: self.description,
                status: self.status,
                last_modified_time: self.last_modified_time,
                created_time: self.created_time,
            }
        }
    }
}
impl TaskTemplateMetadata {
    /// Creates a new builder-style object to manufacture [`TaskTemplateMetadata`](crate::model::TaskTemplateMetadata).
    pub fn builder() -> crate::model::task_template_metadata::Builder {
        crate::model::task_template_metadata::Builder::default()
    }
}

/// <p>Contains information about a security profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SecurityProfileSummary {
    /// <p>The identifier of the security profile.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the security profile.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the security profile.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl SecurityProfileSummary {
    /// <p>The identifier of the security profile.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the security profile.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the security profile.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`SecurityProfileSummary`](crate::model::SecurityProfileSummary).
pub mod security_profile_summary {

    /// A builder for [`SecurityProfileSummary`](crate::model::SecurityProfileSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the security profile.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the security profile.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the security profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the security profile.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the security profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the security profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityProfileSummary`](crate::model::SecurityProfileSummary).
        pub fn build(self) -> crate::model::SecurityProfileSummary {
            crate::model::SecurityProfileSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl SecurityProfileSummary {
    /// Creates a new builder-style object to manufacture [`SecurityProfileSummary`](crate::model::SecurityProfileSummary).
    pub fn builder() -> crate::model::security_profile_summary::Builder {
        crate::model::security_profile_summary::Builder::default()
    }
}

/// <p>Configuration information of the security key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SecurityKey {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    #[doc(hidden)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The key of the security key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>When the security key was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl SecurityKey {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    pub fn association_id(&self) -> std::option::Option<&str> {
        self.association_id.as_deref()
    }
    /// <p>The key of the security key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>When the security key was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
/// See [`SecurityKey`](crate::model::SecurityKey).
pub mod security_key {

    /// A builder for [`SecurityKey`](crate::model::SecurityKey).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The key of the security key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key of the security key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>When the security key was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the security key was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityKey`](crate::model::SecurityKey).
        pub fn build(self) -> crate::model::SecurityKey {
            crate::model::SecurityKey {
                association_id: self.association_id,
                key: self.key,
                creation_time: self.creation_time,
            }
        }
    }
}
impl SecurityKey {
    /// Creates a new builder-style object to manufacture [`SecurityKey`](crate::model::SecurityKey).
    pub fn builder() -> crate::model::security_key::Builder {
        crate::model::security_key::Builder::default()
    }
}

/// <p>A list of <code>ActionTypes</code> associated with a rule. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RuleSummary {
    /// <p>The name of the rule.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the rule.</p>
    #[doc(hidden)]
    pub rule_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    #[doc(hidden)]
    pub rule_arn: std::option::Option<std::string::String>,
    /// <p>The name of the event source.</p>
    #[doc(hidden)]
    pub event_source_name: std::option::Option<crate::model::EventSourceName>,
    /// <p>The publish status of the rule.</p>
    #[doc(hidden)]
    pub publish_status: std::option::Option<crate::model::RulePublishStatus>,
    /// <p>A list of ActionTypes associated with a rule. </p>
    #[doc(hidden)]
    pub action_summaries: std::option::Option<std::vec::Vec<crate::model::ActionSummary>>,
    /// <p>The timestamp for when the rule was created. </p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp for when the rule was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl RuleSummary {
    /// <p>The name of the rule.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A unique identifier for the rule.</p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    pub fn rule_arn(&self) -> std::option::Option<&str> {
        self.rule_arn.as_deref()
    }
    /// <p>The name of the event source.</p>
    pub fn event_source_name(&self) -> std::option::Option<&crate::model::EventSourceName> {
        self.event_source_name.as_ref()
    }
    /// <p>The publish status of the rule.</p>
    pub fn publish_status(&self) -> std::option::Option<&crate::model::RulePublishStatus> {
        self.publish_status.as_ref()
    }
    /// <p>A list of ActionTypes associated with a rule. </p>
    pub fn action_summaries(&self) -> std::option::Option<&[crate::model::ActionSummary]> {
        self.action_summaries.as_deref()
    }
    /// <p>The timestamp for when the rule was created. </p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The timestamp for when the rule was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
}
/// See [`RuleSummary`](crate::model::RuleSummary).
pub mod rule_summary {

    /// A builder for [`RuleSummary`](crate::model::RuleSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) rule_id: std::option::Option<std::string::String>,
        pub(crate) rule_arn: std::option::Option<std::string::String>,
        pub(crate) event_source_name: std::option::Option<crate::model::EventSourceName>,
        pub(crate) publish_status: std::option::Option<crate::model::RulePublishStatus>,
        pub(crate) action_summaries:
            std::option::Option<std::vec::Vec<crate::model::ActionSummary>>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the rule.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the rule.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique identifier for the rule.</p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the rule.</p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the rule.</p>
        pub fn rule_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the rule.</p>
        pub fn set_rule_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_arn = input;
            self
        }
        /// <p>The name of the event source.</p>
        pub fn event_source_name(mut self, input: crate::model::EventSourceName) -> Self {
            self.event_source_name = Some(input);
            self
        }
        /// <p>The name of the event source.</p>
        pub fn set_event_source_name(
            mut self,
            input: std::option::Option<crate::model::EventSourceName>,
        ) -> Self {
            self.event_source_name = input;
            self
        }
        /// <p>The publish status of the rule.</p>
        pub fn publish_status(mut self, input: crate::model::RulePublishStatus) -> Self {
            self.publish_status = Some(input);
            self
        }
        /// <p>The publish status of the rule.</p>
        pub fn set_publish_status(
            mut self,
            input: std::option::Option<crate::model::RulePublishStatus>,
        ) -> Self {
            self.publish_status = input;
            self
        }
        /// Appends an item to `action_summaries`.
        ///
        /// To override the contents of this collection use [`set_action_summaries`](Self::set_action_summaries).
        ///
        /// <p>A list of ActionTypes associated with a rule. </p>
        pub fn action_summaries(mut self, input: crate::model::ActionSummary) -> Self {
            let mut v = self.action_summaries.unwrap_or_default();
            v.push(input);
            self.action_summaries = Some(v);
            self
        }
        /// <p>A list of ActionTypes associated with a rule. </p>
        pub fn set_action_summaries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ActionSummary>>,
        ) -> Self {
            self.action_summaries = input;
            self
        }
        /// <p>The timestamp for when the rule was created. </p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The timestamp for when the rule was created. </p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The timestamp for when the rule was last updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The timestamp for when the rule was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleSummary`](crate::model::RuleSummary).
        pub fn build(self) -> crate::model::RuleSummary {
            crate::model::RuleSummary {
                name: self.name,
                rule_id: self.rule_id,
                rule_arn: self.rule_arn,
                event_source_name: self.event_source_name,
                publish_status: self.publish_status,
                action_summaries: self.action_summaries,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}
impl RuleSummary {
    /// Creates a new builder-style object to manufacture [`RuleSummary`](crate::model::RuleSummary).
    pub fn builder() -> crate::model::rule_summary::Builder {
        crate::model::rule_summary::Builder::default()
    }
}

/// <p>Information about an action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ActionSummary {
    /// <p>The action type.</p>
    #[doc(hidden)]
    pub action_type: std::option::Option<crate::model::ActionType>,
}
impl ActionSummary {
    /// <p>The action type.</p>
    pub fn action_type(&self) -> std::option::Option<&crate::model::ActionType> {
        self.action_type.as_ref()
    }
}
/// See [`ActionSummary`](crate::model::ActionSummary).
pub mod action_summary {

    /// A builder for [`ActionSummary`](crate::model::ActionSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_type: std::option::Option<crate::model::ActionType>,
    }
    impl Builder {
        /// <p>The action type.</p>
        pub fn action_type(mut self, input: crate::model::ActionType) -> Self {
            self.action_type = Some(input);
            self
        }
        /// <p>The action type.</p>
        pub fn set_action_type(
            mut self,
            input: std::option::Option<crate::model::ActionType>,
        ) -> Self {
            self.action_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ActionSummary`](crate::model::ActionSummary).
        pub fn build(self) -> crate::model::ActionSummary {
            crate::model::ActionSummary {
                action_type: self.action_type,
            }
        }
    }
}
impl ActionSummary {
    /// Creates a new builder-style object to manufacture [`ActionSummary`](crate::model::ActionSummary).
    pub fn builder() -> crate::model::action_summary::Builder {
        crate::model::action_summary::Builder::default()
    }
}

/// When writing a match expression against `EventSourceName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let eventsourcename = unimplemented!();
/// match eventsourcename {
///     EventSourceName::OnPostCallAnalysisAvailable => { /* ... */ },
///     EventSourceName::OnPostChatAnalysisAvailable => { /* ... */ },
///     EventSourceName::OnRealTimeCallAnalysisAvailable => { /* ... */ },
///     EventSourceName::OnSalesforceCaseCreate => { /* ... */ },
///     EventSourceName::OnZendeskTicketCreate => { /* ... */ },
///     EventSourceName::OnZendeskTicketStatusUpdate => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `eventsourcename` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EventSourceName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EventSourceName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EventSourceName::NewFeature` is defined.
/// Specifically, when `eventsourcename` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EventSourceName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EventSourceName {
    #[allow(missing_docs)] // documentation missing in model
    OnPostCallAnalysisAvailable,
    #[allow(missing_docs)] // documentation missing in model
    OnPostChatAnalysisAvailable,
    #[allow(missing_docs)] // documentation missing in model
    OnRealTimeCallAnalysisAvailable,
    #[allow(missing_docs)] // documentation missing in model
    OnSalesforceCaseCreate,
    #[allow(missing_docs)] // documentation missing in model
    OnZendeskTicketCreate,
    #[allow(missing_docs)] // documentation missing in model
    OnZendeskTicketStatusUpdate,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EventSourceName {
    fn from(s: &str) -> Self {
        match s {
            "OnPostCallAnalysisAvailable" => EventSourceName::OnPostCallAnalysisAvailable,
            "OnPostChatAnalysisAvailable" => EventSourceName::OnPostChatAnalysisAvailable,
            "OnRealTimeCallAnalysisAvailable" => EventSourceName::OnRealTimeCallAnalysisAvailable,
            "OnSalesforceCaseCreate" => EventSourceName::OnSalesforceCaseCreate,
            "OnZendeskTicketCreate" => EventSourceName::OnZendeskTicketCreate,
            "OnZendeskTicketStatusUpdate" => EventSourceName::OnZendeskTicketStatusUpdate,
            other => EventSourceName::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EventSourceName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EventSourceName::from(s))
    }
}
impl EventSourceName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EventSourceName::OnPostCallAnalysisAvailable => "OnPostCallAnalysisAvailable",
            EventSourceName::OnPostChatAnalysisAvailable => "OnPostChatAnalysisAvailable",
            EventSourceName::OnRealTimeCallAnalysisAvailable => "OnRealTimeCallAnalysisAvailable",
            EventSourceName::OnSalesforceCaseCreate => "OnSalesforceCaseCreate",
            EventSourceName::OnZendeskTicketCreate => "OnZendeskTicketCreate",
            EventSourceName::OnZendeskTicketStatusUpdate => "OnZendeskTicketStatusUpdate",
            EventSourceName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "OnPostCallAnalysisAvailable",
            "OnPostChatAnalysisAvailable",
            "OnRealTimeCallAnalysisAvailable",
            "OnSalesforceCaseCreate",
            "OnZendeskTicketCreate",
            "OnZendeskTicketStatusUpdate",
        ]
    }
}
impl AsRef<str> for EventSourceName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains summary information about a routing profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RoutingProfileSummary {
    /// <p>The identifier of the routing profile.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the routing profile.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl RoutingProfileSummary {
    /// <p>The identifier of the routing profile.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the routing profile.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`RoutingProfileSummary`](crate::model::RoutingProfileSummary).
pub mod routing_profile_summary {

    /// A builder for [`RoutingProfileSummary`](crate::model::RoutingProfileSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the routing profile.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the routing profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the routing profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfileSummary`](crate::model::RoutingProfileSummary).
        pub fn build(self) -> crate::model::RoutingProfileSummary {
            crate::model::RoutingProfileSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl RoutingProfileSummary {
    /// Creates a new builder-style object to manufacture [`RoutingProfileSummary`](crate::model::RoutingProfileSummary).
    pub fn builder() -> crate::model::routing_profile_summary::Builder {
        crate::model::routing_profile_summary::Builder::default()
    }
}

/// <p>Contains summary information about a routing profile queue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RoutingProfileQueueConfigSummary {
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    #[doc(hidden)]
    pub queue_arn: std::option::Option<std::string::String>,
    /// <p>The name of the queue.</p>
    #[doc(hidden)]
    pub queue_name: std::option::Option<std::string::String>,
    /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
    #[doc(hidden)]
    pub priority: i32,
    /// <p>The delay, in seconds, that a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    #[doc(hidden)]
    pub delay: i32,
    /// <p>The channels this queue supports.</p>
    #[doc(hidden)]
    pub channel: std::option::Option<crate::model::Channel>,
}
impl RoutingProfileQueueConfigSummary {
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    pub fn queue_arn(&self) -> std::option::Option<&str> {
        self.queue_arn.as_deref()
    }
    /// <p>The name of the queue.</p>
    pub fn queue_name(&self) -> std::option::Option<&str> {
        self.queue_name.as_deref()
    }
    /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>The delay, in seconds, that a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub fn delay(&self) -> i32 {
        self.delay
    }
    /// <p>The channels this queue supports.</p>
    pub fn channel(&self) -> std::option::Option<&crate::model::Channel> {
        self.channel.as_ref()
    }
}
/// See [`RoutingProfileQueueConfigSummary`](crate::model::RoutingProfileQueueConfigSummary).
pub mod routing_profile_queue_config_summary {

    /// A builder for [`RoutingProfileQueueConfigSummary`](crate::model::RoutingProfileQueueConfigSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) queue_arn: std::option::Option<std::string::String>,
        pub(crate) queue_name: std::option::Option<std::string::String>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) delay: std::option::Option<i32>,
        pub(crate) channel: std::option::Option<crate::model::Channel>,
    }
    impl Builder {
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the queue.</p>
        pub fn queue_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the queue.</p>
        pub fn set_queue_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_arn = input;
            self
        }
        /// <p>The name of the queue.</p>
        pub fn queue_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_name = Some(input.into());
            self
        }
        /// <p>The name of the queue.</p>
        pub fn set_queue_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_name = input;
            self
        }
        /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The delay, in seconds, that a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn delay(mut self, input: i32) -> Self {
            self.delay = Some(input);
            self
        }
        /// <p>The delay, in seconds, that a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn set_delay(mut self, input: std::option::Option<i32>) -> Self {
            self.delay = input;
            self
        }
        /// <p>The channels this queue supports.</p>
        pub fn channel(mut self, input: crate::model::Channel) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>The channels this queue supports.</p>
        pub fn set_channel(mut self, input: std::option::Option<crate::model::Channel>) -> Self {
            self.channel = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfileQueueConfigSummary`](crate::model::RoutingProfileQueueConfigSummary).
        pub fn build(self) -> crate::model::RoutingProfileQueueConfigSummary {
            crate::model::RoutingProfileQueueConfigSummary {
                queue_id: self.queue_id,
                queue_arn: self.queue_arn,
                queue_name: self.queue_name,
                priority: self.priority.unwrap_or_default(),
                delay: self.delay.unwrap_or_default(),
                channel: self.channel,
            }
        }
    }
}
impl RoutingProfileQueueConfigSummary {
    /// Creates a new builder-style object to manufacture [`RoutingProfileQueueConfigSummary`](crate::model::RoutingProfileQueueConfigSummary).
    pub fn builder() -> crate::model::routing_profile_queue_config_summary::Builder {
        crate::model::routing_profile_queue_config_summary::Builder::default()
    }
}

/// <p>Contains summary information about a quick connect.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QuickConnectSummary {
    /// <p>The identifier for the quick connect.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the quick connect.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
    #[doc(hidden)]
    pub quick_connect_type: std::option::Option<crate::model::QuickConnectType>,
}
impl QuickConnectSummary {
    /// <p>The identifier for the quick connect.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the quick connect.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
    pub fn quick_connect_type(&self) -> std::option::Option<&crate::model::QuickConnectType> {
        self.quick_connect_type.as_ref()
    }
}
/// See [`QuickConnectSummary`](crate::model::QuickConnectSummary).
pub mod quick_connect_summary {

    /// A builder for [`QuickConnectSummary`](crate::model::QuickConnectSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) quick_connect_type: std::option::Option<crate::model::QuickConnectType>,
    }
    impl Builder {
        /// <p>The identifier for the quick connect.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the quick connect.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the quick connect.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
        pub fn quick_connect_type(mut self, input: crate::model::QuickConnectType) -> Self {
            self.quick_connect_type = Some(input);
            self
        }
        /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
        pub fn set_quick_connect_type(
            mut self,
            input: std::option::Option<crate::model::QuickConnectType>,
        ) -> Self {
            self.quick_connect_type = input;
            self
        }
        /// Consumes the builder and constructs a [`QuickConnectSummary`](crate::model::QuickConnectSummary).
        pub fn build(self) -> crate::model::QuickConnectSummary {
            crate::model::QuickConnectSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                quick_connect_type: self.quick_connect_type,
            }
        }
    }
}
impl QuickConnectSummary {
    /// Creates a new builder-style object to manufacture [`QuickConnectSummary`](crate::model::QuickConnectSummary).
    pub fn builder() -> crate::model::quick_connect_summary::Builder {
        crate::model::quick_connect_summary::Builder::default()
    }
}

/// <p>Contains summary information about a queue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueueSummary {
    /// <p>The identifier of the queue.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the queue.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of queue.</p>
    #[doc(hidden)]
    pub queue_type: std::option::Option<crate::model::QueueType>,
}
impl QueueSummary {
    /// <p>The identifier of the queue.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the queue.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of queue.</p>
    pub fn queue_type(&self) -> std::option::Option<&crate::model::QueueType> {
        self.queue_type.as_ref()
    }
}
/// See [`QueueSummary`](crate::model::QueueSummary).
pub mod queue_summary {

    /// A builder for [`QueueSummary`](crate::model::QueueSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) queue_type: std::option::Option<crate::model::QueueType>,
    }
    impl Builder {
        /// <p>The identifier of the queue.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the queue.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the queue.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the queue.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the queue.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the queue.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of queue.</p>
        pub fn queue_type(mut self, input: crate::model::QueueType) -> Self {
            self.queue_type = Some(input);
            self
        }
        /// <p>The type of queue.</p>
        pub fn set_queue_type(
            mut self,
            input: std::option::Option<crate::model::QueueType>,
        ) -> Self {
            self.queue_type = input;
            self
        }
        /// Consumes the builder and constructs a [`QueueSummary`](crate::model::QueueSummary).
        pub fn build(self) -> crate::model::QueueSummary {
            crate::model::QueueSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                queue_type: self.queue_type,
            }
        }
    }
}
impl QueueSummary {
    /// Creates a new builder-style object to manufacture [`QueueSummary`](crate::model::QueueSummary).
    pub fn builder() -> crate::model::queue_summary::Builder {
        crate::model::queue_summary::Builder::default()
    }
}

/// When writing a match expression against `QueueType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let queuetype = unimplemented!();
/// match queuetype {
///     QueueType::Agent => { /* ... */ },
///     QueueType::Standard => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `queuetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QueueType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QueueType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QueueType::NewFeature` is defined.
/// Specifically, when `queuetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QueueType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueueType {
    #[allow(missing_docs)] // documentation missing in model
    Agent,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for QueueType {
    fn from(s: &str) -> Self {
        match s {
            "AGENT" => QueueType::Agent,
            "STANDARD" => QueueType::Standard,
            other => QueueType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for QueueType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueueType::from(s))
    }
}
impl QueueType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueueType::Agent => "AGENT",
            QueueType::Standard => "STANDARD",
            QueueType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AGENT", "STANDARD"]
    }
}
impl AsRef<str> for QueueType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the prompt.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PromptSummary {
    /// <p>The identifier of the prompt.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the prompt.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the prompt.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl PromptSummary {
    /// <p>The identifier of the prompt.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the prompt.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the prompt.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`PromptSummary`](crate::model::PromptSummary).
pub mod prompt_summary {

    /// A builder for [`PromptSummary`](crate::model::PromptSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the prompt.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the prompt.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the prompt.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the prompt.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the prompt.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the prompt.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`PromptSummary`](crate::model::PromptSummary).
        pub fn build(self) -> crate::model::PromptSummary {
            crate::model::PromptSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl PromptSummary {
    /// Creates a new builder-style object to manufacture [`PromptSummary`](crate::model::PromptSummary).
    pub fn builder() -> crate::model::prompt_summary::Builder {
        crate::model::prompt_summary::Builder::default()
    }
}

/// <p>Information about phone numbers that have been claimed to your Amazon Connect instance or traffic distribution group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListPhoneNumbersSummary {
    /// <p>A unique identifier for the phone number.</p>
    #[doc(hidden)]
    pub phone_number_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
    #[doc(hidden)]
    pub phone_number_arn: std::option::Option<std::string::String>,
    /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    #[doc(hidden)]
    pub phone_number: std::option::Option<std::string::String>,
    /// <p>The ISO country code.</p>
    #[doc(hidden)]
    pub phone_number_country_code: std::option::Option<crate::model::PhoneNumberCountryCode>,
    /// <p>The type of phone number.</p>
    #[doc(hidden)]
    pub phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
    #[doc(hidden)]
    pub target_arn: std::option::Option<std::string::String>,
}
impl ListPhoneNumbersSummary {
    /// <p>A unique identifier for the phone number.</p>
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
    pub fn phone_number_arn(&self) -> std::option::Option<&str> {
        self.phone_number_arn.as_deref()
    }
    /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
    /// <p>The ISO country code.</p>
    pub fn phone_number_country_code(
        &self,
    ) -> std::option::Option<&crate::model::PhoneNumberCountryCode> {
        self.phone_number_country_code.as_ref()
    }
    /// <p>The type of phone number.</p>
    pub fn phone_number_type(&self) -> std::option::Option<&crate::model::PhoneNumberType> {
        self.phone_number_type.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
    pub fn target_arn(&self) -> std::option::Option<&str> {
        self.target_arn.as_deref()
    }
}
/// See [`ListPhoneNumbersSummary`](crate::model::ListPhoneNumbersSummary).
pub mod list_phone_numbers_summary {

    /// A builder for [`ListPhoneNumbersSummary`](crate::model::ListPhoneNumbersSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
        pub(crate) phone_number_arn: std::option::Option<std::string::String>,
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) phone_number_country_code:
            std::option::Option<crate::model::PhoneNumberCountryCode>,
        pub(crate) phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
        pub(crate) target_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for the phone number.</p>
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the phone number.</p>
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
        pub fn phone_number_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
        pub fn set_phone_number_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_arn = input;
            self
        }
        /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// <p>The ISO country code.</p>
        pub fn phone_number_country_code(
            mut self,
            input: crate::model::PhoneNumberCountryCode,
        ) -> Self {
            self.phone_number_country_code = Some(input);
            self
        }
        /// <p>The ISO country code.</p>
        pub fn set_phone_number_country_code(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberCountryCode>,
        ) -> Self {
            self.phone_number_country_code = input;
            self
        }
        /// <p>The type of phone number.</p>
        pub fn phone_number_type(mut self, input: crate::model::PhoneNumberType) -> Self {
            self.phone_number_type = Some(input);
            self
        }
        /// <p>The type of phone number.</p>
        pub fn set_phone_number_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberType>,
        ) -> Self {
            self.phone_number_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPhoneNumbersSummary`](crate::model::ListPhoneNumbersSummary).
        pub fn build(self) -> crate::model::ListPhoneNumbersSummary {
            crate::model::ListPhoneNumbersSummary {
                phone_number_id: self.phone_number_id,
                phone_number_arn: self.phone_number_arn,
                phone_number: self.phone_number,
                phone_number_country_code: self.phone_number_country_code,
                phone_number_type: self.phone_number_type,
                target_arn: self.target_arn,
            }
        }
    }
}
impl ListPhoneNumbersSummary {
    /// Creates a new builder-style object to manufacture [`ListPhoneNumbersSummary`](crate::model::ListPhoneNumbersSummary).
    pub fn builder() -> crate::model::list_phone_numbers_summary::Builder {
        crate::model::list_phone_numbers_summary::Builder::default()
    }
}

/// <p>Contains summary information about a phone number for a contact center.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PhoneNumberSummary {
    /// <p>The identifier of the phone number.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The phone number.</p>
    #[doc(hidden)]
    pub phone_number: std::option::Option<std::string::String>,
    /// <p>The type of phone number.</p>
    #[doc(hidden)]
    pub phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
    /// <p>The ISO country code.</p>
    #[doc(hidden)]
    pub phone_number_country_code: std::option::Option<crate::model::PhoneNumberCountryCode>,
}
impl PhoneNumberSummary {
    /// <p>The identifier of the phone number.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The phone number.</p>
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
    /// <p>The type of phone number.</p>
    pub fn phone_number_type(&self) -> std::option::Option<&crate::model::PhoneNumberType> {
        self.phone_number_type.as_ref()
    }
    /// <p>The ISO country code.</p>
    pub fn phone_number_country_code(
        &self,
    ) -> std::option::Option<&crate::model::PhoneNumberCountryCode> {
        self.phone_number_country_code.as_ref()
    }
}
/// See [`PhoneNumberSummary`](crate::model::PhoneNumberSummary).
pub mod phone_number_summary {

    /// A builder for [`PhoneNumberSummary`](crate::model::PhoneNumberSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
        pub(crate) phone_number_country_code:
            std::option::Option<crate::model::PhoneNumberCountryCode>,
    }
    impl Builder {
        /// <p>The identifier of the phone number.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the phone number.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The phone number.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>The phone number.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// <p>The type of phone number.</p>
        pub fn phone_number_type(mut self, input: crate::model::PhoneNumberType) -> Self {
            self.phone_number_type = Some(input);
            self
        }
        /// <p>The type of phone number.</p>
        pub fn set_phone_number_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberType>,
        ) -> Self {
            self.phone_number_type = input;
            self
        }
        /// <p>The ISO country code.</p>
        pub fn phone_number_country_code(
            mut self,
            input: crate::model::PhoneNumberCountryCode,
        ) -> Self {
            self.phone_number_country_code = Some(input);
            self
        }
        /// <p>The ISO country code.</p>
        pub fn set_phone_number_country_code(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberCountryCode>,
        ) -> Self {
            self.phone_number_country_code = input;
            self
        }
        /// Consumes the builder and constructs a [`PhoneNumberSummary`](crate::model::PhoneNumberSummary).
        pub fn build(self) -> crate::model::PhoneNumberSummary {
            crate::model::PhoneNumberSummary {
                id: self.id,
                arn: self.arn,
                phone_number: self.phone_number,
                phone_number_type: self.phone_number_type,
                phone_number_country_code: self.phone_number_country_code,
            }
        }
    }
}
impl PhoneNumberSummary {
    /// Creates a new builder-style object to manufacture [`PhoneNumberSummary`](crate::model::PhoneNumberSummary).
    pub fn builder() -> crate::model::phone_number_summary::Builder {
        crate::model::phone_number_summary::Builder::default()
    }
}

/// <p>Configuration information of an Amazon Lex bot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LexBot {
    /// <p>The name of the Amazon Lex bot.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region where the Amazon Lex bot was created.</p>
    #[doc(hidden)]
    pub lex_region: std::option::Option<std::string::String>,
}
impl LexBot {
    /// <p>The name of the Amazon Lex bot.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Web Services Region where the Amazon Lex bot was created.</p>
    pub fn lex_region(&self) -> std::option::Option<&str> {
        self.lex_region.as_deref()
    }
}
/// See [`LexBot`](crate::model::LexBot).
pub mod lex_bot {

    /// A builder for [`LexBot`](crate::model::LexBot).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) lex_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon Lex bot.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Lex bot.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Web Services Region where the Amazon Lex bot was created.</p>
        pub fn lex_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.lex_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region where the Amazon Lex bot was created.</p>
        pub fn set_lex_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lex_region = input;
            self
        }
        /// Consumes the builder and constructs a [`LexBot`](crate::model::LexBot).
        pub fn build(self) -> crate::model::LexBot {
            crate::model::LexBot {
                name: self.name,
                lex_region: self.lex_region,
            }
        }
    }
}
impl LexBot {
    /// Creates a new builder-style object to manufacture [`LexBot`](crate::model::LexBot).
    pub fn builder() -> crate::model::lex_bot::Builder {
        crate::model::lex_bot::Builder::default()
    }
}

/// <p>Contains summary information about the associated AppIntegrations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IntegrationAssociationSummary {
    /// <p>The identifier for the AppIntegration association.</p>
    #[doc(hidden)]
    pub integration_association_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the AppIntegration association.</p>
    #[doc(hidden)]
    pub integration_association_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The integration type.</p>
    #[doc(hidden)]
    pub integration_type: std::option::Option<crate::model::IntegrationType>,
    /// <p>The Amazon Resource Name (ARN) for the AppIntegration.</p>
    #[doc(hidden)]
    pub integration_arn: std::option::Option<std::string::String>,
    /// <p>The URL for the external application.</p>
    #[doc(hidden)]
    pub source_application_url: std::option::Option<std::string::String>,
    /// <p>The user-provided, friendly name for the external application.</p>
    #[doc(hidden)]
    pub source_application_name: std::option::Option<std::string::String>,
    /// <p>The name of the source.</p>
    #[doc(hidden)]
    pub source_type: std::option::Option<crate::model::SourceType>,
}
impl IntegrationAssociationSummary {
    /// <p>The identifier for the AppIntegration association.</p>
    pub fn integration_association_id(&self) -> std::option::Option<&str> {
        self.integration_association_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the AppIntegration association.</p>
    pub fn integration_association_arn(&self) -> std::option::Option<&str> {
        self.integration_association_arn.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The integration type.</p>
    pub fn integration_type(&self) -> std::option::Option<&crate::model::IntegrationType> {
        self.integration_type.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) for the AppIntegration.</p>
    pub fn integration_arn(&self) -> std::option::Option<&str> {
        self.integration_arn.as_deref()
    }
    /// <p>The URL for the external application.</p>
    pub fn source_application_url(&self) -> std::option::Option<&str> {
        self.source_application_url.as_deref()
    }
    /// <p>The user-provided, friendly name for the external application.</p>
    pub fn source_application_name(&self) -> std::option::Option<&str> {
        self.source_application_name.as_deref()
    }
    /// <p>The name of the source.</p>
    pub fn source_type(&self) -> std::option::Option<&crate::model::SourceType> {
        self.source_type.as_ref()
    }
}
/// See [`IntegrationAssociationSummary`](crate::model::IntegrationAssociationSummary).
pub mod integration_association_summary {

    /// A builder for [`IntegrationAssociationSummary`](crate::model::IntegrationAssociationSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) integration_association_id: std::option::Option<std::string::String>,
        pub(crate) integration_association_arn: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) integration_type: std::option::Option<crate::model::IntegrationType>,
        pub(crate) integration_arn: std::option::Option<std::string::String>,
        pub(crate) source_application_url: std::option::Option<std::string::String>,
        pub(crate) source_application_name: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<crate::model::SourceType>,
    }
    impl Builder {
        /// <p>The identifier for the AppIntegration association.</p>
        pub fn integration_association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.integration_association_id = Some(input.into());
            self
        }
        /// <p>The identifier for the AppIntegration association.</p>
        pub fn set_integration_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.integration_association_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the AppIntegration association.</p>
        pub fn integration_association_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.integration_association_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the AppIntegration association.</p>
        pub fn set_integration_association_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.integration_association_arn = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The integration type.</p>
        pub fn integration_type(mut self, input: crate::model::IntegrationType) -> Self {
            self.integration_type = Some(input);
            self
        }
        /// <p>The integration type.</p>
        pub fn set_integration_type(
            mut self,
            input: std::option::Option<crate::model::IntegrationType>,
        ) -> Self {
            self.integration_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the AppIntegration.</p>
        pub fn integration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.integration_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the AppIntegration.</p>
        pub fn set_integration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.integration_arn = input;
            self
        }
        /// <p>The URL for the external application.</p>
        pub fn source_application_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_application_url = Some(input.into());
            self
        }
        /// <p>The URL for the external application.</p>
        pub fn set_source_application_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_application_url = input;
            self
        }
        /// <p>The user-provided, friendly name for the external application.</p>
        pub fn source_application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_application_name = Some(input.into());
            self
        }
        /// <p>The user-provided, friendly name for the external application.</p>
        pub fn set_source_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_application_name = input;
            self
        }
        /// <p>The name of the source.</p>
        pub fn source_type(mut self, input: crate::model::SourceType) -> Self {
            self.source_type = Some(input);
            self
        }
        /// <p>The name of the source.</p>
        pub fn set_source_type(
            mut self,
            input: std::option::Option<crate::model::SourceType>,
        ) -> Self {
            self.source_type = input;
            self
        }
        /// Consumes the builder and constructs a [`IntegrationAssociationSummary`](crate::model::IntegrationAssociationSummary).
        pub fn build(self) -> crate::model::IntegrationAssociationSummary {
            crate::model::IntegrationAssociationSummary {
                integration_association_id: self.integration_association_id,
                integration_association_arn: self.integration_association_arn,
                instance_id: self.instance_id,
                integration_type: self.integration_type,
                integration_arn: self.integration_arn,
                source_application_url: self.source_application_url,
                source_application_name: self.source_application_name,
                source_type: self.source_type,
            }
        }
    }
}
impl IntegrationAssociationSummary {
    /// Creates a new builder-style object to manufacture [`IntegrationAssociationSummary`](crate::model::IntegrationAssociationSummary).
    pub fn builder() -> crate::model::integration_association_summary::Builder {
        crate::model::integration_association_summary::Builder::default()
    }
}

/// When writing a match expression against `SourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sourcetype = unimplemented!();
/// match sourcetype {
///     SourceType::Salesforce => { /* ... */ },
///     SourceType::Zendesk => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SourceType::NewFeature` is defined.
/// Specifically, when `sourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SourceType {
    #[allow(missing_docs)] // documentation missing in model
    Salesforce,
    #[allow(missing_docs)] // documentation missing in model
    Zendesk,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SourceType {
    fn from(s: &str) -> Self {
        match s {
            "SALESFORCE" => SourceType::Salesforce,
            "ZENDESK" => SourceType::Zendesk,
            other => SourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SourceType::from(s))
    }
}
impl SourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SourceType::Salesforce => "SALESFORCE",
            SourceType::Zendesk => "ZENDESK",
            SourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SALESFORCE", "ZENDESK"]
    }
}
impl AsRef<str> for SourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `IntegrationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let integrationtype = unimplemented!();
/// match integrationtype {
///     IntegrationType::CasesDomain => { /* ... */ },
///     IntegrationType::Event => { /* ... */ },
///     IntegrationType::PinpointApp => { /* ... */ },
///     IntegrationType::VoiceId => { /* ... */ },
///     IntegrationType::WisdomAssistant => { /* ... */ },
///     IntegrationType::WisdomKnowledgeBase => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `integrationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IntegrationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IntegrationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IntegrationType::NewFeature` is defined.
/// Specifically, when `integrationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IntegrationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IntegrationType {
    #[allow(missing_docs)] // documentation missing in model
    CasesDomain,
    #[allow(missing_docs)] // documentation missing in model
    Event,
    #[allow(missing_docs)] // documentation missing in model
    PinpointApp,
    #[allow(missing_docs)] // documentation missing in model
    VoiceId,
    #[allow(missing_docs)] // documentation missing in model
    WisdomAssistant,
    #[allow(missing_docs)] // documentation missing in model
    WisdomKnowledgeBase,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IntegrationType {
    fn from(s: &str) -> Self {
        match s {
            "CASES_DOMAIN" => IntegrationType::CasesDomain,
            "EVENT" => IntegrationType::Event,
            "PINPOINT_APP" => IntegrationType::PinpointApp,
            "VOICE_ID" => IntegrationType::VoiceId,
            "WISDOM_ASSISTANT" => IntegrationType::WisdomAssistant,
            "WISDOM_KNOWLEDGE_BASE" => IntegrationType::WisdomKnowledgeBase,
            other => IntegrationType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for IntegrationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IntegrationType::from(s))
    }
}
impl IntegrationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IntegrationType::CasesDomain => "CASES_DOMAIN",
            IntegrationType::Event => "EVENT",
            IntegrationType::PinpointApp => "PINPOINT_APP",
            IntegrationType::VoiceId => "VOICE_ID",
            IntegrationType::WisdomAssistant => "WISDOM_ASSISTANT",
            IntegrationType::WisdomKnowledgeBase => "WISDOM_KNOWLEDGE_BASE",
            IntegrationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CASES_DOMAIN",
            "EVENT",
            "PINPOINT_APP",
            "VOICE_ID",
            "WISDOM_ASSISTANT",
            "WISDOM_KNOWLEDGE_BASE",
        ]
    }
}
impl AsRef<str> for IntegrationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceSummary {
    /// <p>The identifier of the instance.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the instance.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The identity management type of the instance.</p>
    #[doc(hidden)]
    pub identity_management_type: std::option::Option<crate::model::DirectoryType>,
    /// <p>The alias of the instance.</p>
    #[doc(hidden)]
    pub instance_alias: std::option::Option<std::string::String>,
    /// <p>When the instance was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The service role of the instance.</p>
    #[doc(hidden)]
    pub service_role: std::option::Option<std::string::String>,
    /// <p>The state of the instance.</p>
    #[doc(hidden)]
    pub instance_status: std::option::Option<crate::model::InstanceStatus>,
    /// <p>Whether inbound calls are enabled.</p>
    #[doc(hidden)]
    pub inbound_calls_enabled: std::option::Option<bool>,
    /// <p>Whether outbound calls are enabled.</p>
    #[doc(hidden)]
    pub outbound_calls_enabled: std::option::Option<bool>,
}
impl InstanceSummary {
    /// <p>The identifier of the instance.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the instance.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The identity management type of the instance.</p>
    pub fn identity_management_type(&self) -> std::option::Option<&crate::model::DirectoryType> {
        self.identity_management_type.as_ref()
    }
    /// <p>The alias of the instance.</p>
    pub fn instance_alias(&self) -> std::option::Option<&str> {
        self.instance_alias.as_deref()
    }
    /// <p>When the instance was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The service role of the instance.</p>
    pub fn service_role(&self) -> std::option::Option<&str> {
        self.service_role.as_deref()
    }
    /// <p>The state of the instance.</p>
    pub fn instance_status(&self) -> std::option::Option<&crate::model::InstanceStatus> {
        self.instance_status.as_ref()
    }
    /// <p>Whether inbound calls are enabled.</p>
    pub fn inbound_calls_enabled(&self) -> std::option::Option<bool> {
        self.inbound_calls_enabled
    }
    /// <p>Whether outbound calls are enabled.</p>
    pub fn outbound_calls_enabled(&self) -> std::option::Option<bool> {
        self.outbound_calls_enabled
    }
}
impl std::fmt::Debug for InstanceSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("identity_management_type", &self.identity_management_type);
        formatter.field("instance_alias", &"*** Sensitive Data Redacted ***");
        formatter.field("created_time", &self.created_time);
        formatter.field("service_role", &self.service_role);
        formatter.field("instance_status", &self.instance_status);
        formatter.field("inbound_calls_enabled", &self.inbound_calls_enabled);
        formatter.field("outbound_calls_enabled", &self.outbound_calls_enabled);
        formatter.finish()
    }
}
/// See [`InstanceSummary`](crate::model::InstanceSummary).
pub mod instance_summary {

    /// A builder for [`InstanceSummary`](crate::model::InstanceSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) identity_management_type: std::option::Option<crate::model::DirectoryType>,
        pub(crate) instance_alias: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) service_role: std::option::Option<std::string::String>,
        pub(crate) instance_status: std::option::Option<crate::model::InstanceStatus>,
        pub(crate) inbound_calls_enabled: std::option::Option<bool>,
        pub(crate) outbound_calls_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The identifier of the instance.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the instance.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the instance.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the instance.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The identity management type of the instance.</p>
        pub fn identity_management_type(mut self, input: crate::model::DirectoryType) -> Self {
            self.identity_management_type = Some(input);
            self
        }
        /// <p>The identity management type of the instance.</p>
        pub fn set_identity_management_type(
            mut self,
            input: std::option::Option<crate::model::DirectoryType>,
        ) -> Self {
            self.identity_management_type = input;
            self
        }
        /// <p>The alias of the instance.</p>
        pub fn instance_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_alias = Some(input.into());
            self
        }
        /// <p>The alias of the instance.</p>
        pub fn set_instance_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_alias = input;
            self
        }
        /// <p>When the instance was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>When the instance was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The service role of the instance.</p>
        pub fn service_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_role = Some(input.into());
            self
        }
        /// <p>The service role of the instance.</p>
        pub fn set_service_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_role = input;
            self
        }
        /// <p>The state of the instance.</p>
        pub fn instance_status(mut self, input: crate::model::InstanceStatus) -> Self {
            self.instance_status = Some(input);
            self
        }
        /// <p>The state of the instance.</p>
        pub fn set_instance_status(
            mut self,
            input: std::option::Option<crate::model::InstanceStatus>,
        ) -> Self {
            self.instance_status = input;
            self
        }
        /// <p>Whether inbound calls are enabled.</p>
        pub fn inbound_calls_enabled(mut self, input: bool) -> Self {
            self.inbound_calls_enabled = Some(input);
            self
        }
        /// <p>Whether inbound calls are enabled.</p>
        pub fn set_inbound_calls_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inbound_calls_enabled = input;
            self
        }
        /// <p>Whether outbound calls are enabled.</p>
        pub fn outbound_calls_enabled(mut self, input: bool) -> Self {
            self.outbound_calls_enabled = Some(input);
            self
        }
        /// <p>Whether outbound calls are enabled.</p>
        pub fn set_outbound_calls_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.outbound_calls_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceSummary`](crate::model::InstanceSummary).
        pub fn build(self) -> crate::model::InstanceSummary {
            crate::model::InstanceSummary {
                id: self.id,
                arn: self.arn,
                identity_management_type: self.identity_management_type,
                instance_alias: self.instance_alias,
                created_time: self.created_time,
                service_role: self.service_role,
                instance_status: self.instance_status,
                inbound_calls_enabled: self.inbound_calls_enabled,
                outbound_calls_enabled: self.outbound_calls_enabled,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("id", &self.id);
            formatter.field("arn", &self.arn);
            formatter.field("identity_management_type", &self.identity_management_type);
            formatter.field("instance_alias", &"*** Sensitive Data Redacted ***");
            formatter.field("created_time", &self.created_time);
            formatter.field("service_role", &self.service_role);
            formatter.field("instance_status", &self.instance_status);
            formatter.field("inbound_calls_enabled", &self.inbound_calls_enabled);
            formatter.field("outbound_calls_enabled", &self.outbound_calls_enabled);
            formatter.finish()
        }
    }
}
impl InstanceSummary {
    /// Creates a new builder-style object to manufacture [`InstanceSummary`](crate::model::InstanceSummary).
    pub fn builder() -> crate::model::instance_summary::Builder {
        crate::model::instance_summary::Builder::default()
    }
}

/// When writing a match expression against `InstanceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let instancestatus = unimplemented!();
/// match instancestatus {
///     InstanceStatus::Active => { /* ... */ },
///     InstanceStatus::CreationFailed => { /* ... */ },
///     InstanceStatus::CreationInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `instancestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InstanceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InstanceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InstanceStatus::NewFeature` is defined.
/// Specifically, when `instancestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InstanceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    CreationFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreationInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InstanceStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => InstanceStatus::Active,
            "CREATION_FAILED" => InstanceStatus::CreationFailed,
            "CREATION_IN_PROGRESS" => InstanceStatus::CreationInProgress,
            other => InstanceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for InstanceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceStatus::from(s))
    }
}
impl InstanceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InstanceStatus::Active => "ACTIVE",
            InstanceStatus::CreationFailed => "CREATION_FAILED",
            InstanceStatus::CreationInProgress => "CREATION_IN_PROGRESS",
            InstanceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATION_FAILED", "CREATION_IN_PROGRESS"]
    }
}
impl AsRef<str> for InstanceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DirectoryType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let directorytype = unimplemented!();
/// match directorytype {
///     DirectoryType::ConnectManaged => { /* ... */ },
///     DirectoryType::ExistingDirectory => { /* ... */ },
///     DirectoryType::Saml => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `directorytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DirectoryType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DirectoryType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DirectoryType::NewFeature` is defined.
/// Specifically, when `directorytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DirectoryType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DirectoryType {
    #[allow(missing_docs)] // documentation missing in model
    ConnectManaged,
    #[allow(missing_docs)] // documentation missing in model
    ExistingDirectory,
    #[allow(missing_docs)] // documentation missing in model
    Saml,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DirectoryType {
    fn from(s: &str) -> Self {
        match s {
            "CONNECT_MANAGED" => DirectoryType::ConnectManaged,
            "EXISTING_DIRECTORY" => DirectoryType::ExistingDirectory,
            "SAML" => DirectoryType::Saml,
            other => DirectoryType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DirectoryType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DirectoryType::from(s))
    }
}
impl DirectoryType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DirectoryType::ConnectManaged => "CONNECT_MANAGED",
            DirectoryType::ExistingDirectory => "EXISTING_DIRECTORY",
            DirectoryType::Saml => "SAML",
            DirectoryType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CONNECT_MANAGED", "EXISTING_DIRECTORY", "SAML"]
    }
}
impl AsRef<str> for DirectoryType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A toggle for an individual feature at the instance level.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Attribute {
    /// <p>The type of attribute.</p>
    #[doc(hidden)]
    pub attribute_type: std::option::Option<crate::model::InstanceAttributeType>,
    /// <p>The value of the attribute.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Attribute {
    /// <p>The type of attribute.</p>
    pub fn attribute_type(&self) -> std::option::Option<&crate::model::InstanceAttributeType> {
        self.attribute_type.as_ref()
    }
    /// <p>The value of the attribute.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Attribute`](crate::model::Attribute).
pub mod attribute {

    /// A builder for [`Attribute`](crate::model::Attribute).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_type: std::option::Option<crate::model::InstanceAttributeType>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of attribute.</p>
        pub fn attribute_type(mut self, input: crate::model::InstanceAttributeType) -> Self {
            self.attribute_type = Some(input);
            self
        }
        /// <p>The type of attribute.</p>
        pub fn set_attribute_type(
            mut self,
            input: std::option::Option<crate::model::InstanceAttributeType>,
        ) -> Self {
            self.attribute_type = input;
            self
        }
        /// <p>The value of the attribute.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the attribute.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Attribute`](crate::model::Attribute).
        pub fn build(self) -> crate::model::Attribute {
            crate::model::Attribute {
                attribute_type: self.attribute_type,
                value: self.value,
            }
        }
    }
}
impl Attribute {
    /// Creates a new builder-style object to manufacture [`Attribute`](crate::model::Attribute).
    pub fn builder() -> crate::model::attribute::Builder {
        crate::model::attribute::Builder::default()
    }
}

/// <p>Contains summary information about hours of operation for a contact center.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HoursOfOperationSummary {
    /// <p>The identifier of the hours of operation.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the hours of operation.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the hours of operation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl HoursOfOperationSummary {
    /// <p>The identifier of the hours of operation.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the hours of operation.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the hours of operation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`HoursOfOperationSummary`](crate::model::HoursOfOperationSummary).
pub mod hours_of_operation_summary {

    /// A builder for [`HoursOfOperationSummary`](crate::model::HoursOfOperationSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the hours of operation.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the hours of operation.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hours of operation.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hours of operation.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the hours of operation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hours of operation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`HoursOfOperationSummary`](crate::model::HoursOfOperationSummary).
        pub fn build(self) -> crate::model::HoursOfOperationSummary {
            crate::model::HoursOfOperationSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl HoursOfOperationSummary {
    /// Creates a new builder-style object to manufacture [`HoursOfOperationSummary`](crate::model::HoursOfOperationSummary).
    pub fn builder() -> crate::model::hours_of_operation_summary::Builder {
        crate::model::hours_of_operation_summary::Builder::default()
    }
}

/// <p>Contains information about a default vocabulary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultVocabulary {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
    /// <p>The identifier of the custom vocabulary.</p>
    #[doc(hidden)]
    pub vocabulary_id: std::option::Option<std::string::String>,
    /// <p>A unique name of the custom vocabulary.</p>
    #[doc(hidden)]
    pub vocabulary_name: std::option::Option<std::string::String>,
}
impl DefaultVocabulary {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::VocabularyLanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The identifier of the custom vocabulary.</p>
    pub fn vocabulary_id(&self) -> std::option::Option<&str> {
        self.vocabulary_id.as_deref()
    }
    /// <p>A unique name of the custom vocabulary.</p>
    pub fn vocabulary_name(&self) -> std::option::Option<&str> {
        self.vocabulary_name.as_deref()
    }
}
/// See [`DefaultVocabulary`](crate::model::DefaultVocabulary).
pub mod default_vocabulary {

    /// A builder for [`DefaultVocabulary`](crate::model::DefaultVocabulary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
        pub(crate) vocabulary_id: std::option::Option<std::string::String>,
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn language_code(mut self, input: crate::model::VocabularyLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::VocabularyLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn vocabulary_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_id = Some(input.into());
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn set_vocabulary_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_id = input;
            self
        }
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultVocabulary`](crate::model::DefaultVocabulary).
        pub fn build(self) -> crate::model::DefaultVocabulary {
            crate::model::DefaultVocabulary {
                instance_id: self.instance_id,
                language_code: self.language_code,
                vocabulary_id: self.vocabulary_id,
                vocabulary_name: self.vocabulary_name,
            }
        }
    }
}
impl DefaultVocabulary {
    /// Creates a new builder-style object to manufacture [`DefaultVocabulary`](crate::model::DefaultVocabulary).
    pub fn builder() -> crate::model::default_vocabulary::Builder {
        crate::model::default_vocabulary::Builder::default()
    }
}

/// <p>Contains summary information about a reference. <code>ReferenceSummary</code> contains only one non null field between the URL and attachment based on the reference type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ReferenceSummary {
    /// <p>Information about the reference when the <code>referenceType</code> is <code>ATTACHMENT</code>. Otherwise, null.</p>
    Attachment(crate::model::AttachmentReference),
    /// <p>Information about a reference when the <code>referenceType</code> is <code>DATE</code>. Otherwise, null.</p>
    Date(crate::model::DateReference),
    /// <p>Information about a reference when the <code>referenceType</code> is <code>EMAIL</code>. Otherwise, null.</p>
    Email(crate::model::EmailReference),
    /// <p>Information about a reference when the <code>referenceType</code> is <code>NUMBER</code>. Otherwise, null.</p>
    Number(crate::model::NumberReference),
    /// <p>Information about a reference when the <code>referenceType</code> is <code>STRING</code>. Otherwise, null.</p>
    String(crate::model::StringReference),
    /// <p>Information about the reference when the <code>referenceType</code> is <code>URL</code>. Otherwise, null.</p>
    Url(crate::model::UrlReference),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ReferenceSummary {
    /// Tries to convert the enum instance into [`Attachment`](crate::model::ReferenceSummary::Attachment), extracting the inner [`AttachmentReference`](crate::model::AttachmentReference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_attachment(&self) -> std::result::Result<&crate::model::AttachmentReference, &Self> {
        if let ReferenceSummary::Attachment(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Attachment`](crate::model::ReferenceSummary::Attachment).
    pub fn is_attachment(&self) -> bool {
        self.as_attachment().is_ok()
    }
    /// Tries to convert the enum instance into [`Date`](crate::model::ReferenceSummary::Date), extracting the inner [`DateReference`](crate::model::DateReference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_date(&self) -> std::result::Result<&crate::model::DateReference, &Self> {
        if let ReferenceSummary::Date(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Date`](crate::model::ReferenceSummary::Date).
    pub fn is_date(&self) -> bool {
        self.as_date().is_ok()
    }
    /// Tries to convert the enum instance into [`Email`](crate::model::ReferenceSummary::Email), extracting the inner [`EmailReference`](crate::model::EmailReference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_email(&self) -> std::result::Result<&crate::model::EmailReference, &Self> {
        if let ReferenceSummary::Email(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Email`](crate::model::ReferenceSummary::Email).
    pub fn is_email(&self) -> bool {
        self.as_email().is_ok()
    }
    /// Tries to convert the enum instance into [`Number`](crate::model::ReferenceSummary::Number), extracting the inner [`NumberReference`](crate::model::NumberReference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_number(&self) -> std::result::Result<&crate::model::NumberReference, &Self> {
        if let ReferenceSummary::Number(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Number`](crate::model::ReferenceSummary::Number).
    pub fn is_number(&self) -> bool {
        self.as_number().is_ok()
    }
    /// Tries to convert the enum instance into [`String`](crate::model::ReferenceSummary::String), extracting the inner [`StringReference`](crate::model::StringReference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_string(&self) -> std::result::Result<&crate::model::StringReference, &Self> {
        if let ReferenceSummary::String(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`String`](crate::model::ReferenceSummary::String).
    pub fn is_string(&self) -> bool {
        self.as_string().is_ok()
    }
    /// Tries to convert the enum instance into [`Url`](crate::model::ReferenceSummary::Url), extracting the inner [`UrlReference`](crate::model::UrlReference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_url(&self) -> std::result::Result<&crate::model::UrlReference, &Self> {
        if let ReferenceSummary::Url(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Url`](crate::model::ReferenceSummary::Url).
    pub fn is_url(&self) -> bool {
        self.as_url().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Information about a reference when the <code>referenceType</code> is <code>EMAIL</code>. Otherwise, null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EmailReference {
    /// <p>Identifier of the email reference.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A valid email address.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl EmailReference {
    /// <p>Identifier of the email reference.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A valid email address.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`EmailReference`](crate::model::EmailReference).
pub mod email_reference {

    /// A builder for [`EmailReference`](crate::model::EmailReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifier of the email reference.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Identifier of the email reference.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A valid email address.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A valid email address.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`EmailReference`](crate::model::EmailReference).
        pub fn build(self) -> crate::model::EmailReference {
            crate::model::EmailReference {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl EmailReference {
    /// Creates a new builder-style object to manufacture [`EmailReference`](crate::model::EmailReference).
    pub fn builder() -> crate::model::email_reference::Builder {
        crate::model::email_reference::Builder::default()
    }
}

/// <p>Information about a reference when the <code>referenceType</code> is <code>DATE</code>. Otherwise, null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DateReference {
    /// <p>Identifier of the date reference.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A valid date.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl DateReference {
    /// <p>Identifier of the date reference.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A valid date.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`DateReference`](crate::model::DateReference).
pub mod date_reference {

    /// A builder for [`DateReference`](crate::model::DateReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifier of the date reference.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Identifier of the date reference.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A valid date.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A valid date.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`DateReference`](crate::model::DateReference).
        pub fn build(self) -> crate::model::DateReference {
            crate::model::DateReference {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl DateReference {
    /// Creates a new builder-style object to manufacture [`DateReference`](crate::model::DateReference).
    pub fn builder() -> crate::model::date_reference::Builder {
        crate::model::date_reference::Builder::default()
    }
}

/// <p>Information about a reference when the <code>referenceType</code> is <code>NUMBER</code>. Otherwise, null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumberReference {
    /// <p>Identifier of the number reference.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A valid number.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl NumberReference {
    /// <p>Identifier of the number reference.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A valid number.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`NumberReference`](crate::model::NumberReference).
pub mod number_reference {

    /// A builder for [`NumberReference`](crate::model::NumberReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifier of the number reference.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Identifier of the number reference.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A valid number.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A valid number.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`NumberReference`](crate::model::NumberReference).
        pub fn build(self) -> crate::model::NumberReference {
            crate::model::NumberReference {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl NumberReference {
    /// Creates a new builder-style object to manufacture [`NumberReference`](crate::model::NumberReference).
    pub fn builder() -> crate::model::number_reference::Builder {
        crate::model::number_reference::Builder::default()
    }
}

/// <p>Information about a reference when the <code>referenceType</code> is <code>STRING</code>. Otherwise, null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StringReference {
    /// <p>Identifier of the string reference.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A valid string.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl StringReference {
    /// <p>Identifier of the string reference.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A valid string.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`StringReference`](crate::model::StringReference).
pub mod string_reference {

    /// A builder for [`StringReference`](crate::model::StringReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifier of the string reference.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Identifier of the string reference.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A valid string.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A valid string.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`StringReference`](crate::model::StringReference).
        pub fn build(self) -> crate::model::StringReference {
            crate::model::StringReference {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl StringReference {
    /// Creates a new builder-style object to manufacture [`StringReference`](crate::model::StringReference).
    pub fn builder() -> crate::model::string_reference::Builder {
        crate::model::string_reference::Builder::default()
    }
}

/// <p>Information about a reference when the <code>referenceType</code> is <code>ATTACHMENT</code>. Otherwise, null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AttachmentReference {
    /// <p>Identifier of the attachment reference.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The location path of the attachment reference.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>Status of the attachment reference type.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReferenceStatus>,
}
impl AttachmentReference {
    /// <p>Identifier of the attachment reference.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The location path of the attachment reference.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>Status of the attachment reference type.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReferenceStatus> {
        self.status.as_ref()
    }
}
/// See [`AttachmentReference`](crate::model::AttachmentReference).
pub mod attachment_reference {

    /// A builder for [`AttachmentReference`](crate::model::AttachmentReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ReferenceStatus>,
    }
    impl Builder {
        /// <p>Identifier of the attachment reference.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Identifier of the attachment reference.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The location path of the attachment reference.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The location path of the attachment reference.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>Status of the attachment reference type.</p>
        pub fn status(mut self, input: crate::model::ReferenceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status of the attachment reference type.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReferenceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachmentReference`](crate::model::AttachmentReference).
        pub fn build(self) -> crate::model::AttachmentReference {
            crate::model::AttachmentReference {
                name: self.name,
                value: self.value,
                status: self.status,
            }
        }
    }
}
impl AttachmentReference {
    /// Creates a new builder-style object to manufacture [`AttachmentReference`](crate::model::AttachmentReference).
    pub fn builder() -> crate::model::attachment_reference::Builder {
        crate::model::attachment_reference::Builder::default()
    }
}

/// When writing a match expression against `ReferenceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let referencestatus = unimplemented!();
/// match referencestatus {
///     ReferenceStatus::Approved => { /* ... */ },
///     ReferenceStatus::Rejected => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `referencestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReferenceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReferenceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReferenceStatus::NewFeature` is defined.
/// Specifically, when `referencestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReferenceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReferenceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Approved,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReferenceStatus {
    fn from(s: &str) -> Self {
        match s {
            "APPROVED" => ReferenceStatus::Approved,
            "REJECTED" => ReferenceStatus::Rejected,
            other => ReferenceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ReferenceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReferenceStatus::from(s))
    }
}
impl ReferenceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReferenceStatus::Approved => "APPROVED",
            ReferenceStatus::Rejected => "REJECTED",
            ReferenceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["APPROVED", "REJECTED"]
    }
}
impl AsRef<str> for ReferenceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The URL reference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UrlReference {
    /// <p>Identifier of the URL reference.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A valid URL.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl UrlReference {
    /// <p>Identifier of the URL reference.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A valid URL.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`UrlReference`](crate::model::UrlReference).
pub mod url_reference {

    /// A builder for [`UrlReference`](crate::model::UrlReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifier of the URL reference.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Identifier of the URL reference.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A valid URL.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A valid URL.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`UrlReference`](crate::model::UrlReference).
        pub fn build(self) -> crate::model::UrlReference {
            crate::model::UrlReference {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl UrlReference {
    /// Creates a new builder-style object to manufacture [`UrlReference`](crate::model::UrlReference).
    pub fn builder() -> crate::model::url_reference::Builder {
        crate::model::url_reference::Builder::default()
    }
}

/// <p>Contains summary information about a flow.</p>
/// <p>You can also create and update flows using the <a href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language.html">Amazon Connect Flow language</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContactFlowSummary {
    /// <p>The identifier of the flow.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the flow.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the flow.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of flow.</p>
    #[doc(hidden)]
    pub contact_flow_type: std::option::Option<crate::model::ContactFlowType>,
    /// <p>The type of flow.</p>
    #[doc(hidden)]
    pub contact_flow_state: std::option::Option<crate::model::ContactFlowState>,
}
impl ContactFlowSummary {
    /// <p>The identifier of the flow.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the flow.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the flow.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of flow.</p>
    pub fn contact_flow_type(&self) -> std::option::Option<&crate::model::ContactFlowType> {
        self.contact_flow_type.as_ref()
    }
    /// <p>The type of flow.</p>
    pub fn contact_flow_state(&self) -> std::option::Option<&crate::model::ContactFlowState> {
        self.contact_flow_state.as_ref()
    }
}
/// See [`ContactFlowSummary`](crate::model::ContactFlowSummary).
pub mod contact_flow_summary {

    /// A builder for [`ContactFlowSummary`](crate::model::ContactFlowSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) contact_flow_type: std::option::Option<crate::model::ContactFlowType>,
        pub(crate) contact_flow_state: std::option::Option<crate::model::ContactFlowState>,
    }
    impl Builder {
        /// <p>The identifier of the flow.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the flow.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the flow.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the flow.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the flow.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of flow.</p>
        pub fn contact_flow_type(mut self, input: crate::model::ContactFlowType) -> Self {
            self.contact_flow_type = Some(input);
            self
        }
        /// <p>The type of flow.</p>
        pub fn set_contact_flow_type(
            mut self,
            input: std::option::Option<crate::model::ContactFlowType>,
        ) -> Self {
            self.contact_flow_type = input;
            self
        }
        /// <p>The type of flow.</p>
        pub fn contact_flow_state(mut self, input: crate::model::ContactFlowState) -> Self {
            self.contact_flow_state = Some(input);
            self
        }
        /// <p>The type of flow.</p>
        pub fn set_contact_flow_state(
            mut self,
            input: std::option::Option<crate::model::ContactFlowState>,
        ) -> Self {
            self.contact_flow_state = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactFlowSummary`](crate::model::ContactFlowSummary).
        pub fn build(self) -> crate::model::ContactFlowSummary {
            crate::model::ContactFlowSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                contact_flow_type: self.contact_flow_type,
                contact_flow_state: self.contact_flow_state,
            }
        }
    }
}
impl ContactFlowSummary {
    /// Creates a new builder-style object to manufacture [`ContactFlowSummary`](crate::model::ContactFlowSummary).
    pub fn builder() -> crate::model::contact_flow_summary::Builder {
        crate::model::contact_flow_summary::Builder::default()
    }
}

/// When writing a match expression against `ContactFlowType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let contactflowtype = unimplemented!();
/// match contactflowtype {
///     ContactFlowType::AgentHold => { /* ... */ },
///     ContactFlowType::AgentTransfer => { /* ... */ },
///     ContactFlowType::AgentWhisper => { /* ... */ },
///     ContactFlowType::ContactFlow => { /* ... */ },
///     ContactFlowType::CustomerHold => { /* ... */ },
///     ContactFlowType::CustomerQueue => { /* ... */ },
///     ContactFlowType::CustomerWhisper => { /* ... */ },
///     ContactFlowType::OutboundWhisper => { /* ... */ },
///     ContactFlowType::QueueTransfer => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `contactflowtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ContactFlowType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ContactFlowType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ContactFlowType::NewFeature` is defined.
/// Specifically, when `contactflowtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ContactFlowType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContactFlowType {
    #[allow(missing_docs)] // documentation missing in model
    AgentHold,
    #[allow(missing_docs)] // documentation missing in model
    AgentTransfer,
    #[allow(missing_docs)] // documentation missing in model
    AgentWhisper,
    #[allow(missing_docs)] // documentation missing in model
    ContactFlow,
    #[allow(missing_docs)] // documentation missing in model
    CustomerHold,
    #[allow(missing_docs)] // documentation missing in model
    CustomerQueue,
    #[allow(missing_docs)] // documentation missing in model
    CustomerWhisper,
    #[allow(missing_docs)] // documentation missing in model
    OutboundWhisper,
    #[allow(missing_docs)] // documentation missing in model
    QueueTransfer,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ContactFlowType {
    fn from(s: &str) -> Self {
        match s {
            "AGENT_HOLD" => ContactFlowType::AgentHold,
            "AGENT_TRANSFER" => ContactFlowType::AgentTransfer,
            "AGENT_WHISPER" => ContactFlowType::AgentWhisper,
            "CONTACT_FLOW" => ContactFlowType::ContactFlow,
            "CUSTOMER_HOLD" => ContactFlowType::CustomerHold,
            "CUSTOMER_QUEUE" => ContactFlowType::CustomerQueue,
            "CUSTOMER_WHISPER" => ContactFlowType::CustomerWhisper,
            "OUTBOUND_WHISPER" => ContactFlowType::OutboundWhisper,
            "QUEUE_TRANSFER" => ContactFlowType::QueueTransfer,
            other => ContactFlowType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ContactFlowType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContactFlowType::from(s))
    }
}
impl ContactFlowType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContactFlowType::AgentHold => "AGENT_HOLD",
            ContactFlowType::AgentTransfer => "AGENT_TRANSFER",
            ContactFlowType::AgentWhisper => "AGENT_WHISPER",
            ContactFlowType::ContactFlow => "CONTACT_FLOW",
            ContactFlowType::CustomerHold => "CUSTOMER_HOLD",
            ContactFlowType::CustomerQueue => "CUSTOMER_QUEUE",
            ContactFlowType::CustomerWhisper => "CUSTOMER_WHISPER",
            ContactFlowType::OutboundWhisper => "OUTBOUND_WHISPER",
            ContactFlowType::QueueTransfer => "QUEUE_TRANSFER",
            ContactFlowType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AGENT_HOLD",
            "AGENT_TRANSFER",
            "AGENT_WHISPER",
            "CONTACT_FLOW",
            "CUSTOMER_HOLD",
            "CUSTOMER_QUEUE",
            "CUSTOMER_WHISPER",
            "OUTBOUND_WHISPER",
            "QUEUE_TRANSFER",
        ]
    }
}
impl AsRef<str> for ContactFlowType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains summary information about a flow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContactFlowModuleSummary {
    /// <p>The identifier of the flow module.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the flow module.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the flow module.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of flow module.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ContactFlowModuleState>,
}
impl ContactFlowModuleSummary {
    /// <p>The identifier of the flow module.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the flow module.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the flow module.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of flow module.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ContactFlowModuleState> {
        self.state.as_ref()
    }
}
/// See [`ContactFlowModuleSummary`](crate::model::ContactFlowModuleSummary).
pub mod contact_flow_module_summary {

    /// A builder for [`ContactFlowModuleSummary`](crate::model::ContactFlowModuleSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ContactFlowModuleState>,
    }
    impl Builder {
        /// <p>The identifier of the flow module.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow module.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the flow module.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the flow module.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the flow module.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the flow module.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of flow module.</p>
        pub fn state(mut self, input: crate::model::ContactFlowModuleState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The type of flow module.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ContactFlowModuleState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactFlowModuleSummary`](crate::model::ContactFlowModuleSummary).
        pub fn build(self) -> crate::model::ContactFlowModuleSummary {
            crate::model::ContactFlowModuleSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                state: self.state,
            }
        }
    }
}
impl ContactFlowModuleSummary {
    /// Creates a new builder-style object to manufacture [`ContactFlowModuleSummary`](crate::model::ContactFlowModuleSummary).
    pub fn builder() -> crate::model::contact_flow_module_summary::Builder {
        crate::model::contact_flow_module_summary::Builder::default()
    }
}

/// <p>Configuration information of an Amazon Lex or Amazon Lex V2 bot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LexBotConfig {
    /// <p>Configuration information of an Amazon Lex bot.</p>
    #[doc(hidden)]
    pub lex_bot: std::option::Option<crate::model::LexBot>,
    /// <p>Configuration information of an Amazon Lex V2 bot.</p>
    #[doc(hidden)]
    pub lex_v2_bot: std::option::Option<crate::model::LexV2Bot>,
}
impl LexBotConfig {
    /// <p>Configuration information of an Amazon Lex bot.</p>
    pub fn lex_bot(&self) -> std::option::Option<&crate::model::LexBot> {
        self.lex_bot.as_ref()
    }
    /// <p>Configuration information of an Amazon Lex V2 bot.</p>
    pub fn lex_v2_bot(&self) -> std::option::Option<&crate::model::LexV2Bot> {
        self.lex_v2_bot.as_ref()
    }
}
/// See [`LexBotConfig`](crate::model::LexBotConfig).
pub mod lex_bot_config {

    /// A builder for [`LexBotConfig`](crate::model::LexBotConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lex_bot: std::option::Option<crate::model::LexBot>,
        pub(crate) lex_v2_bot: std::option::Option<crate::model::LexV2Bot>,
    }
    impl Builder {
        /// <p>Configuration information of an Amazon Lex bot.</p>
        pub fn lex_bot(mut self, input: crate::model::LexBot) -> Self {
            self.lex_bot = Some(input);
            self
        }
        /// <p>Configuration information of an Amazon Lex bot.</p>
        pub fn set_lex_bot(mut self, input: std::option::Option<crate::model::LexBot>) -> Self {
            self.lex_bot = input;
            self
        }
        /// <p>Configuration information of an Amazon Lex V2 bot.</p>
        pub fn lex_v2_bot(mut self, input: crate::model::LexV2Bot) -> Self {
            self.lex_v2_bot = Some(input);
            self
        }
        /// <p>Configuration information of an Amazon Lex V2 bot.</p>
        pub fn set_lex_v2_bot(
            mut self,
            input: std::option::Option<crate::model::LexV2Bot>,
        ) -> Self {
            self.lex_v2_bot = input;
            self
        }
        /// Consumes the builder and constructs a [`LexBotConfig`](crate::model::LexBotConfig).
        pub fn build(self) -> crate::model::LexBotConfig {
            crate::model::LexBotConfig {
                lex_bot: self.lex_bot,
                lex_v2_bot: self.lex_v2_bot,
            }
        }
    }
}
impl LexBotConfig {
    /// Creates a new builder-style object to manufacture [`LexBotConfig`](crate::model::LexBotConfig).
    pub fn builder() -> crate::model::lex_bot_config::Builder {
        crate::model::lex_bot_config::Builder::default()
    }
}

/// <p>Configuration information of an Amazon Lex V2 bot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LexV2Bot {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.</p>
    #[doc(hidden)]
    pub alias_arn: std::option::Option<std::string::String>,
}
impl LexV2Bot {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.</p>
    pub fn alias_arn(&self) -> std::option::Option<&str> {
        self.alias_arn.as_deref()
    }
}
/// See [`LexV2Bot`](crate::model::LexV2Bot).
pub mod lex_v2_bot {

    /// A builder for [`LexV2Bot`](crate::model::LexV2Bot).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alias_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.</p>
        pub fn alias_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.</p>
        pub fn set_alias_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LexV2Bot`](crate::model::LexV2Bot).
        pub fn build(self) -> crate::model::LexV2Bot {
            crate::model::LexV2Bot {
                alias_arn: self.alias_arn,
            }
        }
    }
}
impl LexV2Bot {
    /// Creates a new builder-style object to manufacture [`LexV2Bot`](crate::model::LexV2Bot).
    pub fn builder() -> crate::model::lex_v2_bot::Builder {
        crate::model::lex_v2_bot::Builder::default()
    }
}

/// When writing a match expression against `LexVersion`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lexversion = unimplemented!();
/// match lexversion {
///     LexVersion::V1 => { /* ... */ },
///     LexVersion::V2 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lexversion` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LexVersion::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LexVersion::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LexVersion::NewFeature` is defined.
/// Specifically, when `lexversion` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LexVersion::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LexVersion {
    #[allow(missing_docs)] // documentation missing in model
    V1,
    #[allow(missing_docs)] // documentation missing in model
    V2,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LexVersion {
    fn from(s: &str) -> Self {
        match s {
            "V1" => LexVersion::V1,
            "V2" => LexVersion::V2,
            other => LexVersion::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LexVersion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LexVersion::from(s))
    }
}
impl LexVersion {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LexVersion::V1 => "V1",
            LexVersion::V2 => "V2",
            LexVersion::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["V1", "V2"]
    }
}
impl AsRef<str> for LexVersion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information for an agent status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AgentStatusSummary {
    /// <p>The identifier for an agent status.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the agent status.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the agent status.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the agent status.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::AgentStatusType>,
}
impl AgentStatusSummary {
    /// <p>The identifier for an agent status.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the agent status.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the agent status.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the agent status.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::AgentStatusType> {
        self.r#type.as_ref()
    }
}
/// See [`AgentStatusSummary`](crate::model::AgentStatusSummary).
pub mod agent_status_summary {

    /// A builder for [`AgentStatusSummary`](crate::model::AgentStatusSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::AgentStatusType>,
    }
    impl Builder {
        /// <p>The identifier for an agent status.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier for an agent status.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the agent status.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the agent status.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the agent status.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the agent status.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the agent status.</p>
        pub fn r#type(mut self, input: crate::model::AgentStatusType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the agent status.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::AgentStatusType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentStatusSummary`](crate::model::AgentStatusSummary).
        pub fn build(self) -> crate::model::AgentStatusSummary {
            crate::model::AgentStatusSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                r#type: self.r#type,
            }
        }
    }
}
impl AgentStatusSummary {
    /// Creates a new builder-style object to manufacture [`AgentStatusSummary`](crate::model::AgentStatusSummary).
    pub fn builder() -> crate::model::agent_status_summary::Builder {
        crate::model::agent_status_summary::Builder::default()
    }
}

/// When writing a match expression against `AgentStatusType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let agentstatustype = unimplemented!();
/// match agentstatustype {
///     AgentStatusType::Custom => { /* ... */ },
///     AgentStatusType::Offline => { /* ... */ },
///     AgentStatusType::Routable => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `agentstatustype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AgentStatusType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AgentStatusType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AgentStatusType::NewFeature` is defined.
/// Specifically, when `agentstatustype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AgentStatusType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AgentStatusType {
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    Offline,
    #[allow(missing_docs)] // documentation missing in model
    Routable,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AgentStatusType {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOM" => AgentStatusType::Custom,
            "OFFLINE" => AgentStatusType::Offline,
            "ROUTABLE" => AgentStatusType::Routable,
            other => AgentStatusType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AgentStatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AgentStatusType::from(s))
    }
}
impl AgentStatusType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AgentStatusType::Custom => "CUSTOM",
            AgentStatusType::Offline => "OFFLINE",
            AgentStatusType::Routable => "ROUTABLE",
            AgentStatusType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CUSTOM", "OFFLINE", "ROUTABLE"]
    }
}
impl AsRef<str> for AgentStatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the historical metrics retrieved.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HistoricalMetricResult {
    /// <p>The dimension for the metrics.</p>
    #[doc(hidden)]
    pub dimensions: std::option::Option<crate::model::Dimensions>,
    /// <p>The set of metrics.</p>
    #[doc(hidden)]
    pub collections: std::option::Option<std::vec::Vec<crate::model::HistoricalMetricData>>,
}
impl HistoricalMetricResult {
    /// <p>The dimension for the metrics.</p>
    pub fn dimensions(&self) -> std::option::Option<&crate::model::Dimensions> {
        self.dimensions.as_ref()
    }
    /// <p>The set of metrics.</p>
    pub fn collections(&self) -> std::option::Option<&[crate::model::HistoricalMetricData]> {
        self.collections.as_deref()
    }
}
/// See [`HistoricalMetricResult`](crate::model::HistoricalMetricResult).
pub mod historical_metric_result {

    /// A builder for [`HistoricalMetricResult`](crate::model::HistoricalMetricResult).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimensions: std::option::Option<crate::model::Dimensions>,
        pub(crate) collections:
            std::option::Option<std::vec::Vec<crate::model::HistoricalMetricData>>,
    }
    impl Builder {
        /// <p>The dimension for the metrics.</p>
        pub fn dimensions(mut self, input: crate::model::Dimensions) -> Self {
            self.dimensions = Some(input);
            self
        }
        /// <p>The dimension for the metrics.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<crate::model::Dimensions>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// Appends an item to `collections`.
        ///
        /// To override the contents of this collection use [`set_collections`](Self::set_collections).
        ///
        /// <p>The set of metrics.</p>
        pub fn collections(mut self, input: crate::model::HistoricalMetricData) -> Self {
            let mut v = self.collections.unwrap_or_default();
            v.push(input);
            self.collections = Some(v);
            self
        }
        /// <p>The set of metrics.</p>
        pub fn set_collections(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HistoricalMetricData>>,
        ) -> Self {
            self.collections = input;
            self
        }
        /// Consumes the builder and constructs a [`HistoricalMetricResult`](crate::model::HistoricalMetricResult).
        pub fn build(self) -> crate::model::HistoricalMetricResult {
            crate::model::HistoricalMetricResult {
                dimensions: self.dimensions,
                collections: self.collections,
            }
        }
    }
}
impl HistoricalMetricResult {
    /// Creates a new builder-style object to manufacture [`HistoricalMetricResult`](crate::model::HistoricalMetricResult).
    pub fn builder() -> crate::model::historical_metric_result::Builder {
        crate::model::historical_metric_result::Builder::default()
    }
}

/// <p>Contains the data for a historical metric.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HistoricalMetricData {
    /// <p>Information about the metric.</p>
    #[doc(hidden)]
    pub metric: std::option::Option<crate::model::HistoricalMetric>,
    /// <p>The value of the metric.</p>
    #[doc(hidden)]
    pub value: std::option::Option<f64>,
}
impl HistoricalMetricData {
    /// <p>Information about the metric.</p>
    pub fn metric(&self) -> std::option::Option<&crate::model::HistoricalMetric> {
        self.metric.as_ref()
    }
    /// <p>The value of the metric.</p>
    pub fn value(&self) -> std::option::Option<f64> {
        self.value
    }
}
/// See [`HistoricalMetricData`](crate::model::HistoricalMetricData).
pub mod historical_metric_data {

    /// A builder for [`HistoricalMetricData`](crate::model::HistoricalMetricData).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric: std::option::Option<crate::model::HistoricalMetric>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>Information about the metric.</p>
        pub fn metric(mut self, input: crate::model::HistoricalMetric) -> Self {
            self.metric = Some(input);
            self
        }
        /// <p>Information about the metric.</p>
        pub fn set_metric(
            mut self,
            input: std::option::Option<crate::model::HistoricalMetric>,
        ) -> Self {
            self.metric = input;
            self
        }
        /// <p>The value of the metric.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the metric.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`HistoricalMetricData`](crate::model::HistoricalMetricData).
        pub fn build(self) -> crate::model::HistoricalMetricData {
            crate::model::HistoricalMetricData {
                metric: self.metric,
                value: self.value,
            }
        }
    }
}
impl HistoricalMetricData {
    /// Creates a new builder-style object to manufacture [`HistoricalMetricData`](crate::model::HistoricalMetricData).
    pub fn builder() -> crate::model::historical_metric_data::Builder {
        crate::model::historical_metric_data::Builder::default()
    }
}

/// <p>Contains information about a historical metric. For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HistoricalMetric {
    /// <p>The name of the metric.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::HistoricalMetricName>,
    /// <p>The threshold for the metric, used with service level metrics.</p>
    #[doc(hidden)]
    pub threshold: std::option::Option<crate::model::Threshold>,
    /// <p>The statistic for the metric.</p>
    #[doc(hidden)]
    pub statistic: std::option::Option<crate::model::Statistic>,
    /// <p>The unit for the metric.</p>
    #[doc(hidden)]
    pub unit: std::option::Option<crate::model::Unit>,
}
impl HistoricalMetric {
    /// <p>The name of the metric.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::HistoricalMetricName> {
        self.name.as_ref()
    }
    /// <p>The threshold for the metric, used with service level metrics.</p>
    pub fn threshold(&self) -> std::option::Option<&crate::model::Threshold> {
        self.threshold.as_ref()
    }
    /// <p>The statistic for the metric.</p>
    pub fn statistic(&self) -> std::option::Option<&crate::model::Statistic> {
        self.statistic.as_ref()
    }
    /// <p>The unit for the metric.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::Unit> {
        self.unit.as_ref()
    }
}
/// See [`HistoricalMetric`](crate::model::HistoricalMetric).
pub mod historical_metric {

    /// A builder for [`HistoricalMetric`](crate::model::HistoricalMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::HistoricalMetricName>,
        pub(crate) threshold: std::option::Option<crate::model::Threshold>,
        pub(crate) statistic: std::option::Option<crate::model::Statistic>,
        pub(crate) unit: std::option::Option<crate::model::Unit>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn name(mut self, input: crate::model::HistoricalMetricName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the metric.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::HistoricalMetricName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The threshold for the metric, used with service level metrics.</p>
        pub fn threshold(mut self, input: crate::model::Threshold) -> Self {
            self.threshold = Some(input);
            self
        }
        /// <p>The threshold for the metric, used with service level metrics.</p>
        pub fn set_threshold(
            mut self,
            input: std::option::Option<crate::model::Threshold>,
        ) -> Self {
            self.threshold = input;
            self
        }
        /// <p>The statistic for the metric.</p>
        pub fn statistic(mut self, input: crate::model::Statistic) -> Self {
            self.statistic = Some(input);
            self
        }
        /// <p>The statistic for the metric.</p>
        pub fn set_statistic(
            mut self,
            input: std::option::Option<crate::model::Statistic>,
        ) -> Self {
            self.statistic = input;
            self
        }
        /// <p>The unit for the metric.</p>
        pub fn unit(mut self, input: crate::model::Unit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit for the metric.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::Unit>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`HistoricalMetric`](crate::model::HistoricalMetric).
        pub fn build(self) -> crate::model::HistoricalMetric {
            crate::model::HistoricalMetric {
                name: self.name,
                threshold: self.threshold,
                statistic: self.statistic,
                unit: self.unit,
            }
        }
    }
}
impl HistoricalMetric {
    /// Creates a new builder-style object to manufacture [`HistoricalMetric`](crate::model::HistoricalMetric).
    pub fn builder() -> crate::model::historical_metric::Builder {
        crate::model::historical_metric::Builder::default()
    }
}

/// When writing a match expression against `Unit`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let unit = unimplemented!();
/// match unit {
///     Unit::Count => { /* ... */ },
///     Unit::Percent => { /* ... */ },
///     Unit::Seconds => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `unit` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Unit::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Unit::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Unit::NewFeature` is defined.
/// Specifically, when `unit` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Unit::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Unit {
    #[allow(missing_docs)] // documentation missing in model
    Count,
    #[allow(missing_docs)] // documentation missing in model
    Percent,
    #[allow(missing_docs)] // documentation missing in model
    Seconds,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Unit {
    fn from(s: &str) -> Self {
        match s {
            "COUNT" => Unit::Count,
            "PERCENT" => Unit::Percent,
            "SECONDS" => Unit::Seconds,
            other => Unit::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Unit {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Unit::from(s))
    }
}
impl Unit {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Unit::Count => "COUNT",
            Unit::Percent => "PERCENT",
            Unit::Seconds => "SECONDS",
            Unit::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COUNT", "PERCENT", "SECONDS"]
    }
}
impl AsRef<str> for Unit {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Statistic`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let statistic = unimplemented!();
/// match statistic {
///     Statistic::Avg => { /* ... */ },
///     Statistic::Max => { /* ... */ },
///     Statistic::Sum => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `statistic` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Statistic::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Statistic::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Statistic::NewFeature` is defined.
/// Specifically, when `statistic` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Statistic::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Statistic {
    #[allow(missing_docs)] // documentation missing in model
    Avg,
    #[allow(missing_docs)] // documentation missing in model
    Max,
    #[allow(missing_docs)] // documentation missing in model
    Sum,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Statistic {
    fn from(s: &str) -> Self {
        match s {
            "AVG" => Statistic::Avg,
            "MAX" => Statistic::Max,
            "SUM" => Statistic::Sum,
            other => Statistic::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Statistic {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Statistic::from(s))
    }
}
impl Statistic {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Statistic::Avg => "AVG",
            Statistic::Max => "MAX",
            Statistic::Sum => "SUM",
            Statistic::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVG", "MAX", "SUM"]
    }
}
impl AsRef<str> for Statistic {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the threshold for service level metrics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Threshold {
    /// <p>The type of comparison. Only "less than" (LT) comparisons are supported.</p>
    #[doc(hidden)]
    pub comparison: std::option::Option<crate::model::Comparison>,
    /// <p>The threshold value to compare.</p>
    #[doc(hidden)]
    pub threshold_value: std::option::Option<f64>,
}
impl Threshold {
    /// <p>The type of comparison. Only "less than" (LT) comparisons are supported.</p>
    pub fn comparison(&self) -> std::option::Option<&crate::model::Comparison> {
        self.comparison.as_ref()
    }
    /// <p>The threshold value to compare.</p>
    pub fn threshold_value(&self) -> std::option::Option<f64> {
        self.threshold_value
    }
}
/// See [`Threshold`](crate::model::Threshold).
pub mod threshold {

    /// A builder for [`Threshold`](crate::model::Threshold).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comparison: std::option::Option<crate::model::Comparison>,
        pub(crate) threshold_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The type of comparison. Only "less than" (LT) comparisons are supported.</p>
        pub fn comparison(mut self, input: crate::model::Comparison) -> Self {
            self.comparison = Some(input);
            self
        }
        /// <p>The type of comparison. Only "less than" (LT) comparisons are supported.</p>
        pub fn set_comparison(
            mut self,
            input: std::option::Option<crate::model::Comparison>,
        ) -> Self {
            self.comparison = input;
            self
        }
        /// <p>The threshold value to compare.</p>
        pub fn threshold_value(mut self, input: f64) -> Self {
            self.threshold_value = Some(input);
            self
        }
        /// <p>The threshold value to compare.</p>
        pub fn set_threshold_value(mut self, input: std::option::Option<f64>) -> Self {
            self.threshold_value = input;
            self
        }
        /// Consumes the builder and constructs a [`Threshold`](crate::model::Threshold).
        pub fn build(self) -> crate::model::Threshold {
            crate::model::Threshold {
                comparison: self.comparison,
                threshold_value: self.threshold_value,
            }
        }
    }
}
impl Threshold {
    /// Creates a new builder-style object to manufacture [`Threshold`](crate::model::Threshold).
    pub fn builder() -> crate::model::threshold::Builder {
        crate::model::threshold::Builder::default()
    }
}

/// When writing a match expression against `Comparison`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let comparison = unimplemented!();
/// match comparison {
///     Comparison::Lt => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `comparison` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Comparison::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Comparison::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Comparison::NewFeature` is defined.
/// Specifically, when `comparison` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Comparison::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Comparison {
    #[allow(missing_docs)] // documentation missing in model
    Lt,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Comparison {
    fn from(s: &str) -> Self {
        match s {
            "LT" => Comparison::Lt,
            other => Comparison::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Comparison {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Comparison::from(s))
    }
}
impl Comparison {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Comparison::Lt => "LT",
            Comparison::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LT"]
    }
}
impl AsRef<str> for Comparison {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `HistoricalMetricName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let historicalmetricname = unimplemented!();
/// match historicalmetricname {
///     HistoricalMetricName::AbandonTime => { /* ... */ },
///     HistoricalMetricName::AfterContactWorkTime => { /* ... */ },
///     HistoricalMetricName::ApiContactsHandled => { /* ... */ },
///     HistoricalMetricName::CallbackContactsHandled => { /* ... */ },
///     HistoricalMetricName::ContactsAbandoned => { /* ... */ },
///     HistoricalMetricName::ContactsAgentHungUpFirst => { /* ... */ },
///     HistoricalMetricName::ContactsConsulted => { /* ... */ },
///     HistoricalMetricName::ContactsHandled => { /* ... */ },
///     HistoricalMetricName::ContactsHandledIncoming => { /* ... */ },
///     HistoricalMetricName::ContactsHandledOutbound => { /* ... */ },
///     HistoricalMetricName::ContactsHoldAbandons => { /* ... */ },
///     HistoricalMetricName::ContactsMissed => { /* ... */ },
///     HistoricalMetricName::ContactsQueued => { /* ... */ },
///     HistoricalMetricName::ContactsTransferredIn => { /* ... */ },
///     HistoricalMetricName::ContactsTransferredInFromQueue => { /* ... */ },
///     HistoricalMetricName::ContactsTransferredOut => { /* ... */ },
///     HistoricalMetricName::ContactsTransferredOutFromQueue => { /* ... */ },
///     HistoricalMetricName::HandleTime => { /* ... */ },
///     HistoricalMetricName::HoldTime => { /* ... */ },
///     HistoricalMetricName::InteractionAndHoldTime => { /* ... */ },
///     HistoricalMetricName::InteractionTime => { /* ... */ },
///     HistoricalMetricName::Occupancy => { /* ... */ },
///     HistoricalMetricName::QueuedTime => { /* ... */ },
///     HistoricalMetricName::QueueAnswerTime => { /* ... */ },
///     HistoricalMetricName::ServiceLevel => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `historicalmetricname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HistoricalMetricName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HistoricalMetricName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HistoricalMetricName::NewFeature` is defined.
/// Specifically, when `historicalmetricname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HistoricalMetricName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The historical metric names.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HistoricalMetricName {
    #[allow(missing_docs)] // documentation missing in model
    AbandonTime,
    #[allow(missing_docs)] // documentation missing in model
    AfterContactWorkTime,
    #[allow(missing_docs)] // documentation missing in model
    ApiContactsHandled,
    #[allow(missing_docs)] // documentation missing in model
    CallbackContactsHandled,
    #[allow(missing_docs)] // documentation missing in model
    ContactsAbandoned,
    #[allow(missing_docs)] // documentation missing in model
    ContactsAgentHungUpFirst,
    #[allow(missing_docs)] // documentation missing in model
    ContactsConsulted,
    #[allow(missing_docs)] // documentation missing in model
    ContactsHandled,
    #[allow(missing_docs)] // documentation missing in model
    ContactsHandledIncoming,
    #[allow(missing_docs)] // documentation missing in model
    ContactsHandledOutbound,
    #[allow(missing_docs)] // documentation missing in model
    ContactsHoldAbandons,
    #[allow(missing_docs)] // documentation missing in model
    ContactsMissed,
    #[allow(missing_docs)] // documentation missing in model
    ContactsQueued,
    #[allow(missing_docs)] // documentation missing in model
    ContactsTransferredIn,
    #[allow(missing_docs)] // documentation missing in model
    ContactsTransferredInFromQueue,
    #[allow(missing_docs)] // documentation missing in model
    ContactsTransferredOut,
    #[allow(missing_docs)] // documentation missing in model
    ContactsTransferredOutFromQueue,
    #[allow(missing_docs)] // documentation missing in model
    HandleTime,
    #[allow(missing_docs)] // documentation missing in model
    HoldTime,
    #[allow(missing_docs)] // documentation missing in model
    InteractionAndHoldTime,
    #[allow(missing_docs)] // documentation missing in model
    InteractionTime,
    #[allow(missing_docs)] // documentation missing in model
    Occupancy,
    #[allow(missing_docs)] // documentation missing in model
    QueuedTime,
    #[allow(missing_docs)] // documentation missing in model
    QueueAnswerTime,
    #[allow(missing_docs)] // documentation missing in model
    ServiceLevel,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HistoricalMetricName {
    fn from(s: &str) -> Self {
        match s {
            "ABANDON_TIME" => HistoricalMetricName::AbandonTime,
            "AFTER_CONTACT_WORK_TIME" => HistoricalMetricName::AfterContactWorkTime,
            "API_CONTACTS_HANDLED" => HistoricalMetricName::ApiContactsHandled,
            "CALLBACK_CONTACTS_HANDLED" => HistoricalMetricName::CallbackContactsHandled,
            "CONTACTS_ABANDONED" => HistoricalMetricName::ContactsAbandoned,
            "CONTACTS_AGENT_HUNG_UP_FIRST" => HistoricalMetricName::ContactsAgentHungUpFirst,
            "CONTACTS_CONSULTED" => HistoricalMetricName::ContactsConsulted,
            "CONTACTS_HANDLED" => HistoricalMetricName::ContactsHandled,
            "CONTACTS_HANDLED_INCOMING" => HistoricalMetricName::ContactsHandledIncoming,
            "CONTACTS_HANDLED_OUTBOUND" => HistoricalMetricName::ContactsHandledOutbound,
            "CONTACTS_HOLD_ABANDONS" => HistoricalMetricName::ContactsHoldAbandons,
            "CONTACTS_MISSED" => HistoricalMetricName::ContactsMissed,
            "CONTACTS_QUEUED" => HistoricalMetricName::ContactsQueued,
            "CONTACTS_TRANSFERRED_IN" => HistoricalMetricName::ContactsTransferredIn,
            "CONTACTS_TRANSFERRED_IN_FROM_QUEUE" => {
                HistoricalMetricName::ContactsTransferredInFromQueue
            }
            "CONTACTS_TRANSFERRED_OUT" => HistoricalMetricName::ContactsTransferredOut,
            "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE" => {
                HistoricalMetricName::ContactsTransferredOutFromQueue
            }
            "HANDLE_TIME" => HistoricalMetricName::HandleTime,
            "HOLD_TIME" => HistoricalMetricName::HoldTime,
            "INTERACTION_AND_HOLD_TIME" => HistoricalMetricName::InteractionAndHoldTime,
            "INTERACTION_TIME" => HistoricalMetricName::InteractionTime,
            "OCCUPANCY" => HistoricalMetricName::Occupancy,
            "QUEUED_TIME" => HistoricalMetricName::QueuedTime,
            "QUEUE_ANSWER_TIME" => HistoricalMetricName::QueueAnswerTime,
            "SERVICE_LEVEL" => HistoricalMetricName::ServiceLevel,
            other => {
                HistoricalMetricName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for HistoricalMetricName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HistoricalMetricName::from(s))
    }
}
impl HistoricalMetricName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HistoricalMetricName::AbandonTime => "ABANDON_TIME",
            HistoricalMetricName::AfterContactWorkTime => "AFTER_CONTACT_WORK_TIME",
            HistoricalMetricName::ApiContactsHandled => "API_CONTACTS_HANDLED",
            HistoricalMetricName::CallbackContactsHandled => "CALLBACK_CONTACTS_HANDLED",
            HistoricalMetricName::ContactsAbandoned => "CONTACTS_ABANDONED",
            HistoricalMetricName::ContactsAgentHungUpFirst => "CONTACTS_AGENT_HUNG_UP_FIRST",
            HistoricalMetricName::ContactsConsulted => "CONTACTS_CONSULTED",
            HistoricalMetricName::ContactsHandled => "CONTACTS_HANDLED",
            HistoricalMetricName::ContactsHandledIncoming => "CONTACTS_HANDLED_INCOMING",
            HistoricalMetricName::ContactsHandledOutbound => "CONTACTS_HANDLED_OUTBOUND",
            HistoricalMetricName::ContactsHoldAbandons => "CONTACTS_HOLD_ABANDONS",
            HistoricalMetricName::ContactsMissed => "CONTACTS_MISSED",
            HistoricalMetricName::ContactsQueued => "CONTACTS_QUEUED",
            HistoricalMetricName::ContactsTransferredIn => "CONTACTS_TRANSFERRED_IN",
            HistoricalMetricName::ContactsTransferredInFromQueue => {
                "CONTACTS_TRANSFERRED_IN_FROM_QUEUE"
            }
            HistoricalMetricName::ContactsTransferredOut => "CONTACTS_TRANSFERRED_OUT",
            HistoricalMetricName::ContactsTransferredOutFromQueue => {
                "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE"
            }
            HistoricalMetricName::HandleTime => "HANDLE_TIME",
            HistoricalMetricName::HoldTime => "HOLD_TIME",
            HistoricalMetricName::InteractionAndHoldTime => "INTERACTION_AND_HOLD_TIME",
            HistoricalMetricName::InteractionTime => "INTERACTION_TIME",
            HistoricalMetricName::Occupancy => "OCCUPANCY",
            HistoricalMetricName::QueuedTime => "QUEUED_TIME",
            HistoricalMetricName::QueueAnswerTime => "QUEUE_ANSWER_TIME",
            HistoricalMetricName::ServiceLevel => "SERVICE_LEVEL",
            HistoricalMetricName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ABANDON_TIME",
            "AFTER_CONTACT_WORK_TIME",
            "API_CONTACTS_HANDLED",
            "CALLBACK_CONTACTS_HANDLED",
            "CONTACTS_ABANDONED",
            "CONTACTS_AGENT_HUNG_UP_FIRST",
            "CONTACTS_CONSULTED",
            "CONTACTS_HANDLED",
            "CONTACTS_HANDLED_INCOMING",
            "CONTACTS_HANDLED_OUTBOUND",
            "CONTACTS_HOLD_ABANDONS",
            "CONTACTS_MISSED",
            "CONTACTS_QUEUED",
            "CONTACTS_TRANSFERRED_IN",
            "CONTACTS_TRANSFERRED_IN_FROM_QUEUE",
            "CONTACTS_TRANSFERRED_OUT",
            "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE",
            "HANDLE_TIME",
            "HOLD_TIME",
            "INTERACTION_AND_HOLD_TIME",
            "INTERACTION_TIME",
            "OCCUPANCY",
            "QUEUED_TIME",
            "QUEUE_ANSWER_TIME",
            "SERVICE_LEVEL",
        ]
    }
}
impl AsRef<str> for HistoricalMetricName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the dimensions for a set of metrics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Dimensions {
    /// <p>Information about the queue for which metrics are returned.</p>
    #[doc(hidden)]
    pub queue: std::option::Option<crate::model::QueueReference>,
    /// <p>The channel used for grouping and filters.</p>
    #[doc(hidden)]
    pub channel: std::option::Option<crate::model::Channel>,
    /// <p>Information about the routing profile assigned to the user.</p>
    #[doc(hidden)]
    pub routing_profile: std::option::Option<crate::model::RoutingProfileReference>,
}
impl Dimensions {
    /// <p>Information about the queue for which metrics are returned.</p>
    pub fn queue(&self) -> std::option::Option<&crate::model::QueueReference> {
        self.queue.as_ref()
    }
    /// <p>The channel used for grouping and filters.</p>
    pub fn channel(&self) -> std::option::Option<&crate::model::Channel> {
        self.channel.as_ref()
    }
    /// <p>Information about the routing profile assigned to the user.</p>
    pub fn routing_profile(&self) -> std::option::Option<&crate::model::RoutingProfileReference> {
        self.routing_profile.as_ref()
    }
}
/// See [`Dimensions`](crate::model::Dimensions).
pub mod dimensions {

    /// A builder for [`Dimensions`](crate::model::Dimensions).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queue: std::option::Option<crate::model::QueueReference>,
        pub(crate) channel: std::option::Option<crate::model::Channel>,
        pub(crate) routing_profile: std::option::Option<crate::model::RoutingProfileReference>,
    }
    impl Builder {
        /// <p>Information about the queue for which metrics are returned.</p>
        pub fn queue(mut self, input: crate::model::QueueReference) -> Self {
            self.queue = Some(input);
            self
        }
        /// <p>Information about the queue for which metrics are returned.</p>
        pub fn set_queue(
            mut self,
            input: std::option::Option<crate::model::QueueReference>,
        ) -> Self {
            self.queue = input;
            self
        }
        /// <p>The channel used for grouping and filters.</p>
        pub fn channel(mut self, input: crate::model::Channel) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>The channel used for grouping and filters.</p>
        pub fn set_channel(mut self, input: std::option::Option<crate::model::Channel>) -> Self {
            self.channel = input;
            self
        }
        /// <p>Information about the routing profile assigned to the user.</p>
        pub fn routing_profile(mut self, input: crate::model::RoutingProfileReference) -> Self {
            self.routing_profile = Some(input);
            self
        }
        /// <p>Information about the routing profile assigned to the user.</p>
        pub fn set_routing_profile(
            mut self,
            input: std::option::Option<crate::model::RoutingProfileReference>,
        ) -> Self {
            self.routing_profile = input;
            self
        }
        /// Consumes the builder and constructs a [`Dimensions`](crate::model::Dimensions).
        pub fn build(self) -> crate::model::Dimensions {
            crate::model::Dimensions {
                queue: self.queue,
                channel: self.channel,
                routing_profile: self.routing_profile,
            }
        }
    }
}
impl Dimensions {
    /// Creates a new builder-style object to manufacture [`Dimensions`](crate::model::Dimensions).
    pub fn builder() -> crate::model::dimensions::Builder {
        crate::model::dimensions::Builder::default()
    }
}

/// <p>Information about the routing profile assigned to the user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RoutingProfileReference {
    /// <p>The identifier of the routing profile.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl RoutingProfileReference {
    /// <p>The identifier of the routing profile.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`RoutingProfileReference`](crate::model::RoutingProfileReference).
pub mod routing_profile_reference {

    /// A builder for [`RoutingProfileReference`](crate::model::RoutingProfileReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the routing profile.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfileReference`](crate::model::RoutingProfileReference).
        pub fn build(self) -> crate::model::RoutingProfileReference {
            crate::model::RoutingProfileReference {
                id: self.id,
                arn: self.arn,
            }
        }
    }
}
impl RoutingProfileReference {
    /// Creates a new builder-style object to manufacture [`RoutingProfileReference`](crate::model::RoutingProfileReference).
    pub fn builder() -> crate::model::routing_profile_reference::Builder {
        crate::model::routing_profile_reference::Builder::default()
    }
}

/// <p>Contains information about a queue resource for which metrics are returned.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueueReference {
    /// <p>The identifier of the queue.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl QueueReference {
    /// <p>The identifier of the queue.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`QueueReference`](crate::model::QueueReference).
pub mod queue_reference {

    /// A builder for [`QueueReference`](crate::model::QueueReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the queue.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the queue.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the queue.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the queue.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`QueueReference`](crate::model::QueueReference).
        pub fn build(self) -> crate::model::QueueReference {
            crate::model::QueueReference {
                id: self.id,
                arn: self.arn,
            }
        }
    }
}
impl QueueReference {
    /// Creates a new builder-style object to manufacture [`QueueReference`](crate::model::QueueReference).
    pub fn builder() -> crate::model::queue_reference::Builder {
        crate::model::queue_reference::Builder::default()
    }
}

/// When writing a match expression against `Grouping`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let grouping = unimplemented!();
/// match grouping {
///     Grouping::Channel => { /* ... */ },
///     Grouping::Queue => { /* ... */ },
///     Grouping::RoutingProfile => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `grouping` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Grouping::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Grouping::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Grouping::NewFeature` is defined.
/// Specifically, when `grouping` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Grouping::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Grouping {
    #[allow(missing_docs)] // documentation missing in model
    Channel,
    #[allow(missing_docs)] // documentation missing in model
    Queue,
    #[allow(missing_docs)] // documentation missing in model
    RoutingProfile,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Grouping {
    fn from(s: &str) -> Self {
        match s {
            "CHANNEL" => Grouping::Channel,
            "QUEUE" => Grouping::Queue,
            "ROUTING_PROFILE" => Grouping::RoutingProfile,
            other => Grouping::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Grouping {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Grouping::from(s))
    }
}
impl Grouping {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Grouping::Channel => "CHANNEL",
            Grouping::Queue => "QUEUE",
            Grouping::RoutingProfile => "ROUTING_PROFILE",
            Grouping::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CHANNEL", "QUEUE", "ROUTING_PROFILE"]
    }
}
impl AsRef<str> for Grouping {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains the filter to apply when retrieving metrics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Filters {
    /// <p>The queues to use to filter the metrics. You should specify at least one queue, and can specify up to 100 queues per request. The <code>GetCurrentMetricsData</code> API in particular requires a queue when you include a <code>Filter</code> in your request. </p>
    #[doc(hidden)]
    pub queues: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The channel to use to filter the metrics.</p>
    #[doc(hidden)]
    pub channels: std::option::Option<std::vec::Vec<crate::model::Channel>>,
    /// <p>A list of up to 100 routing profile IDs or ARNs.</p>
    #[doc(hidden)]
    pub routing_profiles: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl Filters {
    /// <p>The queues to use to filter the metrics. You should specify at least one queue, and can specify up to 100 queues per request. The <code>GetCurrentMetricsData</code> API in particular requires a queue when you include a <code>Filter</code> in your request. </p>
    pub fn queues(&self) -> std::option::Option<&[std::string::String]> {
        self.queues.as_deref()
    }
    /// <p>The channel to use to filter the metrics.</p>
    pub fn channels(&self) -> std::option::Option<&[crate::model::Channel]> {
        self.channels.as_deref()
    }
    /// <p>A list of up to 100 routing profile IDs or ARNs.</p>
    pub fn routing_profiles(&self) -> std::option::Option<&[std::string::String]> {
        self.routing_profiles.as_deref()
    }
}
/// See [`Filters`](crate::model::Filters).
pub mod filters {

    /// A builder for [`Filters`](crate::model::Filters).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queues: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) channels: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        pub(crate) routing_profiles: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `queues`.
        ///
        /// To override the contents of this collection use [`set_queues`](Self::set_queues).
        ///
        /// <p>The queues to use to filter the metrics. You should specify at least one queue, and can specify up to 100 queues per request. The <code>GetCurrentMetricsData</code> API in particular requires a queue when you include a <code>Filter</code> in your request. </p>
        pub fn queues(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.queues.unwrap_or_default();
            v.push(input.into());
            self.queues = Some(v);
            self
        }
        /// <p>The queues to use to filter the metrics. You should specify at least one queue, and can specify up to 100 queues per request. The <code>GetCurrentMetricsData</code> API in particular requires a queue when you include a <code>Filter</code> in your request. </p>
        pub fn set_queues(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.queues = input;
            self
        }
        /// Appends an item to `channels`.
        ///
        /// To override the contents of this collection use [`set_channels`](Self::set_channels).
        ///
        /// <p>The channel to use to filter the metrics.</p>
        pub fn channels(mut self, input: crate::model::Channel) -> Self {
            let mut v = self.channels.unwrap_or_default();
            v.push(input);
            self.channels = Some(v);
            self
        }
        /// <p>The channel to use to filter the metrics.</p>
        pub fn set_channels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        ) -> Self {
            self.channels = input;
            self
        }
        /// Appends an item to `routing_profiles`.
        ///
        /// To override the contents of this collection use [`set_routing_profiles`](Self::set_routing_profiles).
        ///
        /// <p>A list of up to 100 routing profile IDs or ARNs.</p>
        pub fn routing_profiles(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.routing_profiles.unwrap_or_default();
            v.push(input.into());
            self.routing_profiles = Some(v);
            self
        }
        /// <p>A list of up to 100 routing profile IDs or ARNs.</p>
        pub fn set_routing_profiles(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.routing_profiles = input;
            self
        }
        /// Consumes the builder and constructs a [`Filters`](crate::model::Filters).
        pub fn build(self) -> crate::model::Filters {
            crate::model::Filters {
                queues: self.queues,
                channels: self.channels,
                routing_profiles: self.routing_profiles,
            }
        }
    }
}
impl Filters {
    /// Creates a new builder-style object to manufacture [`Filters`](crate::model::Filters).
    pub fn builder() -> crate::model::filters::Builder {
        crate::model::filters::Builder::default()
    }
}

/// <p>Contains credentials to use for federation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Credentials {
    /// <p>An access token generated for a federated user to access Amazon Connect.</p>
    #[doc(hidden)]
    pub access_token: std::option::Option<std::string::String>,
    /// <p>A token generated with an expiration time for the session a user is logged in to Amazon Connect.</p>
    #[doc(hidden)]
    pub access_token_expiration: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Renews a token generated for a user to access the Amazon Connect instance.</p>
    #[doc(hidden)]
    pub refresh_token: std::option::Option<std::string::String>,
    /// <p>Renews the expiration timer for a generated token.</p>
    #[doc(hidden)]
    pub refresh_token_expiration: std::option::Option<aws_smithy_types::DateTime>,
}
impl Credentials {
    /// <p>An access token generated for a federated user to access Amazon Connect.</p>
    pub fn access_token(&self) -> std::option::Option<&str> {
        self.access_token.as_deref()
    }
    /// <p>A token generated with an expiration time for the session a user is logged in to Amazon Connect.</p>
    pub fn access_token_expiration(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.access_token_expiration.as_ref()
    }
    /// <p>Renews a token generated for a user to access the Amazon Connect instance.</p>
    pub fn refresh_token(&self) -> std::option::Option<&str> {
        self.refresh_token.as_deref()
    }
    /// <p>Renews the expiration timer for a generated token.</p>
    pub fn refresh_token_expiration(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.refresh_token_expiration.as_ref()
    }
}
impl std::fmt::Debug for Credentials {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Credentials");
        formatter.field("access_token", &"*** Sensitive Data Redacted ***");
        formatter.field("access_token_expiration", &self.access_token_expiration);
        formatter.field("refresh_token", &"*** Sensitive Data Redacted ***");
        formatter.field("refresh_token_expiration", &self.refresh_token_expiration);
        formatter.finish()
    }
}
/// See [`Credentials`](crate::model::Credentials).
pub mod credentials {

    /// A builder for [`Credentials`](crate::model::Credentials).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) access_token: std::option::Option<std::string::String>,
        pub(crate) access_token_expiration: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) refresh_token: std::option::Option<std::string::String>,
        pub(crate) refresh_token_expiration: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>An access token generated for a federated user to access Amazon Connect.</p>
        pub fn access_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_token = Some(input.into());
            self
        }
        /// <p>An access token generated for a federated user to access Amazon Connect.</p>
        pub fn set_access_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.access_token = input;
            self
        }
        /// <p>A token generated with an expiration time for the session a user is logged in to Amazon Connect.</p>
        pub fn access_token_expiration(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.access_token_expiration = Some(input);
            self
        }
        /// <p>A token generated with an expiration time for the session a user is logged in to Amazon Connect.</p>
        pub fn set_access_token_expiration(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.access_token_expiration = input;
            self
        }
        /// <p>Renews a token generated for a user to access the Amazon Connect instance.</p>
        pub fn refresh_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.refresh_token = Some(input.into());
            self
        }
        /// <p>Renews a token generated for a user to access the Amazon Connect instance.</p>
        pub fn set_refresh_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.refresh_token = input;
            self
        }
        /// <p>Renews the expiration timer for a generated token.</p>
        pub fn refresh_token_expiration(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.refresh_token_expiration = Some(input);
            self
        }
        /// <p>Renews the expiration timer for a generated token.</p>
        pub fn set_refresh_token_expiration(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.refresh_token_expiration = input;
            self
        }
        /// Consumes the builder and constructs a [`Credentials`](crate::model::Credentials).
        pub fn build(self) -> crate::model::Credentials {
            crate::model::Credentials {
                access_token: self.access_token,
                access_token_expiration: self.access_token_expiration,
                refresh_token: self.refresh_token,
                refresh_token_expiration: self.refresh_token_expiration,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("access_token", &"*** Sensitive Data Redacted ***");
            formatter.field("access_token_expiration", &self.access_token_expiration);
            formatter.field("refresh_token", &"*** Sensitive Data Redacted ***");
            formatter.field("refresh_token_expiration", &self.refresh_token_expiration);
            formatter.finish()
        }
    }
}
impl Credentials {
    /// Creates a new builder-style object to manufacture [`Credentials`](crate::model::Credentials).
    pub fn builder() -> crate::model::credentials::Builder {
        crate::model::credentials::Builder::default()
    }
}

/// <p>Data for a user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserData {
    /// <p>Information about the user for the data that is returned. It contains the <code>resourceId</code> and ARN of the user. </p>
    #[doc(hidden)]
    pub user: std::option::Option<crate::model::UserReference>,
    /// <p>Information about the routing profile that is assigned to the user.</p>
    #[doc(hidden)]
    pub routing_profile: std::option::Option<crate::model::RoutingProfileReference>,
    /// <p>Contains information about the levels of a hierarchy group assigned to a user.</p>
    #[doc(hidden)]
    pub hierarchy_path: std::option::Option<crate::model::HierarchyPathReference>,
    /// <p>The status of the agent that they manually set in their Contact Control Panel (CCP), or that the supervisor manually changes in the real-time metrics report.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AgentStatusReference>,
    /// <p>A map of available slots by channel. The key is a channel name. The value is an integer: the available number of slots. </p>
    #[doc(hidden)]
    pub available_slots_by_channel:
        std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
    /// <p>A map of maximum slots by channel. The key is a channel name. The value is an integer: the maximum number of slots. This is calculated from <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_MediaConcurrency.html">MediaConcurrency</a> of the <code>RoutingProfile</code> assigned to the agent. </p>
    #[doc(hidden)]
    pub max_slots_by_channel:
        std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
    /// <p> A map of active slots by channel. The key is a channel name. The value is an integer: the number of active slots. </p>
    #[doc(hidden)]
    pub active_slots_by_channel:
        std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
    /// <p>A list of contact reference information.</p>
    #[doc(hidden)]
    pub contacts: std::option::Option<std::vec::Vec<crate::model::AgentContactReference>>,
    /// <p>The Next status of the agent.</p>
    #[doc(hidden)]
    pub next_status: std::option::Option<std::string::String>,
}
impl UserData {
    /// <p>Information about the user for the data that is returned. It contains the <code>resourceId</code> and ARN of the user. </p>
    pub fn user(&self) -> std::option::Option<&crate::model::UserReference> {
        self.user.as_ref()
    }
    /// <p>Information about the routing profile that is assigned to the user.</p>
    pub fn routing_profile(&self) -> std::option::Option<&crate::model::RoutingProfileReference> {
        self.routing_profile.as_ref()
    }
    /// <p>Contains information about the levels of a hierarchy group assigned to a user.</p>
    pub fn hierarchy_path(&self) -> std::option::Option<&crate::model::HierarchyPathReference> {
        self.hierarchy_path.as_ref()
    }
    /// <p>The status of the agent that they manually set in their Contact Control Panel (CCP), or that the supervisor manually changes in the real-time metrics report.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AgentStatusReference> {
        self.status.as_ref()
    }
    /// <p>A map of available slots by channel. The key is a channel name. The value is an integer: the available number of slots. </p>
    pub fn available_slots_by_channel(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::Channel, i32>> {
        self.available_slots_by_channel.as_ref()
    }
    /// <p>A map of maximum slots by channel. The key is a channel name. The value is an integer: the maximum number of slots. This is calculated from <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_MediaConcurrency.html">MediaConcurrency</a> of the <code>RoutingProfile</code> assigned to the agent. </p>
    pub fn max_slots_by_channel(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::Channel, i32>> {
        self.max_slots_by_channel.as_ref()
    }
    /// <p> A map of active slots by channel. The key is a channel name. The value is an integer: the number of active slots. </p>
    pub fn active_slots_by_channel(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::Channel, i32>> {
        self.active_slots_by_channel.as_ref()
    }
    /// <p>A list of contact reference information.</p>
    pub fn contacts(&self) -> std::option::Option<&[crate::model::AgentContactReference]> {
        self.contacts.as_deref()
    }
    /// <p>The Next status of the agent.</p>
    pub fn next_status(&self) -> std::option::Option<&str> {
        self.next_status.as_deref()
    }
}
/// See [`UserData`](crate::model::UserData).
pub mod user_data {

    /// A builder for [`UserData`](crate::model::UserData).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user: std::option::Option<crate::model::UserReference>,
        pub(crate) routing_profile: std::option::Option<crate::model::RoutingProfileReference>,
        pub(crate) hierarchy_path: std::option::Option<crate::model::HierarchyPathReference>,
        pub(crate) status: std::option::Option<crate::model::AgentStatusReference>,
        pub(crate) available_slots_by_channel:
            std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
        pub(crate) max_slots_by_channel:
            std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
        pub(crate) active_slots_by_channel:
            std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
        pub(crate) contacts:
            std::option::Option<std::vec::Vec<crate::model::AgentContactReference>>,
        pub(crate) next_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Information about the user for the data that is returned. It contains the <code>resourceId</code> and ARN of the user. </p>
        pub fn user(mut self, input: crate::model::UserReference) -> Self {
            self.user = Some(input);
            self
        }
        /// <p>Information about the user for the data that is returned. It contains the <code>resourceId</code> and ARN of the user. </p>
        pub fn set_user(mut self, input: std::option::Option<crate::model::UserReference>) -> Self {
            self.user = input;
            self
        }
        /// <p>Information about the routing profile that is assigned to the user.</p>
        pub fn routing_profile(mut self, input: crate::model::RoutingProfileReference) -> Self {
            self.routing_profile = Some(input);
            self
        }
        /// <p>Information about the routing profile that is assigned to the user.</p>
        pub fn set_routing_profile(
            mut self,
            input: std::option::Option<crate::model::RoutingProfileReference>,
        ) -> Self {
            self.routing_profile = input;
            self
        }
        /// <p>Contains information about the levels of a hierarchy group assigned to a user.</p>
        pub fn hierarchy_path(mut self, input: crate::model::HierarchyPathReference) -> Self {
            self.hierarchy_path = Some(input);
            self
        }
        /// <p>Contains information about the levels of a hierarchy group assigned to a user.</p>
        pub fn set_hierarchy_path(
            mut self,
            input: std::option::Option<crate::model::HierarchyPathReference>,
        ) -> Self {
            self.hierarchy_path = input;
            self
        }
        /// <p>The status of the agent that they manually set in their Contact Control Panel (CCP), or that the supervisor manually changes in the real-time metrics report.</p>
        pub fn status(mut self, input: crate::model::AgentStatusReference) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the agent that they manually set in their Contact Control Panel (CCP), or that the supervisor manually changes in the real-time metrics report.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AgentStatusReference>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Adds a key-value pair to `available_slots_by_channel`.
        ///
        /// To override the contents of this collection use [`set_available_slots_by_channel`](Self::set_available_slots_by_channel).
        ///
        /// <p>A map of available slots by channel. The key is a channel name. The value is an integer: the available number of slots. </p>
        pub fn available_slots_by_channel(mut self, k: crate::model::Channel, v: i32) -> Self {
            let mut hash_map = self.available_slots_by_channel.unwrap_or_default();
            hash_map.insert(k, v);
            self.available_slots_by_channel = Some(hash_map);
            self
        }
        /// <p>A map of available slots by channel. The key is a channel name. The value is an integer: the available number of slots. </p>
        pub fn set_available_slots_by_channel(
            mut self,
            input: std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
        ) -> Self {
            self.available_slots_by_channel = input;
            self
        }
        /// Adds a key-value pair to `max_slots_by_channel`.
        ///
        /// To override the contents of this collection use [`set_max_slots_by_channel`](Self::set_max_slots_by_channel).
        ///
        /// <p>A map of maximum slots by channel. The key is a channel name. The value is an integer: the maximum number of slots. This is calculated from <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_MediaConcurrency.html">MediaConcurrency</a> of the <code>RoutingProfile</code> assigned to the agent. </p>
        pub fn max_slots_by_channel(mut self, k: crate::model::Channel, v: i32) -> Self {
            let mut hash_map = self.max_slots_by_channel.unwrap_or_default();
            hash_map.insert(k, v);
            self.max_slots_by_channel = Some(hash_map);
            self
        }
        /// <p>A map of maximum slots by channel. The key is a channel name. The value is an integer: the maximum number of slots. This is calculated from <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_MediaConcurrency.html">MediaConcurrency</a> of the <code>RoutingProfile</code> assigned to the agent. </p>
        pub fn set_max_slots_by_channel(
            mut self,
            input: std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
        ) -> Self {
            self.max_slots_by_channel = input;
            self
        }
        /// Adds a key-value pair to `active_slots_by_channel`.
        ///
        /// To override the contents of this collection use [`set_active_slots_by_channel`](Self::set_active_slots_by_channel).
        ///
        /// <p> A map of active slots by channel. The key is a channel name. The value is an integer: the number of active slots. </p>
        pub fn active_slots_by_channel(mut self, k: crate::model::Channel, v: i32) -> Self {
            let mut hash_map = self.active_slots_by_channel.unwrap_or_default();
            hash_map.insert(k, v);
            self.active_slots_by_channel = Some(hash_map);
            self
        }
        /// <p> A map of active slots by channel. The key is a channel name. The value is an integer: the number of active slots. </p>
        pub fn set_active_slots_by_channel(
            mut self,
            input: std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
        ) -> Self {
            self.active_slots_by_channel = input;
            self
        }
        /// Appends an item to `contacts`.
        ///
        /// To override the contents of this collection use [`set_contacts`](Self::set_contacts).
        ///
        /// <p>A list of contact reference information.</p>
        pub fn contacts(mut self, input: crate::model::AgentContactReference) -> Self {
            let mut v = self.contacts.unwrap_or_default();
            v.push(input);
            self.contacts = Some(v);
            self
        }
        /// <p>A list of contact reference information.</p>
        pub fn set_contacts(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AgentContactReference>>,
        ) -> Self {
            self.contacts = input;
            self
        }
        /// <p>The Next status of the agent.</p>
        pub fn next_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_status = Some(input.into());
            self
        }
        /// <p>The Next status of the agent.</p>
        pub fn set_next_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_status = input;
            self
        }
        /// Consumes the builder and constructs a [`UserData`](crate::model::UserData).
        pub fn build(self) -> crate::model::UserData {
            crate::model::UserData {
                user: self.user,
                routing_profile: self.routing_profile,
                hierarchy_path: self.hierarchy_path,
                status: self.status,
                available_slots_by_channel: self.available_slots_by_channel,
                max_slots_by_channel: self.max_slots_by_channel,
                active_slots_by_channel: self.active_slots_by_channel,
                contacts: self.contacts,
                next_status: self.next_status,
            }
        }
    }
}
impl UserData {
    /// Creates a new builder-style object to manufacture [`UserData`](crate::model::UserData).
    pub fn builder() -> crate::model::user_data::Builder {
        crate::model::user_data::Builder::default()
    }
}

/// <p>Information about the <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_Contact.html">contact</a> associated to the user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AgentContactReference {
    /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The channel of the contact.</p>
    #[doc(hidden)]
    pub channel: std::option::Option<crate::model::Channel>,
    /// <p>How the contact was initiated.</p>
    #[doc(hidden)]
    pub initiation_method: std::option::Option<crate::model::ContactInitiationMethod>,
    /// <p>The <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">state of the contact</a>.</p>
    #[doc(hidden)]
    pub agent_contact_state: std::option::Option<crate::model::ContactState>,
    /// <p>The epoch timestamp when the contact state started.</p>
    #[doc(hidden)]
    pub state_start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the contact was connected to an agent.</p>
    #[doc(hidden)]
    pub connected_to_agent_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Contains information about a queue resource for which metrics are returned.</p>
    #[doc(hidden)]
    pub queue: std::option::Option<crate::model::QueueReference>,
}
impl AgentContactReference {
    /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The channel of the contact.</p>
    pub fn channel(&self) -> std::option::Option<&crate::model::Channel> {
        self.channel.as_ref()
    }
    /// <p>How the contact was initiated.</p>
    pub fn initiation_method(&self) -> std::option::Option<&crate::model::ContactInitiationMethod> {
        self.initiation_method.as_ref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">state of the contact</a>.</p>
    pub fn agent_contact_state(&self) -> std::option::Option<&crate::model::ContactState> {
        self.agent_contact_state.as_ref()
    }
    /// <p>The epoch timestamp when the contact state started.</p>
    pub fn state_start_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.state_start_timestamp.as_ref()
    }
    /// <p>The time at which the contact was connected to an agent.</p>
    pub fn connected_to_agent_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.connected_to_agent_timestamp.as_ref()
    }
    /// <p>Contains information about a queue resource for which metrics are returned.</p>
    pub fn queue(&self) -> std::option::Option<&crate::model::QueueReference> {
        self.queue.as_ref()
    }
}
/// See [`AgentContactReference`](crate::model::AgentContactReference).
pub mod agent_contact_reference {

    /// A builder for [`AgentContactReference`](crate::model::AgentContactReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) channel: std::option::Option<crate::model::Channel>,
        pub(crate) initiation_method: std::option::Option<crate::model::ContactInitiationMethod>,
        pub(crate) agent_contact_state: std::option::Option<crate::model::ContactState>,
        pub(crate) state_start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) connected_to_agent_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) queue: std::option::Option<crate::model::QueueReference>,
    }
    impl Builder {
        /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The channel of the contact.</p>
        pub fn channel(mut self, input: crate::model::Channel) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>The channel of the contact.</p>
        pub fn set_channel(mut self, input: std::option::Option<crate::model::Channel>) -> Self {
            self.channel = input;
            self
        }
        /// <p>How the contact was initiated.</p>
        pub fn initiation_method(mut self, input: crate::model::ContactInitiationMethod) -> Self {
            self.initiation_method = Some(input);
            self
        }
        /// <p>How the contact was initiated.</p>
        pub fn set_initiation_method(
            mut self,
            input: std::option::Option<crate::model::ContactInitiationMethod>,
        ) -> Self {
            self.initiation_method = input;
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">state of the contact</a>.</p>
        pub fn agent_contact_state(mut self, input: crate::model::ContactState) -> Self {
            self.agent_contact_state = Some(input);
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">state of the contact</a>.</p>
        pub fn set_agent_contact_state(
            mut self,
            input: std::option::Option<crate::model::ContactState>,
        ) -> Self {
            self.agent_contact_state = input;
            self
        }
        /// <p>The epoch timestamp when the contact state started.</p>
        pub fn state_start_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.state_start_timestamp = Some(input);
            self
        }
        /// <p>The epoch timestamp when the contact state started.</p>
        pub fn set_state_start_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.state_start_timestamp = input;
            self
        }
        /// <p>The time at which the contact was connected to an agent.</p>
        pub fn connected_to_agent_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.connected_to_agent_timestamp = Some(input);
            self
        }
        /// <p>The time at which the contact was connected to an agent.</p>
        pub fn set_connected_to_agent_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.connected_to_agent_timestamp = input;
            self
        }
        /// <p>Contains information about a queue resource for which metrics are returned.</p>
        pub fn queue(mut self, input: crate::model::QueueReference) -> Self {
            self.queue = Some(input);
            self
        }
        /// <p>Contains information about a queue resource for which metrics are returned.</p>
        pub fn set_queue(
            mut self,
            input: std::option::Option<crate::model::QueueReference>,
        ) -> Self {
            self.queue = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentContactReference`](crate::model::AgentContactReference).
        pub fn build(self) -> crate::model::AgentContactReference {
            crate::model::AgentContactReference {
                contact_id: self.contact_id,
                channel: self.channel,
                initiation_method: self.initiation_method,
                agent_contact_state: self.agent_contact_state,
                state_start_timestamp: self.state_start_timestamp,
                connected_to_agent_timestamp: self.connected_to_agent_timestamp,
                queue: self.queue,
            }
        }
    }
}
impl AgentContactReference {
    /// Creates a new builder-style object to manufacture [`AgentContactReference`](crate::model::AgentContactReference).
    pub fn builder() -> crate::model::agent_contact_reference::Builder {
        crate::model::agent_contact_reference::Builder::default()
    }
}

/// When writing a match expression against `ContactState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let contactstate = unimplemented!();
/// match contactstate {
///     ContactState::Connected => { /* ... */ },
///     ContactState::ConnectedOnhold => { /* ... */ },
///     ContactState::Connecting => { /* ... */ },
///     ContactState::Ended => { /* ... */ },
///     ContactState::Error => { /* ... */ },
///     ContactState::Incoming => { /* ... */ },
///     ContactState::Missed => { /* ... */ },
///     ContactState::Pending => { /* ... */ },
///     ContactState::Rejected => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `contactstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ContactState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ContactState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ContactState::NewFeature` is defined.
/// Specifically, when `contactstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ContactState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContactState {
    #[allow(missing_docs)] // documentation missing in model
    Connected,
    #[allow(missing_docs)] // documentation missing in model
    ConnectedOnhold,
    #[allow(missing_docs)] // documentation missing in model
    Connecting,
    #[allow(missing_docs)] // documentation missing in model
    Ended,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Incoming,
    #[allow(missing_docs)] // documentation missing in model
    Missed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ContactState {
    fn from(s: &str) -> Self {
        match s {
            "CONNECTED" => ContactState::Connected,
            "CONNECTED_ONHOLD" => ContactState::ConnectedOnhold,
            "CONNECTING" => ContactState::Connecting,
            "ENDED" => ContactState::Ended,
            "ERROR" => ContactState::Error,
            "INCOMING" => ContactState::Incoming,
            "MISSED" => ContactState::Missed,
            "PENDING" => ContactState::Pending,
            "REJECTED" => ContactState::Rejected,
            other => ContactState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ContactState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContactState::from(s))
    }
}
impl ContactState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContactState::Connected => "CONNECTED",
            ContactState::ConnectedOnhold => "CONNECTED_ONHOLD",
            ContactState::Connecting => "CONNECTING",
            ContactState::Ended => "ENDED",
            ContactState::Error => "ERROR",
            ContactState::Incoming => "INCOMING",
            ContactState::Missed => "MISSED",
            ContactState::Pending => "PENDING",
            ContactState::Rejected => "REJECTED",
            ContactState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CONNECTED",
            "CONNECTED_ONHOLD",
            "CONNECTING",
            "ENDED",
            "ERROR",
            "INCOMING",
            "MISSED",
            "PENDING",
            "REJECTED",
        ]
    }
}
impl AsRef<str> for ContactState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ContactInitiationMethod`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let contactinitiationmethod = unimplemented!();
/// match contactinitiationmethod {
///     ContactInitiationMethod::Api => { /* ... */ },
///     ContactInitiationMethod::Callback => { /* ... */ },
///     ContactInitiationMethod::Disconnect => { /* ... */ },
///     ContactInitiationMethod::Inbound => { /* ... */ },
///     ContactInitiationMethod::Monitor => { /* ... */ },
///     ContactInitiationMethod::Outbound => { /* ... */ },
///     ContactInitiationMethod::QueueTransfer => { /* ... */ },
///     ContactInitiationMethod::Transfer => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `contactinitiationmethod` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ContactInitiationMethod::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ContactInitiationMethod::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ContactInitiationMethod::NewFeature` is defined.
/// Specifically, when `contactinitiationmethod` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ContactInitiationMethod::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContactInitiationMethod {
    #[allow(missing_docs)] // documentation missing in model
    Api,
    #[allow(missing_docs)] // documentation missing in model
    Callback,
    #[allow(missing_docs)] // documentation missing in model
    Disconnect,
    #[allow(missing_docs)] // documentation missing in model
    Inbound,
    #[allow(missing_docs)] // documentation missing in model
    Monitor,
    #[allow(missing_docs)] // documentation missing in model
    Outbound,
    #[allow(missing_docs)] // documentation missing in model
    QueueTransfer,
    #[allow(missing_docs)] // documentation missing in model
    Transfer,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ContactInitiationMethod {
    fn from(s: &str) -> Self {
        match s {
            "API" => ContactInitiationMethod::Api,
            "CALLBACK" => ContactInitiationMethod::Callback,
            "DISCONNECT" => ContactInitiationMethod::Disconnect,
            "INBOUND" => ContactInitiationMethod::Inbound,
            "MONITOR" => ContactInitiationMethod::Monitor,
            "OUTBOUND" => ContactInitiationMethod::Outbound,
            "QUEUE_TRANSFER" => ContactInitiationMethod::QueueTransfer,
            "TRANSFER" => ContactInitiationMethod::Transfer,
            other => ContactInitiationMethod::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ContactInitiationMethod {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContactInitiationMethod::from(s))
    }
}
impl ContactInitiationMethod {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContactInitiationMethod::Api => "API",
            ContactInitiationMethod::Callback => "CALLBACK",
            ContactInitiationMethod::Disconnect => "DISCONNECT",
            ContactInitiationMethod::Inbound => "INBOUND",
            ContactInitiationMethod::Monitor => "MONITOR",
            ContactInitiationMethod::Outbound => "OUTBOUND",
            ContactInitiationMethod::QueueTransfer => "QUEUE_TRANSFER",
            ContactInitiationMethod::Transfer => "TRANSFER",
            ContactInitiationMethod::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "API",
            "CALLBACK",
            "DISCONNECT",
            "INBOUND",
            "MONITOR",
            "OUTBOUND",
            "QUEUE_TRANSFER",
            "TRANSFER",
        ]
    }
}
impl AsRef<str> for ContactInitiationMethod {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the agent's status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AgentStatusReference {
    /// <p>The start timestamp of the agent's status.</p>
    #[doc(hidden)]
    pub status_start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) of the agent's status.</p>
    #[doc(hidden)]
    pub status_arn: std::option::Option<std::string::String>,
    /// <p>The name of the agent status.</p>
    #[doc(hidden)]
    pub status_name: std::option::Option<std::string::String>,
}
impl AgentStatusReference {
    /// <p>The start timestamp of the agent's status.</p>
    pub fn status_start_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.status_start_timestamp.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the agent's status.</p>
    pub fn status_arn(&self) -> std::option::Option<&str> {
        self.status_arn.as_deref()
    }
    /// <p>The name of the agent status.</p>
    pub fn status_name(&self) -> std::option::Option<&str> {
        self.status_name.as_deref()
    }
}
/// See [`AgentStatusReference`](crate::model::AgentStatusReference).
pub mod agent_status_reference {

    /// A builder for [`AgentStatusReference`](crate::model::AgentStatusReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status_start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status_arn: std::option::Option<std::string::String>,
        pub(crate) status_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The start timestamp of the agent's status.</p>
        pub fn status_start_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.status_start_timestamp = Some(input);
            self
        }
        /// <p>The start timestamp of the agent's status.</p>
        pub fn set_status_start_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.status_start_timestamp = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the agent's status.</p>
        pub fn status_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the agent's status.</p>
        pub fn set_status_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status_arn = input;
            self
        }
        /// <p>The name of the agent status.</p>
        pub fn status_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_name = Some(input.into());
            self
        }
        /// <p>The name of the agent status.</p>
        pub fn set_status_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentStatusReference`](crate::model::AgentStatusReference).
        pub fn build(self) -> crate::model::AgentStatusReference {
            crate::model::AgentStatusReference {
                status_start_timestamp: self.status_start_timestamp,
                status_arn: self.status_arn,
                status_name: self.status_name,
            }
        }
    }
}
impl AgentStatusReference {
    /// Creates a new builder-style object to manufacture [`AgentStatusReference`](crate::model::AgentStatusReference).
    pub fn builder() -> crate::model::agent_status_reference::Builder {
        crate::model::agent_status_reference::Builder::default()
    }
}

/// <p>Information about the levels in the hierarchy group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HierarchyPathReference {
    /// <p>Information about level one.</p>
    #[doc(hidden)]
    pub level_one: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
    /// <p>Information about level two.</p>
    #[doc(hidden)]
    pub level_two: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
    /// <p>Information about level three.</p>
    #[doc(hidden)]
    pub level_three: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
    /// <p>Information about level four.</p>
    #[doc(hidden)]
    pub level_four: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
    /// <p>Information about level five.</p>
    #[doc(hidden)]
    pub level_five: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
}
impl HierarchyPathReference {
    /// <p>Information about level one.</p>
    pub fn level_one(&self) -> std::option::Option<&crate::model::HierarchyGroupSummaryReference> {
        self.level_one.as_ref()
    }
    /// <p>Information about level two.</p>
    pub fn level_two(&self) -> std::option::Option<&crate::model::HierarchyGroupSummaryReference> {
        self.level_two.as_ref()
    }
    /// <p>Information about level three.</p>
    pub fn level_three(
        &self,
    ) -> std::option::Option<&crate::model::HierarchyGroupSummaryReference> {
        self.level_three.as_ref()
    }
    /// <p>Information about level four.</p>
    pub fn level_four(&self) -> std::option::Option<&crate::model::HierarchyGroupSummaryReference> {
        self.level_four.as_ref()
    }
    /// <p>Information about level five.</p>
    pub fn level_five(&self) -> std::option::Option<&crate::model::HierarchyGroupSummaryReference> {
        self.level_five.as_ref()
    }
}
/// See [`HierarchyPathReference`](crate::model::HierarchyPathReference).
pub mod hierarchy_path_reference {

    /// A builder for [`HierarchyPathReference`](crate::model::HierarchyPathReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) level_one: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        pub(crate) level_two: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        pub(crate) level_three: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        pub(crate) level_four: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        pub(crate) level_five: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
    }
    impl Builder {
        /// <p>Information about level one.</p>
        pub fn level_one(mut self, input: crate::model::HierarchyGroupSummaryReference) -> Self {
            self.level_one = Some(input);
            self
        }
        /// <p>Information about level one.</p>
        pub fn set_level_one(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        ) -> Self {
            self.level_one = input;
            self
        }
        /// <p>Information about level two.</p>
        pub fn level_two(mut self, input: crate::model::HierarchyGroupSummaryReference) -> Self {
            self.level_two = Some(input);
            self
        }
        /// <p>Information about level two.</p>
        pub fn set_level_two(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        ) -> Self {
            self.level_two = input;
            self
        }
        /// <p>Information about level three.</p>
        pub fn level_three(mut self, input: crate::model::HierarchyGroupSummaryReference) -> Self {
            self.level_three = Some(input);
            self
        }
        /// <p>Information about level three.</p>
        pub fn set_level_three(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        ) -> Self {
            self.level_three = input;
            self
        }
        /// <p>Information about level four.</p>
        pub fn level_four(mut self, input: crate::model::HierarchyGroupSummaryReference) -> Self {
            self.level_four = Some(input);
            self
        }
        /// <p>Information about level four.</p>
        pub fn set_level_four(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        ) -> Self {
            self.level_four = input;
            self
        }
        /// <p>Information about level five.</p>
        pub fn level_five(mut self, input: crate::model::HierarchyGroupSummaryReference) -> Self {
            self.level_five = Some(input);
            self
        }
        /// <p>Information about level five.</p>
        pub fn set_level_five(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        ) -> Self {
            self.level_five = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyPathReference`](crate::model::HierarchyPathReference).
        pub fn build(self) -> crate::model::HierarchyPathReference {
            crate::model::HierarchyPathReference {
                level_one: self.level_one,
                level_two: self.level_two,
                level_three: self.level_three,
                level_four: self.level_four,
                level_five: self.level_five,
            }
        }
    }
}
impl HierarchyPathReference {
    /// Creates a new builder-style object to manufacture [`HierarchyPathReference`](crate::model::HierarchyPathReference).
    pub fn builder() -> crate::model::hierarchy_path_reference::Builder {
        crate::model::hierarchy_path_reference::Builder::default()
    }
}

/// <p>Information about the hierarchy group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HierarchyGroupSummaryReference {
    /// <p>The unique identifier for the hierarchy group.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the hierarchy group. </p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl HierarchyGroupSummaryReference {
    /// <p>The unique identifier for the hierarchy group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the hierarchy group. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`HierarchyGroupSummaryReference`](crate::model::HierarchyGroupSummaryReference).
pub mod hierarchy_group_summary_reference {

    /// A builder for [`HierarchyGroupSummaryReference`](crate::model::HierarchyGroupSummaryReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the hierarchy group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the hierarchy group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the hierarchy group. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the hierarchy group. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyGroupSummaryReference`](crate::model::HierarchyGroupSummaryReference).
        pub fn build(self) -> crate::model::HierarchyGroupSummaryReference {
            crate::model::HierarchyGroupSummaryReference {
                id: self.id,
                arn: self.arn,
            }
        }
    }
}
impl HierarchyGroupSummaryReference {
    /// Creates a new builder-style object to manufacture [`HierarchyGroupSummaryReference`](crate::model::HierarchyGroupSummaryReference).
    pub fn builder() -> crate::model::hierarchy_group_summary_reference::Builder {
        crate::model::hierarchy_group_summary_reference::Builder::default()
    }
}

/// <p>Information about the user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserReference {
    /// <p>The unique identifier for the user.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the user.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl UserReference {
    /// <p>The unique identifier for the user.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the user.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`UserReference`](crate::model::UserReference).
pub mod user_reference {

    /// A builder for [`UserReference`](crate::model::UserReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the user.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the user.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the user.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the user.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`UserReference`](crate::model::UserReference).
        pub fn build(self) -> crate::model::UserReference {
            crate::model::UserReference {
                id: self.id,
                arn: self.arn,
            }
        }
    }
}
impl UserReference {
    /// Creates a new builder-style object to manufacture [`UserReference`](crate::model::UserReference).
    pub fn builder() -> crate::model::user_reference::Builder {
        crate::model::user_reference::Builder::default()
    }
}

/// <p>A filter for the user data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserDataFilters {
    /// <p>A list of up to 100 queues or ARNs.</p>
    #[doc(hidden)]
    pub queues: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A filter for the user data based on the contact information that is associated to the user. It contains a list of contact states. </p>
    #[doc(hidden)]
    pub contact_filter: std::option::Option<crate::model::ContactFilter>,
    /// <p>A list of up to 100 routing profile IDs or ARNs.</p>
    #[doc(hidden)]
    pub routing_profiles: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of up to 100 agent IDs or ARNs.</p>
    #[doc(hidden)]
    pub agents: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A UserHierarchyGroup ID or ARN.</p>
    #[doc(hidden)]
    pub user_hierarchy_groups: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UserDataFilters {
    /// <p>A list of up to 100 queues or ARNs.</p>
    pub fn queues(&self) -> std::option::Option<&[std::string::String]> {
        self.queues.as_deref()
    }
    /// <p>A filter for the user data based on the contact information that is associated to the user. It contains a list of contact states. </p>
    pub fn contact_filter(&self) -> std::option::Option<&crate::model::ContactFilter> {
        self.contact_filter.as_ref()
    }
    /// <p>A list of up to 100 routing profile IDs or ARNs.</p>
    pub fn routing_profiles(&self) -> std::option::Option<&[std::string::String]> {
        self.routing_profiles.as_deref()
    }
    /// <p>A list of up to 100 agent IDs or ARNs.</p>
    pub fn agents(&self) -> std::option::Option<&[std::string::String]> {
        self.agents.as_deref()
    }
    /// <p>A UserHierarchyGroup ID or ARN.</p>
    pub fn user_hierarchy_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.user_hierarchy_groups.as_deref()
    }
}
/// See [`UserDataFilters`](crate::model::UserDataFilters).
pub mod user_data_filters {

    /// A builder for [`UserDataFilters`](crate::model::UserDataFilters).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queues: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) contact_filter: std::option::Option<crate::model::ContactFilter>,
        pub(crate) routing_profiles: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) agents: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) user_hierarchy_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `queues`.
        ///
        /// To override the contents of this collection use [`set_queues`](Self::set_queues).
        ///
        /// <p>A list of up to 100 queues or ARNs.</p>
        pub fn queues(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.queues.unwrap_or_default();
            v.push(input.into());
            self.queues = Some(v);
            self
        }
        /// <p>A list of up to 100 queues or ARNs.</p>
        pub fn set_queues(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.queues = input;
            self
        }
        /// <p>A filter for the user data based on the contact information that is associated to the user. It contains a list of contact states. </p>
        pub fn contact_filter(mut self, input: crate::model::ContactFilter) -> Self {
            self.contact_filter = Some(input);
            self
        }
        /// <p>A filter for the user data based on the contact information that is associated to the user. It contains a list of contact states. </p>
        pub fn set_contact_filter(
            mut self,
            input: std::option::Option<crate::model::ContactFilter>,
        ) -> Self {
            self.contact_filter = input;
            self
        }
        /// Appends an item to `routing_profiles`.
        ///
        /// To override the contents of this collection use [`set_routing_profiles`](Self::set_routing_profiles).
        ///
        /// <p>A list of up to 100 routing profile IDs or ARNs.</p>
        pub fn routing_profiles(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.routing_profiles.unwrap_or_default();
            v.push(input.into());
            self.routing_profiles = Some(v);
            self
        }
        /// <p>A list of up to 100 routing profile IDs or ARNs.</p>
        pub fn set_routing_profiles(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.routing_profiles = input;
            self
        }
        /// Appends an item to `agents`.
        ///
        /// To override the contents of this collection use [`set_agents`](Self::set_agents).
        ///
        /// <p>A list of up to 100 agent IDs or ARNs.</p>
        pub fn agents(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.agents.unwrap_or_default();
            v.push(input.into());
            self.agents = Some(v);
            self
        }
        /// <p>A list of up to 100 agent IDs or ARNs.</p>
        pub fn set_agents(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.agents = input;
            self
        }
        /// Appends an item to `user_hierarchy_groups`.
        ///
        /// To override the contents of this collection use [`set_user_hierarchy_groups`](Self::set_user_hierarchy_groups).
        ///
        /// <p>A UserHierarchyGroup ID or ARN.</p>
        pub fn user_hierarchy_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.user_hierarchy_groups.unwrap_or_default();
            v.push(input.into());
            self.user_hierarchy_groups = Some(v);
            self
        }
        /// <p>A UserHierarchyGroup ID or ARN.</p>
        pub fn set_user_hierarchy_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.user_hierarchy_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`UserDataFilters`](crate::model::UserDataFilters).
        pub fn build(self) -> crate::model::UserDataFilters {
            crate::model::UserDataFilters {
                queues: self.queues,
                contact_filter: self.contact_filter,
                routing_profiles: self.routing_profiles,
                agents: self.agents,
                user_hierarchy_groups: self.user_hierarchy_groups,
            }
        }
    }
}
impl UserDataFilters {
    /// Creates a new builder-style object to manufacture [`UserDataFilters`](crate::model::UserDataFilters).
    pub fn builder() -> crate::model::user_data_filters::Builder {
        crate::model::user_data_filters::Builder::default()
    }
}

/// <p>Filters user data based on the contact information that is associated to the users. It contains a list of <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">contact states</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContactFilter {
    /// <p>A list of up to 9 <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">contact states</a>.</p>
    #[doc(hidden)]
    pub contact_states: std::option::Option<std::vec::Vec<crate::model::ContactState>>,
}
impl ContactFilter {
    /// <p>A list of up to 9 <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">contact states</a>.</p>
    pub fn contact_states(&self) -> std::option::Option<&[crate::model::ContactState]> {
        self.contact_states.as_deref()
    }
}
/// See [`ContactFilter`](crate::model::ContactFilter).
pub mod contact_filter {

    /// A builder for [`ContactFilter`](crate::model::ContactFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) contact_states: std::option::Option<std::vec::Vec<crate::model::ContactState>>,
    }
    impl Builder {
        /// Appends an item to `contact_states`.
        ///
        /// To override the contents of this collection use [`set_contact_states`](Self::set_contact_states).
        ///
        /// <p>A list of up to 9 <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">contact states</a>.</p>
        pub fn contact_states(mut self, input: crate::model::ContactState) -> Self {
            let mut v = self.contact_states.unwrap_or_default();
            v.push(input);
            self.contact_states = Some(v);
            self
        }
        /// <p>A list of up to 9 <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">contact states</a>.</p>
        pub fn set_contact_states(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContactState>>,
        ) -> Self {
            self.contact_states = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactFilter`](crate::model::ContactFilter).
        pub fn build(self) -> crate::model::ContactFilter {
            crate::model::ContactFilter {
                contact_states: self.contact_states,
            }
        }
    }
}
impl ContactFilter {
    /// Creates a new builder-style object to manufacture [`ContactFilter`](crate::model::ContactFilter).
    pub fn builder() -> crate::model::contact_filter::Builder {
        crate::model::contact_filter::Builder::default()
    }
}

/// <p>Contains information about a set of real-time metrics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CurrentMetricResult {
    /// <p>The dimensions for the metrics.</p>
    #[doc(hidden)]
    pub dimensions: std::option::Option<crate::model::Dimensions>,
    /// <p>The set of metrics.</p>
    #[doc(hidden)]
    pub collections: std::option::Option<std::vec::Vec<crate::model::CurrentMetricData>>,
}
impl CurrentMetricResult {
    /// <p>The dimensions for the metrics.</p>
    pub fn dimensions(&self) -> std::option::Option<&crate::model::Dimensions> {
        self.dimensions.as_ref()
    }
    /// <p>The set of metrics.</p>
    pub fn collections(&self) -> std::option::Option<&[crate::model::CurrentMetricData]> {
        self.collections.as_deref()
    }
}
/// See [`CurrentMetricResult`](crate::model::CurrentMetricResult).
pub mod current_metric_result {

    /// A builder for [`CurrentMetricResult`](crate::model::CurrentMetricResult).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimensions: std::option::Option<crate::model::Dimensions>,
        pub(crate) collections: std::option::Option<std::vec::Vec<crate::model::CurrentMetricData>>,
    }
    impl Builder {
        /// <p>The dimensions for the metrics.</p>
        pub fn dimensions(mut self, input: crate::model::Dimensions) -> Self {
            self.dimensions = Some(input);
            self
        }
        /// <p>The dimensions for the metrics.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<crate::model::Dimensions>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// Appends an item to `collections`.
        ///
        /// To override the contents of this collection use [`set_collections`](Self::set_collections).
        ///
        /// <p>The set of metrics.</p>
        pub fn collections(mut self, input: crate::model::CurrentMetricData) -> Self {
            let mut v = self.collections.unwrap_or_default();
            v.push(input);
            self.collections = Some(v);
            self
        }
        /// <p>The set of metrics.</p>
        pub fn set_collections(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CurrentMetricData>>,
        ) -> Self {
            self.collections = input;
            self
        }
        /// Consumes the builder and constructs a [`CurrentMetricResult`](crate::model::CurrentMetricResult).
        pub fn build(self) -> crate::model::CurrentMetricResult {
            crate::model::CurrentMetricResult {
                dimensions: self.dimensions,
                collections: self.collections,
            }
        }
    }
}
impl CurrentMetricResult {
    /// Creates a new builder-style object to manufacture [`CurrentMetricResult`](crate::model::CurrentMetricResult).
    pub fn builder() -> crate::model::current_metric_result::Builder {
        crate::model::current_metric_result::Builder::default()
    }
}

/// <p>Contains the data for a real-time metric.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CurrentMetricData {
    /// <p>Information about the metric.</p>
    #[doc(hidden)]
    pub metric: std::option::Option<crate::model::CurrentMetric>,
    /// <p>The value of the metric.</p>
    #[doc(hidden)]
    pub value: std::option::Option<f64>,
}
impl CurrentMetricData {
    /// <p>Information about the metric.</p>
    pub fn metric(&self) -> std::option::Option<&crate::model::CurrentMetric> {
        self.metric.as_ref()
    }
    /// <p>The value of the metric.</p>
    pub fn value(&self) -> std::option::Option<f64> {
        self.value
    }
}
/// See [`CurrentMetricData`](crate::model::CurrentMetricData).
pub mod current_metric_data {

    /// A builder for [`CurrentMetricData`](crate::model::CurrentMetricData).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric: std::option::Option<crate::model::CurrentMetric>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>Information about the metric.</p>
        pub fn metric(mut self, input: crate::model::CurrentMetric) -> Self {
            self.metric = Some(input);
            self
        }
        /// <p>Information about the metric.</p>
        pub fn set_metric(
            mut self,
            input: std::option::Option<crate::model::CurrentMetric>,
        ) -> Self {
            self.metric = input;
            self
        }
        /// <p>The value of the metric.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the metric.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`CurrentMetricData`](crate::model::CurrentMetricData).
        pub fn build(self) -> crate::model::CurrentMetricData {
            crate::model::CurrentMetricData {
                metric: self.metric,
                value: self.value,
            }
        }
    }
}
impl CurrentMetricData {
    /// Creates a new builder-style object to manufacture [`CurrentMetricData`](crate::model::CurrentMetricData).
    pub fn builder() -> crate::model::current_metric_data::Builder {
        crate::model::current_metric_data::Builder::default()
    }
}

/// <p>Contains information about a real-time metric. For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CurrentMetric {
    /// <p>The name of the metric.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::CurrentMetricName>,
    /// <p>The unit for the metric.</p>
    #[doc(hidden)]
    pub unit: std::option::Option<crate::model::Unit>,
}
impl CurrentMetric {
    /// <p>The name of the metric.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::CurrentMetricName> {
        self.name.as_ref()
    }
    /// <p>The unit for the metric.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::Unit> {
        self.unit.as_ref()
    }
}
/// See [`CurrentMetric`](crate::model::CurrentMetric).
pub mod current_metric {

    /// A builder for [`CurrentMetric`](crate::model::CurrentMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::CurrentMetricName>,
        pub(crate) unit: std::option::Option<crate::model::Unit>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn name(mut self, input: crate::model::CurrentMetricName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the metric.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::CurrentMetricName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The unit for the metric.</p>
        pub fn unit(mut self, input: crate::model::Unit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit for the metric.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::Unit>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`CurrentMetric`](crate::model::CurrentMetric).
        pub fn build(self) -> crate::model::CurrentMetric {
            crate::model::CurrentMetric {
                name: self.name,
                unit: self.unit,
            }
        }
    }
}
impl CurrentMetric {
    /// Creates a new builder-style object to manufacture [`CurrentMetric`](crate::model::CurrentMetric).
    pub fn builder() -> crate::model::current_metric::Builder {
        crate::model::current_metric::Builder::default()
    }
}

/// When writing a match expression against `CurrentMetricName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let currentmetricname = unimplemented!();
/// match currentmetricname {
///     CurrentMetricName::AgentsAfterContactWork => { /* ... */ },
///     CurrentMetricName::AgentsAvailable => { /* ... */ },
///     CurrentMetricName::AgentsError => { /* ... */ },
///     CurrentMetricName::AgentsNonProductive => { /* ... */ },
///     CurrentMetricName::AgentsOnline => { /* ... */ },
///     CurrentMetricName::AgentsOnCall => { /* ... */ },
///     CurrentMetricName::AgentsOnContact => { /* ... */ },
///     CurrentMetricName::AgentsStaffed => { /* ... */ },
///     CurrentMetricName::ContactsInQueue => { /* ... */ },
///     CurrentMetricName::ContactsScheduled => { /* ... */ },
///     CurrentMetricName::OldestContactAge => { /* ... */ },
///     CurrentMetricName::SlotsActive => { /* ... */ },
///     CurrentMetricName::SlotsAvailable => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `currentmetricname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CurrentMetricName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CurrentMetricName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CurrentMetricName::NewFeature` is defined.
/// Specifically, when `currentmetricname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CurrentMetricName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The current metric names.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CurrentMetricName {
    #[allow(missing_docs)] // documentation missing in model
    AgentsAfterContactWork,
    #[allow(missing_docs)] // documentation missing in model
    AgentsAvailable,
    #[allow(missing_docs)] // documentation missing in model
    AgentsError,
    #[allow(missing_docs)] // documentation missing in model
    AgentsNonProductive,
    #[allow(missing_docs)] // documentation missing in model
    AgentsOnline,
    #[allow(missing_docs)] // documentation missing in model
    AgentsOnCall,
    #[allow(missing_docs)] // documentation missing in model
    AgentsOnContact,
    #[allow(missing_docs)] // documentation missing in model
    AgentsStaffed,
    #[allow(missing_docs)] // documentation missing in model
    ContactsInQueue,
    #[allow(missing_docs)] // documentation missing in model
    ContactsScheduled,
    #[allow(missing_docs)] // documentation missing in model
    OldestContactAge,
    #[allow(missing_docs)] // documentation missing in model
    SlotsActive,
    #[allow(missing_docs)] // documentation missing in model
    SlotsAvailable,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CurrentMetricName {
    fn from(s: &str) -> Self {
        match s {
            "AGENTS_AFTER_CONTACT_WORK" => CurrentMetricName::AgentsAfterContactWork,
            "AGENTS_AVAILABLE" => CurrentMetricName::AgentsAvailable,
            "AGENTS_ERROR" => CurrentMetricName::AgentsError,
            "AGENTS_NON_PRODUCTIVE" => CurrentMetricName::AgentsNonProductive,
            "AGENTS_ONLINE" => CurrentMetricName::AgentsOnline,
            "AGENTS_ON_CALL" => CurrentMetricName::AgentsOnCall,
            "AGENTS_ON_CONTACT" => CurrentMetricName::AgentsOnContact,
            "AGENTS_STAFFED" => CurrentMetricName::AgentsStaffed,
            "CONTACTS_IN_QUEUE" => CurrentMetricName::ContactsInQueue,
            "CONTACTS_SCHEDULED" => CurrentMetricName::ContactsScheduled,
            "OLDEST_CONTACT_AGE" => CurrentMetricName::OldestContactAge,
            "SLOTS_ACTIVE" => CurrentMetricName::SlotsActive,
            "SLOTS_AVAILABLE" => CurrentMetricName::SlotsAvailable,
            other => {
                CurrentMetricName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CurrentMetricName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CurrentMetricName::from(s))
    }
}
impl CurrentMetricName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CurrentMetricName::AgentsAfterContactWork => "AGENTS_AFTER_CONTACT_WORK",
            CurrentMetricName::AgentsAvailable => "AGENTS_AVAILABLE",
            CurrentMetricName::AgentsError => "AGENTS_ERROR",
            CurrentMetricName::AgentsNonProductive => "AGENTS_NON_PRODUCTIVE",
            CurrentMetricName::AgentsOnline => "AGENTS_ONLINE",
            CurrentMetricName::AgentsOnCall => "AGENTS_ON_CALL",
            CurrentMetricName::AgentsOnContact => "AGENTS_ON_CONTACT",
            CurrentMetricName::AgentsStaffed => "AGENTS_STAFFED",
            CurrentMetricName::ContactsInQueue => "CONTACTS_IN_QUEUE",
            CurrentMetricName::ContactsScheduled => "CONTACTS_SCHEDULED",
            CurrentMetricName::OldestContactAge => "OLDEST_CONTACT_AGE",
            CurrentMetricName::SlotsActive => "SLOTS_ACTIVE",
            CurrentMetricName::SlotsAvailable => "SLOTS_AVAILABLE",
            CurrentMetricName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AGENTS_AFTER_CONTACT_WORK",
            "AGENTS_AVAILABLE",
            "AGENTS_ERROR",
            "AGENTS_NON_PRODUCTIVE",
            "AGENTS_ONLINE",
            "AGENTS_ON_CALL",
            "AGENTS_ON_CONTACT",
            "AGENTS_STAFFED",
            "CONTACTS_IN_QUEUE",
            "CONTACTS_SCHEDULED",
            "OLDEST_CONTACT_AGE",
            "SLOTS_ACTIVE",
            "SLOTS_AVAILABLE",
        ]
    }
}
impl AsRef<str> for CurrentMetricName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The way to sort the resulting response based on metrics. By default resources are sorted based on <code>AGENTS_ONLINE</code>, <code>DESCENDING</code>. The metric collection is sorted based on the input metrics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CurrentMetricSortCriteria {
    /// <p>The current metric names.</p>
    #[doc(hidden)]
    pub sort_by_metric: std::option::Option<crate::model::CurrentMetricName>,
    /// <p>The way to sort.</p>
    #[doc(hidden)]
    pub sort_order: std::option::Option<crate::model::SortOrder>,
}
impl CurrentMetricSortCriteria {
    /// <p>The current metric names.</p>
    pub fn sort_by_metric(&self) -> std::option::Option<&crate::model::CurrentMetricName> {
        self.sort_by_metric.as_ref()
    }
    /// <p>The way to sort.</p>
    pub fn sort_order(&self) -> std::option::Option<&crate::model::SortOrder> {
        self.sort_order.as_ref()
    }
}
/// See [`CurrentMetricSortCriteria`](crate::model::CurrentMetricSortCriteria).
pub mod current_metric_sort_criteria {

    /// A builder for [`CurrentMetricSortCriteria`](crate::model::CurrentMetricSortCriteria).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sort_by_metric: std::option::Option<crate::model::CurrentMetricName>,
        pub(crate) sort_order: std::option::Option<crate::model::SortOrder>,
    }
    impl Builder {
        /// <p>The current metric names.</p>
        pub fn sort_by_metric(mut self, input: crate::model::CurrentMetricName) -> Self {
            self.sort_by_metric = Some(input);
            self
        }
        /// <p>The current metric names.</p>
        pub fn set_sort_by_metric(
            mut self,
            input: std::option::Option<crate::model::CurrentMetricName>,
        ) -> Self {
            self.sort_by_metric = input;
            self
        }
        /// <p>The way to sort.</p>
        pub fn sort_order(mut self, input: crate::model::SortOrder) -> Self {
            self.sort_order = Some(input);
            self
        }
        /// <p>The way to sort.</p>
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::SortOrder>,
        ) -> Self {
            self.sort_order = input;
            self
        }
        /// Consumes the builder and constructs a [`CurrentMetricSortCriteria`](crate::model::CurrentMetricSortCriteria).
        pub fn build(self) -> crate::model::CurrentMetricSortCriteria {
            crate::model::CurrentMetricSortCriteria {
                sort_by_metric: self.sort_by_metric,
                sort_order: self.sort_order,
            }
        }
    }
}
impl CurrentMetricSortCriteria {
    /// Creates a new builder-style object to manufacture [`CurrentMetricSortCriteria`](crate::model::CurrentMetricSortCriteria).
    pub fn builder() -> crate::model::current_metric_sort_criteria::Builder {
        crate::model::current_metric_sort_criteria::Builder::default()
    }
}

/// When writing a match expression against `SortOrder`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sortorder = unimplemented!();
/// match sortorder {
///     SortOrder::Ascending => { /* ... */ },
///     SortOrder::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sortorder` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SortOrder::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SortOrder::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SortOrder::NewFeature` is defined.
/// Specifically, when `sortorder` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SortOrder::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SortOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => SortOrder::Ascending,
            "DESCENDING" => SortOrder::Descending,
            other => SortOrder::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortOrder::from(s))
    }
}
impl SortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortOrder::Ascending => "ASCENDING",
            SortOrder::Descending => "DESCENDING",
            SortOrder::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for SortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about a custom vocabulary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Vocabulary {
    /// <p>A unique name of the custom vocabulary.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier of the custom vocabulary.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
    /// <p>The current state of the custom vocabulary.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::VocabularyState>,
    /// <p>The timestamp when the custom vocabulary was last modified.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The reason why the custom vocabulary was not created.</p>
    #[doc(hidden)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and <code>DisplayAs</code> fields. Separate the fields with TAB characters. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create a custom vocabulary using a table</a>.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Vocabulary {
    /// <p>A unique name of the custom vocabulary.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier of the custom vocabulary.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::VocabularyLanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The current state of the custom vocabulary.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::VocabularyState> {
        self.state.as_ref()
    }
    /// <p>The timestamp when the custom vocabulary was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The reason why the custom vocabulary was not created.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and <code>DisplayAs</code> fields. Separate the fields with TAB characters. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create a custom vocabulary using a table</a>.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`Vocabulary`](crate::model::Vocabulary).
pub mod vocabulary {

    /// A builder for [`Vocabulary`](crate::model::Vocabulary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
        pub(crate) state: std::option::Option<crate::model::VocabularyState>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn language_code(mut self, input: crate::model::VocabularyLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::VocabularyLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The current state of the custom vocabulary.</p>
        pub fn state(mut self, input: crate::model::VocabularyState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the custom vocabulary.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The timestamp when the custom vocabulary was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp when the custom vocabulary was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The reason why the custom vocabulary was not created.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason why the custom vocabulary was not created.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and <code>DisplayAs</code> fields. Separate the fields with TAB characters. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create a custom vocabulary using a table</a>.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and <code>DisplayAs</code> fields. Separate the fields with TAB characters. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create a custom vocabulary using a table</a>.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Vocabulary`](crate::model::Vocabulary).
        pub fn build(self) -> crate::model::Vocabulary {
            crate::model::Vocabulary {
                name: self.name,
                id: self.id,
                arn: self.arn,
                language_code: self.language_code,
                state: self.state,
                last_modified_time: self.last_modified_time,
                failure_reason: self.failure_reason,
                content: self.content,
                tags: self.tags,
            }
        }
    }
}
impl Vocabulary {
    /// Creates a new builder-style object to manufacture [`Vocabulary`](crate::model::Vocabulary).
    pub fn builder() -> crate::model::vocabulary::Builder {
        crate::model::vocabulary::Builder::default()
    }
}

/// <p>Contains information about a hierarchy structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HierarchyStructure {
    /// <p>Information about level one.</p>
    #[doc(hidden)]
    pub level_one: std::option::Option<crate::model::HierarchyLevel>,
    /// <p>Information about level two.</p>
    #[doc(hidden)]
    pub level_two: std::option::Option<crate::model::HierarchyLevel>,
    /// <p>Information about level three.</p>
    #[doc(hidden)]
    pub level_three: std::option::Option<crate::model::HierarchyLevel>,
    /// <p>Information about level four.</p>
    #[doc(hidden)]
    pub level_four: std::option::Option<crate::model::HierarchyLevel>,
    /// <p>Information about level five.</p>
    #[doc(hidden)]
    pub level_five: std::option::Option<crate::model::HierarchyLevel>,
}
impl HierarchyStructure {
    /// <p>Information about level one.</p>
    pub fn level_one(&self) -> std::option::Option<&crate::model::HierarchyLevel> {
        self.level_one.as_ref()
    }
    /// <p>Information about level two.</p>
    pub fn level_two(&self) -> std::option::Option<&crate::model::HierarchyLevel> {
        self.level_two.as_ref()
    }
    /// <p>Information about level three.</p>
    pub fn level_three(&self) -> std::option::Option<&crate::model::HierarchyLevel> {
        self.level_three.as_ref()
    }
    /// <p>Information about level four.</p>
    pub fn level_four(&self) -> std::option::Option<&crate::model::HierarchyLevel> {
        self.level_four.as_ref()
    }
    /// <p>Information about level five.</p>
    pub fn level_five(&self) -> std::option::Option<&crate::model::HierarchyLevel> {
        self.level_five.as_ref()
    }
}
/// See [`HierarchyStructure`](crate::model::HierarchyStructure).
pub mod hierarchy_structure {

    /// A builder for [`HierarchyStructure`](crate::model::HierarchyStructure).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) level_one: std::option::Option<crate::model::HierarchyLevel>,
        pub(crate) level_two: std::option::Option<crate::model::HierarchyLevel>,
        pub(crate) level_three: std::option::Option<crate::model::HierarchyLevel>,
        pub(crate) level_four: std::option::Option<crate::model::HierarchyLevel>,
        pub(crate) level_five: std::option::Option<crate::model::HierarchyLevel>,
    }
    impl Builder {
        /// <p>Information about level one.</p>
        pub fn level_one(mut self, input: crate::model::HierarchyLevel) -> Self {
            self.level_one = Some(input);
            self
        }
        /// <p>Information about level one.</p>
        pub fn set_level_one(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevel>,
        ) -> Self {
            self.level_one = input;
            self
        }
        /// <p>Information about level two.</p>
        pub fn level_two(mut self, input: crate::model::HierarchyLevel) -> Self {
            self.level_two = Some(input);
            self
        }
        /// <p>Information about level two.</p>
        pub fn set_level_two(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevel>,
        ) -> Self {
            self.level_two = input;
            self
        }
        /// <p>Information about level three.</p>
        pub fn level_three(mut self, input: crate::model::HierarchyLevel) -> Self {
            self.level_three = Some(input);
            self
        }
        /// <p>Information about level three.</p>
        pub fn set_level_three(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevel>,
        ) -> Self {
            self.level_three = input;
            self
        }
        /// <p>Information about level four.</p>
        pub fn level_four(mut self, input: crate::model::HierarchyLevel) -> Self {
            self.level_four = Some(input);
            self
        }
        /// <p>Information about level four.</p>
        pub fn set_level_four(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevel>,
        ) -> Self {
            self.level_four = input;
            self
        }
        /// <p>Information about level five.</p>
        pub fn level_five(mut self, input: crate::model::HierarchyLevel) -> Self {
            self.level_five = Some(input);
            self
        }
        /// <p>Information about level five.</p>
        pub fn set_level_five(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevel>,
        ) -> Self {
            self.level_five = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyStructure`](crate::model::HierarchyStructure).
        pub fn build(self) -> crate::model::HierarchyStructure {
            crate::model::HierarchyStructure {
                level_one: self.level_one,
                level_two: self.level_two,
                level_three: self.level_three,
                level_four: self.level_four,
                level_five: self.level_five,
            }
        }
    }
}
impl HierarchyStructure {
    /// Creates a new builder-style object to manufacture [`HierarchyStructure`](crate::model::HierarchyStructure).
    pub fn builder() -> crate::model::hierarchy_structure::Builder {
        crate::model::hierarchy_structure::Builder::default()
    }
}

/// <p>Contains information about a hierarchy level.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HierarchyLevel {
    /// <p>The identifier of the hierarchy level.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the hierarchy level.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the hierarchy level.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl HierarchyLevel {
    /// <p>The identifier of the hierarchy level.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the hierarchy level.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the hierarchy level.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`HierarchyLevel`](crate::model::HierarchyLevel).
pub mod hierarchy_level {

    /// A builder for [`HierarchyLevel`](crate::model::HierarchyLevel).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the hierarchy level.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the hierarchy level.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hierarchy level.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hierarchy level.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the hierarchy level.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hierarchy level.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyLevel`](crate::model::HierarchyLevel).
        pub fn build(self) -> crate::model::HierarchyLevel {
            crate::model::HierarchyLevel {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl HierarchyLevel {
    /// Creates a new builder-style object to manufacture [`HierarchyLevel`](crate::model::HierarchyLevel).
    pub fn builder() -> crate::model::hierarchy_level::Builder {
        crate::model::hierarchy_level::Builder::default()
    }
}

/// <p>Contains information about a hierarchy group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HierarchyGroup {
    /// <p>The identifier of the hierarchy group.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the hierarchy group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier of the level in the hierarchy group.</p>
    #[doc(hidden)]
    pub level_id: std::option::Option<std::string::String>,
    /// <p>Information about the levels in the hierarchy group.</p>
    #[doc(hidden)]
    pub hierarchy_path: std::option::Option<crate::model::HierarchyPath>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl HierarchyGroup {
    /// <p>The identifier of the hierarchy group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the hierarchy group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier of the level in the hierarchy group.</p>
    pub fn level_id(&self) -> std::option::Option<&str> {
        self.level_id.as_deref()
    }
    /// <p>Information about the levels in the hierarchy group.</p>
    pub fn hierarchy_path(&self) -> std::option::Option<&crate::model::HierarchyPath> {
        self.hierarchy_path.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`HierarchyGroup`](crate::model::HierarchyGroup).
pub mod hierarchy_group {

    /// A builder for [`HierarchyGroup`](crate::model::HierarchyGroup).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) level_id: std::option::Option<std::string::String>,
        pub(crate) hierarchy_path: std::option::Option<crate::model::HierarchyPath>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the hierarchy group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the hierarchy group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the hierarchy group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hierarchy group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The identifier of the level in the hierarchy group.</p>
        pub fn level_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.level_id = Some(input.into());
            self
        }
        /// <p>The identifier of the level in the hierarchy group.</p>
        pub fn set_level_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.level_id = input;
            self
        }
        /// <p>Information about the levels in the hierarchy group.</p>
        pub fn hierarchy_path(mut self, input: crate::model::HierarchyPath) -> Self {
            self.hierarchy_path = Some(input);
            self
        }
        /// <p>Information about the levels in the hierarchy group.</p>
        pub fn set_hierarchy_path(
            mut self,
            input: std::option::Option<crate::model::HierarchyPath>,
        ) -> Self {
            self.hierarchy_path = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyGroup`](crate::model::HierarchyGroup).
        pub fn build(self) -> crate::model::HierarchyGroup {
            crate::model::HierarchyGroup {
                id: self.id,
                arn: self.arn,
                name: self.name,
                level_id: self.level_id,
                hierarchy_path: self.hierarchy_path,
                tags: self.tags,
            }
        }
    }
}
impl HierarchyGroup {
    /// Creates a new builder-style object to manufacture [`HierarchyGroup`](crate::model::HierarchyGroup).
    pub fn builder() -> crate::model::hierarchy_group::Builder {
        crate::model::hierarchy_group::Builder::default()
    }
}

/// <p>Contains information about the levels of a hierarchy group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HierarchyPath {
    /// <p>Information about level one.</p>
    #[doc(hidden)]
    pub level_one: std::option::Option<crate::model::HierarchyGroupSummary>,
    /// <p>Information about level two.</p>
    #[doc(hidden)]
    pub level_two: std::option::Option<crate::model::HierarchyGroupSummary>,
    /// <p>Information about level three.</p>
    #[doc(hidden)]
    pub level_three: std::option::Option<crate::model::HierarchyGroupSummary>,
    /// <p>Information about level four.</p>
    #[doc(hidden)]
    pub level_four: std::option::Option<crate::model::HierarchyGroupSummary>,
    /// <p>Information about level five.</p>
    #[doc(hidden)]
    pub level_five: std::option::Option<crate::model::HierarchyGroupSummary>,
}
impl HierarchyPath {
    /// <p>Information about level one.</p>
    pub fn level_one(&self) -> std::option::Option<&crate::model::HierarchyGroupSummary> {
        self.level_one.as_ref()
    }
    /// <p>Information about level two.</p>
    pub fn level_two(&self) -> std::option::Option<&crate::model::HierarchyGroupSummary> {
        self.level_two.as_ref()
    }
    /// <p>Information about level three.</p>
    pub fn level_three(&self) -> std::option::Option<&crate::model::HierarchyGroupSummary> {
        self.level_three.as_ref()
    }
    /// <p>Information about level four.</p>
    pub fn level_four(&self) -> std::option::Option<&crate::model::HierarchyGroupSummary> {
        self.level_four.as_ref()
    }
    /// <p>Information about level five.</p>
    pub fn level_five(&self) -> std::option::Option<&crate::model::HierarchyGroupSummary> {
        self.level_five.as_ref()
    }
}
/// See [`HierarchyPath`](crate::model::HierarchyPath).
pub mod hierarchy_path {

    /// A builder for [`HierarchyPath`](crate::model::HierarchyPath).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) level_one: std::option::Option<crate::model::HierarchyGroupSummary>,
        pub(crate) level_two: std::option::Option<crate::model::HierarchyGroupSummary>,
        pub(crate) level_three: std::option::Option<crate::model::HierarchyGroupSummary>,
        pub(crate) level_four: std::option::Option<crate::model::HierarchyGroupSummary>,
        pub(crate) level_five: std::option::Option<crate::model::HierarchyGroupSummary>,
    }
    impl Builder {
        /// <p>Information about level one.</p>
        pub fn level_one(mut self, input: crate::model::HierarchyGroupSummary) -> Self {
            self.level_one = Some(input);
            self
        }
        /// <p>Information about level one.</p>
        pub fn set_level_one(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummary>,
        ) -> Self {
            self.level_one = input;
            self
        }
        /// <p>Information about level two.</p>
        pub fn level_two(mut self, input: crate::model::HierarchyGroupSummary) -> Self {
            self.level_two = Some(input);
            self
        }
        /// <p>Information about level two.</p>
        pub fn set_level_two(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummary>,
        ) -> Self {
            self.level_two = input;
            self
        }
        /// <p>Information about level three.</p>
        pub fn level_three(mut self, input: crate::model::HierarchyGroupSummary) -> Self {
            self.level_three = Some(input);
            self
        }
        /// <p>Information about level three.</p>
        pub fn set_level_three(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummary>,
        ) -> Self {
            self.level_three = input;
            self
        }
        /// <p>Information about level four.</p>
        pub fn level_four(mut self, input: crate::model::HierarchyGroupSummary) -> Self {
            self.level_four = Some(input);
            self
        }
        /// <p>Information about level four.</p>
        pub fn set_level_four(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummary>,
        ) -> Self {
            self.level_four = input;
            self
        }
        /// <p>Information about level five.</p>
        pub fn level_five(mut self, input: crate::model::HierarchyGroupSummary) -> Self {
            self.level_five = Some(input);
            self
        }
        /// <p>Information about level five.</p>
        pub fn set_level_five(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummary>,
        ) -> Self {
            self.level_five = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyPath`](crate::model::HierarchyPath).
        pub fn build(self) -> crate::model::HierarchyPath {
            crate::model::HierarchyPath {
                level_one: self.level_one,
                level_two: self.level_two,
                level_three: self.level_three,
                level_four: self.level_four,
                level_five: self.level_five,
            }
        }
    }
}
impl HierarchyPath {
    /// Creates a new builder-style object to manufacture [`HierarchyPath`](crate::model::HierarchyPath).
    pub fn builder() -> crate::model::hierarchy_path::Builder {
        crate::model::hierarchy_path::Builder::default()
    }
}

/// <p>Contains information about a user account for an Amazon Connect instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct User {
    /// <p>The identifier of the user account.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the user account.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The user name assigned to the user account.</p>
    #[doc(hidden)]
    pub username: std::option::Option<std::string::String>,
    /// <p>Information about the user identity.</p>
    #[doc(hidden)]
    pub identity_info: std::option::Option<crate::model::UserIdentityInfo>,
    /// <p>Information about the phone configuration for the user.</p>
    #[doc(hidden)]
    pub phone_config: std::option::Option<crate::model::UserPhoneConfig>,
    /// <p>The identifier of the user account in the directory used for identity management.</p>
    #[doc(hidden)]
    pub directory_user_id: std::option::Option<std::string::String>,
    /// <p>The identifiers of the security profiles for the user.</p>
    #[doc(hidden)]
    pub security_profile_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The identifier of the routing profile for the user.</p>
    #[doc(hidden)]
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the hierarchy group for the user.</p>
    #[doc(hidden)]
    pub hierarchy_group_id: std::option::Option<std::string::String>,
    /// <p>The tags.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl User {
    /// <p>The identifier of the user account.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the user account.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The user name assigned to the user account.</p>
    pub fn username(&self) -> std::option::Option<&str> {
        self.username.as_deref()
    }
    /// <p>Information about the user identity.</p>
    pub fn identity_info(&self) -> std::option::Option<&crate::model::UserIdentityInfo> {
        self.identity_info.as_ref()
    }
    /// <p>Information about the phone configuration for the user.</p>
    pub fn phone_config(&self) -> std::option::Option<&crate::model::UserPhoneConfig> {
        self.phone_config.as_ref()
    }
    /// <p>The identifier of the user account in the directory used for identity management.</p>
    pub fn directory_user_id(&self) -> std::option::Option<&str> {
        self.directory_user_id.as_deref()
    }
    /// <p>The identifiers of the security profiles for the user.</p>
    pub fn security_profile_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_profile_ids.as_deref()
    }
    /// <p>The identifier of the routing profile for the user.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The identifier of the hierarchy group for the user.</p>
    pub fn hierarchy_group_id(&self) -> std::option::Option<&str> {
        self.hierarchy_group_id.as_deref()
    }
    /// <p>The tags.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`User`](crate::model::User).
pub mod user {

    /// A builder for [`User`](crate::model::User).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) username: std::option::Option<std::string::String>,
        pub(crate) identity_info: std::option::Option<crate::model::UserIdentityInfo>,
        pub(crate) phone_config: std::option::Option<crate::model::UserPhoneConfig>,
        pub(crate) directory_user_id: std::option::Option<std::string::String>,
        pub(crate) security_profile_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) hierarchy_group_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the user account.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user account.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user account.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The user name assigned to the user account.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        /// <p>The user name assigned to the user account.</p>
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input;
            self
        }
        /// <p>Information about the user identity.</p>
        pub fn identity_info(mut self, input: crate::model::UserIdentityInfo) -> Self {
            self.identity_info = Some(input);
            self
        }
        /// <p>Information about the user identity.</p>
        pub fn set_identity_info(
            mut self,
            input: std::option::Option<crate::model::UserIdentityInfo>,
        ) -> Self {
            self.identity_info = input;
            self
        }
        /// <p>Information about the phone configuration for the user.</p>
        pub fn phone_config(mut self, input: crate::model::UserPhoneConfig) -> Self {
            self.phone_config = Some(input);
            self
        }
        /// <p>Information about the phone configuration for the user.</p>
        pub fn set_phone_config(
            mut self,
            input: std::option::Option<crate::model::UserPhoneConfig>,
        ) -> Self {
            self.phone_config = input;
            self
        }
        /// <p>The identifier of the user account in the directory used for identity management.</p>
        pub fn directory_user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account in the directory used for identity management.</p>
        pub fn set_directory_user_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.directory_user_id = input;
            self
        }
        /// Appends an item to `security_profile_ids`.
        ///
        /// To override the contents of this collection use [`set_security_profile_ids`](Self::set_security_profile_ids).
        ///
        /// <p>The identifiers of the security profiles for the user.</p>
        pub fn security_profile_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_profile_ids.unwrap_or_default();
            v.push(input.into());
            self.security_profile_ids = Some(v);
            self
        }
        /// <p>The identifiers of the security profiles for the user.</p>
        pub fn set_security_profile_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_profile_ids = input;
            self
        }
        /// <p>The identifier of the routing profile for the user.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile for the user.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// <p>The identifier of the hierarchy group for the user.</p>
        pub fn hierarchy_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the hierarchy group for the user.</p>
        pub fn set_hierarchy_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hierarchy_group_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`User`](crate::model::User).
        pub fn build(self) -> crate::model::User {
            crate::model::User {
                id: self.id,
                arn: self.arn,
                username: self.username,
                identity_info: self.identity_info,
                phone_config: self.phone_config,
                directory_user_id: self.directory_user_id,
                security_profile_ids: self.security_profile_ids,
                routing_profile_id: self.routing_profile_id,
                hierarchy_group_id: self.hierarchy_group_id,
                tags: self.tags,
            }
        }
    }
}
impl User {
    /// Creates a new builder-style object to manufacture [`User`](crate::model::User).
    pub fn builder() -> crate::model::user::Builder {
        crate::model::user::Builder::default()
    }
}

/// <p>Information about a traffic distribution group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TrafficDistributionGroup {
    /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the traffic distribution group.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the traffic distribution group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the traffic distribution group.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN).</p>
    #[doc(hidden)]
    pub instance_arn: std::option::Option<std::string::String>,
    /// <p>The status of the traffic distribution group.</p>
    /// <ul>
    /// <li> <p> <code>CREATION_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
    /// <li> <p> <code>ACTIVE</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has succeeded.</p> </li>
    /// <li> <p> <code>CREATION_FAILED</code> indicates that the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has failed.</p> </li>
    /// <li> <p> <code>PENDING_DELETION</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
    /// <li> <p> <code>DELETION_FAILED</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation has failed.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistributionGroup.html">UpdateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TrafficDistributionGroupStatus>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl TrafficDistributionGroup {
    /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the traffic distribution group.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the traffic distribution group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the traffic distribution group.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN).</p>
    pub fn instance_arn(&self) -> std::option::Option<&str> {
        self.instance_arn.as_deref()
    }
    /// <p>The status of the traffic distribution group.</p>
    /// <ul>
    /// <li> <p> <code>CREATION_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
    /// <li> <p> <code>ACTIVE</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has succeeded.</p> </li>
    /// <li> <p> <code>CREATION_FAILED</code> indicates that the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has failed.</p> </li>
    /// <li> <p> <code>PENDING_DELETION</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
    /// <li> <p> <code>DELETION_FAILED</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation has failed.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistributionGroup.html">UpdateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::TrafficDistributionGroupStatus> {
        self.status.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`TrafficDistributionGroup`](crate::model::TrafficDistributionGroup).
pub mod traffic_distribution_group {

    /// A builder for [`TrafficDistributionGroup`](crate::model::TrafficDistributionGroup).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) instance_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TrafficDistributionGroupStatus>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the traffic distribution group.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the traffic distribution group.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the traffic distribution group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the traffic distribution group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the traffic distribution group.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the traffic distribution group.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN).</p>
        pub fn instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN).</p>
        pub fn set_instance_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_arn = input;
            self
        }
        /// <p>The status of the traffic distribution group.</p>
        /// <ul>
        /// <li> <p> <code>CREATION_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
        /// <li> <p> <code>ACTIVE</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has succeeded.</p> </li>
        /// <li> <p> <code>CREATION_FAILED</code> indicates that the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has failed.</p> </li>
        /// <li> <p> <code>PENDING_DELETION</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
        /// <li> <p> <code>DELETION_FAILED</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation has failed.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistributionGroup.html">UpdateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::TrafficDistributionGroupStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the traffic distribution group.</p>
        /// <ul>
        /// <li> <p> <code>CREATION_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
        /// <li> <p> <code>ACTIVE</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has succeeded.</p> </li>
        /// <li> <p> <code>CREATION_FAILED</code> indicates that the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a> operation has failed.</p> </li>
        /// <li> <p> <code>PENDING_DELETION</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
        /// <li> <p> <code>DELETION_FAILED</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a> operation has failed.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistributionGroup.html">UpdateTrafficDistributionGroup</a> operation is still in progress and has not yet completed.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TrafficDistributionGroupStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TrafficDistributionGroup`](crate::model::TrafficDistributionGroup).
        pub fn build(self) -> crate::model::TrafficDistributionGroup {
            crate::model::TrafficDistributionGroup {
                id: self.id,
                arn: self.arn,
                name: self.name,
                description: self.description,
                instance_arn: self.instance_arn,
                status: self.status,
                tags: self.tags,
            }
        }
    }
}
impl TrafficDistributionGroup {
    /// Creates a new builder-style object to manufacture [`TrafficDistributionGroup`](crate::model::TrafficDistributionGroup).
    pub fn builder() -> crate::model::traffic_distribution_group::Builder {
        crate::model::traffic_distribution_group::Builder::default()
    }
}

/// <p>Contains information about a security profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SecurityProfile {
    /// <p>The identifier for the security profile.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The organization resource identifier for the security profile.</p>
    #[doc(hidden)]
    pub organization_resource_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the secruity profile.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name for the security profile.</p>
    #[doc(hidden)]
    pub security_profile_name: std::option::Option<std::string::String>,
    /// <p>The description of the security profile.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The list of tags that a security profile uses to restrict access to resources in Amazon Connect.</p>
    #[doc(hidden)]
    pub allowed_access_control_tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The list of resources that a security profile applies tag restrictions to in Amazon Connect.</p>
    #[doc(hidden)]
    pub tag_restricted_resources: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl SecurityProfile {
    /// <p>The identifier for the security profile.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The organization resource identifier for the security profile.</p>
    pub fn organization_resource_id(&self) -> std::option::Option<&str> {
        self.organization_resource_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the secruity profile.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name for the security profile.</p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
    /// <p>The description of the security profile.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The list of tags that a security profile uses to restrict access to resources in Amazon Connect.</p>
    pub fn allowed_access_control_tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.allowed_access_control_tags.as_ref()
    }
    /// <p>The list of resources that a security profile applies tag restrictions to in Amazon Connect.</p>
    pub fn tag_restricted_resources(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_restricted_resources.as_deref()
    }
}
/// See [`SecurityProfile`](crate::model::SecurityProfile).
pub mod security_profile {

    /// A builder for [`SecurityProfile`](crate::model::SecurityProfile).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) organization_resource_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) allowed_access_control_tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) tag_restricted_resources:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The identifier for the security profile.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier for the security profile.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The organization resource identifier for the security profile.</p>
        pub fn organization_resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.organization_resource_id = Some(input.into());
            self
        }
        /// <p>The organization resource identifier for the security profile.</p>
        pub fn set_organization_resource_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_resource_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the secruity profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the secruity profile.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name for the security profile.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p>The name for the security profile.</p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// <p>The description of the security profile.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the security profile.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Adds a key-value pair to `allowed_access_control_tags`.
        ///
        /// To override the contents of this collection use [`set_allowed_access_control_tags`](Self::set_allowed_access_control_tags).
        ///
        /// <p>The list of tags that a security profile uses to restrict access to resources in Amazon Connect.</p>
        pub fn allowed_access_control_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.allowed_access_control_tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.allowed_access_control_tags = Some(hash_map);
            self
        }
        /// <p>The list of tags that a security profile uses to restrict access to resources in Amazon Connect.</p>
        pub fn set_allowed_access_control_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.allowed_access_control_tags = input;
            self
        }
        /// Appends an item to `tag_restricted_resources`.
        ///
        /// To override the contents of this collection use [`set_tag_restricted_resources`](Self::set_tag_restricted_resources).
        ///
        /// <p>The list of resources that a security profile applies tag restrictions to in Amazon Connect.</p>
        pub fn tag_restricted_resources(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_restricted_resources.unwrap_or_default();
            v.push(input.into());
            self.tag_restricted_resources = Some(v);
            self
        }
        /// <p>The list of resources that a security profile applies tag restrictions to in Amazon Connect.</p>
        pub fn set_tag_restricted_resources(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_restricted_resources = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityProfile`](crate::model::SecurityProfile).
        pub fn build(self) -> crate::model::SecurityProfile {
            crate::model::SecurityProfile {
                id: self.id,
                organization_resource_id: self.organization_resource_id,
                arn: self.arn,
                security_profile_name: self.security_profile_name,
                description: self.description,
                tags: self.tags,
                allowed_access_control_tags: self.allowed_access_control_tags,
                tag_restricted_resources: self.tag_restricted_resources,
            }
        }
    }
}
impl SecurityProfile {
    /// Creates a new builder-style object to manufacture [`SecurityProfile`](crate::model::SecurityProfile).
    pub fn builder() -> crate::model::security_profile::Builder {
        crate::model::security_profile::Builder::default()
    }
}

/// <p>Information about a rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Rule {
    /// <p>The name of the rule.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the rule.</p>
    #[doc(hidden)]
    pub rule_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    #[doc(hidden)]
    pub rule_arn: std::option::Option<std::string::String>,
    /// <p>The event source to trigger the rule.</p>
    #[doc(hidden)]
    pub trigger_event_source: std::option::Option<crate::model::RuleTriggerEventSource>,
    /// <p>The conditions of the rule.</p>
    #[doc(hidden)]
    pub function: std::option::Option<std::string::String>,
    /// <p>A list of actions to be run when the rule is triggered.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::RuleAction>>,
    /// <p>The publish status of the rule.</p>
    #[doc(hidden)]
    pub publish_status: std::option::Option<crate::model::RulePublishStatus>,
    /// <p>The timestamp for when the rule was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp for the when the rule was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) of the user who last updated the rule.</p>
    #[doc(hidden)]
    pub last_updated_by: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Rule {
    /// <p>The name of the rule.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A unique identifier for the rule.</p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    pub fn rule_arn(&self) -> std::option::Option<&str> {
        self.rule_arn.as_deref()
    }
    /// <p>The event source to trigger the rule.</p>
    pub fn trigger_event_source(
        &self,
    ) -> std::option::Option<&crate::model::RuleTriggerEventSource> {
        self.trigger_event_source.as_ref()
    }
    /// <p>The conditions of the rule.</p>
    pub fn function(&self) -> std::option::Option<&str> {
        self.function.as_deref()
    }
    /// <p>A list of actions to be run when the rule is triggered.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::RuleAction]> {
        self.actions.as_deref()
    }
    /// <p>The publish status of the rule.</p>
    pub fn publish_status(&self) -> std::option::Option<&crate::model::RulePublishStatus> {
        self.publish_status.as_ref()
    }
    /// <p>The timestamp for when the rule was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The timestamp for the when the rule was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the user who last updated the rule.</p>
    pub fn last_updated_by(&self) -> std::option::Option<&str> {
        self.last_updated_by.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`Rule`](crate::model::Rule).
pub mod rule {

    /// A builder for [`Rule`](crate::model::Rule).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) rule_id: std::option::Option<std::string::String>,
        pub(crate) rule_arn: std::option::Option<std::string::String>,
        pub(crate) trigger_event_source: std::option::Option<crate::model::RuleTriggerEventSource>,
        pub(crate) function: std::option::Option<std::string::String>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::RuleAction>>,
        pub(crate) publish_status: std::option::Option<crate::model::RulePublishStatus>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_by: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the rule.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the rule.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique identifier for the rule.</p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the rule.</p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the rule.</p>
        pub fn rule_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the rule.</p>
        pub fn set_rule_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_arn = input;
            self
        }
        /// <p>The event source to trigger the rule.</p>
        pub fn trigger_event_source(mut self, input: crate::model::RuleTriggerEventSource) -> Self {
            self.trigger_event_source = Some(input);
            self
        }
        /// <p>The event source to trigger the rule.</p>
        pub fn set_trigger_event_source(
            mut self,
            input: std::option::Option<crate::model::RuleTriggerEventSource>,
        ) -> Self {
            self.trigger_event_source = input;
            self
        }
        /// <p>The conditions of the rule.</p>
        pub fn function(mut self, input: impl Into<std::string::String>) -> Self {
            self.function = Some(input.into());
            self
        }
        /// <p>The conditions of the rule.</p>
        pub fn set_function(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>A list of actions to be run when the rule is triggered.</p>
        pub fn actions(mut self, input: crate::model::RuleAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>A list of actions to be run when the rule is triggered.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RuleAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// <p>The publish status of the rule.</p>
        pub fn publish_status(mut self, input: crate::model::RulePublishStatus) -> Self {
            self.publish_status = Some(input);
            self
        }
        /// <p>The publish status of the rule.</p>
        pub fn set_publish_status(
            mut self,
            input: std::option::Option<crate::model::RulePublishStatus>,
        ) -> Self {
            self.publish_status = input;
            self
        }
        /// <p>The timestamp for when the rule was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The timestamp for when the rule was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The timestamp for the when the rule was last updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The timestamp for the when the rule was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user who last updated the rule.</p>
        pub fn last_updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_by = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user who last updated the rule.</p>
        pub fn set_last_updated_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_by = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Rule`](crate::model::Rule).
        pub fn build(self) -> crate::model::Rule {
            crate::model::Rule {
                name: self.name,
                rule_id: self.rule_id,
                rule_arn: self.rule_arn,
                trigger_event_source: self.trigger_event_source,
                function: self.function,
                actions: self.actions,
                publish_status: self.publish_status,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
                last_updated_by: self.last_updated_by,
                tags: self.tags,
            }
        }
    }
}
impl Rule {
    /// Creates a new builder-style object to manufacture [`Rule`](crate::model::Rule).
    pub fn builder() -> crate::model::rule::Builder {
        crate::model::rule::Builder::default()
    }
}

/// <p>The name of the event source. This field is required if <code>TriggerEventSource</code> is one of the following values: <code>OnZendeskTicketCreate</code> | <code>OnZendeskTicketStatusUpdate</code> | <code>OnSalesforceCaseCreate</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RuleTriggerEventSource {
    /// <p>The name of the event source.</p>
    #[doc(hidden)]
    pub event_source_name: std::option::Option<crate::model::EventSourceName>,
    /// <p>The identifier for the integration association.</p>
    #[doc(hidden)]
    pub integration_association_id: std::option::Option<std::string::String>,
}
impl RuleTriggerEventSource {
    /// <p>The name of the event source.</p>
    pub fn event_source_name(&self) -> std::option::Option<&crate::model::EventSourceName> {
        self.event_source_name.as_ref()
    }
    /// <p>The identifier for the integration association.</p>
    pub fn integration_association_id(&self) -> std::option::Option<&str> {
        self.integration_association_id.as_deref()
    }
}
/// See [`RuleTriggerEventSource`](crate::model::RuleTriggerEventSource).
pub mod rule_trigger_event_source {

    /// A builder for [`RuleTriggerEventSource`](crate::model::RuleTriggerEventSource).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_source_name: std::option::Option<crate::model::EventSourceName>,
        pub(crate) integration_association_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the event source.</p>
        pub fn event_source_name(mut self, input: crate::model::EventSourceName) -> Self {
            self.event_source_name = Some(input);
            self
        }
        /// <p>The name of the event source.</p>
        pub fn set_event_source_name(
            mut self,
            input: std::option::Option<crate::model::EventSourceName>,
        ) -> Self {
            self.event_source_name = input;
            self
        }
        /// <p>The identifier for the integration association.</p>
        pub fn integration_association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.integration_association_id = Some(input.into());
            self
        }
        /// <p>The identifier for the integration association.</p>
        pub fn set_integration_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.integration_association_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleTriggerEventSource`](crate::model::RuleTriggerEventSource).
        pub fn build(self) -> crate::model::RuleTriggerEventSource {
            crate::model::RuleTriggerEventSource {
                event_source_name: self.event_source_name,
                integration_association_id: self.integration_association_id,
            }
        }
    }
}
impl RuleTriggerEventSource {
    /// Creates a new builder-style object to manufacture [`RuleTriggerEventSource`](crate::model::RuleTriggerEventSource).
    pub fn builder() -> crate::model::rule_trigger_event_source::Builder {
        crate::model::rule_trigger_event_source::Builder::default()
    }
}

/// <p>Contains information about a quick connect.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QuickConnect {
    /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
    #[doc(hidden)]
    pub quick_connect_arn: std::option::Option<std::string::String>,
    /// <p>The identifier for the quick connect.</p>
    #[doc(hidden)]
    pub quick_connect_id: std::option::Option<std::string::String>,
    /// <p>The name of the quick connect.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Contains information about the quick connect.</p>
    #[doc(hidden)]
    pub quick_connect_config: std::option::Option<crate::model::QuickConnectConfig>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl QuickConnect {
    /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
    pub fn quick_connect_arn(&self) -> std::option::Option<&str> {
        self.quick_connect_arn.as_deref()
    }
    /// <p>The identifier for the quick connect.</p>
    pub fn quick_connect_id(&self) -> std::option::Option<&str> {
        self.quick_connect_id.as_deref()
    }
    /// <p>The name of the quick connect.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Contains information about the quick connect.</p>
    pub fn quick_connect_config(&self) -> std::option::Option<&crate::model::QuickConnectConfig> {
        self.quick_connect_config.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`QuickConnect`](crate::model::QuickConnect).
pub mod quick_connect {

    /// A builder for [`QuickConnect`](crate::model::QuickConnect).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) quick_connect_arn: std::option::Option<std::string::String>,
        pub(crate) quick_connect_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) quick_connect_config: std::option::Option<crate::model::QuickConnectConfig>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
        pub fn quick_connect_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.quick_connect_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
        pub fn set_quick_connect_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.quick_connect_arn = input;
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn quick_connect_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.quick_connect_id = Some(input.into());
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn set_quick_connect_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.quick_connect_id = input;
            self
        }
        /// <p>The name of the quick connect.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the quick connect.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Contains information about the quick connect.</p>
        pub fn quick_connect_config(mut self, input: crate::model::QuickConnectConfig) -> Self {
            self.quick_connect_config = Some(input);
            self
        }
        /// <p>Contains information about the quick connect.</p>
        pub fn set_quick_connect_config(
            mut self,
            input: std::option::Option<crate::model::QuickConnectConfig>,
        ) -> Self {
            self.quick_connect_config = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`QuickConnect`](crate::model::QuickConnect).
        pub fn build(self) -> crate::model::QuickConnect {
            crate::model::QuickConnect {
                quick_connect_arn: self.quick_connect_arn,
                quick_connect_id: self.quick_connect_id,
                name: self.name,
                description: self.description,
                quick_connect_config: self.quick_connect_config,
                tags: self.tags,
            }
        }
    }
}
impl QuickConnect {
    /// Creates a new builder-style object to manufacture [`QuickConnect`](crate::model::QuickConnect).
    pub fn builder() -> crate::model::quick_connect::Builder {
        crate::model::quick_connect::Builder::default()
    }
}

/// <p>Information about a phone number that has been claimed to your Amazon Connect instance or traffic distribution group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClaimedPhoneNumberSummary {
    /// <p>A unique identifier for the phone number.</p>
    #[doc(hidden)]
    pub phone_number_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
    #[doc(hidden)]
    pub phone_number_arn: std::option::Option<std::string::String>,
    /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    #[doc(hidden)]
    pub phone_number: std::option::Option<std::string::String>,
    /// <p>The ISO country code.</p>
    #[doc(hidden)]
    pub phone_number_country_code: std::option::Option<crate::model::PhoneNumberCountryCode>,
    /// <p>The type of phone number.</p>
    #[doc(hidden)]
    pub phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
    /// <p>The description of the phone number.</p>
    #[doc(hidden)]
    pub phone_number_description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
    #[doc(hidden)]
    pub target_arn: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The status of the phone number.</p>
    /// <ul>
    /// <li> <p> <code>CLAIMED</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation succeeded.</p> </li>
    /// <li> <p> <code>IN_PROGRESS</code> means a <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation is still in progress and has not yet completed. You can call <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html">DescribePhoneNumber</a> at a later time to verify if the previous operation has completed.</p> </li>
    /// <li> <p> <code>FAILED</code> indicates that the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation has failed. It will include a message indicating the failure reason. A common reason for a failure may be that the <code>TargetArn</code> value you are claiming or updating a phone number to has reached its limit of total claimed numbers. If you received a <code>FAILED</code> status from a <code>ClaimPhoneNumber</code> API call, you have one day to retry claiming the phone number before the number is released back to the inventory for other customers to claim.</p> </li>
    /// </ul> <note>
    /// <p>You will not be billed for the phone number during the 1-day period if number claiming fails. </p>
    /// </note>
    #[doc(hidden)]
    pub phone_number_status: std::option::Option<crate::model::PhoneNumberStatus>,
}
impl ClaimedPhoneNumberSummary {
    /// <p>A unique identifier for the phone number.</p>
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
    pub fn phone_number_arn(&self) -> std::option::Option<&str> {
        self.phone_number_arn.as_deref()
    }
    /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
    /// <p>The ISO country code.</p>
    pub fn phone_number_country_code(
        &self,
    ) -> std::option::Option<&crate::model::PhoneNumberCountryCode> {
        self.phone_number_country_code.as_ref()
    }
    /// <p>The type of phone number.</p>
    pub fn phone_number_type(&self) -> std::option::Option<&crate::model::PhoneNumberType> {
        self.phone_number_type.as_ref()
    }
    /// <p>The description of the phone number.</p>
    pub fn phone_number_description(&self) -> std::option::Option<&str> {
        self.phone_number_description.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
    pub fn target_arn(&self) -> std::option::Option<&str> {
        self.target_arn.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The status of the phone number.</p>
    /// <ul>
    /// <li> <p> <code>CLAIMED</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation succeeded.</p> </li>
    /// <li> <p> <code>IN_PROGRESS</code> means a <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation is still in progress and has not yet completed. You can call <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html">DescribePhoneNumber</a> at a later time to verify if the previous operation has completed.</p> </li>
    /// <li> <p> <code>FAILED</code> indicates that the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation has failed. It will include a message indicating the failure reason. A common reason for a failure may be that the <code>TargetArn</code> value you are claiming or updating a phone number to has reached its limit of total claimed numbers. If you received a <code>FAILED</code> status from a <code>ClaimPhoneNumber</code> API call, you have one day to retry claiming the phone number before the number is released back to the inventory for other customers to claim.</p> </li>
    /// </ul> <note>
    /// <p>You will not be billed for the phone number during the 1-day period if number claiming fails. </p>
    /// </note>
    pub fn phone_number_status(&self) -> std::option::Option<&crate::model::PhoneNumberStatus> {
        self.phone_number_status.as_ref()
    }
}
/// See [`ClaimedPhoneNumberSummary`](crate::model::ClaimedPhoneNumberSummary).
pub mod claimed_phone_number_summary {

    /// A builder for [`ClaimedPhoneNumberSummary`](crate::model::ClaimedPhoneNumberSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
        pub(crate) phone_number_arn: std::option::Option<std::string::String>,
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) phone_number_country_code:
            std::option::Option<crate::model::PhoneNumberCountryCode>,
        pub(crate) phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
        pub(crate) phone_number_description: std::option::Option<std::string::String>,
        pub(crate) target_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) phone_number_status: std::option::Option<crate::model::PhoneNumberStatus>,
    }
    impl Builder {
        /// <p>A unique identifier for the phone number.</p>
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the phone number.</p>
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
        pub fn phone_number_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
        pub fn set_phone_number_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_arn = input;
            self
        }
        /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// <p>The ISO country code.</p>
        pub fn phone_number_country_code(
            mut self,
            input: crate::model::PhoneNumberCountryCode,
        ) -> Self {
            self.phone_number_country_code = Some(input);
            self
        }
        /// <p>The ISO country code.</p>
        pub fn set_phone_number_country_code(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberCountryCode>,
        ) -> Self {
            self.phone_number_country_code = input;
            self
        }
        /// <p>The type of phone number.</p>
        pub fn phone_number_type(mut self, input: crate::model::PhoneNumberType) -> Self {
            self.phone_number_type = Some(input);
            self
        }
        /// <p>The type of phone number.</p>
        pub fn set_phone_number_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberType>,
        ) -> Self {
            self.phone_number_type = input;
            self
        }
        /// <p>The description of the phone number.</p>
        pub fn phone_number_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_description = Some(input.into());
            self
        }
        /// <p>The description of the phone number.</p>
        pub fn set_phone_number_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_description = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The status of the phone number.</p>
        /// <ul>
        /// <li> <p> <code>CLAIMED</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation succeeded.</p> </li>
        /// <li> <p> <code>IN_PROGRESS</code> means a <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation is still in progress and has not yet completed. You can call <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html">DescribePhoneNumber</a> at a later time to verify if the previous operation has completed.</p> </li>
        /// <li> <p> <code>FAILED</code> indicates that the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation has failed. It will include a message indicating the failure reason. A common reason for a failure may be that the <code>TargetArn</code> value you are claiming or updating a phone number to has reached its limit of total claimed numbers. If you received a <code>FAILED</code> status from a <code>ClaimPhoneNumber</code> API call, you have one day to retry claiming the phone number before the number is released back to the inventory for other customers to claim.</p> </li>
        /// </ul> <note>
        /// <p>You will not be billed for the phone number during the 1-day period if number claiming fails. </p>
        /// </note>
        pub fn phone_number_status(mut self, input: crate::model::PhoneNumberStatus) -> Self {
            self.phone_number_status = Some(input);
            self
        }
        /// <p>The status of the phone number.</p>
        /// <ul>
        /// <li> <p> <code>CLAIMED</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation succeeded.</p> </li>
        /// <li> <p> <code>IN_PROGRESS</code> means a <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation is still in progress and has not yet completed. You can call <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html">DescribePhoneNumber</a> at a later time to verify if the previous operation has completed.</p> </li>
        /// <li> <p> <code>FAILED</code> indicates that the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation has failed. It will include a message indicating the failure reason. A common reason for a failure may be that the <code>TargetArn</code> value you are claiming or updating a phone number to has reached its limit of total claimed numbers. If you received a <code>FAILED</code> status from a <code>ClaimPhoneNumber</code> API call, you have one day to retry claiming the phone number before the number is released back to the inventory for other customers to claim.</p> </li>
        /// </ul> <note>
        /// <p>You will not be billed for the phone number during the 1-day period if number claiming fails. </p>
        /// </note>
        pub fn set_phone_number_status(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberStatus>,
        ) -> Self {
            self.phone_number_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ClaimedPhoneNumberSummary`](crate::model::ClaimedPhoneNumberSummary).
        pub fn build(self) -> crate::model::ClaimedPhoneNumberSummary {
            crate::model::ClaimedPhoneNumberSummary {
                phone_number_id: self.phone_number_id,
                phone_number_arn: self.phone_number_arn,
                phone_number: self.phone_number,
                phone_number_country_code: self.phone_number_country_code,
                phone_number_type: self.phone_number_type,
                phone_number_description: self.phone_number_description,
                target_arn: self.target_arn,
                tags: self.tags,
                phone_number_status: self.phone_number_status,
            }
        }
    }
}
impl ClaimedPhoneNumberSummary {
    /// Creates a new builder-style object to manufacture [`ClaimedPhoneNumberSummary`](crate::model::ClaimedPhoneNumberSummary).
    pub fn builder() -> crate::model::claimed_phone_number_summary::Builder {
        crate::model::claimed_phone_number_summary::Builder::default()
    }
}

/// <p>The status of the phone number.</p>
/// <ul>
/// <li> <p> <code>CLAIMED</code> means the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation succeeded.</p> </li>
/// <li> <p> <code>IN_PROGRESS</code> means a <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation is still in progress and has not yet completed. You can call <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html">DescribePhoneNumber</a> at a later time to verify if the previous operation has completed.</p> </li>
/// <li> <p> <code>FAILED</code> indicates that the previous <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimedPhoneNumber.html">ClaimedPhoneNumber</a> or <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a> operation has failed. It will include a message indicating the failure reason. A common reason for a failure may be that the <code>TargetArn</code> value you are claiming or updating a phone number to has reached its limit of total claimed numbers. If you received a <code>FAILED</code> status from a <code>ClaimPhoneNumber</code> API call, you have one day to retry claiming the phone number before the number is released back to the inventory for other customers to claim.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PhoneNumberStatus {
    /// <p>The status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::PhoneNumberWorkflowStatus>,
    /// <p>The status message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl PhoneNumberStatus {
    /// <p>The status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::PhoneNumberWorkflowStatus> {
        self.status.as_ref()
    }
    /// <p>The status message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`PhoneNumberStatus`](crate::model::PhoneNumberStatus).
pub mod phone_number_status {

    /// A builder for [`PhoneNumberStatus`](crate::model::PhoneNumberStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::PhoneNumberWorkflowStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status.</p>
        pub fn status(mut self, input: crate::model::PhoneNumberWorkflowStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberWorkflowStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The status message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The status message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PhoneNumberStatus`](crate::model::PhoneNumberStatus).
        pub fn build(self) -> crate::model::PhoneNumberStatus {
            crate::model::PhoneNumberStatus {
                status: self.status,
                message: self.message,
            }
        }
    }
}
impl PhoneNumberStatus {
    /// Creates a new builder-style object to manufacture [`PhoneNumberStatus`](crate::model::PhoneNumberStatus).
    pub fn builder() -> crate::model::phone_number_status::Builder {
        crate::model::phone_number_status::Builder::default()
    }
}

/// When writing a match expression against `PhoneNumberWorkflowStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let phonenumberworkflowstatus = unimplemented!();
/// match phonenumberworkflowstatus {
///     PhoneNumberWorkflowStatus::Claimed => { /* ... */ },
///     PhoneNumberWorkflowStatus::Failed => { /* ... */ },
///     PhoneNumberWorkflowStatus::InProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `phonenumberworkflowstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PhoneNumberWorkflowStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PhoneNumberWorkflowStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PhoneNumberWorkflowStatus::NewFeature` is defined.
/// Specifically, when `phonenumberworkflowstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PhoneNumberWorkflowStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneNumberWorkflowStatus {
    #[allow(missing_docs)] // documentation missing in model
    Claimed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PhoneNumberWorkflowStatus {
    fn from(s: &str) -> Self {
        match s {
            "CLAIMED" => PhoneNumberWorkflowStatus::Claimed,
            "FAILED" => PhoneNumberWorkflowStatus::Failed,
            "IN_PROGRESS" => PhoneNumberWorkflowStatus::InProgress,
            other => PhoneNumberWorkflowStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PhoneNumberWorkflowStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneNumberWorkflowStatus::from(s))
    }
}
impl PhoneNumberWorkflowStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneNumberWorkflowStatus::Claimed => "CLAIMED",
            PhoneNumberWorkflowStatus::Failed => "FAILED",
            PhoneNumberWorkflowStatus::InProgress => "IN_PROGRESS",
            PhoneNumberWorkflowStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLAIMED", "FAILED", "IN_PROGRESS"]
    }
}
impl AsRef<str> for PhoneNumberWorkflowStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Amazon Connect instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Instance {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the instance.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The identity management type.</p>
    #[doc(hidden)]
    pub identity_management_type: std::option::Option<crate::model::DirectoryType>,
    /// <p>The alias of instance.</p>
    #[doc(hidden)]
    pub instance_alias: std::option::Option<std::string::String>,
    /// <p>When the instance was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The service role of the instance.</p>
    #[doc(hidden)]
    pub service_role: std::option::Option<std::string::String>,
    /// <p>The state of the instance.</p>
    #[doc(hidden)]
    pub instance_status: std::option::Option<crate::model::InstanceStatus>,
    /// <p>Relevant details why the instance was not successfully created. </p>
    #[doc(hidden)]
    pub status_reason: std::option::Option<crate::model::InstanceStatusReason>,
    /// <p>Whether inbound calls are enabled.</p>
    #[doc(hidden)]
    pub inbound_calls_enabled: std::option::Option<bool>,
    /// <p>Whether outbound calls are enabled.</p>
    #[doc(hidden)]
    pub outbound_calls_enabled: std::option::Option<bool>,
}
impl Instance {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the instance.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The identity management type.</p>
    pub fn identity_management_type(&self) -> std::option::Option<&crate::model::DirectoryType> {
        self.identity_management_type.as_ref()
    }
    /// <p>The alias of instance.</p>
    pub fn instance_alias(&self) -> std::option::Option<&str> {
        self.instance_alias.as_deref()
    }
    /// <p>When the instance was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The service role of the instance.</p>
    pub fn service_role(&self) -> std::option::Option<&str> {
        self.service_role.as_deref()
    }
    /// <p>The state of the instance.</p>
    pub fn instance_status(&self) -> std::option::Option<&crate::model::InstanceStatus> {
        self.instance_status.as_ref()
    }
    /// <p>Relevant details why the instance was not successfully created. </p>
    pub fn status_reason(&self) -> std::option::Option<&crate::model::InstanceStatusReason> {
        self.status_reason.as_ref()
    }
    /// <p>Whether inbound calls are enabled.</p>
    pub fn inbound_calls_enabled(&self) -> std::option::Option<bool> {
        self.inbound_calls_enabled
    }
    /// <p>Whether outbound calls are enabled.</p>
    pub fn outbound_calls_enabled(&self) -> std::option::Option<bool> {
        self.outbound_calls_enabled
    }
}
impl std::fmt::Debug for Instance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Instance");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("identity_management_type", &self.identity_management_type);
        formatter.field("instance_alias", &"*** Sensitive Data Redacted ***");
        formatter.field("created_time", &self.created_time);
        formatter.field("service_role", &self.service_role);
        formatter.field("instance_status", &self.instance_status);
        formatter.field("status_reason", &self.status_reason);
        formatter.field("inbound_calls_enabled", &self.inbound_calls_enabled);
        formatter.field("outbound_calls_enabled", &self.outbound_calls_enabled);
        formatter.finish()
    }
}
/// See [`Instance`](crate::model::Instance).
pub mod instance {

    /// A builder for [`Instance`](crate::model::Instance).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) identity_management_type: std::option::Option<crate::model::DirectoryType>,
        pub(crate) instance_alias: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) service_role: std::option::Option<std::string::String>,
        pub(crate) instance_status: std::option::Option<crate::model::InstanceStatus>,
        pub(crate) status_reason: std::option::Option<crate::model::InstanceStatusReason>,
        pub(crate) inbound_calls_enabled: std::option::Option<bool>,
        pub(crate) outbound_calls_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the instance.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the instance.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The identity management type.</p>
        pub fn identity_management_type(mut self, input: crate::model::DirectoryType) -> Self {
            self.identity_management_type = Some(input);
            self
        }
        /// <p>The identity management type.</p>
        pub fn set_identity_management_type(
            mut self,
            input: std::option::Option<crate::model::DirectoryType>,
        ) -> Self {
            self.identity_management_type = input;
            self
        }
        /// <p>The alias of instance.</p>
        pub fn instance_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_alias = Some(input.into());
            self
        }
        /// <p>The alias of instance.</p>
        pub fn set_instance_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_alias = input;
            self
        }
        /// <p>When the instance was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>When the instance was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The service role of the instance.</p>
        pub fn service_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_role = Some(input.into());
            self
        }
        /// <p>The service role of the instance.</p>
        pub fn set_service_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_role = input;
            self
        }
        /// <p>The state of the instance.</p>
        pub fn instance_status(mut self, input: crate::model::InstanceStatus) -> Self {
            self.instance_status = Some(input);
            self
        }
        /// <p>The state of the instance.</p>
        pub fn set_instance_status(
            mut self,
            input: std::option::Option<crate::model::InstanceStatus>,
        ) -> Self {
            self.instance_status = input;
            self
        }
        /// <p>Relevant details why the instance was not successfully created. </p>
        pub fn status_reason(mut self, input: crate::model::InstanceStatusReason) -> Self {
            self.status_reason = Some(input);
            self
        }
        /// <p>Relevant details why the instance was not successfully created. </p>
        pub fn set_status_reason(
            mut self,
            input: std::option::Option<crate::model::InstanceStatusReason>,
        ) -> Self {
            self.status_reason = input;
            self
        }
        /// <p>Whether inbound calls are enabled.</p>
        pub fn inbound_calls_enabled(mut self, input: bool) -> Self {
            self.inbound_calls_enabled = Some(input);
            self
        }
        /// <p>Whether inbound calls are enabled.</p>
        pub fn set_inbound_calls_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inbound_calls_enabled = input;
            self
        }
        /// <p>Whether outbound calls are enabled.</p>
        pub fn outbound_calls_enabled(mut self, input: bool) -> Self {
            self.outbound_calls_enabled = Some(input);
            self
        }
        /// <p>Whether outbound calls are enabled.</p>
        pub fn set_outbound_calls_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.outbound_calls_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Instance`](crate::model::Instance).
        pub fn build(self) -> crate::model::Instance {
            crate::model::Instance {
                id: self.id,
                arn: self.arn,
                identity_management_type: self.identity_management_type,
                instance_alias: self.instance_alias,
                created_time: self.created_time,
                service_role: self.service_role,
                instance_status: self.instance_status,
                status_reason: self.status_reason,
                inbound_calls_enabled: self.inbound_calls_enabled,
                outbound_calls_enabled: self.outbound_calls_enabled,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("id", &self.id);
            formatter.field("arn", &self.arn);
            formatter.field("identity_management_type", &self.identity_management_type);
            formatter.field("instance_alias", &"*** Sensitive Data Redacted ***");
            formatter.field("created_time", &self.created_time);
            formatter.field("service_role", &self.service_role);
            formatter.field("instance_status", &self.instance_status);
            formatter.field("status_reason", &self.status_reason);
            formatter.field("inbound_calls_enabled", &self.inbound_calls_enabled);
            formatter.field("outbound_calls_enabled", &self.outbound_calls_enabled);
            formatter.finish()
        }
    }
}
impl Instance {
    /// Creates a new builder-style object to manufacture [`Instance`](crate::model::Instance).
    pub fn builder() -> crate::model::instance::Builder {
        crate::model::instance::Builder::default()
    }
}

/// <p>Relevant details why the instance was not successfully created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceStatusReason {
    /// <p>The message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl InstanceStatusReason {
    /// <p>The message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`InstanceStatusReason`](crate::model::InstanceStatusReason).
pub mod instance_status_reason {

    /// A builder for [`InstanceStatusReason`](crate::model::InstanceStatusReason).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceStatusReason`](crate::model::InstanceStatusReason).
        pub fn build(self) -> crate::model::InstanceStatusReason {
            crate::model::InstanceStatusReason {
                message: self.message,
            }
        }
    }
}
impl InstanceStatusReason {
    /// Creates a new builder-style object to manufacture [`InstanceStatusReason`](crate::model::InstanceStatusReason).
    pub fn builder() -> crate::model::instance_status_reason::Builder {
        crate::model::instance_status_reason::Builder::default()
    }
}

/// <p>Information about of the hours of operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HoursOfOperation {
    /// <p>The identifier for the hours of operation.</p>
    #[doc(hidden)]
    pub hours_of_operation_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the hours of operation.</p>
    #[doc(hidden)]
    pub hours_of_operation_arn: std::option::Option<std::string::String>,
    /// <p>The name for the hours of operation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description for the hours of operation.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The time zone for the hours of operation.</p>
    #[doc(hidden)]
    pub time_zone: std::option::Option<std::string::String>,
    /// <p>Configuration information for the hours of operation.</p>
    #[doc(hidden)]
    pub config: std::option::Option<std::vec::Vec<crate::model::HoursOfOperationConfig>>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl HoursOfOperation {
    /// <p>The identifier for the hours of operation.</p>
    pub fn hours_of_operation_id(&self) -> std::option::Option<&str> {
        self.hours_of_operation_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the hours of operation.</p>
    pub fn hours_of_operation_arn(&self) -> std::option::Option<&str> {
        self.hours_of_operation_arn.as_deref()
    }
    /// <p>The name for the hours of operation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description for the hours of operation.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The time zone for the hours of operation.</p>
    pub fn time_zone(&self) -> std::option::Option<&str> {
        self.time_zone.as_deref()
    }
    /// <p>Configuration information for the hours of operation.</p>
    pub fn config(&self) -> std::option::Option<&[crate::model::HoursOfOperationConfig]> {
        self.config.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`HoursOfOperation`](crate::model::HoursOfOperation).
pub mod hours_of_operation {

    /// A builder for [`HoursOfOperation`](crate::model::HoursOfOperation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hours_of_operation_id: std::option::Option<std::string::String>,
        pub(crate) hours_of_operation_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) time_zone: std::option::Option<std::string::String>,
        pub(crate) config: std::option::Option<std::vec::Vec<crate::model::HoursOfOperationConfig>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier for the hours of operation.</p>
        pub fn hours_of_operation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hours_of_operation_id = Some(input.into());
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn set_hours_of_operation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hours_of_operation_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the hours of operation.</p>
        pub fn hours_of_operation_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.hours_of_operation_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the hours of operation.</p>
        pub fn set_hours_of_operation_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hours_of_operation_arn = input;
            self
        }
        /// <p>The name for the hours of operation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the hours of operation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description for the hours of operation.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description for the hours of operation.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The time zone for the hours of operation.</p>
        pub fn time_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.time_zone = Some(input.into());
            self
        }
        /// <p>The time zone for the hours of operation.</p>
        pub fn set_time_zone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.time_zone = input;
            self
        }
        /// Appends an item to `config`.
        ///
        /// To override the contents of this collection use [`set_config`](Self::set_config).
        ///
        /// <p>Configuration information for the hours of operation.</p>
        pub fn config(mut self, input: crate::model::HoursOfOperationConfig) -> Self {
            let mut v = self.config.unwrap_or_default();
            v.push(input);
            self.config = Some(v);
            self
        }
        /// <p>Configuration information for the hours of operation.</p>
        pub fn set_config(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HoursOfOperationConfig>>,
        ) -> Self {
            self.config = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`HoursOfOperation`](crate::model::HoursOfOperation).
        pub fn build(self) -> crate::model::HoursOfOperation {
            crate::model::HoursOfOperation {
                hours_of_operation_id: self.hours_of_operation_id,
                hours_of_operation_arn: self.hours_of_operation_arn,
                name: self.name,
                description: self.description,
                time_zone: self.time_zone,
                config: self.config,
                tags: self.tags,
            }
        }
    }
}
impl HoursOfOperation {
    /// Creates a new builder-style object to manufacture [`HoursOfOperation`](crate::model::HoursOfOperation).
    pub fn builder() -> crate::model::hours_of_operation::Builder {
        crate::model::hours_of_operation::Builder::default()
    }
}

/// <p>Contains information about a flow module.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContactFlowModule {
    /// <p>The Amazon Resource Name (ARN).</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow module.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the flow module.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The content of the flow module.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The description of the flow module.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of flow module.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ContactFlowModuleState>,
    /// <p>The status of the flow module.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ContactFlowModuleStatus>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ContactFlowModule {
    /// <p>The Amazon Resource Name (ARN).</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The identifier of the flow module.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the flow module.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The content of the flow module.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The description of the flow module.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of flow module.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ContactFlowModuleState> {
        self.state.as_ref()
    }
    /// <p>The status of the flow module.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ContactFlowModuleStatus> {
        self.status.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`ContactFlowModule`](crate::model::ContactFlowModule).
pub mod contact_flow_module {

    /// A builder for [`ContactFlowModule`](crate::model::ContactFlowModule).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ContactFlowModuleState>,
        pub(crate) status: std::option::Option<crate::model::ContactFlowModuleStatus>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN).</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN).</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The identifier of the flow module.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow module.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the flow module.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the flow module.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The content of the flow module.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the flow module.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The description of the flow module.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the flow module.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of flow module.</p>
        pub fn state(mut self, input: crate::model::ContactFlowModuleState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The type of flow module.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ContactFlowModuleState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status of the flow module.</p>
        pub fn status(mut self, input: crate::model::ContactFlowModuleStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the flow module.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ContactFlowModuleStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactFlowModule`](crate::model::ContactFlowModule).
        pub fn build(self) -> crate::model::ContactFlowModule {
            crate::model::ContactFlowModule {
                arn: self.arn,
                id: self.id,
                name: self.name,
                content: self.content,
                description: self.description,
                state: self.state,
                status: self.status,
                tags: self.tags,
            }
        }
    }
}
impl ContactFlowModule {
    /// Creates a new builder-style object to manufacture [`ContactFlowModule`](crate::model::ContactFlowModule).
    pub fn builder() -> crate::model::contact_flow_module::Builder {
        crate::model::contact_flow_module::Builder::default()
    }
}

/// When writing a match expression against `ContactFlowModuleStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let contactflowmodulestatus = unimplemented!();
/// match contactflowmodulestatus {
///     ContactFlowModuleStatus::Published => { /* ... */ },
///     ContactFlowModuleStatus::Saved => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `contactflowmodulestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ContactFlowModuleStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ContactFlowModuleStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ContactFlowModuleStatus::NewFeature` is defined.
/// Specifically, when `contactflowmodulestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ContactFlowModuleStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContactFlowModuleStatus {
    #[allow(missing_docs)] // documentation missing in model
    Published,
    #[allow(missing_docs)] // documentation missing in model
    Saved,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ContactFlowModuleStatus {
    fn from(s: &str) -> Self {
        match s {
            "PUBLISHED" => ContactFlowModuleStatus::Published,
            "SAVED" => ContactFlowModuleStatus::Saved,
            other => ContactFlowModuleStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ContactFlowModuleStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContactFlowModuleStatus::from(s))
    }
}
impl ContactFlowModuleStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContactFlowModuleStatus::Published => "PUBLISHED",
            ContactFlowModuleStatus::Saved => "SAVED",
            ContactFlowModuleStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PUBLISHED", "SAVED"]
    }
}
impl AsRef<str> for ContactFlowModuleStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about a flow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContactFlow {
    /// <p>The Amazon Resource Name (ARN) of the flow.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the flow.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a flow type</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ContactFlowType>,
    /// <p>The type of flow.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ContactFlowState>,
    /// <p>The description of the flow.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The content of the flow.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ContactFlow {
    /// <p>The Amazon Resource Name (ARN) of the flow.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The identifier of the flow.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the flow.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a flow type</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ContactFlowType> {
        self.r#type.as_ref()
    }
    /// <p>The type of flow.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ContactFlowState> {
        self.state.as_ref()
    }
    /// <p>The description of the flow.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The content of the flow.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`ContactFlow`](crate::model::ContactFlow).
pub mod contact_flow {

    /// A builder for [`ContactFlow`](crate::model::ContactFlow).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ContactFlowType>,
        pub(crate) state: std::option::Option<crate::model::ContactFlowState>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the flow.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the flow.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the flow.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the flow.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a flow type</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn r#type(mut self, input: crate::model::ContactFlowType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a flow type</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ContactFlowType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The type of flow.</p>
        pub fn state(mut self, input: crate::model::ContactFlowState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The type of flow.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ContactFlowState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The description of the flow.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the flow.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The content of the flow.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the flow.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactFlow`](crate::model::ContactFlow).
        pub fn build(self) -> crate::model::ContactFlow {
            crate::model::ContactFlow {
                arn: self.arn,
                id: self.id,
                name: self.name,
                r#type: self.r#type,
                state: self.state,
                description: self.description,
                content: self.content,
                tags: self.tags,
            }
        }
    }
}
impl ContactFlow {
    /// Creates a new builder-style object to manufacture [`ContactFlow`](crate::model::ContactFlow).
    pub fn builder() -> crate::model::contact_flow::Builder {
        crate::model::contact_flow::Builder::default()
    }
}

/// <p>Contains information about a contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Contact {
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The identifier for the contact.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    #[doc(hidden)]
    pub initial_contact_id: std::option::Option<std::string::String>,
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    #[doc(hidden)]
    pub previous_contact_id: std::option::Option<std::string::String>,
    /// <p>Indicates how the contact was initiated.</p>
    #[doc(hidden)]
    pub initiation_method: std::option::Option<crate::model::ContactInitiationMethod>,
    /// <p>The name of the contact.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the contact.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>How the contact reached your contact center.</p>
    #[doc(hidden)]
    pub channel: std::option::Option<crate::model::Channel>,
    /// <p>If this contact was queued, this contains information about the queue. </p>
    #[doc(hidden)]
    pub queue_info: std::option::Option<crate::model::QueueInfo>,
    /// <p>Information about the agent who accepted the contact.</p>
    #[doc(hidden)]
    pub agent_info: std::option::Option<crate::model::AgentInfo>,
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived.</p>
    #[doc(hidden)]
    pub initiation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp when the customer endpoint disconnected from Amazon Connect.</p>
    #[doc(hidden)]
    pub disconnect_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp when contact was last updated.</p>
    #[doc(hidden)]
    pub last_update_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow. </p>
    #[doc(hidden)]
    pub scheduled_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
    #[doc(hidden)]
    pub related_contact_id: std::option::Option<std::string::String>,
}
impl Contact {
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The identifier for the contact.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    pub fn initial_contact_id(&self) -> std::option::Option<&str> {
        self.initial_contact_id.as_deref()
    }
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    pub fn previous_contact_id(&self) -> std::option::Option<&str> {
        self.previous_contact_id.as_deref()
    }
    /// <p>Indicates how the contact was initiated.</p>
    pub fn initiation_method(&self) -> std::option::Option<&crate::model::ContactInitiationMethod> {
        self.initiation_method.as_ref()
    }
    /// <p>The name of the contact.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the contact.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>How the contact reached your contact center.</p>
    pub fn channel(&self) -> std::option::Option<&crate::model::Channel> {
        self.channel.as_ref()
    }
    /// <p>If this contact was queued, this contains information about the queue. </p>
    pub fn queue_info(&self) -> std::option::Option<&crate::model::QueueInfo> {
        self.queue_info.as_ref()
    }
    /// <p>Information about the agent who accepted the contact.</p>
    pub fn agent_info(&self) -> std::option::Option<&crate::model::AgentInfo> {
        self.agent_info.as_ref()
    }
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived.</p>
    pub fn initiation_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.initiation_timestamp.as_ref()
    }
    /// <p>The timestamp when the customer endpoint disconnected from Amazon Connect.</p>
    pub fn disconnect_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.disconnect_timestamp.as_ref()
    }
    /// <p>The timestamp when contact was last updated.</p>
    pub fn last_update_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_timestamp.as_ref()
    }
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow. </p>
    pub fn scheduled_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.scheduled_timestamp.as_ref()
    }
    /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
    pub fn related_contact_id(&self) -> std::option::Option<&str> {
        self.related_contact_id.as_deref()
    }
}
/// See [`Contact`](crate::model::Contact).
pub mod contact {

    /// A builder for [`Contact`](crate::model::Contact).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) initial_contact_id: std::option::Option<std::string::String>,
        pub(crate) previous_contact_id: std::option::Option<std::string::String>,
        pub(crate) initiation_method: std::option::Option<crate::model::ContactInitiationMethod>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) channel: std::option::Option<crate::model::Channel>,
        pub(crate) queue_info: std::option::Option<crate::model::QueueInfo>,
        pub(crate) agent_info: std::option::Option<crate::model::AgentInfo>,
        pub(crate) initiation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) disconnect_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_update_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) scheduled_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) related_contact_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the contact.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the contact.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The identifier for the contact.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier for the contact.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
        pub fn initial_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.initial_contact_id = Some(input.into());
            self
        }
        /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
        pub fn set_initial_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_contact_id = input;
            self
        }
        /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
        pub fn previous_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.previous_contact_id = Some(input.into());
            self
        }
        /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
        pub fn set_previous_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.previous_contact_id = input;
            self
        }
        /// <p>Indicates how the contact was initiated.</p>
        pub fn initiation_method(mut self, input: crate::model::ContactInitiationMethod) -> Self {
            self.initiation_method = Some(input);
            self
        }
        /// <p>Indicates how the contact was initiated.</p>
        pub fn set_initiation_method(
            mut self,
            input: std::option::Option<crate::model::ContactInitiationMethod>,
        ) -> Self {
            self.initiation_method = input;
            self
        }
        /// <p>The name of the contact.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the contact.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the contact.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the contact.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>How the contact reached your contact center.</p>
        pub fn channel(mut self, input: crate::model::Channel) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>How the contact reached your contact center.</p>
        pub fn set_channel(mut self, input: std::option::Option<crate::model::Channel>) -> Self {
            self.channel = input;
            self
        }
        /// <p>If this contact was queued, this contains information about the queue. </p>
        pub fn queue_info(mut self, input: crate::model::QueueInfo) -> Self {
            self.queue_info = Some(input);
            self
        }
        /// <p>If this contact was queued, this contains information about the queue. </p>
        pub fn set_queue_info(
            mut self,
            input: std::option::Option<crate::model::QueueInfo>,
        ) -> Self {
            self.queue_info = input;
            self
        }
        /// <p>Information about the agent who accepted the contact.</p>
        pub fn agent_info(mut self, input: crate::model::AgentInfo) -> Self {
            self.agent_info = Some(input);
            self
        }
        /// <p>Information about the agent who accepted the contact.</p>
        pub fn set_agent_info(
            mut self,
            input: std::option::Option<crate::model::AgentInfo>,
        ) -> Self {
            self.agent_info = input;
            self
        }
        /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived.</p>
        pub fn initiation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.initiation_timestamp = Some(input);
            self
        }
        /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived.</p>
        pub fn set_initiation_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.initiation_timestamp = input;
            self
        }
        /// <p>The timestamp when the customer endpoint disconnected from Amazon Connect.</p>
        pub fn disconnect_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.disconnect_timestamp = Some(input);
            self
        }
        /// <p>The timestamp when the customer endpoint disconnected from Amazon Connect.</p>
        pub fn set_disconnect_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.disconnect_timestamp = input;
            self
        }
        /// <p>The timestamp when contact was last updated.</p>
        pub fn last_update_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_timestamp = Some(input);
            self
        }
        /// <p>The timestamp when contact was last updated.</p>
        pub fn set_last_update_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_timestamp = input;
            self
        }
        /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow. </p>
        pub fn scheduled_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.scheduled_timestamp = Some(input);
            self
        }
        /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow. </p>
        pub fn set_scheduled_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.scheduled_timestamp = input;
            self
        }
        /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
        pub fn related_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.related_contact_id = Some(input.into());
            self
        }
        /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
        pub fn set_related_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.related_contact_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Contact`](crate::model::Contact).
        pub fn build(self) -> crate::model::Contact {
            crate::model::Contact {
                arn: self.arn,
                id: self.id,
                initial_contact_id: self.initial_contact_id,
                previous_contact_id: self.previous_contact_id,
                initiation_method: self.initiation_method,
                name: self.name,
                description: self.description,
                channel: self.channel,
                queue_info: self.queue_info,
                agent_info: self.agent_info,
                initiation_timestamp: self.initiation_timestamp,
                disconnect_timestamp: self.disconnect_timestamp,
                last_update_timestamp: self.last_update_timestamp,
                scheduled_timestamp: self.scheduled_timestamp,
                related_contact_id: self.related_contact_id,
            }
        }
    }
}
impl Contact {
    /// Creates a new builder-style object to manufacture [`Contact`](crate::model::Contact).
    pub fn builder() -> crate::model::contact::Builder {
        crate::model::contact::Builder::default()
    }
}

/// <p>Information about the agent who accepted the contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AgentInfo {
    /// <p>The identifier of the agent who accepted the contact.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The timestamp when the contact was connected to the agent.</p>
    #[doc(hidden)]
    pub connected_to_agent_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl AgentInfo {
    /// <p>The identifier of the agent who accepted the contact.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The timestamp when the contact was connected to the agent.</p>
    pub fn connected_to_agent_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.connected_to_agent_timestamp.as_ref()
    }
}
/// See [`AgentInfo`](crate::model::AgentInfo).
pub mod agent_info {

    /// A builder for [`AgentInfo`](crate::model::AgentInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) connected_to_agent_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the agent who accepted the contact.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the agent who accepted the contact.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The timestamp when the contact was connected to the agent.</p>
        pub fn connected_to_agent_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.connected_to_agent_timestamp = Some(input);
            self
        }
        /// <p>The timestamp when the contact was connected to the agent.</p>
        pub fn set_connected_to_agent_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.connected_to_agent_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentInfo`](crate::model::AgentInfo).
        pub fn build(self) -> crate::model::AgentInfo {
            crate::model::AgentInfo {
                id: self.id,
                connected_to_agent_timestamp: self.connected_to_agent_timestamp,
            }
        }
    }
}
impl AgentInfo {
    /// Creates a new builder-style object to manufacture [`AgentInfo`](crate::model::AgentInfo).
    pub fn builder() -> crate::model::agent_info::Builder {
        crate::model::agent_info::Builder::default()
    }
}

/// <p>If this contact was queued, this contains information about the queue. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueueInfo {
    /// <p>The unique identifier for the queue.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The timestamp when the contact was added to the queue.</p>
    #[doc(hidden)]
    pub enqueue_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl QueueInfo {
    /// <p>The unique identifier for the queue.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The timestamp when the contact was added to the queue.</p>
    pub fn enqueue_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.enqueue_timestamp.as_ref()
    }
}
/// See [`QueueInfo`](crate::model::QueueInfo).
pub mod queue_info {

    /// A builder for [`QueueInfo`](crate::model::QueueInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) enqueue_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The unique identifier for the queue.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the queue.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The timestamp when the contact was added to the queue.</p>
        pub fn enqueue_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.enqueue_timestamp = Some(input);
            self
        }
        /// <p>The timestamp when the contact was added to the queue.</p>
        pub fn set_enqueue_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.enqueue_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`QueueInfo`](crate::model::QueueInfo).
        pub fn build(self) -> crate::model::QueueInfo {
            crate::model::QueueInfo {
                id: self.id,
                enqueue_timestamp: self.enqueue_timestamp,
            }
        }
    }
}
impl QueueInfo {
    /// Creates a new builder-style object to manufacture [`QueueInfo`](crate::model::QueueInfo).
    pub fn builder() -> crate::model::queue_info::Builder {
        crate::model::queue_info::Builder::default()
    }
}

/// <p>Contains information about an agent status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AgentStatus {
    /// <p>The Amazon Resource Name (ARN) of the agent status.</p>
    #[doc(hidden)]
    pub agent_status_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the agent status.</p>
    #[doc(hidden)]
    pub agent_status_id: std::option::Option<std::string::String>,
    /// <p>The name of the agent status.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the agent status.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of agent status.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::AgentStatusType>,
    /// <p>The display order of the agent status.</p>
    #[doc(hidden)]
    pub display_order: std::option::Option<i32>,
    /// <p>The state of the agent status.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::AgentStatusState>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl AgentStatus {
    /// <p>The Amazon Resource Name (ARN) of the agent status.</p>
    pub fn agent_status_arn(&self) -> std::option::Option<&str> {
        self.agent_status_arn.as_deref()
    }
    /// <p>The identifier of the agent status.</p>
    pub fn agent_status_id(&self) -> std::option::Option<&str> {
        self.agent_status_id.as_deref()
    }
    /// <p>The name of the agent status.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the agent status.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of agent status.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::AgentStatusType> {
        self.r#type.as_ref()
    }
    /// <p>The display order of the agent status.</p>
    pub fn display_order(&self) -> std::option::Option<i32> {
        self.display_order
    }
    /// <p>The state of the agent status.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::AgentStatusState> {
        self.state.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`AgentStatus`](crate::model::AgentStatus).
pub mod agent_status {

    /// A builder for [`AgentStatus`](crate::model::AgentStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) agent_status_arn: std::option::Option<std::string::String>,
        pub(crate) agent_status_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::AgentStatusType>,
        pub(crate) display_order: std::option::Option<i32>,
        pub(crate) state: std::option::Option<crate::model::AgentStatusState>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the agent status.</p>
        pub fn agent_status_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_status_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the agent status.</p>
        pub fn set_agent_status_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.agent_status_arn = input;
            self
        }
        /// <p>The identifier of the agent status.</p>
        pub fn agent_status_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_status_id = Some(input.into());
            self
        }
        /// <p>The identifier of the agent status.</p>
        pub fn set_agent_status_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.agent_status_id = input;
            self
        }
        /// <p>The name of the agent status.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the agent status.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the agent status.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the agent status.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of agent status.</p>
        pub fn r#type(mut self, input: crate::model::AgentStatusType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of agent status.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::AgentStatusType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The display order of the agent status.</p>
        pub fn display_order(mut self, input: i32) -> Self {
            self.display_order = Some(input);
            self
        }
        /// <p>The display order of the agent status.</p>
        pub fn set_display_order(mut self, input: std::option::Option<i32>) -> Self {
            self.display_order = input;
            self
        }
        /// <p>The state of the agent status.</p>
        pub fn state(mut self, input: crate::model::AgentStatusState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the agent status.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AgentStatusState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentStatus`](crate::model::AgentStatus).
        pub fn build(self) -> crate::model::AgentStatus {
            crate::model::AgentStatus {
                agent_status_arn: self.agent_status_arn,
                agent_status_id: self.agent_status_id,
                name: self.name,
                description: self.description,
                r#type: self.r#type,
                display_order: self.display_order,
                state: self.state,
                tags: self.tags,
            }
        }
    }
}
impl AgentStatus {
    /// Creates a new builder-style object to manufacture [`AgentStatus`](crate::model::AgentStatus).
    pub fn builder() -> crate::model::agent_status::Builder {
        crate::model::agent_status::Builder::default()
    }
}
