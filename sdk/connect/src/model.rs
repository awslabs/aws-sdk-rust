// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains information about the phone configuration settings for a user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserPhoneConfig {
    /// <p>The phone type.</p>
    pub phone_type: std::option::Option<crate::model::PhoneType>,
    /// <p>The Auto accept setting.</p>
    pub auto_accept: bool,
    /// <p>The After Call Work (ACW) timeout setting, in seconds.</p>
    pub after_contact_work_time_limit: i32,
    /// <p>The phone number for the user's desk phone.</p>
    pub desk_phone_number: std::option::Option<std::string::String>,
}
impl UserPhoneConfig {
    /// <p>The phone type.</p>
    pub fn phone_type(&self) -> std::option::Option<&crate::model::PhoneType> {
        self.phone_type.as_ref()
    }
    /// <p>The Auto accept setting.</p>
    pub fn auto_accept(&self) -> bool {
        self.auto_accept
    }
    /// <p>The After Call Work (ACW) timeout setting, in seconds.</p>
    pub fn after_contact_work_time_limit(&self) -> i32 {
        self.after_contact_work_time_limit
    }
    /// <p>The phone number for the user's desk phone.</p>
    pub fn desk_phone_number(&self) -> std::option::Option<&str> {
        self.desk_phone_number.as_deref()
    }
}
impl std::fmt::Debug for UserPhoneConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserPhoneConfig");
        formatter.field("phone_type", &self.phone_type);
        formatter.field("auto_accept", &self.auto_accept);
        formatter.field(
            "after_contact_work_time_limit",
            &self.after_contact_work_time_limit,
        );
        formatter.field("desk_phone_number", &self.desk_phone_number);
        formatter.finish()
    }
}
/// See [`UserPhoneConfig`](crate::model::UserPhoneConfig)
pub mod user_phone_config {

    /// A builder for [`UserPhoneConfig`](crate::model::UserPhoneConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_type: std::option::Option<crate::model::PhoneType>,
        pub(crate) auto_accept: std::option::Option<bool>,
        pub(crate) after_contact_work_time_limit: std::option::Option<i32>,
        pub(crate) desk_phone_number: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The phone type.</p>
        pub fn phone_type(mut self, input: crate::model::PhoneType) -> Self {
            self.phone_type = Some(input);
            self
        }
        /// <p>The phone type.</p>
        pub fn set_phone_type(
            mut self,
            input: std::option::Option<crate::model::PhoneType>,
        ) -> Self {
            self.phone_type = input;
            self
        }
        /// <p>The Auto accept setting.</p>
        pub fn auto_accept(mut self, input: bool) -> Self {
            self.auto_accept = Some(input);
            self
        }
        /// <p>The Auto accept setting.</p>
        pub fn set_auto_accept(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_accept = input;
            self
        }
        /// <p>The After Call Work (ACW) timeout setting, in seconds.</p>
        pub fn after_contact_work_time_limit(mut self, input: i32) -> Self {
            self.after_contact_work_time_limit = Some(input);
            self
        }
        /// <p>The After Call Work (ACW) timeout setting, in seconds.</p>
        pub fn set_after_contact_work_time_limit(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.after_contact_work_time_limit = input;
            self
        }
        /// <p>The phone number for the user's desk phone.</p>
        pub fn desk_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.desk_phone_number = Some(input.into());
            self
        }
        /// <p>The phone number for the user's desk phone.</p>
        pub fn set_desk_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.desk_phone_number = input;
            self
        }
        /// Consumes the builder and constructs a [`UserPhoneConfig`](crate::model::UserPhoneConfig)
        pub fn build(self) -> crate::model::UserPhoneConfig {
            crate::model::UserPhoneConfig {
                phone_type: self.phone_type,
                auto_accept: self.auto_accept.unwrap_or_default(),
                after_contact_work_time_limit: self
                    .after_contact_work_time_limit
                    .unwrap_or_default(),
                desk_phone_number: self.desk_phone_number,
            }
        }
    }
}
impl UserPhoneConfig {
    /// Creates a new builder-style object to manufacture [`UserPhoneConfig`](crate::model::UserPhoneConfig)
    pub fn builder() -> crate::model::user_phone_config::Builder {
        crate::model::user_phone_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneType {
    #[allow(missing_docs)] // documentation missing in model
    DeskPhone,
    #[allow(missing_docs)] // documentation missing in model
    SoftPhone,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PhoneType {
    fn from(s: &str) -> Self {
        match s {
            "DESK_PHONE" => PhoneType::DeskPhone,
            "SOFT_PHONE" => PhoneType::SoftPhone,
            other => PhoneType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PhoneType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneType::from(s))
    }
}
impl PhoneType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneType::DeskPhone => "DESK_PHONE",
            PhoneType::SoftPhone => "SOFT_PHONE",
            PhoneType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DESK_PHONE", "SOFT_PHONE"]
    }
}
impl AsRef<str> for PhoneType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the identity of a user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserIdentityInfo {
    /// <p>The first name. This is required if you are using Amazon Connect or SAML for identity management.</p>
    pub first_name: std::option::Option<std::string::String>,
    /// <p>The last name. This is required if you are using Amazon Connect or SAML for identity management.</p>
    pub last_name: std::option::Option<std::string::String>,
    /// <p>The email address. If you are using SAML for identity management and include this parameter, an error is returned.</p>
    pub email: std::option::Option<std::string::String>,
}
impl UserIdentityInfo {
    /// <p>The first name. This is required if you are using Amazon Connect or SAML for identity management.</p>
    pub fn first_name(&self) -> std::option::Option<&str> {
        self.first_name.as_deref()
    }
    /// <p>The last name. This is required if you are using Amazon Connect or SAML for identity management.</p>
    pub fn last_name(&self) -> std::option::Option<&str> {
        self.last_name.as_deref()
    }
    /// <p>The email address. If you are using SAML for identity management and include this parameter, an error is returned.</p>
    pub fn email(&self) -> std::option::Option<&str> {
        self.email.as_deref()
    }
}
impl std::fmt::Debug for UserIdentityInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserIdentityInfo");
        formatter.field("first_name", &self.first_name);
        formatter.field("last_name", &self.last_name);
        formatter.field("email", &self.email);
        formatter.finish()
    }
}
/// See [`UserIdentityInfo`](crate::model::UserIdentityInfo)
pub mod user_identity_info {

    /// A builder for [`UserIdentityInfo`](crate::model::UserIdentityInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) first_name: std::option::Option<std::string::String>,
        pub(crate) last_name: std::option::Option<std::string::String>,
        pub(crate) email: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The first name. This is required if you are using Amazon Connect or SAML for identity management.</p>
        pub fn first_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_name = Some(input.into());
            self
        }
        /// <p>The first name. This is required if you are using Amazon Connect or SAML for identity management.</p>
        pub fn set_first_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.first_name = input;
            self
        }
        /// <p>The last name. This is required if you are using Amazon Connect or SAML for identity management.</p>
        pub fn last_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_name = Some(input.into());
            self
        }
        /// <p>The last name. This is required if you are using Amazon Connect or SAML for identity management.</p>
        pub fn set_last_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_name = input;
            self
        }
        /// <p>The email address. If you are using SAML for identity management and include this parameter, an error is returned.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.email = Some(input.into());
            self
        }
        /// <p>The email address. If you are using SAML for identity management and include this parameter, an error is returned.</p>
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.email = input;
            self
        }
        /// Consumes the builder and constructs a [`UserIdentityInfo`](crate::model::UserIdentityInfo)
        pub fn build(self) -> crate::model::UserIdentityInfo {
            crate::model::UserIdentityInfo {
                first_name: self.first_name,
                last_name: self.last_name,
                email: self.email,
            }
        }
    }
}
impl UserIdentityInfo {
    /// Creates a new builder-style object to manufacture [`UserIdentityInfo`](crate::model::UserIdentityInfo)
    pub fn builder() -> crate::model::user_identity_info::Builder {
        crate::model::user_identity_info::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Contact,
    #[allow(missing_docs)] // documentation missing in model
    ContactFlow,
    #[allow(missing_docs)] // documentation missing in model
    HierarchyGroup,
    #[allow(missing_docs)] // documentation missing in model
    HierarchyLevel,
    #[allow(missing_docs)] // documentation missing in model
    Instance,
    #[allow(missing_docs)] // documentation missing in model
    Participant,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "CONTACT" => ResourceType::Contact,
            "CONTACT_FLOW" => ResourceType::ContactFlow,
            "HIERARCHY_GROUP" => ResourceType::HierarchyGroup,
            "HIERARCHY_LEVEL" => ResourceType::HierarchyLevel,
            "INSTANCE" => ResourceType::Instance,
            "PARTICIPANT" => ResourceType::Participant,
            "USER" => ResourceType::User,
            other => ResourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Contact => "CONTACT",
            ResourceType::ContactFlow => "CONTACT_FLOW",
            ResourceType::HierarchyGroup => "HIERARCHY_GROUP",
            ResourceType::HierarchyLevel => "HIERARCHY_LEVEL",
            ResourceType::Instance => "INSTANCE",
            ResourceType::Participant => "PARTICIPANT",
            ResourceType::User => "USER",
            ResourceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CONTACT",
            "CONTACT_FLOW",
            "HIERARCHY_GROUP",
            "HIERARCHY_LEVEL",
            "INSTANCE",
            "PARTICIPANT",
            "USER",
        ]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the level hierarchy to update.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HierarchyStructureUpdate {
    /// <p>The update for level one.</p>
    pub level_one: std::option::Option<crate::model::HierarchyLevelUpdate>,
    /// <p>The update for level two.</p>
    pub level_two: std::option::Option<crate::model::HierarchyLevelUpdate>,
    /// <p>The update for level three.</p>
    pub level_three: std::option::Option<crate::model::HierarchyLevelUpdate>,
    /// <p>The update for level four.</p>
    pub level_four: std::option::Option<crate::model::HierarchyLevelUpdate>,
    /// <p>The update for level five.</p>
    pub level_five: std::option::Option<crate::model::HierarchyLevelUpdate>,
}
impl HierarchyStructureUpdate {
    /// <p>The update for level one.</p>
    pub fn level_one(&self) -> std::option::Option<&crate::model::HierarchyLevelUpdate> {
        self.level_one.as_ref()
    }
    /// <p>The update for level two.</p>
    pub fn level_two(&self) -> std::option::Option<&crate::model::HierarchyLevelUpdate> {
        self.level_two.as_ref()
    }
    /// <p>The update for level three.</p>
    pub fn level_three(&self) -> std::option::Option<&crate::model::HierarchyLevelUpdate> {
        self.level_three.as_ref()
    }
    /// <p>The update for level four.</p>
    pub fn level_four(&self) -> std::option::Option<&crate::model::HierarchyLevelUpdate> {
        self.level_four.as_ref()
    }
    /// <p>The update for level five.</p>
    pub fn level_five(&self) -> std::option::Option<&crate::model::HierarchyLevelUpdate> {
        self.level_five.as_ref()
    }
}
impl std::fmt::Debug for HierarchyStructureUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HierarchyStructureUpdate");
        formatter.field("level_one", &self.level_one);
        formatter.field("level_two", &self.level_two);
        formatter.field("level_three", &self.level_three);
        formatter.field("level_four", &self.level_four);
        formatter.field("level_five", &self.level_five);
        formatter.finish()
    }
}
/// See [`HierarchyStructureUpdate`](crate::model::HierarchyStructureUpdate)
pub mod hierarchy_structure_update {

    /// A builder for [`HierarchyStructureUpdate`](crate::model::HierarchyStructureUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) level_one: std::option::Option<crate::model::HierarchyLevelUpdate>,
        pub(crate) level_two: std::option::Option<crate::model::HierarchyLevelUpdate>,
        pub(crate) level_three: std::option::Option<crate::model::HierarchyLevelUpdate>,
        pub(crate) level_four: std::option::Option<crate::model::HierarchyLevelUpdate>,
        pub(crate) level_five: std::option::Option<crate::model::HierarchyLevelUpdate>,
    }
    impl Builder {
        /// <p>The update for level one.</p>
        pub fn level_one(mut self, input: crate::model::HierarchyLevelUpdate) -> Self {
            self.level_one = Some(input);
            self
        }
        /// <p>The update for level one.</p>
        pub fn set_level_one(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevelUpdate>,
        ) -> Self {
            self.level_one = input;
            self
        }
        /// <p>The update for level two.</p>
        pub fn level_two(mut self, input: crate::model::HierarchyLevelUpdate) -> Self {
            self.level_two = Some(input);
            self
        }
        /// <p>The update for level two.</p>
        pub fn set_level_two(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevelUpdate>,
        ) -> Self {
            self.level_two = input;
            self
        }
        /// <p>The update for level three.</p>
        pub fn level_three(mut self, input: crate::model::HierarchyLevelUpdate) -> Self {
            self.level_three = Some(input);
            self
        }
        /// <p>The update for level three.</p>
        pub fn set_level_three(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevelUpdate>,
        ) -> Self {
            self.level_three = input;
            self
        }
        /// <p>The update for level four.</p>
        pub fn level_four(mut self, input: crate::model::HierarchyLevelUpdate) -> Self {
            self.level_four = Some(input);
            self
        }
        /// <p>The update for level four.</p>
        pub fn set_level_four(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevelUpdate>,
        ) -> Self {
            self.level_four = input;
            self
        }
        /// <p>The update for level five.</p>
        pub fn level_five(mut self, input: crate::model::HierarchyLevelUpdate) -> Self {
            self.level_five = Some(input);
            self
        }
        /// <p>The update for level five.</p>
        pub fn set_level_five(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevelUpdate>,
        ) -> Self {
            self.level_five = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyStructureUpdate`](crate::model::HierarchyStructureUpdate)
        pub fn build(self) -> crate::model::HierarchyStructureUpdate {
            crate::model::HierarchyStructureUpdate {
                level_one: self.level_one,
                level_two: self.level_two,
                level_three: self.level_three,
                level_four: self.level_four,
                level_five: self.level_five,
            }
        }
    }
}
impl HierarchyStructureUpdate {
    /// Creates a new builder-style object to manufacture [`HierarchyStructureUpdate`](crate::model::HierarchyStructureUpdate)
    pub fn builder() -> crate::model::hierarchy_structure_update::Builder {
        crate::model::hierarchy_structure_update::Builder::default()
    }
}

/// <p>Contains information about the hierarchy level to update.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HierarchyLevelUpdate {
    /// <p>The name of the user hierarchy level. Must not be more than 50 characters.</p>
    pub name: std::option::Option<std::string::String>,
}
impl HierarchyLevelUpdate {
    /// <p>The name of the user hierarchy level. Must not be more than 50 characters.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for HierarchyLevelUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HierarchyLevelUpdate");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`HierarchyLevelUpdate`](crate::model::HierarchyLevelUpdate)
pub mod hierarchy_level_update {

    /// A builder for [`HierarchyLevelUpdate`](crate::model::HierarchyLevelUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user hierarchy level. Must not be more than 50 characters.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the user hierarchy level. Must not be more than 50 characters.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyLevelUpdate`](crate::model::HierarchyLevelUpdate)
        pub fn build(self) -> crate::model::HierarchyLevelUpdate {
            crate::model::HierarchyLevelUpdate { name: self.name }
        }
    }
}
impl HierarchyLevelUpdate {
    /// Creates a new builder-style object to manufacture [`HierarchyLevelUpdate`](crate::model::HierarchyLevelUpdate)
    pub fn builder() -> crate::model::hierarchy_level_update::Builder {
        crate::model::hierarchy_level_update::Builder::default()
    }
}

/// <p>Contains information about why a property is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PropertyValidationExceptionProperty {
    /// <p>The full property path.</p>
    pub property_path: std::option::Option<std::string::String>,
    /// <p>Why the property is not valid.</p>
    pub reason: std::option::Option<crate::model::PropertyValidationExceptionReason>,
    /// <p>A message describing why the property is not valid.</p>
    pub message: std::option::Option<std::string::String>,
}
impl PropertyValidationExceptionProperty {
    /// <p>The full property path.</p>
    pub fn property_path(&self) -> std::option::Option<&str> {
        self.property_path.as_deref()
    }
    /// <p>Why the property is not valid.</p>
    pub fn reason(&self) -> std::option::Option<&crate::model::PropertyValidationExceptionReason> {
        self.reason.as_ref()
    }
    /// <p>A message describing why the property is not valid.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for PropertyValidationExceptionProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PropertyValidationExceptionProperty");
        formatter.field("property_path", &self.property_path);
        formatter.field("reason", &self.reason);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`PropertyValidationExceptionProperty`](crate::model::PropertyValidationExceptionProperty)
pub mod property_validation_exception_property {

    /// A builder for [`PropertyValidationExceptionProperty`](crate::model::PropertyValidationExceptionProperty)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_path: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<crate::model::PropertyValidationExceptionReason>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The full property path.</p>
        pub fn property_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_path = Some(input.into());
            self
        }
        /// <p>The full property path.</p>
        pub fn set_property_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_path = input;
            self
        }
        /// <p>Why the property is not valid.</p>
        pub fn reason(mut self, input: crate::model::PropertyValidationExceptionReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>Why the property is not valid.</p>
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::PropertyValidationExceptionReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// <p>A message describing why the property is not valid.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing why the property is not valid.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyValidationExceptionProperty`](crate::model::PropertyValidationExceptionProperty)
        pub fn build(self) -> crate::model::PropertyValidationExceptionProperty {
            crate::model::PropertyValidationExceptionProperty {
                property_path: self.property_path,
                reason: self.reason,
                message: self.message,
            }
        }
    }
}
impl PropertyValidationExceptionProperty {
    /// Creates a new builder-style object to manufacture [`PropertyValidationExceptionProperty`](crate::model::PropertyValidationExceptionProperty)
    pub fn builder() -> crate::model::property_validation_exception_property::Builder {
        crate::model::property_validation_exception_property::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PropertyValidationExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    InvalidFormat,
    #[allow(missing_docs)] // documentation missing in model
    NotSupported,
    #[allow(missing_docs)] // documentation missing in model
    ReferencedResourceNotFound,
    #[allow(missing_docs)] // documentation missing in model
    RequiredPropertyMissing,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNameAlreadyExists,
    #[allow(missing_docs)] // documentation missing in model
    UniqueConstraintViolated,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PropertyValidationExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "INVALID_FORMAT" => PropertyValidationExceptionReason::InvalidFormat,
            "NOT_SUPPORTED" => PropertyValidationExceptionReason::NotSupported,
            "REFERENCED_RESOURCE_NOT_FOUND" => {
                PropertyValidationExceptionReason::ReferencedResourceNotFound
            }
            "REQUIRED_PROPERTY_MISSING" => {
                PropertyValidationExceptionReason::RequiredPropertyMissing
            }
            "RESOURCE_NAME_ALREADY_EXISTS" => {
                PropertyValidationExceptionReason::ResourceNameAlreadyExists
            }
            "UNIQUE_CONSTRAINT_VIOLATED" => {
                PropertyValidationExceptionReason::UniqueConstraintViolated
            }
            other => PropertyValidationExceptionReason::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PropertyValidationExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PropertyValidationExceptionReason::from(s))
    }
}
impl PropertyValidationExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PropertyValidationExceptionReason::InvalidFormat => "INVALID_FORMAT",
            PropertyValidationExceptionReason::NotSupported => "NOT_SUPPORTED",
            PropertyValidationExceptionReason::ReferencedResourceNotFound => {
                "REFERENCED_RESOURCE_NOT_FOUND"
            }
            PropertyValidationExceptionReason::RequiredPropertyMissing => {
                "REQUIRED_PROPERTY_MISSING"
            }
            PropertyValidationExceptionReason::ResourceNameAlreadyExists => {
                "RESOURCE_NAME_ALREADY_EXISTS"
            }
            PropertyValidationExceptionReason::UniqueConstraintViolated => {
                "UNIQUE_CONSTRAINT_VIOLATED"
            }
            PropertyValidationExceptionReason::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "INVALID_FORMAT",
            "NOT_SUPPORTED",
            "REFERENCED_RESOURCE_NOT_FOUND",
            "REQUIRED_PROPERTY_MISSING",
            "RESOURCE_NAME_ALREADY_EXISTS",
            "UNIQUE_CONSTRAINT_VIOLATED",
        ]
    }
}
impl AsRef<str> for PropertyValidationExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskTemplateStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TaskTemplateStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => TaskTemplateStatus::Active,
            "INACTIVE" => TaskTemplateStatus::Inactive,
            other => TaskTemplateStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TaskTemplateStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TaskTemplateStatus::from(s))
    }
}
impl TaskTemplateStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TaskTemplateStatus::Active => "ACTIVE",
            TaskTemplateStatus::Inactive => "INACTIVE",
            TaskTemplateStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ACTIVE", "INACTIVE"]
    }
}
impl AsRef<str> for TaskTemplateStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a single task template field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TaskTemplateField {
    /// <p>The unique identifier for the field.</p>
    pub id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
    /// <p>The description of the field.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Indicates the type of field.</p>
    pub r#type: std::option::Option<crate::model::TaskTemplateFieldType>,
    /// <p>A list of options for a single select field.</p>
    pub single_select_options: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl TaskTemplateField {
    /// <p>The unique identifier for the field.</p>
    pub fn id(&self) -> std::option::Option<&crate::model::TaskTemplateFieldIdentifier> {
        self.id.as_ref()
    }
    /// <p>The description of the field.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Indicates the type of field.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::TaskTemplateFieldType> {
        self.r#type.as_ref()
    }
    /// <p>A list of options for a single select field.</p>
    pub fn single_select_options(&self) -> std::option::Option<&[std::string::String]> {
        self.single_select_options.as_deref()
    }
}
impl std::fmt::Debug for TaskTemplateField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TaskTemplateField");
        formatter.field("id", &self.id);
        formatter.field("description", &self.description);
        formatter.field("r#type", &self.r#type);
        formatter.field("single_select_options", &self.single_select_options);
        formatter.finish()
    }
}
/// See [`TaskTemplateField`](crate::model::TaskTemplateField)
pub mod task_template_field {

    /// A builder for [`TaskTemplateField`](crate::model::TaskTemplateField)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::TaskTemplateFieldType>,
        pub(crate) single_select_options: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The unique identifier for the field.</p>
        pub fn id(mut self, input: crate::model::TaskTemplateFieldIdentifier) -> Self {
            self.id = Some(input);
            self
        }
        /// <p>The unique identifier for the field.</p>
        pub fn set_id(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        ) -> Self {
            self.id = input;
            self
        }
        /// <p>The description of the field.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the field.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Indicates the type of field.</p>
        pub fn r#type(mut self, input: crate::model::TaskTemplateFieldType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Indicates the type of field.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateFieldType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `single_select_options`.
        ///
        /// To override the contents of this collection use [`set_single_select_options`](Self::set_single_select_options).
        ///
        /// <p>A list of options for a single select field.</p>
        pub fn single_select_options(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.single_select_options.unwrap_or_default();
            v.push(input.into());
            self.single_select_options = Some(v);
            self
        }
        /// <p>A list of options for a single select field.</p>
        pub fn set_single_select_options(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.single_select_options = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskTemplateField`](crate::model::TaskTemplateField)
        pub fn build(self) -> crate::model::TaskTemplateField {
            crate::model::TaskTemplateField {
                id: self.id,
                description: self.description,
                r#type: self.r#type,
                single_select_options: self.single_select_options,
            }
        }
    }
}
impl TaskTemplateField {
    /// Creates a new builder-style object to manufacture [`TaskTemplateField`](crate::model::TaskTemplateField)
    pub fn builder() -> crate::model::task_template_field::Builder {
        crate::model::task_template_field::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskTemplateFieldType {
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    DateTime,
    #[allow(missing_docs)] // documentation missing in model
    Description,
    #[allow(missing_docs)] // documentation missing in model
    Email,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    Number,
    #[allow(missing_docs)] // documentation missing in model
    QuickConnect,
    #[allow(missing_docs)] // documentation missing in model
    ScheduledTime,
    #[allow(missing_docs)] // documentation missing in model
    SingleSelect,
    #[allow(missing_docs)] // documentation missing in model
    Text,
    #[allow(missing_docs)] // documentation missing in model
    TextArea,
    #[allow(missing_docs)] // documentation missing in model
    Url,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TaskTemplateFieldType {
    fn from(s: &str) -> Self {
        match s {
            "BOOLEAN" => TaskTemplateFieldType::Boolean,
            "DATE_TIME" => TaskTemplateFieldType::DateTime,
            "DESCRIPTION" => TaskTemplateFieldType::Description,
            "EMAIL" => TaskTemplateFieldType::Email,
            "NAME" => TaskTemplateFieldType::Name,
            "NUMBER" => TaskTemplateFieldType::Number,
            "QUICK_CONNECT" => TaskTemplateFieldType::QuickConnect,
            "SCHEDULED_TIME" => TaskTemplateFieldType::ScheduledTime,
            "SINGLE_SELECT" => TaskTemplateFieldType::SingleSelect,
            "TEXT" => TaskTemplateFieldType::Text,
            "TEXT_AREA" => TaskTemplateFieldType::TextArea,
            "URL" => TaskTemplateFieldType::Url,
            other => TaskTemplateFieldType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TaskTemplateFieldType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TaskTemplateFieldType::from(s))
    }
}
impl TaskTemplateFieldType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TaskTemplateFieldType::Boolean => "BOOLEAN",
            TaskTemplateFieldType::DateTime => "DATE_TIME",
            TaskTemplateFieldType::Description => "DESCRIPTION",
            TaskTemplateFieldType::Email => "EMAIL",
            TaskTemplateFieldType::Name => "NAME",
            TaskTemplateFieldType::Number => "NUMBER",
            TaskTemplateFieldType::QuickConnect => "QUICK_CONNECT",
            TaskTemplateFieldType::ScheduledTime => "SCHEDULED_TIME",
            TaskTemplateFieldType::SingleSelect => "SINGLE_SELECT",
            TaskTemplateFieldType::Text => "TEXT",
            TaskTemplateFieldType::TextArea => "TEXT_AREA",
            TaskTemplateFieldType::Url => "URL",
            TaskTemplateFieldType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "BOOLEAN",
            "DATE_TIME",
            "DESCRIPTION",
            "EMAIL",
            "NAME",
            "NUMBER",
            "QUICK_CONNECT",
            "SCHEDULED_TIME",
            "SINGLE_SELECT",
            "TEXT",
            "TEXT_AREA",
            "URL",
        ]
    }
}
impl AsRef<str> for TaskTemplateFieldType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The identifier of the task template field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TaskTemplateFieldIdentifier {
    /// <p>The name of the task template field.</p>
    pub name: std::option::Option<std::string::String>,
}
impl TaskTemplateFieldIdentifier {
    /// <p>The name of the task template field.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for TaskTemplateFieldIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TaskTemplateFieldIdentifier");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`TaskTemplateFieldIdentifier`](crate::model::TaskTemplateFieldIdentifier)
pub mod task_template_field_identifier {

    /// A builder for [`TaskTemplateFieldIdentifier`](crate::model::TaskTemplateFieldIdentifier)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the task template field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the task template field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskTemplateFieldIdentifier`](crate::model::TaskTemplateFieldIdentifier)
        pub fn build(self) -> crate::model::TaskTemplateFieldIdentifier {
            crate::model::TaskTemplateFieldIdentifier { name: self.name }
        }
    }
}
impl TaskTemplateFieldIdentifier {
    /// Creates a new builder-style object to manufacture [`TaskTemplateFieldIdentifier`](crate::model::TaskTemplateFieldIdentifier)
    pub fn builder() -> crate::model::task_template_field_identifier::Builder {
        crate::model::task_template_field_identifier::Builder::default()
    }
}

/// <p>Describes default values for fields on a template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TaskTemplateDefaults {
    /// <p>Default value for the field.</p>
    pub default_field_values:
        std::option::Option<std::vec::Vec<crate::model::TaskTemplateDefaultFieldValue>>,
}
impl TaskTemplateDefaults {
    /// <p>Default value for the field.</p>
    pub fn default_field_values(
        &self,
    ) -> std::option::Option<&[crate::model::TaskTemplateDefaultFieldValue]> {
        self.default_field_values.as_deref()
    }
}
impl std::fmt::Debug for TaskTemplateDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TaskTemplateDefaults");
        formatter.field("default_field_values", &self.default_field_values);
        formatter.finish()
    }
}
/// See [`TaskTemplateDefaults`](crate::model::TaskTemplateDefaults)
pub mod task_template_defaults {

    /// A builder for [`TaskTemplateDefaults`](crate::model::TaskTemplateDefaults)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_field_values:
            std::option::Option<std::vec::Vec<crate::model::TaskTemplateDefaultFieldValue>>,
    }
    impl Builder {
        /// Appends an item to `default_field_values`.
        ///
        /// To override the contents of this collection use [`set_default_field_values`](Self::set_default_field_values).
        ///
        /// <p>Default value for the field.</p>
        pub fn default_field_values(
            mut self,
            input: crate::model::TaskTemplateDefaultFieldValue,
        ) -> Self {
            let mut v = self.default_field_values.unwrap_or_default();
            v.push(input);
            self.default_field_values = Some(v);
            self
        }
        /// <p>Default value for the field.</p>
        pub fn set_default_field_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TaskTemplateDefaultFieldValue>>,
        ) -> Self {
            self.default_field_values = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskTemplateDefaults`](crate::model::TaskTemplateDefaults)
        pub fn build(self) -> crate::model::TaskTemplateDefaults {
            crate::model::TaskTemplateDefaults {
                default_field_values: self.default_field_values,
            }
        }
    }
}
impl TaskTemplateDefaults {
    /// Creates a new builder-style object to manufacture [`TaskTemplateDefaults`](crate::model::TaskTemplateDefaults)
    pub fn builder() -> crate::model::task_template_defaults::Builder {
        crate::model::task_template_defaults::Builder::default()
    }
}

/// <p>Describes a default field and its corresponding value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TaskTemplateDefaultFieldValue {
    /// <p>Identifier of a field. </p>
    pub id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
    /// <p>Default value for the field.</p>
    pub default_value: std::option::Option<std::string::String>,
}
impl TaskTemplateDefaultFieldValue {
    /// <p>Identifier of a field. </p>
    pub fn id(&self) -> std::option::Option<&crate::model::TaskTemplateFieldIdentifier> {
        self.id.as_ref()
    }
    /// <p>Default value for the field.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
}
impl std::fmt::Debug for TaskTemplateDefaultFieldValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TaskTemplateDefaultFieldValue");
        formatter.field("id", &self.id);
        formatter.field("default_value", &self.default_value);
        formatter.finish()
    }
}
/// See [`TaskTemplateDefaultFieldValue`](crate::model::TaskTemplateDefaultFieldValue)
pub mod task_template_default_field_value {

    /// A builder for [`TaskTemplateDefaultFieldValue`](crate::model::TaskTemplateDefaultFieldValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        pub(crate) default_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifier of a field. </p>
        pub fn id(mut self, input: crate::model::TaskTemplateFieldIdentifier) -> Self {
            self.id = Some(input);
            self
        }
        /// <p>Identifier of a field. </p>
        pub fn set_id(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        ) -> Self {
            self.id = input;
            self
        }
        /// <p>Default value for the field.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>Default value for the field.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskTemplateDefaultFieldValue`](crate::model::TaskTemplateDefaultFieldValue)
        pub fn build(self) -> crate::model::TaskTemplateDefaultFieldValue {
            crate::model::TaskTemplateDefaultFieldValue {
                id: self.id,
                default_value: self.default_value,
            }
        }
    }
}
impl TaskTemplateDefaultFieldValue {
    /// Creates a new builder-style object to manufacture [`TaskTemplateDefaultFieldValue`](crate::model::TaskTemplateDefaultFieldValue)
    pub fn builder() -> crate::model::task_template_default_field_value::Builder {
        crate::model::task_template_default_field_value::Builder::default()
    }
}

/// <p>Describes constraints that apply to the template fields.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TaskTemplateConstraints {
    /// <p>Lists the fields that are required to be filled by agents.</p>
    pub required_fields: std::option::Option<std::vec::Vec<crate::model::RequiredFieldInfo>>,
    /// <p>Lists the fields that are read-only to agents, and cannot be edited.</p>
    pub read_only_fields: std::option::Option<std::vec::Vec<crate::model::ReadOnlyFieldInfo>>,
    /// <p>Lists the fields that are invisible to agents.</p>
    pub invisible_fields: std::option::Option<std::vec::Vec<crate::model::InvisibleFieldInfo>>,
}
impl TaskTemplateConstraints {
    /// <p>Lists the fields that are required to be filled by agents.</p>
    pub fn required_fields(&self) -> std::option::Option<&[crate::model::RequiredFieldInfo]> {
        self.required_fields.as_deref()
    }
    /// <p>Lists the fields that are read-only to agents, and cannot be edited.</p>
    pub fn read_only_fields(&self) -> std::option::Option<&[crate::model::ReadOnlyFieldInfo]> {
        self.read_only_fields.as_deref()
    }
    /// <p>Lists the fields that are invisible to agents.</p>
    pub fn invisible_fields(&self) -> std::option::Option<&[crate::model::InvisibleFieldInfo]> {
        self.invisible_fields.as_deref()
    }
}
impl std::fmt::Debug for TaskTemplateConstraints {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TaskTemplateConstraints");
        formatter.field("required_fields", &self.required_fields);
        formatter.field("read_only_fields", &self.read_only_fields);
        formatter.field("invisible_fields", &self.invisible_fields);
        formatter.finish()
    }
}
/// See [`TaskTemplateConstraints`](crate::model::TaskTemplateConstraints)
pub mod task_template_constraints {

    /// A builder for [`TaskTemplateConstraints`](crate::model::TaskTemplateConstraints)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) required_fields:
            std::option::Option<std::vec::Vec<crate::model::RequiredFieldInfo>>,
        pub(crate) read_only_fields:
            std::option::Option<std::vec::Vec<crate::model::ReadOnlyFieldInfo>>,
        pub(crate) invisible_fields:
            std::option::Option<std::vec::Vec<crate::model::InvisibleFieldInfo>>,
    }
    impl Builder {
        /// Appends an item to `required_fields`.
        ///
        /// To override the contents of this collection use [`set_required_fields`](Self::set_required_fields).
        ///
        /// <p>Lists the fields that are required to be filled by agents.</p>
        pub fn required_fields(mut self, input: crate::model::RequiredFieldInfo) -> Self {
            let mut v = self.required_fields.unwrap_or_default();
            v.push(input);
            self.required_fields = Some(v);
            self
        }
        /// <p>Lists the fields that are required to be filled by agents.</p>
        pub fn set_required_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RequiredFieldInfo>>,
        ) -> Self {
            self.required_fields = input;
            self
        }
        /// Appends an item to `read_only_fields`.
        ///
        /// To override the contents of this collection use [`set_read_only_fields`](Self::set_read_only_fields).
        ///
        /// <p>Lists the fields that are read-only to agents, and cannot be edited.</p>
        pub fn read_only_fields(mut self, input: crate::model::ReadOnlyFieldInfo) -> Self {
            let mut v = self.read_only_fields.unwrap_or_default();
            v.push(input);
            self.read_only_fields = Some(v);
            self
        }
        /// <p>Lists the fields that are read-only to agents, and cannot be edited.</p>
        pub fn set_read_only_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReadOnlyFieldInfo>>,
        ) -> Self {
            self.read_only_fields = input;
            self
        }
        /// Appends an item to `invisible_fields`.
        ///
        /// To override the contents of this collection use [`set_invisible_fields`](Self::set_invisible_fields).
        ///
        /// <p>Lists the fields that are invisible to agents.</p>
        pub fn invisible_fields(mut self, input: crate::model::InvisibleFieldInfo) -> Self {
            let mut v = self.invisible_fields.unwrap_or_default();
            v.push(input);
            self.invisible_fields = Some(v);
            self
        }
        /// <p>Lists the fields that are invisible to agents.</p>
        pub fn set_invisible_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InvisibleFieldInfo>>,
        ) -> Self {
            self.invisible_fields = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskTemplateConstraints`](crate::model::TaskTemplateConstraints)
        pub fn build(self) -> crate::model::TaskTemplateConstraints {
            crate::model::TaskTemplateConstraints {
                required_fields: self.required_fields,
                read_only_fields: self.read_only_fields,
                invisible_fields: self.invisible_fields,
            }
        }
    }
}
impl TaskTemplateConstraints {
    /// Creates a new builder-style object to manufacture [`TaskTemplateConstraints`](crate::model::TaskTemplateConstraints)
    pub fn builder() -> crate::model::task_template_constraints::Builder {
        crate::model::task_template_constraints::Builder::default()
    }
}

/// <p>A field that is invisible to an agent.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvisibleFieldInfo {
    /// <p>Identifier of the invisible field.</p>
    pub id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
}
impl InvisibleFieldInfo {
    /// <p>Identifier of the invisible field.</p>
    pub fn id(&self) -> std::option::Option<&crate::model::TaskTemplateFieldIdentifier> {
        self.id.as_ref()
    }
}
impl std::fmt::Debug for InvisibleFieldInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvisibleFieldInfo");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}
/// See [`InvisibleFieldInfo`](crate::model::InvisibleFieldInfo)
pub mod invisible_field_info {

    /// A builder for [`InvisibleFieldInfo`](crate::model::InvisibleFieldInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
    }
    impl Builder {
        /// <p>Identifier of the invisible field.</p>
        pub fn id(mut self, input: crate::model::TaskTemplateFieldIdentifier) -> Self {
            self.id = Some(input);
            self
        }
        /// <p>Identifier of the invisible field.</p>
        pub fn set_id(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        ) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`InvisibleFieldInfo`](crate::model::InvisibleFieldInfo)
        pub fn build(self) -> crate::model::InvisibleFieldInfo {
            crate::model::InvisibleFieldInfo { id: self.id }
        }
    }
}
impl InvisibleFieldInfo {
    /// Creates a new builder-style object to manufacture [`InvisibleFieldInfo`](crate::model::InvisibleFieldInfo)
    pub fn builder() -> crate::model::invisible_field_info::Builder {
        crate::model::invisible_field_info::Builder::default()
    }
}

/// <p>Indicates a field that is read-only to an agent.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReadOnlyFieldInfo {
    /// <p>Identifier of the read-only field.</p>
    pub id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
}
impl ReadOnlyFieldInfo {
    /// <p>Identifier of the read-only field.</p>
    pub fn id(&self) -> std::option::Option<&crate::model::TaskTemplateFieldIdentifier> {
        self.id.as_ref()
    }
}
impl std::fmt::Debug for ReadOnlyFieldInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReadOnlyFieldInfo");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}
/// See [`ReadOnlyFieldInfo`](crate::model::ReadOnlyFieldInfo)
pub mod read_only_field_info {

    /// A builder for [`ReadOnlyFieldInfo`](crate::model::ReadOnlyFieldInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
    }
    impl Builder {
        /// <p>Identifier of the read-only field.</p>
        pub fn id(mut self, input: crate::model::TaskTemplateFieldIdentifier) -> Self {
            self.id = Some(input);
            self
        }
        /// <p>Identifier of the read-only field.</p>
        pub fn set_id(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        ) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`ReadOnlyFieldInfo`](crate::model::ReadOnlyFieldInfo)
        pub fn build(self) -> crate::model::ReadOnlyFieldInfo {
            crate::model::ReadOnlyFieldInfo { id: self.id }
        }
    }
}
impl ReadOnlyFieldInfo {
    /// Creates a new builder-style object to manufacture [`ReadOnlyFieldInfo`](crate::model::ReadOnlyFieldInfo)
    pub fn builder() -> crate::model::read_only_field_info::Builder {
        crate::model::read_only_field_info::Builder::default()
    }
}

/// <p>Information about a required field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RequiredFieldInfo {
    /// <p>The unique identifier for the field.</p>
    pub id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
}
impl RequiredFieldInfo {
    /// <p>The unique identifier for the field.</p>
    pub fn id(&self) -> std::option::Option<&crate::model::TaskTemplateFieldIdentifier> {
        self.id.as_ref()
    }
}
impl std::fmt::Debug for RequiredFieldInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RequiredFieldInfo");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}
/// See [`RequiredFieldInfo`](crate::model::RequiredFieldInfo)
pub mod required_field_info {

    /// A builder for [`RequiredFieldInfo`](crate::model::RequiredFieldInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
    }
    impl Builder {
        /// <p>The unique identifier for the field.</p>
        pub fn id(mut self, input: crate::model::TaskTemplateFieldIdentifier) -> Self {
            self.id = Some(input);
            self
        }
        /// <p>The unique identifier for the field.</p>
        pub fn set_id(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateFieldIdentifier>,
        ) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`RequiredFieldInfo`](crate::model::RequiredFieldInfo)
        pub fn build(self) -> crate::model::RequiredFieldInfo {
            crate::model::RequiredFieldInfo { id: self.id }
        }
    }
}
impl RequiredFieldInfo {
    /// Creates a new builder-style object to manufacture [`RequiredFieldInfo`](crate::model::RequiredFieldInfo)
    pub fn builder() -> crate::model::required_field_info::Builder {
        crate::model::required_field_info::Builder::default()
    }
}

/// <p>Contains information about the queue and channel for which priority and delay can be set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RoutingProfileQueueConfig {
    /// <p>Contains information about a queue resource.</p>
    pub queue_reference: std::option::Option<crate::model::RoutingProfileQueueReference>,
    /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
    pub priority: std::option::Option<i32>,
    /// <p>The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub delay: std::option::Option<i32>,
}
impl RoutingProfileQueueConfig {
    /// <p>Contains information about a queue resource.</p>
    pub fn queue_reference(
        &self,
    ) -> std::option::Option<&crate::model::RoutingProfileQueueReference> {
        self.queue_reference.as_ref()
    }
    /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
    pub fn priority(&self) -> std::option::Option<i32> {
        self.priority
    }
    /// <p>The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub fn delay(&self) -> std::option::Option<i32> {
        self.delay
    }
}
impl std::fmt::Debug for RoutingProfileQueueConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RoutingProfileQueueConfig");
        formatter.field("queue_reference", &self.queue_reference);
        formatter.field("priority", &self.priority);
        formatter.field("delay", &self.delay);
        formatter.finish()
    }
}
/// See [`RoutingProfileQueueConfig`](crate::model::RoutingProfileQueueConfig)
pub mod routing_profile_queue_config {

    /// A builder for [`RoutingProfileQueueConfig`](crate::model::RoutingProfileQueueConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queue_reference: std::option::Option<crate::model::RoutingProfileQueueReference>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) delay: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Contains information about a queue resource.</p>
        pub fn queue_reference(
            mut self,
            input: crate::model::RoutingProfileQueueReference,
        ) -> Self {
            self.queue_reference = Some(input);
            self
        }
        /// <p>Contains information about a queue resource.</p>
        pub fn set_queue_reference(
            mut self,
            input: std::option::Option<crate::model::RoutingProfileQueueReference>,
        ) -> Self {
            self.queue_reference = input;
            self
        }
        /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn delay(mut self, input: i32) -> Self {
            self.delay = Some(input);
            self
        }
        /// <p>The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn set_delay(mut self, input: std::option::Option<i32>) -> Self {
            self.delay = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfileQueueConfig`](crate::model::RoutingProfileQueueConfig)
        pub fn build(self) -> crate::model::RoutingProfileQueueConfig {
            crate::model::RoutingProfileQueueConfig {
                queue_reference: self.queue_reference,
                priority: self.priority,
                delay: self.delay,
            }
        }
    }
}
impl RoutingProfileQueueConfig {
    /// Creates a new builder-style object to manufacture [`RoutingProfileQueueConfig`](crate::model::RoutingProfileQueueConfig)
    pub fn builder() -> crate::model::routing_profile_queue_config::Builder {
        crate::model::routing_profile_queue_config::Builder::default()
    }
}

/// <p>Contains the channel and queue identifier for a routing profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RoutingProfileQueueReference {
    /// <p>The identifier for the queue.</p>
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
    pub channel: std::option::Option<crate::model::Channel>,
}
impl RoutingProfileQueueReference {
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
    pub fn channel(&self) -> std::option::Option<&crate::model::Channel> {
        self.channel.as_ref()
    }
}
impl std::fmt::Debug for RoutingProfileQueueReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RoutingProfileQueueReference");
        formatter.field("queue_id", &self.queue_id);
        formatter.field("channel", &self.channel);
        formatter.finish()
    }
}
/// See [`RoutingProfileQueueReference`](crate::model::RoutingProfileQueueReference)
pub mod routing_profile_queue_reference {

    /// A builder for [`RoutingProfileQueueReference`](crate::model::RoutingProfileQueueReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) channel: std::option::Option<crate::model::Channel>,
    }
    impl Builder {
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
        pub fn channel(mut self, input: crate::model::Channel) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
        pub fn set_channel(mut self, input: std::option::Option<crate::model::Channel>) -> Self {
            self.channel = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfileQueueReference`](crate::model::RoutingProfileQueueReference)
        pub fn build(self) -> crate::model::RoutingProfileQueueReference {
            crate::model::RoutingProfileQueueReference {
                queue_id: self.queue_id,
                channel: self.channel,
            }
        }
    }
}
impl RoutingProfileQueueReference {
    /// Creates a new builder-style object to manufacture [`RoutingProfileQueueReference`](crate::model::RoutingProfileQueueReference)
    pub fn builder() -> crate::model::routing_profile_queue_reference::Builder {
        crate::model::routing_profile_queue_reference::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Channel {
    #[allow(missing_docs)] // documentation missing in model
    Chat,
    #[allow(missing_docs)] // documentation missing in model
    Task,
    #[allow(missing_docs)] // documentation missing in model
    Voice,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Channel {
    fn from(s: &str) -> Self {
        match s {
            "CHAT" => Channel::Chat,
            "TASK" => Channel::Task,
            "VOICE" => Channel::Voice,
            other => Channel::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Channel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Channel::from(s))
    }
}
impl Channel {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Channel::Chat => "CHAT",
            Channel::Task => "TASK",
            Channel::Voice => "VOICE",
            Channel::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CHAT", "TASK", "VOICE"]
    }
}
impl AsRef<str> for Channel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about which channels are supported, and how many contacts an agent can have on a channel simultaneously.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MediaConcurrency {
    /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
    pub channel: std::option::Option<crate::model::Channel>,
    /// <p>The number of contacts an agent can have on a channel simultaneously.</p>
    /// <p>Valid Range for <code>VOICE</code>: Minimum value of 1. Maximum value of 1.</p>
    /// <p>Valid Range for <code>CHAT</code>: Minimum value of 1. Maximum value of 10.</p>
    /// <p>Valid Range for <code>TASK</code>: Minimum value of 1. Maximum value of 10.</p>
    pub concurrency: i32,
}
impl MediaConcurrency {
    /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
    pub fn channel(&self) -> std::option::Option<&crate::model::Channel> {
        self.channel.as_ref()
    }
    /// <p>The number of contacts an agent can have on a channel simultaneously.</p>
    /// <p>Valid Range for <code>VOICE</code>: Minimum value of 1. Maximum value of 1.</p>
    /// <p>Valid Range for <code>CHAT</code>: Minimum value of 1. Maximum value of 10.</p>
    /// <p>Valid Range for <code>TASK</code>: Minimum value of 1. Maximum value of 10.</p>
    pub fn concurrency(&self) -> i32 {
        self.concurrency
    }
}
impl std::fmt::Debug for MediaConcurrency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MediaConcurrency");
        formatter.field("channel", &self.channel);
        formatter.field("concurrency", &self.concurrency);
        formatter.finish()
    }
}
/// See [`MediaConcurrency`](crate::model::MediaConcurrency)
pub mod media_concurrency {

    /// A builder for [`MediaConcurrency`](crate::model::MediaConcurrency)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel: std::option::Option<crate::model::Channel>,
        pub(crate) concurrency: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
        pub fn channel(mut self, input: crate::model::Channel) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
        pub fn set_channel(mut self, input: std::option::Option<crate::model::Channel>) -> Self {
            self.channel = input;
            self
        }
        /// <p>The number of contacts an agent can have on a channel simultaneously.</p>
        /// <p>Valid Range for <code>VOICE</code>: Minimum value of 1. Maximum value of 1.</p>
        /// <p>Valid Range for <code>CHAT</code>: Minimum value of 1. Maximum value of 10.</p>
        /// <p>Valid Range for <code>TASK</code>: Minimum value of 1. Maximum value of 10.</p>
        pub fn concurrency(mut self, input: i32) -> Self {
            self.concurrency = Some(input);
            self
        }
        /// <p>The number of contacts an agent can have on a channel simultaneously.</p>
        /// <p>Valid Range for <code>VOICE</code>: Minimum value of 1. Maximum value of 1.</p>
        /// <p>Valid Range for <code>CHAT</code>: Minimum value of 1. Maximum value of 10.</p>
        /// <p>Valid Range for <code>TASK</code>: Minimum value of 1. Maximum value of 10.</p>
        pub fn set_concurrency(mut self, input: std::option::Option<i32>) -> Self {
            self.concurrency = input;
            self
        }
        /// Consumes the builder and constructs a [`MediaConcurrency`](crate::model::MediaConcurrency)
        pub fn build(self) -> crate::model::MediaConcurrency {
            crate::model::MediaConcurrency {
                channel: self.channel,
                concurrency: self.concurrency.unwrap_or_default(),
            }
        }
    }
}
impl MediaConcurrency {
    /// Creates a new builder-style object to manufacture [`MediaConcurrency`](crate::model::MediaConcurrency)
    pub fn builder() -> crate::model::media_concurrency::Builder {
        crate::model::media_concurrency::Builder::default()
    }
}

/// <p>Contains configuration settings for a quick connect.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QuickConnectConfig {
    /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE). </p>
    pub quick_connect_type: std::option::Option<crate::model::QuickConnectType>,
    /// <p>The user configuration. This is required only if QuickConnectType is USER.</p>
    pub user_config: std::option::Option<crate::model::UserQuickConnectConfig>,
    /// <p>The queue configuration. This is required only if QuickConnectType is QUEUE.</p>
    pub queue_config: std::option::Option<crate::model::QueueQuickConnectConfig>,
    /// <p>The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.</p>
    pub phone_config: std::option::Option<crate::model::PhoneNumberQuickConnectConfig>,
}
impl QuickConnectConfig {
    /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE). </p>
    pub fn quick_connect_type(&self) -> std::option::Option<&crate::model::QuickConnectType> {
        self.quick_connect_type.as_ref()
    }
    /// <p>The user configuration. This is required only if QuickConnectType is USER.</p>
    pub fn user_config(&self) -> std::option::Option<&crate::model::UserQuickConnectConfig> {
        self.user_config.as_ref()
    }
    /// <p>The queue configuration. This is required only if QuickConnectType is QUEUE.</p>
    pub fn queue_config(&self) -> std::option::Option<&crate::model::QueueQuickConnectConfig> {
        self.queue_config.as_ref()
    }
    /// <p>The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.</p>
    pub fn phone_config(
        &self,
    ) -> std::option::Option<&crate::model::PhoneNumberQuickConnectConfig> {
        self.phone_config.as_ref()
    }
}
impl std::fmt::Debug for QuickConnectConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QuickConnectConfig");
        formatter.field("quick_connect_type", &self.quick_connect_type);
        formatter.field("user_config", &self.user_config);
        formatter.field("queue_config", &self.queue_config);
        formatter.field("phone_config", &self.phone_config);
        formatter.finish()
    }
}
/// See [`QuickConnectConfig`](crate::model::QuickConnectConfig)
pub mod quick_connect_config {

    /// A builder for [`QuickConnectConfig`](crate::model::QuickConnectConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) quick_connect_type: std::option::Option<crate::model::QuickConnectType>,
        pub(crate) user_config: std::option::Option<crate::model::UserQuickConnectConfig>,
        pub(crate) queue_config: std::option::Option<crate::model::QueueQuickConnectConfig>,
        pub(crate) phone_config: std::option::Option<crate::model::PhoneNumberQuickConnectConfig>,
    }
    impl Builder {
        /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE). </p>
        pub fn quick_connect_type(mut self, input: crate::model::QuickConnectType) -> Self {
            self.quick_connect_type = Some(input);
            self
        }
        /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE). </p>
        pub fn set_quick_connect_type(
            mut self,
            input: std::option::Option<crate::model::QuickConnectType>,
        ) -> Self {
            self.quick_connect_type = input;
            self
        }
        /// <p>The user configuration. This is required only if QuickConnectType is USER.</p>
        pub fn user_config(mut self, input: crate::model::UserQuickConnectConfig) -> Self {
            self.user_config = Some(input);
            self
        }
        /// <p>The user configuration. This is required only if QuickConnectType is USER.</p>
        pub fn set_user_config(
            mut self,
            input: std::option::Option<crate::model::UserQuickConnectConfig>,
        ) -> Self {
            self.user_config = input;
            self
        }
        /// <p>The queue configuration. This is required only if QuickConnectType is QUEUE.</p>
        pub fn queue_config(mut self, input: crate::model::QueueQuickConnectConfig) -> Self {
            self.queue_config = Some(input);
            self
        }
        /// <p>The queue configuration. This is required only if QuickConnectType is QUEUE.</p>
        pub fn set_queue_config(
            mut self,
            input: std::option::Option<crate::model::QueueQuickConnectConfig>,
        ) -> Self {
            self.queue_config = input;
            self
        }
        /// <p>The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.</p>
        pub fn phone_config(mut self, input: crate::model::PhoneNumberQuickConnectConfig) -> Self {
            self.phone_config = Some(input);
            self
        }
        /// <p>The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.</p>
        pub fn set_phone_config(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberQuickConnectConfig>,
        ) -> Self {
            self.phone_config = input;
            self
        }
        /// Consumes the builder and constructs a [`QuickConnectConfig`](crate::model::QuickConnectConfig)
        pub fn build(self) -> crate::model::QuickConnectConfig {
            crate::model::QuickConnectConfig {
                quick_connect_type: self.quick_connect_type,
                user_config: self.user_config,
                queue_config: self.queue_config,
                phone_config: self.phone_config,
            }
        }
    }
}
impl QuickConnectConfig {
    /// Creates a new builder-style object to manufacture [`QuickConnectConfig`](crate::model::QuickConnectConfig)
    pub fn builder() -> crate::model::quick_connect_config::Builder {
        crate::model::quick_connect_config::Builder::default()
    }
}

/// <p>Contains information about a phone number for a quick connect.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PhoneNumberQuickConnectConfig {
    /// <p>The phone number in E.164 format.</p>
    pub phone_number: std::option::Option<std::string::String>,
}
impl PhoneNumberQuickConnectConfig {
    /// <p>The phone number in E.164 format.</p>
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
}
impl std::fmt::Debug for PhoneNumberQuickConnectConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PhoneNumberQuickConnectConfig");
        formatter.field("phone_number", &self.phone_number);
        formatter.finish()
    }
}
/// See [`PhoneNumberQuickConnectConfig`](crate::model::PhoneNumberQuickConnectConfig)
pub mod phone_number_quick_connect_config {

    /// A builder for [`PhoneNumberQuickConnectConfig`](crate::model::PhoneNumberQuickConnectConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The phone number in E.164 format.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>The phone number in E.164 format.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// Consumes the builder and constructs a [`PhoneNumberQuickConnectConfig`](crate::model::PhoneNumberQuickConnectConfig)
        pub fn build(self) -> crate::model::PhoneNumberQuickConnectConfig {
            crate::model::PhoneNumberQuickConnectConfig {
                phone_number: self.phone_number,
            }
        }
    }
}
impl PhoneNumberQuickConnectConfig {
    /// Creates a new builder-style object to manufacture [`PhoneNumberQuickConnectConfig`](crate::model::PhoneNumberQuickConnectConfig)
    pub fn builder() -> crate::model::phone_number_quick_connect_config::Builder {
        crate::model::phone_number_quick_connect_config::Builder::default()
    }
}

/// <p>Contains information about a queue for a quick connect. The contact flow must be of type Transfer to Queue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueueQuickConnectConfig {
    /// <p>The identifier for the queue.</p>
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact flow.</p>
    pub contact_flow_id: std::option::Option<std::string::String>,
}
impl QueueQuickConnectConfig {
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The identifier of the contact flow.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
}
impl std::fmt::Debug for QueueQuickConnectConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueueQuickConnectConfig");
        formatter.field("queue_id", &self.queue_id);
        formatter.field("contact_flow_id", &self.contact_flow_id);
        formatter.finish()
    }
}
/// See [`QueueQuickConnectConfig`](crate::model::QueueQuickConnectConfig)
pub mod queue_quick_connect_config {

    /// A builder for [`QueueQuickConnectConfig`](crate::model::QueueQuickConnectConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The identifier of the contact flow.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact flow.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// Consumes the builder and constructs a [`QueueQuickConnectConfig`](crate::model::QueueQuickConnectConfig)
        pub fn build(self) -> crate::model::QueueQuickConnectConfig {
            crate::model::QueueQuickConnectConfig {
                queue_id: self.queue_id,
                contact_flow_id: self.contact_flow_id,
            }
        }
    }
}
impl QueueQuickConnectConfig {
    /// Creates a new builder-style object to manufacture [`QueueQuickConnectConfig`](crate::model::QueueQuickConnectConfig)
    pub fn builder() -> crate::model::queue_quick_connect_config::Builder {
        crate::model::queue_quick_connect_config::Builder::default()
    }
}

/// <p>Contains information about the quick connect configuration settings for a user. The contact flow must be of type Transfer to Agent.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserQuickConnectConfig {
    /// <p>The identifier of the user.</p>
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact flow.</p>
    pub contact_flow_id: std::option::Option<std::string::String>,
}
impl UserQuickConnectConfig {
    /// <p>The identifier of the user.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The identifier of the contact flow.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
}
impl std::fmt::Debug for UserQuickConnectConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserQuickConnectConfig");
        formatter.field("user_id", &self.user_id);
        formatter.field("contact_flow_id", &self.contact_flow_id);
        formatter.finish()
    }
}
/// See [`UserQuickConnectConfig`](crate::model::UserQuickConnectConfig)
pub mod user_quick_connect_config {

    /// A builder for [`UserQuickConnectConfig`](crate::model::UserQuickConnectConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the user.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The identifier of the contact flow.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact flow.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UserQuickConnectConfig`](crate::model::UserQuickConnectConfig)
        pub fn build(self) -> crate::model::UserQuickConnectConfig {
            crate::model::UserQuickConnectConfig {
                user_id: self.user_id,
                contact_flow_id: self.contact_flow_id,
            }
        }
    }
}
impl UserQuickConnectConfig {
    /// Creates a new builder-style object to manufacture [`UserQuickConnectConfig`](crate::model::UserQuickConnectConfig)
    pub fn builder() -> crate::model::user_quick_connect_config::Builder {
        crate::model::user_quick_connect_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QuickConnectType {
    #[allow(missing_docs)] // documentation missing in model
    PhoneNumber,
    #[allow(missing_docs)] // documentation missing in model
    Queue,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for QuickConnectType {
    fn from(s: &str) -> Self {
        match s {
            "PHONE_NUMBER" => QuickConnectType::PhoneNumber,
            "QUEUE" => QuickConnectType::Queue,
            "USER" => QuickConnectType::User,
            other => QuickConnectType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for QuickConnectType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QuickConnectType::from(s))
    }
}
impl QuickConnectType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QuickConnectType::PhoneNumber => "PHONE_NUMBER",
            QuickConnectType::Queue => "QUEUE",
            QuickConnectType::User => "USER",
            QuickConnectType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["PHONE_NUMBER", "QUEUE", "USER"]
    }
}
impl AsRef<str> for QuickConnectType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueueStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for QueueStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => QueueStatus::Disabled,
            "ENABLED" => QueueStatus::Enabled,
            other => QueueStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for QueueStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueueStatus::from(s))
    }
}
impl QueueStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueueStatus::Disabled => "DISABLED",
            QueueStatus::Enabled => "ENABLED",
            QueueStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for QueueStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutboundCallerConfig {
    /// <p>The caller ID name.</p>
    pub outbound_caller_id_name: std::option::Option<std::string::String>,
    /// <p>The caller ID number.</p>
    pub outbound_caller_id_number_id: std::option::Option<std::string::String>,
    /// <p>The outbound whisper flow to be used during an outbound call.</p>
    pub outbound_flow_id: std::option::Option<std::string::String>,
}
impl OutboundCallerConfig {
    /// <p>The caller ID name.</p>
    pub fn outbound_caller_id_name(&self) -> std::option::Option<&str> {
        self.outbound_caller_id_name.as_deref()
    }
    /// <p>The caller ID number.</p>
    pub fn outbound_caller_id_number_id(&self) -> std::option::Option<&str> {
        self.outbound_caller_id_number_id.as_deref()
    }
    /// <p>The outbound whisper flow to be used during an outbound call.</p>
    pub fn outbound_flow_id(&self) -> std::option::Option<&str> {
        self.outbound_flow_id.as_deref()
    }
}
impl std::fmt::Debug for OutboundCallerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutboundCallerConfig");
        formatter.field("outbound_caller_id_name", &self.outbound_caller_id_name);
        formatter.field(
            "outbound_caller_id_number_id",
            &self.outbound_caller_id_number_id,
        );
        formatter.field("outbound_flow_id", &self.outbound_flow_id);
        formatter.finish()
    }
}
/// See [`OutboundCallerConfig`](crate::model::OutboundCallerConfig)
pub mod outbound_caller_config {

    /// A builder for [`OutboundCallerConfig`](crate::model::OutboundCallerConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) outbound_caller_id_name: std::option::Option<std::string::String>,
        pub(crate) outbound_caller_id_number_id: std::option::Option<std::string::String>,
        pub(crate) outbound_flow_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The caller ID name.</p>
        pub fn outbound_caller_id_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.outbound_caller_id_name = Some(input.into());
            self
        }
        /// <p>The caller ID name.</p>
        pub fn set_outbound_caller_id_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.outbound_caller_id_name = input;
            self
        }
        /// <p>The caller ID number.</p>
        pub fn outbound_caller_id_number_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.outbound_caller_id_number_id = Some(input.into());
            self
        }
        /// <p>The caller ID number.</p>
        pub fn set_outbound_caller_id_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.outbound_caller_id_number_id = input;
            self
        }
        /// <p>The outbound whisper flow to be used during an outbound call.</p>
        pub fn outbound_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.outbound_flow_id = Some(input.into());
            self
        }
        /// <p>The outbound whisper flow to be used during an outbound call.</p>
        pub fn set_outbound_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.outbound_flow_id = input;
            self
        }
        /// Consumes the builder and constructs a [`OutboundCallerConfig`](crate::model::OutboundCallerConfig)
        pub fn build(self) -> crate::model::OutboundCallerConfig {
            crate::model::OutboundCallerConfig {
                outbound_caller_id_name: self.outbound_caller_id_name,
                outbound_caller_id_number_id: self.outbound_caller_id_number_id,
                outbound_flow_id: self.outbound_flow_id,
            }
        }
    }
}
impl OutboundCallerConfig {
    /// Creates a new builder-style object to manufacture [`OutboundCallerConfig`](crate::model::OutboundCallerConfig)
    pub fn builder() -> crate::model::outbound_caller_config::Builder {
        crate::model::outbound_caller_config::Builder::default()
    }
}

/// <p>The storage configuration for the instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceStorageConfig {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    pub association_id: std::option::Option<std::string::String>,
    /// <p>A valid storage type.</p>
    pub storage_type: std::option::Option<crate::model::StorageType>,
    /// <p>The S3 bucket configuration.</p>
    pub s3_config: std::option::Option<crate::model::S3Config>,
    /// <p>The configuration of the Kinesis video stream.</p>
    pub kinesis_video_stream_config: std::option::Option<crate::model::KinesisVideoStreamConfig>,
    /// <p>The configuration of the Kinesis data stream.</p>
    pub kinesis_stream_config: std::option::Option<crate::model::KinesisStreamConfig>,
    /// <p>The configuration of the Kinesis Firehose delivery stream.</p>
    pub kinesis_firehose_config: std::option::Option<crate::model::KinesisFirehoseConfig>,
}
impl InstanceStorageConfig {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    pub fn association_id(&self) -> std::option::Option<&str> {
        self.association_id.as_deref()
    }
    /// <p>A valid storage type.</p>
    pub fn storage_type(&self) -> std::option::Option<&crate::model::StorageType> {
        self.storage_type.as_ref()
    }
    /// <p>The S3 bucket configuration.</p>
    pub fn s3_config(&self) -> std::option::Option<&crate::model::S3Config> {
        self.s3_config.as_ref()
    }
    /// <p>The configuration of the Kinesis video stream.</p>
    pub fn kinesis_video_stream_config(
        &self,
    ) -> std::option::Option<&crate::model::KinesisVideoStreamConfig> {
        self.kinesis_video_stream_config.as_ref()
    }
    /// <p>The configuration of the Kinesis data stream.</p>
    pub fn kinesis_stream_config(&self) -> std::option::Option<&crate::model::KinesisStreamConfig> {
        self.kinesis_stream_config.as_ref()
    }
    /// <p>The configuration of the Kinesis Firehose delivery stream.</p>
    pub fn kinesis_firehose_config(
        &self,
    ) -> std::option::Option<&crate::model::KinesisFirehoseConfig> {
        self.kinesis_firehose_config.as_ref()
    }
}
impl std::fmt::Debug for InstanceStorageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceStorageConfig");
        formatter.field("association_id", &self.association_id);
        formatter.field("storage_type", &self.storage_type);
        formatter.field("s3_config", &self.s3_config);
        formatter.field(
            "kinesis_video_stream_config",
            &self.kinesis_video_stream_config,
        );
        formatter.field("kinesis_stream_config", &self.kinesis_stream_config);
        formatter.field("kinesis_firehose_config", &self.kinesis_firehose_config);
        formatter.finish()
    }
}
/// See [`InstanceStorageConfig`](crate::model::InstanceStorageConfig)
pub mod instance_storage_config {

    /// A builder for [`InstanceStorageConfig`](crate::model::InstanceStorageConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) storage_type: std::option::Option<crate::model::StorageType>,
        pub(crate) s3_config: std::option::Option<crate::model::S3Config>,
        pub(crate) kinesis_video_stream_config:
            std::option::Option<crate::model::KinesisVideoStreamConfig>,
        pub(crate) kinesis_stream_config: std::option::Option<crate::model::KinesisStreamConfig>,
        pub(crate) kinesis_firehose_config:
            std::option::Option<crate::model::KinesisFirehoseConfig>,
    }
    impl Builder {
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>A valid storage type.</p>
        pub fn storage_type(mut self, input: crate::model::StorageType) -> Self {
            self.storage_type = Some(input);
            self
        }
        /// <p>A valid storage type.</p>
        pub fn set_storage_type(
            mut self,
            input: std::option::Option<crate::model::StorageType>,
        ) -> Self {
            self.storage_type = input;
            self
        }
        /// <p>The S3 bucket configuration.</p>
        pub fn s3_config(mut self, input: crate::model::S3Config) -> Self {
            self.s3_config = Some(input);
            self
        }
        /// <p>The S3 bucket configuration.</p>
        pub fn set_s3_config(mut self, input: std::option::Option<crate::model::S3Config>) -> Self {
            self.s3_config = input;
            self
        }
        /// <p>The configuration of the Kinesis video stream.</p>
        pub fn kinesis_video_stream_config(
            mut self,
            input: crate::model::KinesisVideoStreamConfig,
        ) -> Self {
            self.kinesis_video_stream_config = Some(input);
            self
        }
        /// <p>The configuration of the Kinesis video stream.</p>
        pub fn set_kinesis_video_stream_config(
            mut self,
            input: std::option::Option<crate::model::KinesisVideoStreamConfig>,
        ) -> Self {
            self.kinesis_video_stream_config = input;
            self
        }
        /// <p>The configuration of the Kinesis data stream.</p>
        pub fn kinesis_stream_config(mut self, input: crate::model::KinesisStreamConfig) -> Self {
            self.kinesis_stream_config = Some(input);
            self
        }
        /// <p>The configuration of the Kinesis data stream.</p>
        pub fn set_kinesis_stream_config(
            mut self,
            input: std::option::Option<crate::model::KinesisStreamConfig>,
        ) -> Self {
            self.kinesis_stream_config = input;
            self
        }
        /// <p>The configuration of the Kinesis Firehose delivery stream.</p>
        pub fn kinesis_firehose_config(
            mut self,
            input: crate::model::KinesisFirehoseConfig,
        ) -> Self {
            self.kinesis_firehose_config = Some(input);
            self
        }
        /// <p>The configuration of the Kinesis Firehose delivery stream.</p>
        pub fn set_kinesis_firehose_config(
            mut self,
            input: std::option::Option<crate::model::KinesisFirehoseConfig>,
        ) -> Self {
            self.kinesis_firehose_config = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceStorageConfig`](crate::model::InstanceStorageConfig)
        pub fn build(self) -> crate::model::InstanceStorageConfig {
            crate::model::InstanceStorageConfig {
                association_id: self.association_id,
                storage_type: self.storage_type,
                s3_config: self.s3_config,
                kinesis_video_stream_config: self.kinesis_video_stream_config,
                kinesis_stream_config: self.kinesis_stream_config,
                kinesis_firehose_config: self.kinesis_firehose_config,
            }
        }
    }
}
impl InstanceStorageConfig {
    /// Creates a new builder-style object to manufacture [`InstanceStorageConfig`](crate::model::InstanceStorageConfig)
    pub fn builder() -> crate::model::instance_storage_config::Builder {
        crate::model::instance_storage_config::Builder::default()
    }
}

/// <p>Configuration information of a Kinesis Data Firehose delivery stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisFirehoseConfig {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    pub firehose_arn: std::option::Option<std::string::String>,
}
impl KinesisFirehoseConfig {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    pub fn firehose_arn(&self) -> std::option::Option<&str> {
        self.firehose_arn.as_deref()
    }
}
impl std::fmt::Debug for KinesisFirehoseConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisFirehoseConfig");
        formatter.field("firehose_arn", &self.firehose_arn);
        formatter.finish()
    }
}
/// See [`KinesisFirehoseConfig`](crate::model::KinesisFirehoseConfig)
pub mod kinesis_firehose_config {

    /// A builder for [`KinesisFirehoseConfig`](crate::model::KinesisFirehoseConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firehose_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
        pub fn firehose_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firehose_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
        pub fn set_firehose_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firehose_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisFirehoseConfig`](crate::model::KinesisFirehoseConfig)
        pub fn build(self) -> crate::model::KinesisFirehoseConfig {
            crate::model::KinesisFirehoseConfig {
                firehose_arn: self.firehose_arn,
            }
        }
    }
}
impl KinesisFirehoseConfig {
    /// Creates a new builder-style object to manufacture [`KinesisFirehoseConfig`](crate::model::KinesisFirehoseConfig)
    pub fn builder() -> crate::model::kinesis_firehose_config::Builder {
        crate::model::kinesis_firehose_config::Builder::default()
    }
}

/// <p>Configuration information of a Kinesis data stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisStreamConfig {
    /// <p>The Amazon Resource Name (ARN) of the data stream.</p>
    pub stream_arn: std::option::Option<std::string::String>,
}
impl KinesisStreamConfig {
    /// <p>The Amazon Resource Name (ARN) of the data stream.</p>
    pub fn stream_arn(&self) -> std::option::Option<&str> {
        self.stream_arn.as_deref()
    }
}
impl std::fmt::Debug for KinesisStreamConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisStreamConfig");
        formatter.field("stream_arn", &self.stream_arn);
        formatter.finish()
    }
}
/// See [`KinesisStreamConfig`](crate::model::KinesisStreamConfig)
pub mod kinesis_stream_config {

    /// A builder for [`KinesisStreamConfig`](crate::model::KinesisStreamConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the data stream.</p>
        pub fn stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the data stream.</p>
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisStreamConfig`](crate::model::KinesisStreamConfig)
        pub fn build(self) -> crate::model::KinesisStreamConfig {
            crate::model::KinesisStreamConfig {
                stream_arn: self.stream_arn,
            }
        }
    }
}
impl KinesisStreamConfig {
    /// Creates a new builder-style object to manufacture [`KinesisStreamConfig`](crate::model::KinesisStreamConfig)
    pub fn builder() -> crate::model::kinesis_stream_config::Builder {
        crate::model::kinesis_stream_config::Builder::default()
    }
}

/// <p>Configuration information of a Kinesis video stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisVideoStreamConfig {
    /// <p>The prefix of the video stream.</p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.</p>
    /// <p>The default value is 0, indicating that the stream does not persist data.</p>
    pub retention_period_hours: i32,
    /// <p>The encryption configuration.</p>
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,
}
impl KinesisVideoStreamConfig {
    /// <p>The prefix of the video stream.</p>
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
    /// <p>The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.</p>
    /// <p>The default value is 0, indicating that the stream does not persist data.</p>
    pub fn retention_period_hours(&self) -> i32 {
        self.retention_period_hours
    }
    /// <p>The encryption configuration.</p>
    pub fn encryption_config(&self) -> std::option::Option<&crate::model::EncryptionConfig> {
        self.encryption_config.as_ref()
    }
}
impl std::fmt::Debug for KinesisVideoStreamConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisVideoStreamConfig");
        formatter.field("prefix", &self.prefix);
        formatter.field("retention_period_hours", &self.retention_period_hours);
        formatter.field("encryption_config", &self.encryption_config);
        formatter.finish()
    }
}
/// See [`KinesisVideoStreamConfig`](crate::model::KinesisVideoStreamConfig)
pub mod kinesis_video_stream_config {

    /// A builder for [`KinesisVideoStreamConfig`](crate::model::KinesisVideoStreamConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) retention_period_hours: std::option::Option<i32>,
        pub(crate) encryption_config: std::option::Option<crate::model::EncryptionConfig>,
    }
    impl Builder {
        /// <p>The prefix of the video stream.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        /// <p>The prefix of the video stream.</p>
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.</p>
        /// <p>The default value is 0, indicating that the stream does not persist data.</p>
        pub fn retention_period_hours(mut self, input: i32) -> Self {
            self.retention_period_hours = Some(input);
            self
        }
        /// <p>The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.</p>
        /// <p>The default value is 0, indicating that the stream does not persist data.</p>
        pub fn set_retention_period_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.retention_period_hours = input;
            self
        }
        /// <p>The encryption configuration.</p>
        pub fn encryption_config(mut self, input: crate::model::EncryptionConfig) -> Self {
            self.encryption_config = Some(input);
            self
        }
        /// <p>The encryption configuration.</p>
        pub fn set_encryption_config(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfig>,
        ) -> Self {
            self.encryption_config = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisVideoStreamConfig`](crate::model::KinesisVideoStreamConfig)
        pub fn build(self) -> crate::model::KinesisVideoStreamConfig {
            crate::model::KinesisVideoStreamConfig {
                prefix: self.prefix,
                retention_period_hours: self.retention_period_hours.unwrap_or_default(),
                encryption_config: self.encryption_config,
            }
        }
    }
}
impl KinesisVideoStreamConfig {
    /// Creates a new builder-style object to manufacture [`KinesisVideoStreamConfig`](crate::model::KinesisVideoStreamConfig)
    pub fn builder() -> crate::model::kinesis_video_stream_config::Builder {
        crate::model::kinesis_video_stream_config::Builder::default()
    }
}

/// <p>The encryption configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionConfig {
    /// <p>The type of encryption.</p>
    pub encryption_type: std::option::Option<crate::model::EncryptionType>,
    /// <p>The full ARN of the encryption key. </p> <note>
    /// <p>Be sure to provide the full ARN of the encryption key, not just the ID.</p>
    /// </note>
    pub key_id: std::option::Option<std::string::String>,
}
impl EncryptionConfig {
    /// <p>The type of encryption.</p>
    pub fn encryption_type(&self) -> std::option::Option<&crate::model::EncryptionType> {
        self.encryption_type.as_ref()
    }
    /// <p>The full ARN of the encryption key. </p> <note>
    /// <p>Be sure to provide the full ARN of the encryption key, not just the ID.</p>
    /// </note>
    pub fn key_id(&self) -> std::option::Option<&str> {
        self.key_id.as_deref()
    }
}
impl std::fmt::Debug for EncryptionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionConfig");
        formatter.field("encryption_type", &self.encryption_type);
        formatter.field("key_id", &self.key_id);
        formatter.finish()
    }
}
/// See [`EncryptionConfig`](crate::model::EncryptionConfig)
pub mod encryption_config {

    /// A builder for [`EncryptionConfig`](crate::model::EncryptionConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_type: std::option::Option<crate::model::EncryptionType>,
        pub(crate) key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of encryption.</p>
        pub fn encryption_type(mut self, input: crate::model::EncryptionType) -> Self {
            self.encryption_type = Some(input);
            self
        }
        /// <p>The type of encryption.</p>
        pub fn set_encryption_type(
            mut self,
            input: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.encryption_type = input;
            self
        }
        /// <p>The full ARN of the encryption key. </p> <note>
        /// <p>Be sure to provide the full ARN of the encryption key, not just the ID.</p>
        /// </note>
        pub fn key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_id = Some(input.into());
            self
        }
        /// <p>The full ARN of the encryption key. </p> <note>
        /// <p>Be sure to provide the full ARN of the encryption key, not just the ID.</p>
        /// </note>
        pub fn set_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionConfig`](crate::model::EncryptionConfig)
        pub fn build(self) -> crate::model::EncryptionConfig {
            crate::model::EncryptionConfig {
                encryption_type: self.encryption_type,
                key_id: self.key_id,
            }
        }
    }
}
impl EncryptionConfig {
    /// Creates a new builder-style object to manufacture [`EncryptionConfig`](crate::model::EncryptionConfig)
    pub fn builder() -> crate::model::encryption_config::Builder {
        crate::model::encryption_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EncryptionType {
    #[allow(missing_docs)] // documentation missing in model
    Kms,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EncryptionType {
    fn from(s: &str) -> Self {
        match s {
            "KMS" => EncryptionType::Kms,
            other => EncryptionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EncryptionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EncryptionType::from(s))
    }
}
impl EncryptionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EncryptionType::Kms => "KMS",
            EncryptionType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["KMS"]
    }
}
impl AsRef<str> for EncryptionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the Amazon Simple Storage Service (Amazon S3) storage type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3Config {
    /// <p>The S3 bucket name.</p>
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>The S3 bucket prefix.</p>
    pub bucket_prefix: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 encryption configuration.</p>
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,
}
impl S3Config {
    /// <p>The S3 bucket name.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
    /// <p>The S3 bucket prefix.</p>
    pub fn bucket_prefix(&self) -> std::option::Option<&str> {
        self.bucket_prefix.as_deref()
    }
    /// <p>The Amazon S3 encryption configuration.</p>
    pub fn encryption_config(&self) -> std::option::Option<&crate::model::EncryptionConfig> {
        self.encryption_config.as_ref()
    }
}
impl std::fmt::Debug for S3Config {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3Config");
        formatter.field("bucket_name", &self.bucket_name);
        formatter.field("bucket_prefix", &self.bucket_prefix);
        formatter.field("encryption_config", &self.encryption_config);
        formatter.finish()
    }
}
/// See [`S3Config`](crate::model::S3Config)
pub mod s3_config {

    /// A builder for [`S3Config`](crate::model::S3Config)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) bucket_prefix: std::option::Option<std::string::String>,
        pub(crate) encryption_config: std::option::Option<crate::model::EncryptionConfig>,
    }
    impl Builder {
        /// <p>The S3 bucket name.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The S3 bucket name.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// <p>The S3 bucket prefix.</p>
        pub fn bucket_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_prefix = Some(input.into());
            self
        }
        /// <p>The S3 bucket prefix.</p>
        pub fn set_bucket_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.bucket_prefix = input;
            self
        }
        /// <p>The Amazon S3 encryption configuration.</p>
        pub fn encryption_config(mut self, input: crate::model::EncryptionConfig) -> Self {
            self.encryption_config = Some(input);
            self
        }
        /// <p>The Amazon S3 encryption configuration.</p>
        pub fn set_encryption_config(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfig>,
        ) -> Self {
            self.encryption_config = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Config`](crate::model::S3Config)
        pub fn build(self) -> crate::model::S3Config {
            crate::model::S3Config {
                bucket_name: self.bucket_name,
                bucket_prefix: self.bucket_prefix,
                encryption_config: self.encryption_config,
            }
        }
    }
}
impl S3Config {
    /// Creates a new builder-style object to manufacture [`S3Config`](crate::model::S3Config)
    pub fn builder() -> crate::model::s3_config::Builder {
        crate::model::s3_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StorageType {
    #[allow(missing_docs)] // documentation missing in model
    KinesisFirehose,
    #[allow(missing_docs)] // documentation missing in model
    KinesisStream,
    #[allow(missing_docs)] // documentation missing in model
    KinesisVideoStream,
    #[allow(missing_docs)] // documentation missing in model
    S3,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StorageType {
    fn from(s: &str) -> Self {
        match s {
            "KINESIS_FIREHOSE" => StorageType::KinesisFirehose,
            "KINESIS_STREAM" => StorageType::KinesisStream,
            "KINESIS_VIDEO_STREAM" => StorageType::KinesisVideoStream,
            "S3" => StorageType::S3,
            other => StorageType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StorageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StorageType::from(s))
    }
}
impl StorageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StorageType::KinesisFirehose => "KINESIS_FIREHOSE",
            StorageType::KinesisStream => "KINESIS_STREAM",
            StorageType::KinesisVideoStream => "KINESIS_VIDEO_STREAM",
            StorageType::S3 => "S3",
            StorageType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "KINESIS_FIREHOSE",
            "KINESIS_STREAM",
            "KINESIS_VIDEO_STREAM",
            "S3",
        ]
    }
}
impl AsRef<str> for StorageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceStorageResourceType {
    #[allow(missing_docs)] // documentation missing in model
    AgentEvents,
    #[allow(missing_docs)] // documentation missing in model
    CallRecordings,
    #[allow(missing_docs)] // documentation missing in model
    ChatTranscripts,
    #[allow(missing_docs)] // documentation missing in model
    ContactTraceRecords,
    #[allow(missing_docs)] // documentation missing in model
    MediaStreams,
    #[allow(missing_docs)] // documentation missing in model
    RealTimeContactAnalysisSegments,
    #[allow(missing_docs)] // documentation missing in model
    ScheduledReports,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceStorageResourceType {
    fn from(s: &str) -> Self {
        match s {
            "AGENT_EVENTS" => InstanceStorageResourceType::AgentEvents,
            "CALL_RECORDINGS" => InstanceStorageResourceType::CallRecordings,
            "CHAT_TRANSCRIPTS" => InstanceStorageResourceType::ChatTranscripts,
            "CONTACT_TRACE_RECORDS" => InstanceStorageResourceType::ContactTraceRecords,
            "MEDIA_STREAMS" => InstanceStorageResourceType::MediaStreams,
            "REAL_TIME_CONTACT_ANALYSIS_SEGMENTS" => {
                InstanceStorageResourceType::RealTimeContactAnalysisSegments
            }
            "SCHEDULED_REPORTS" => InstanceStorageResourceType::ScheduledReports,
            other => InstanceStorageResourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceStorageResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceStorageResourceType::from(s))
    }
}
impl InstanceStorageResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InstanceStorageResourceType::AgentEvents => "AGENT_EVENTS",
            InstanceStorageResourceType::CallRecordings => "CALL_RECORDINGS",
            InstanceStorageResourceType::ChatTranscripts => "CHAT_TRANSCRIPTS",
            InstanceStorageResourceType::ContactTraceRecords => "CONTACT_TRACE_RECORDS",
            InstanceStorageResourceType::MediaStreams => "MEDIA_STREAMS",
            InstanceStorageResourceType::RealTimeContactAnalysisSegments => {
                "REAL_TIME_CONTACT_ANALYSIS_SEGMENTS"
            }
            InstanceStorageResourceType::ScheduledReports => "SCHEDULED_REPORTS",
            InstanceStorageResourceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AGENT_EVENTS",
            "CALL_RECORDINGS",
            "CHAT_TRANSCRIPTS",
            "CONTACT_TRACE_RECORDS",
            "MEDIA_STREAMS",
            "REAL_TIME_CONTACT_ANALYSIS_SEGMENTS",
            "SCHEDULED_REPORTS",
        ]
    }
}
impl AsRef<str> for InstanceStorageResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceAttributeType {
    #[allow(missing_docs)] // documentation missing in model
    AutoResolveBestVoices,
    #[allow(missing_docs)] // documentation missing in model
    ContactflowLogs,
    #[allow(missing_docs)] // documentation missing in model
    ContactLens,
    #[allow(missing_docs)] // documentation missing in model
    EarlyMedia,
    #[allow(missing_docs)] // documentation missing in model
    HighVolumeOutbound,
    #[allow(missing_docs)] // documentation missing in model
    InboundCalls,
    #[allow(missing_docs)] // documentation missing in model
    MultiPartyConference,
    #[allow(missing_docs)] // documentation missing in model
    OutboundCalls,
    #[allow(missing_docs)] // documentation missing in model
    UseCustomTtsVoices,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceAttributeType {
    fn from(s: &str) -> Self {
        match s {
            "AUTO_RESOLVE_BEST_VOICES" => InstanceAttributeType::AutoResolveBestVoices,
            "CONTACTFLOW_LOGS" => InstanceAttributeType::ContactflowLogs,
            "CONTACT_LENS" => InstanceAttributeType::ContactLens,
            "EARLY_MEDIA" => InstanceAttributeType::EarlyMedia,
            "HIGH_VOLUME_OUTBOUND" => InstanceAttributeType::HighVolumeOutbound,
            "INBOUND_CALLS" => InstanceAttributeType::InboundCalls,
            "MULTI_PARTY_CONFERENCE" => InstanceAttributeType::MultiPartyConference,
            "OUTBOUND_CALLS" => InstanceAttributeType::OutboundCalls,
            "USE_CUSTOM_TTS_VOICES" => InstanceAttributeType::UseCustomTtsVoices,
            other => InstanceAttributeType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceAttributeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceAttributeType::from(s))
    }
}
impl InstanceAttributeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InstanceAttributeType::AutoResolveBestVoices => "AUTO_RESOLVE_BEST_VOICES",
            InstanceAttributeType::ContactflowLogs => "CONTACTFLOW_LOGS",
            InstanceAttributeType::ContactLens => "CONTACT_LENS",
            InstanceAttributeType::EarlyMedia => "EARLY_MEDIA",
            InstanceAttributeType::HighVolumeOutbound => "HIGH_VOLUME_OUTBOUND",
            InstanceAttributeType::InboundCalls => "INBOUND_CALLS",
            InstanceAttributeType::MultiPartyConference => "MULTI_PARTY_CONFERENCE",
            InstanceAttributeType::OutboundCalls => "OUTBOUND_CALLS",
            InstanceAttributeType::UseCustomTtsVoices => "USE_CUSTOM_TTS_VOICES",
            InstanceAttributeType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AUTO_RESOLVE_BEST_VOICES",
            "CONTACTFLOW_LOGS",
            "CONTACT_LENS",
            "EARLY_MEDIA",
            "HIGH_VOLUME_OUTBOUND",
            "INBOUND_CALLS",
            "MULTI_PARTY_CONFERENCE",
            "OUTBOUND_CALLS",
            "USE_CUSTOM_TTS_VOICES",
        ]
    }
}
impl AsRef<str> for InstanceAttributeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the hours of operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HoursOfOperationConfig {
    /// <p>The day that the hours of operation applies to.</p>
    pub day: std::option::Option<crate::model::HoursOfOperationDays>,
    /// <p>The start time that your contact center opens.</p>
    pub start_time: std::option::Option<crate::model::HoursOfOperationTimeSlice>,
    /// <p>The end time that your contact center closes.</p>
    pub end_time: std::option::Option<crate::model::HoursOfOperationTimeSlice>,
}
impl HoursOfOperationConfig {
    /// <p>The day that the hours of operation applies to.</p>
    pub fn day(&self) -> std::option::Option<&crate::model::HoursOfOperationDays> {
        self.day.as_ref()
    }
    /// <p>The start time that your contact center opens.</p>
    pub fn start_time(&self) -> std::option::Option<&crate::model::HoursOfOperationTimeSlice> {
        self.start_time.as_ref()
    }
    /// <p>The end time that your contact center closes.</p>
    pub fn end_time(&self) -> std::option::Option<&crate::model::HoursOfOperationTimeSlice> {
        self.end_time.as_ref()
    }
}
impl std::fmt::Debug for HoursOfOperationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HoursOfOperationConfig");
        formatter.field("day", &self.day);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.finish()
    }
}
/// See [`HoursOfOperationConfig`](crate::model::HoursOfOperationConfig)
pub mod hours_of_operation_config {

    /// A builder for [`HoursOfOperationConfig`](crate::model::HoursOfOperationConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) day: std::option::Option<crate::model::HoursOfOperationDays>,
        pub(crate) start_time: std::option::Option<crate::model::HoursOfOperationTimeSlice>,
        pub(crate) end_time: std::option::Option<crate::model::HoursOfOperationTimeSlice>,
    }
    impl Builder {
        /// <p>The day that the hours of operation applies to.</p>
        pub fn day(mut self, input: crate::model::HoursOfOperationDays) -> Self {
            self.day = Some(input);
            self
        }
        /// <p>The day that the hours of operation applies to.</p>
        pub fn set_day(
            mut self,
            input: std::option::Option<crate::model::HoursOfOperationDays>,
        ) -> Self {
            self.day = input;
            self
        }
        /// <p>The start time that your contact center opens.</p>
        pub fn start_time(mut self, input: crate::model::HoursOfOperationTimeSlice) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time that your contact center opens.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<crate::model::HoursOfOperationTimeSlice>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time that your contact center closes.</p>
        pub fn end_time(mut self, input: crate::model::HoursOfOperationTimeSlice) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time that your contact center closes.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<crate::model::HoursOfOperationTimeSlice>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`HoursOfOperationConfig`](crate::model::HoursOfOperationConfig)
        pub fn build(self) -> crate::model::HoursOfOperationConfig {
            crate::model::HoursOfOperationConfig {
                day: self.day,
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}
impl HoursOfOperationConfig {
    /// Creates a new builder-style object to manufacture [`HoursOfOperationConfig`](crate::model::HoursOfOperationConfig)
    pub fn builder() -> crate::model::hours_of_operation_config::Builder {
        crate::model::hours_of_operation_config::Builder::default()
    }
}

/// <p>The start time or end time for an hours of operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HoursOfOperationTimeSlice {
    /// <p>The hours.</p>
    pub hours: std::option::Option<i32>,
    /// <p>The minutes.</p>
    pub minutes: std::option::Option<i32>,
}
impl HoursOfOperationTimeSlice {
    /// <p>The hours.</p>
    pub fn hours(&self) -> std::option::Option<i32> {
        self.hours
    }
    /// <p>The minutes.</p>
    pub fn minutes(&self) -> std::option::Option<i32> {
        self.minutes
    }
}
impl std::fmt::Debug for HoursOfOperationTimeSlice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HoursOfOperationTimeSlice");
        formatter.field("hours", &self.hours);
        formatter.field("minutes", &self.minutes);
        formatter.finish()
    }
}
/// See [`HoursOfOperationTimeSlice`](crate::model::HoursOfOperationTimeSlice)
pub mod hours_of_operation_time_slice {

    /// A builder for [`HoursOfOperationTimeSlice`](crate::model::HoursOfOperationTimeSlice)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hours: std::option::Option<i32>,
        pub(crate) minutes: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The hours.</p>
        pub fn hours(mut self, input: i32) -> Self {
            self.hours = Some(input);
            self
        }
        /// <p>The hours.</p>
        pub fn set_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.hours = input;
            self
        }
        /// <p>The minutes.</p>
        pub fn minutes(mut self, input: i32) -> Self {
            self.minutes = Some(input);
            self
        }
        /// <p>The minutes.</p>
        pub fn set_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.minutes = input;
            self
        }
        /// Consumes the builder and constructs a [`HoursOfOperationTimeSlice`](crate::model::HoursOfOperationTimeSlice)
        pub fn build(self) -> crate::model::HoursOfOperationTimeSlice {
            crate::model::HoursOfOperationTimeSlice {
                hours: self.hours,
                minutes: self.minutes,
            }
        }
    }
}
impl HoursOfOperationTimeSlice {
    /// Creates a new builder-style object to manufacture [`HoursOfOperationTimeSlice`](crate::model::HoursOfOperationTimeSlice)
    pub fn builder() -> crate::model::hours_of_operation_time_slice::Builder {
        crate::model::hours_of_operation_time_slice::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HoursOfOperationDays {
    #[allow(missing_docs)] // documentation missing in model
    Friday,
    #[allow(missing_docs)] // documentation missing in model
    Monday,
    #[allow(missing_docs)] // documentation missing in model
    Saturday,
    #[allow(missing_docs)] // documentation missing in model
    Sunday,
    #[allow(missing_docs)] // documentation missing in model
    Thursday,
    #[allow(missing_docs)] // documentation missing in model
    Tuesday,
    #[allow(missing_docs)] // documentation missing in model
    Wednesday,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HoursOfOperationDays {
    fn from(s: &str) -> Self {
        match s {
            "FRIDAY" => HoursOfOperationDays::Friday,
            "MONDAY" => HoursOfOperationDays::Monday,
            "SATURDAY" => HoursOfOperationDays::Saturday,
            "SUNDAY" => HoursOfOperationDays::Sunday,
            "THURSDAY" => HoursOfOperationDays::Thursday,
            "TUESDAY" => HoursOfOperationDays::Tuesday,
            "WEDNESDAY" => HoursOfOperationDays::Wednesday,
            other => HoursOfOperationDays::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HoursOfOperationDays {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HoursOfOperationDays::from(s))
    }
}
impl HoursOfOperationDays {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HoursOfOperationDays::Friday => "FRIDAY",
            HoursOfOperationDays::Monday => "MONDAY",
            HoursOfOperationDays::Saturday => "SATURDAY",
            HoursOfOperationDays::Sunday => "SUNDAY",
            HoursOfOperationDays::Thursday => "THURSDAY",
            HoursOfOperationDays::Tuesday => "TUESDAY",
            HoursOfOperationDays::Wednesday => "WEDNESDAY",
            HoursOfOperationDays::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "FRIDAY",
            "MONDAY",
            "SATURDAY",
            "SUNDAY",
            "THURSDAY",
            "TUESDAY",
            "WEDNESDAY",
        ]
    }
}
impl AsRef<str> for HoursOfOperationDays {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContactFlowModuleState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Archived,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContactFlowModuleState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ContactFlowModuleState::Active,
            "ARCHIVED" => ContactFlowModuleState::Archived,
            other => ContactFlowModuleState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContactFlowModuleState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContactFlowModuleState::from(s))
    }
}
impl ContactFlowModuleState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContactFlowModuleState::Active => "ACTIVE",
            ContactFlowModuleState::Archived => "ARCHIVED",
            ContactFlowModuleState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ACTIVE", "ARCHIVED"]
    }
}
impl AsRef<str> for ContactFlowModuleState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a problem detail.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProblemDetail {
    /// <p>The problem detail's message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl ProblemDetail {
    /// <p>The problem detail's message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for ProblemDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProblemDetail");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`ProblemDetail`](crate::model::ProblemDetail)
pub mod problem_detail {

    /// A builder for [`ProblemDetail`](crate::model::ProblemDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The problem detail's message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The problem detail's message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ProblemDetail`](crate::model::ProblemDetail)
        pub fn build(self) -> crate::model::ProblemDetail {
            crate::model::ProblemDetail {
                message: self.message,
            }
        }
    }
}
impl ProblemDetail {
    /// Creates a new builder-style object to manufacture [`ProblemDetail`](crate::model::ProblemDetail)
    pub fn builder() -> crate::model::problem_detail::Builder {
        crate::model::problem_detail::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContactFlowState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Archived,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContactFlowState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ContactFlowState::Active,
            "ARCHIVED" => ContactFlowState::Archived,
            other => ContactFlowState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContactFlowState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContactFlowState::from(s))
    }
}
impl ContactFlowState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContactFlowState::Active => "ACTIVE",
            ContactFlowState::Archived => "ARCHIVED",
            ContactFlowState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ACTIVE", "ARCHIVED"]
    }
}
impl AsRef<str> for ContactFlowState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Well-formed data on a contact, used by agents to complete a contact request. You can have up to 4,096 UTF-8 bytes across all references for a contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Reference {
    /// <p>A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>The type of the reference.</p>
    pub r#type: std::option::Option<crate::model::ReferenceType>,
}
impl Reference {
    /// <p>A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The type of the reference.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ReferenceType> {
        self.r#type.as_ref()
    }
}
impl std::fmt::Debug for Reference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Reference");
        formatter.field("value", &self.value);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`Reference`](crate::model::Reference)
pub mod reference {

    /// A builder for [`Reference`](crate::model::Reference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ReferenceType>,
    }
    impl Builder {
        /// <p>A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The type of the reference.</p>
        pub fn r#type(mut self, input: crate::model::ReferenceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the reference.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ReferenceType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`Reference`](crate::model::Reference)
        pub fn build(self) -> crate::model::Reference {
            crate::model::Reference {
                value: self.value,
                r#type: self.r#type,
            }
        }
    }
}
impl Reference {
    /// Creates a new builder-style object to manufacture [`Reference`](crate::model::Reference)
    pub fn builder() -> crate::model::reference::Builder {
        crate::model::reference::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReferenceType {
    #[allow(missing_docs)] // documentation missing in model
    Attachment,
    #[allow(missing_docs)] // documentation missing in model
    Date,
    #[allow(missing_docs)] // documentation missing in model
    Email,
    #[allow(missing_docs)] // documentation missing in model
    Number,
    #[allow(missing_docs)] // documentation missing in model
    String,
    #[allow(missing_docs)] // documentation missing in model
    Url,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReferenceType {
    fn from(s: &str) -> Self {
        match s {
            "ATTACHMENT" => ReferenceType::Attachment,
            "DATE" => ReferenceType::Date,
            "EMAIL" => ReferenceType::Email,
            "NUMBER" => ReferenceType::Number,
            "STRING" => ReferenceType::String,
            "URL" => ReferenceType::Url,
            other => ReferenceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReferenceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReferenceType::from(s))
    }
}
impl ReferenceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReferenceType::Attachment => "ATTACHMENT",
            ReferenceType::Date => "DATE",
            ReferenceType::Email => "EMAIL",
            ReferenceType::Number => "NUMBER",
            ReferenceType::String => "STRING",
            ReferenceType::Url => "URL",
            ReferenceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ATTACHMENT", "DATE", "EMAIL", "NUMBER", "STRING", "URL"]
    }
}
impl AsRef<str> for ReferenceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AgentStatusState {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AgentStatusState {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => AgentStatusState::Disabled,
            "ENABLED" => AgentStatusState::Enabled,
            other => AgentStatusState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AgentStatusState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AgentStatusState::from(s))
    }
}
impl AgentStatusState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AgentStatusState::Disabled => "DISABLED",
            AgentStatusState::Enabled => "ENABLED",
            AgentStatusState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for AgentStatusState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrafficType {
    #[allow(missing_docs)] // documentation missing in model
    Campaign,
    #[allow(missing_docs)] // documentation missing in model
    General,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrafficType {
    fn from(s: &str) -> Self {
        match s {
            "CAMPAIGN" => TrafficType::Campaign,
            "GENERAL" => TrafficType::General,
            other => TrafficType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrafficType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrafficType::from(s))
    }
}
impl TrafficType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TrafficType::Campaign => "CAMPAIGN",
            TrafficType::General => "GENERAL",
            TrafficType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CAMPAIGN", "GENERAL"]
    }
}
impl AsRef<str> for TrafficType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration of the answering machine detection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnswerMachineDetectionConfig {
    /// <p>The flag to indicate if answer machine detection analysis needs to be performed for a voice call. If set to <code>true</code>, <code>TrafficType</code> must be set as <code>CAMPAIGN</code>. </p>
    pub enable_answer_machine_detection: bool,
    /// <p>Wait for the answering machine prompt.</p>
    pub await_answer_machine_prompt: bool,
}
impl AnswerMachineDetectionConfig {
    /// <p>The flag to indicate if answer machine detection analysis needs to be performed for a voice call. If set to <code>true</code>, <code>TrafficType</code> must be set as <code>CAMPAIGN</code>. </p>
    pub fn enable_answer_machine_detection(&self) -> bool {
        self.enable_answer_machine_detection
    }
    /// <p>Wait for the answering machine prompt.</p>
    pub fn await_answer_machine_prompt(&self) -> bool {
        self.await_answer_machine_prompt
    }
}
impl std::fmt::Debug for AnswerMachineDetectionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnswerMachineDetectionConfig");
        formatter.field(
            "enable_answer_machine_detection",
            &self.enable_answer_machine_detection,
        );
        formatter.field(
            "await_answer_machine_prompt",
            &self.await_answer_machine_prompt,
        );
        formatter.finish()
    }
}
/// See [`AnswerMachineDetectionConfig`](crate::model::AnswerMachineDetectionConfig)
pub mod answer_machine_detection_config {

    /// A builder for [`AnswerMachineDetectionConfig`](crate::model::AnswerMachineDetectionConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_answer_machine_detection: std::option::Option<bool>,
        pub(crate) await_answer_machine_prompt: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The flag to indicate if answer machine detection analysis needs to be performed for a voice call. If set to <code>true</code>, <code>TrafficType</code> must be set as <code>CAMPAIGN</code>. </p>
        pub fn enable_answer_machine_detection(mut self, input: bool) -> Self {
            self.enable_answer_machine_detection = Some(input);
            self
        }
        /// <p>The flag to indicate if answer machine detection analysis needs to be performed for a voice call. If set to <code>true</code>, <code>TrafficType</code> must be set as <code>CAMPAIGN</code>. </p>
        pub fn set_enable_answer_machine_detection(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_answer_machine_detection = input;
            self
        }
        /// <p>Wait for the answering machine prompt.</p>
        pub fn await_answer_machine_prompt(mut self, input: bool) -> Self {
            self.await_answer_machine_prompt = Some(input);
            self
        }
        /// <p>Wait for the answering machine prompt.</p>
        pub fn set_await_answer_machine_prompt(mut self, input: std::option::Option<bool>) -> Self {
            self.await_answer_machine_prompt = input;
            self
        }
        /// Consumes the builder and constructs a [`AnswerMachineDetectionConfig`](crate::model::AnswerMachineDetectionConfig)
        pub fn build(self) -> crate::model::AnswerMachineDetectionConfig {
            crate::model::AnswerMachineDetectionConfig {
                enable_answer_machine_detection: self
                    .enable_answer_machine_detection
                    .unwrap_or_default(),
                await_answer_machine_prompt: self.await_answer_machine_prompt.unwrap_or_default(),
            }
        }
    }
}
impl AnswerMachineDetectionConfig {
    /// Creates a new builder-style object to manufacture [`AnswerMachineDetectionConfig`](crate::model::AnswerMachineDetectionConfig)
    pub fn builder() -> crate::model::answer_machine_detection_config::Builder {
        crate::model::answer_machine_detection_config::Builder::default()
    }
}

/// <p>The streaming configuration, such as the Amazon SNS streaming endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatStreamingConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon Resource Name (ARN) of the streaming endpoint that is used to publish real-time message streaming for chat conversations.</p>
    pub streaming_endpoint_arn: std::option::Option<std::string::String>,
}
impl ChatStreamingConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon Resource Name (ARN) of the streaming endpoint that is used to publish real-time message streaming for chat conversations.</p>
    pub fn streaming_endpoint_arn(&self) -> std::option::Option<&str> {
        self.streaming_endpoint_arn.as_deref()
    }
}
impl std::fmt::Debug for ChatStreamingConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChatStreamingConfiguration");
        formatter.field("streaming_endpoint_arn", &self.streaming_endpoint_arn);
        formatter.finish()
    }
}
/// See [`ChatStreamingConfiguration`](crate::model::ChatStreamingConfiguration)
pub mod chat_streaming_configuration {

    /// A builder for [`ChatStreamingConfiguration`](crate::model::ChatStreamingConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) streaming_endpoint_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon Resource Name (ARN) of the streaming endpoint that is used to publish real-time message streaming for chat conversations.</p>
        pub fn streaming_endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.streaming_endpoint_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon Resource Name (ARN) of the streaming endpoint that is used to publish real-time message streaming for chat conversations.</p>
        pub fn set_streaming_endpoint_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.streaming_endpoint_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ChatStreamingConfiguration`](crate::model::ChatStreamingConfiguration)
        pub fn build(self) -> crate::model::ChatStreamingConfiguration {
            crate::model::ChatStreamingConfiguration {
                streaming_endpoint_arn: self.streaming_endpoint_arn,
            }
        }
    }
}
impl ChatStreamingConfiguration {
    /// Creates a new builder-style object to manufacture [`ChatStreamingConfiguration`](crate::model::ChatStreamingConfiguration)
    pub fn builder() -> crate::model::chat_streaming_configuration::Builder {
        crate::model::chat_streaming_configuration::Builder::default()
    }
}

/// <p>Contains information about the recording configuration settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VoiceRecordingConfiguration {
    /// <p>Identifies which track is being recorded.</p>
    pub voice_recording_track: std::option::Option<crate::model::VoiceRecordingTrack>,
}
impl VoiceRecordingConfiguration {
    /// <p>Identifies which track is being recorded.</p>
    pub fn voice_recording_track(&self) -> std::option::Option<&crate::model::VoiceRecordingTrack> {
        self.voice_recording_track.as_ref()
    }
}
impl std::fmt::Debug for VoiceRecordingConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VoiceRecordingConfiguration");
        formatter.field("voice_recording_track", &self.voice_recording_track);
        formatter.finish()
    }
}
/// See [`VoiceRecordingConfiguration`](crate::model::VoiceRecordingConfiguration)
pub mod voice_recording_configuration {

    /// A builder for [`VoiceRecordingConfiguration`](crate::model::VoiceRecordingConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_recording_track: std::option::Option<crate::model::VoiceRecordingTrack>,
    }
    impl Builder {
        /// <p>Identifies which track is being recorded.</p>
        pub fn voice_recording_track(mut self, input: crate::model::VoiceRecordingTrack) -> Self {
            self.voice_recording_track = Some(input);
            self
        }
        /// <p>Identifies which track is being recorded.</p>
        pub fn set_voice_recording_track(
            mut self,
            input: std::option::Option<crate::model::VoiceRecordingTrack>,
        ) -> Self {
            self.voice_recording_track = input;
            self
        }
        /// Consumes the builder and constructs a [`VoiceRecordingConfiguration`](crate::model::VoiceRecordingConfiguration)
        pub fn build(self) -> crate::model::VoiceRecordingConfiguration {
            crate::model::VoiceRecordingConfiguration {
                voice_recording_track: self.voice_recording_track,
            }
        }
    }
}
impl VoiceRecordingConfiguration {
    /// Creates a new builder-style object to manufacture [`VoiceRecordingConfiguration`](crate::model::VoiceRecordingConfiguration)
    pub fn builder() -> crate::model::voice_recording_configuration::Builder {
        crate::model::voice_recording_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VoiceRecordingTrack {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    FromAgent,
    #[allow(missing_docs)] // documentation missing in model
    ToAgent,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VoiceRecordingTrack {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => VoiceRecordingTrack::All,
            "FROM_AGENT" => VoiceRecordingTrack::FromAgent,
            "TO_AGENT" => VoiceRecordingTrack::ToAgent,
            other => VoiceRecordingTrack::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VoiceRecordingTrack {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VoiceRecordingTrack::from(s))
    }
}
impl VoiceRecordingTrack {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VoiceRecordingTrack::All => "ALL",
            VoiceRecordingTrack::FromAgent => "FROM_AGENT",
            VoiceRecordingTrack::ToAgent => "TO_AGENT",
            VoiceRecordingTrack::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ALL", "FROM_AGENT", "TO_AGENT"]
    }
}
impl AsRef<str> for VoiceRecordingTrack {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A chat message.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessage {
    /// <p>The type of the content. Supported types are <code>text/plain</code>.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The content of the chat message.</p>
    pub content: std::option::Option<std::string::String>,
}
impl ChatMessage {
    /// <p>The type of the content. Supported types are <code>text/plain</code>.</p>
    pub fn content_type(&self) -> std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p>The content of the chat message.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
}
impl std::fmt::Debug for ChatMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChatMessage");
        formatter.field("content_type", &self.content_type);
        formatter.field("content", &self.content);
        formatter.finish()
    }
}
/// See [`ChatMessage`](crate::model::ChatMessage)
pub mod chat_message {

    /// A builder for [`ChatMessage`](crate::model::ChatMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the content. Supported types are <code>text/plain</code>.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        /// <p>The type of the content. Supported types are <code>text/plain</code>.</p>
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The content of the chat message.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the chat message.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`ChatMessage`](crate::model::ChatMessage)
        pub fn build(self) -> crate::model::ChatMessage {
            crate::model::ChatMessage {
                content_type: self.content_type,
                content: self.content,
            }
        }
    }
}
impl ChatMessage {
    /// Creates a new builder-style object to manufacture [`ChatMessage`](crate::model::ChatMessage)
    pub fn builder() -> crate::model::chat_message::Builder {
        crate::model::chat_message::Builder::default()
    }
}

/// <p>The customer's details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParticipantDetails {
    /// <p>Display name of the participant.</p>
    pub display_name: std::option::Option<std::string::String>,
}
impl ParticipantDetails {
    /// <p>Display name of the participant.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
}
impl std::fmt::Debug for ParticipantDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParticipantDetails");
        formatter.field("display_name", &self.display_name);
        formatter.finish()
    }
}
/// See [`ParticipantDetails`](crate::model::ParticipantDetails)
pub mod participant_details {

    /// A builder for [`ParticipantDetails`](crate::model::ParticipantDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Display name of the participant.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>Display name of the participant.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ParticipantDetails`](crate::model::ParticipantDetails)
        pub fn build(self) -> crate::model::ParticipantDetails {
            crate::model::ParticipantDetails {
                display_name: self.display_name,
            }
        }
    }
}
impl ParticipantDetails {
    /// Creates a new builder-style object to manufacture [`ParticipantDetails`](crate::model::ParticipantDetails)
    pub fn builder() -> crate::model::participant_details::Builder {
        crate::model::participant_details::Builder::default()
    }
}

/// <p>Contains summary information about the custom vocabulary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VocabularySummary {
    /// <p>A unique name of the custom vocabulary.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier of the custom vocabulary.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    pub language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
    /// <p>The current state of the custom vocabulary.</p>
    pub state: std::option::Option<crate::model::VocabularyState>,
    /// <p>The timestamp when the custom vocabulary was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The reason why the custom vocabulary was not created.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl VocabularySummary {
    /// <p>A unique name of the custom vocabulary.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier of the custom vocabulary.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::VocabularyLanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The current state of the custom vocabulary.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::VocabularyState> {
        self.state.as_ref()
    }
    /// <p>The timestamp when the custom vocabulary was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The reason why the custom vocabulary was not created.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
}
impl std::fmt::Debug for VocabularySummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VocabularySummary");
        formatter.field("name", &self.name);
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("language_code", &self.language_code);
        formatter.field("state", &self.state);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`VocabularySummary`](crate::model::VocabularySummary)
pub mod vocabulary_summary {

    /// A builder for [`VocabularySummary`](crate::model::VocabularySummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
        pub(crate) state: std::option::Option<crate::model::VocabularyState>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn language_code(mut self, input: crate::model::VocabularyLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::VocabularyLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The current state of the custom vocabulary.</p>
        pub fn state(mut self, input: crate::model::VocabularyState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the custom vocabulary.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The timestamp when the custom vocabulary was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp when the custom vocabulary was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The reason why the custom vocabulary was not created.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason why the custom vocabulary was not created.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`VocabularySummary`](crate::model::VocabularySummary)
        pub fn build(self) -> crate::model::VocabularySummary {
            crate::model::VocabularySummary {
                name: self.name,
                id: self.id,
                arn: self.arn,
                language_code: self.language_code,
                state: self.state,
                last_modified_time: self.last_modified_time,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl VocabularySummary {
    /// Creates a new builder-style object to manufacture [`VocabularySummary`](crate::model::VocabularySummary)
    pub fn builder() -> crate::model::vocabulary_summary::Builder {
        crate::model::vocabulary_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VocabularyState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    CreationFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreationInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VocabularyState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => VocabularyState::Active,
            "CREATION_FAILED" => VocabularyState::CreationFailed,
            "CREATION_IN_PROGRESS" => VocabularyState::CreationInProgress,
            "DELETE_IN_PROGRESS" => VocabularyState::DeleteInProgress,
            other => VocabularyState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VocabularyState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VocabularyState::from(s))
    }
}
impl VocabularyState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VocabularyState::Active => "ACTIVE",
            VocabularyState::CreationFailed => "CREATION_FAILED",
            VocabularyState::CreationInProgress => "CREATION_IN_PROGRESS",
            VocabularyState::DeleteInProgress => "DELETE_IN_PROGRESS",
            VocabularyState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "CREATION_FAILED",
            "CREATION_IN_PROGRESS",
            "DELETE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for VocabularyState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VocabularyLanguageCode {
    #[allow(missing_docs)] // documentation missing in model
    ArAe,
    #[allow(missing_docs)] // documentation missing in model
    DeCh,
    #[allow(missing_docs)] // documentation missing in model
    DeDe,
    #[allow(missing_docs)] // documentation missing in model
    EnAb,
    #[allow(missing_docs)] // documentation missing in model
    EnAu,
    #[allow(missing_docs)] // documentation missing in model
    EnGb,
    #[allow(missing_docs)] // documentation missing in model
    EnIe,
    #[allow(missing_docs)] // documentation missing in model
    EnIn,
    #[allow(missing_docs)] // documentation missing in model
    EnUs,
    #[allow(missing_docs)] // documentation missing in model
    EnWl,
    #[allow(missing_docs)] // documentation missing in model
    EsEs,
    #[allow(missing_docs)] // documentation missing in model
    EsUs,
    #[allow(missing_docs)] // documentation missing in model
    FrCa,
    #[allow(missing_docs)] // documentation missing in model
    FrFr,
    #[allow(missing_docs)] // documentation missing in model
    HiIn,
    #[allow(missing_docs)] // documentation missing in model
    ItIt,
    #[allow(missing_docs)] // documentation missing in model
    JaJp,
    #[allow(missing_docs)] // documentation missing in model
    KoKr,
    #[allow(missing_docs)] // documentation missing in model
    PtBr,
    #[allow(missing_docs)] // documentation missing in model
    PtPt,
    #[allow(missing_docs)] // documentation missing in model
    ZhCn,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VocabularyLanguageCode {
    fn from(s: &str) -> Self {
        match s {
            "ar-AE" => VocabularyLanguageCode::ArAe,
            "de-CH" => VocabularyLanguageCode::DeCh,
            "de-DE" => VocabularyLanguageCode::DeDe,
            "en-AB" => VocabularyLanguageCode::EnAb,
            "en-AU" => VocabularyLanguageCode::EnAu,
            "en-GB" => VocabularyLanguageCode::EnGb,
            "en-IE" => VocabularyLanguageCode::EnIe,
            "en-IN" => VocabularyLanguageCode::EnIn,
            "en-US" => VocabularyLanguageCode::EnUs,
            "en-WL" => VocabularyLanguageCode::EnWl,
            "es-ES" => VocabularyLanguageCode::EsEs,
            "es-US" => VocabularyLanguageCode::EsUs,
            "fr-CA" => VocabularyLanguageCode::FrCa,
            "fr-FR" => VocabularyLanguageCode::FrFr,
            "hi-IN" => VocabularyLanguageCode::HiIn,
            "it-IT" => VocabularyLanguageCode::ItIt,
            "ja-JP" => VocabularyLanguageCode::JaJp,
            "ko-KR" => VocabularyLanguageCode::KoKr,
            "pt-BR" => VocabularyLanguageCode::PtBr,
            "pt-PT" => VocabularyLanguageCode::PtPt,
            "zh-CN" => VocabularyLanguageCode::ZhCn,
            other => VocabularyLanguageCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VocabularyLanguageCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VocabularyLanguageCode::from(s))
    }
}
impl VocabularyLanguageCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VocabularyLanguageCode::ArAe => "ar-AE",
            VocabularyLanguageCode::DeCh => "de-CH",
            VocabularyLanguageCode::DeDe => "de-DE",
            VocabularyLanguageCode::EnAb => "en-AB",
            VocabularyLanguageCode::EnAu => "en-AU",
            VocabularyLanguageCode::EnGb => "en-GB",
            VocabularyLanguageCode::EnIe => "en-IE",
            VocabularyLanguageCode::EnIn => "en-IN",
            VocabularyLanguageCode::EnUs => "en-US",
            VocabularyLanguageCode::EnWl => "en-WL",
            VocabularyLanguageCode::EsEs => "es-ES",
            VocabularyLanguageCode::EsUs => "es-US",
            VocabularyLanguageCode::FrCa => "fr-CA",
            VocabularyLanguageCode::FrFr => "fr-FR",
            VocabularyLanguageCode::HiIn => "hi-IN",
            VocabularyLanguageCode::ItIt => "it-IT",
            VocabularyLanguageCode::JaJp => "ja-JP",
            VocabularyLanguageCode::KoKr => "ko-KR",
            VocabularyLanguageCode::PtBr => "pt-BR",
            VocabularyLanguageCode::PtPt => "pt-PT",
            VocabularyLanguageCode::ZhCn => "zh-CN",
            VocabularyLanguageCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ar-AE", "de-CH", "de-DE", "en-AB", "en-AU", "en-GB", "en-IE", "en-IN", "en-US",
            "en-WL", "es-ES", "es-US", "fr-CA", "fr-FR", "hi-IN", "it-IT", "ja-JP", "ko-KR",
            "pt-BR", "pt-PT", "zh-CN",
        ]
    }
}
impl AsRef<str> for VocabularyLanguageCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the returned users.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserSearchSummary {
    /// <p>The Amazon Resource Name (ARN) of the user.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The directory identifier of the user.</p>
    pub directory_user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the user's hierarchy group.</p>
    pub hierarchy_group_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the user's summary.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The user's first name and last name.</p>
    pub identity_info: std::option::Option<crate::model::UserIdentityInfoLite>,
    /// <p>Contains information about the phone configuration settings for a user.</p>
    pub phone_config: std::option::Option<crate::model::UserPhoneConfig>,
    /// <p>The identifier of the user's routing profile.</p>
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The identifiers of the user's security profiles.</p>
    pub security_profile_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name of the user.</p>
    pub username: std::option::Option<std::string::String>,
}
impl UserSearchSummary {
    /// <p>The Amazon Resource Name (ARN) of the user.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The directory identifier of the user.</p>
    pub fn directory_user_id(&self) -> std::option::Option<&str> {
        self.directory_user_id.as_deref()
    }
    /// <p>The identifier of the user's hierarchy group.</p>
    pub fn hierarchy_group_id(&self) -> std::option::Option<&str> {
        self.hierarchy_group_id.as_deref()
    }
    /// <p>The identifier of the user's summary.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The user's first name and last name.</p>
    pub fn identity_info(&self) -> std::option::Option<&crate::model::UserIdentityInfoLite> {
        self.identity_info.as_ref()
    }
    /// <p>Contains information about the phone configuration settings for a user.</p>
    pub fn phone_config(&self) -> std::option::Option<&crate::model::UserPhoneConfig> {
        self.phone_config.as_ref()
    }
    /// <p>The identifier of the user's routing profile.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The identifiers of the user's security profiles.</p>
    pub fn security_profile_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_profile_ids.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The name of the user.</p>
    pub fn username(&self) -> std::option::Option<&str> {
        self.username.as_deref()
    }
}
impl std::fmt::Debug for UserSearchSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserSearchSummary");
        formatter.field("arn", &self.arn);
        formatter.field("directory_user_id", &self.directory_user_id);
        formatter.field("hierarchy_group_id", &self.hierarchy_group_id);
        formatter.field("id", &self.id);
        formatter.field("identity_info", &self.identity_info);
        formatter.field("phone_config", &self.phone_config);
        formatter.field("routing_profile_id", &self.routing_profile_id);
        formatter.field("security_profile_ids", &self.security_profile_ids);
        formatter.field("tags", &self.tags);
        formatter.field("username", &self.username);
        formatter.finish()
    }
}
/// See [`UserSearchSummary`](crate::model::UserSearchSummary)
pub mod user_search_summary {

    /// A builder for [`UserSearchSummary`](crate::model::UserSearchSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) directory_user_id: std::option::Option<std::string::String>,
        pub(crate) hierarchy_group_id: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) identity_info: std::option::Option<crate::model::UserIdentityInfoLite>,
        pub(crate) phone_config: std::option::Option<crate::model::UserPhoneConfig>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) security_profile_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) username: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the user.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The directory identifier of the user.</p>
        pub fn directory_user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_user_id = Some(input.into());
            self
        }
        /// <p>The directory identifier of the user.</p>
        pub fn set_directory_user_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.directory_user_id = input;
            self
        }
        /// <p>The identifier of the user's hierarchy group.</p>
        pub fn hierarchy_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user's hierarchy group.</p>
        pub fn set_hierarchy_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hierarchy_group_id = input;
            self
        }
        /// <p>The identifier of the user's summary.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the user's summary.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The user's first name and last name.</p>
        pub fn identity_info(mut self, input: crate::model::UserIdentityInfoLite) -> Self {
            self.identity_info = Some(input);
            self
        }
        /// <p>The user's first name and last name.</p>
        pub fn set_identity_info(
            mut self,
            input: std::option::Option<crate::model::UserIdentityInfoLite>,
        ) -> Self {
            self.identity_info = input;
            self
        }
        /// <p>Contains information about the phone configuration settings for a user.</p>
        pub fn phone_config(mut self, input: crate::model::UserPhoneConfig) -> Self {
            self.phone_config = Some(input);
            self
        }
        /// <p>Contains information about the phone configuration settings for a user.</p>
        pub fn set_phone_config(
            mut self,
            input: std::option::Option<crate::model::UserPhoneConfig>,
        ) -> Self {
            self.phone_config = input;
            self
        }
        /// <p>The identifier of the user's routing profile.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user's routing profile.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// Appends an item to `security_profile_ids`.
        ///
        /// To override the contents of this collection use [`set_security_profile_ids`](Self::set_security_profile_ids).
        ///
        /// <p>The identifiers of the user's security profiles.</p>
        pub fn security_profile_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_profile_ids.unwrap_or_default();
            v.push(input.into());
            self.security_profile_ids = Some(v);
            self
        }
        /// <p>The identifiers of the user's security profiles.</p>
        pub fn set_security_profile_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_profile_ids = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The name of the user.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        /// <p>The name of the user.</p>
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input;
            self
        }
        /// Consumes the builder and constructs a [`UserSearchSummary`](crate::model::UserSearchSummary)
        pub fn build(self) -> crate::model::UserSearchSummary {
            crate::model::UserSearchSummary {
                arn: self.arn,
                directory_user_id: self.directory_user_id,
                hierarchy_group_id: self.hierarchy_group_id,
                id: self.id,
                identity_info: self.identity_info,
                phone_config: self.phone_config,
                routing_profile_id: self.routing_profile_id,
                security_profile_ids: self.security_profile_ids,
                tags: self.tags,
                username: self.username,
            }
        }
    }
}
impl UserSearchSummary {
    /// Creates a new builder-style object to manufacture [`UserSearchSummary`](crate::model::UserSearchSummary)
    pub fn builder() -> crate::model::user_search_summary::Builder {
        crate::model::user_search_summary::Builder::default()
    }
}

/// <p>The user's first name and last name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserIdentityInfoLite {
    /// <p>The user's first name.</p>
    pub first_name: std::option::Option<std::string::String>,
    /// <p>The user's last name.</p>
    pub last_name: std::option::Option<std::string::String>,
}
impl UserIdentityInfoLite {
    /// <p>The user's first name.</p>
    pub fn first_name(&self) -> std::option::Option<&str> {
        self.first_name.as_deref()
    }
    /// <p>The user's last name.</p>
    pub fn last_name(&self) -> std::option::Option<&str> {
        self.last_name.as_deref()
    }
}
impl std::fmt::Debug for UserIdentityInfoLite {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserIdentityInfoLite");
        formatter.field("first_name", &self.first_name);
        formatter.field("last_name", &self.last_name);
        formatter.finish()
    }
}
/// See [`UserIdentityInfoLite`](crate::model::UserIdentityInfoLite)
pub mod user_identity_info_lite {

    /// A builder for [`UserIdentityInfoLite`](crate::model::UserIdentityInfoLite)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) first_name: std::option::Option<std::string::String>,
        pub(crate) last_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The user's first name.</p>
        pub fn first_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_name = Some(input.into());
            self
        }
        /// <p>The user's first name.</p>
        pub fn set_first_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.first_name = input;
            self
        }
        /// <p>The user's last name.</p>
        pub fn last_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_name = Some(input.into());
            self
        }
        /// <p>The user's last name.</p>
        pub fn set_last_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UserIdentityInfoLite`](crate::model::UserIdentityInfoLite)
        pub fn build(self) -> crate::model::UserIdentityInfoLite {
            crate::model::UserIdentityInfoLite {
                first_name: self.first_name,
                last_name: self.last_name,
            }
        }
    }
}
impl UserIdentityInfoLite {
    /// Creates a new builder-style object to manufacture [`UserIdentityInfoLite`](crate::model::UserIdentityInfoLite)
    pub fn builder() -> crate::model::user_identity_info_lite::Builder {
        crate::model::user_identity_info_lite::Builder::default()
    }
}

/// <p>The search criteria to be used to return users.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserSearchCriteria {
    /// <p>A list of conditions which would be applied together with an <code>OR</code> condition.</p>
    pub or_conditions: std::option::Option<std::vec::Vec<crate::model::UserSearchCriteria>>,
    /// <p>A list of conditions which would be applied together with an <code>AND</code> condition. </p>
    pub and_conditions: std::option::Option<std::vec::Vec<crate::model::UserSearchCriteria>>,
    /// <p>A leaf node condition which can be used to specify a string condition.</p>
    pub string_condition: std::option::Option<crate::model::StringCondition>,
    /// <p>A leaf node condition which can be used to specify a hierarchy group condition.</p>
    pub hierarchy_group_condition: std::option::Option<crate::model::HierarchyGroupCondition>,
}
impl UserSearchCriteria {
    /// <p>A list of conditions which would be applied together with an <code>OR</code> condition.</p>
    pub fn or_conditions(&self) -> std::option::Option<&[crate::model::UserSearchCriteria]> {
        self.or_conditions.as_deref()
    }
    /// <p>A list of conditions which would be applied together with an <code>AND</code> condition. </p>
    pub fn and_conditions(&self) -> std::option::Option<&[crate::model::UserSearchCriteria]> {
        self.and_conditions.as_deref()
    }
    /// <p>A leaf node condition which can be used to specify a string condition.</p>
    pub fn string_condition(&self) -> std::option::Option<&crate::model::StringCondition> {
        self.string_condition.as_ref()
    }
    /// <p>A leaf node condition which can be used to specify a hierarchy group condition.</p>
    pub fn hierarchy_group_condition(
        &self,
    ) -> std::option::Option<&crate::model::HierarchyGroupCondition> {
        self.hierarchy_group_condition.as_ref()
    }
}
impl std::fmt::Debug for UserSearchCriteria {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserSearchCriteria");
        formatter.field("or_conditions", &self.or_conditions);
        formatter.field("and_conditions", &self.and_conditions);
        formatter.field("string_condition", &self.string_condition);
        formatter.field("hierarchy_group_condition", &self.hierarchy_group_condition);
        formatter.finish()
    }
}
/// See [`UserSearchCriteria`](crate::model::UserSearchCriteria)
pub mod user_search_criteria {

    /// A builder for [`UserSearchCriteria`](crate::model::UserSearchCriteria)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) or_conditions:
            std::option::Option<std::vec::Vec<crate::model::UserSearchCriteria>>,
        pub(crate) and_conditions:
            std::option::Option<std::vec::Vec<crate::model::UserSearchCriteria>>,
        pub(crate) string_condition: std::option::Option<crate::model::StringCondition>,
        pub(crate) hierarchy_group_condition:
            std::option::Option<crate::model::HierarchyGroupCondition>,
    }
    impl Builder {
        /// Appends an item to `or_conditions`.
        ///
        /// To override the contents of this collection use [`set_or_conditions`](Self::set_or_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an <code>OR</code> condition.</p>
        pub fn or_conditions(mut self, input: crate::model::UserSearchCriteria) -> Self {
            let mut v = self.or_conditions.unwrap_or_default();
            v.push(input);
            self.or_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an <code>OR</code> condition.</p>
        pub fn set_or_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UserSearchCriteria>>,
        ) -> Self {
            self.or_conditions = input;
            self
        }
        /// Appends an item to `and_conditions`.
        ///
        /// To override the contents of this collection use [`set_and_conditions`](Self::set_and_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an <code>AND</code> condition. </p>
        pub fn and_conditions(mut self, input: crate::model::UserSearchCriteria) -> Self {
            let mut v = self.and_conditions.unwrap_or_default();
            v.push(input);
            self.and_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an <code>AND</code> condition. </p>
        pub fn set_and_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UserSearchCriteria>>,
        ) -> Self {
            self.and_conditions = input;
            self
        }
        /// <p>A leaf node condition which can be used to specify a string condition.</p>
        pub fn string_condition(mut self, input: crate::model::StringCondition) -> Self {
            self.string_condition = Some(input);
            self
        }
        /// <p>A leaf node condition which can be used to specify a string condition.</p>
        pub fn set_string_condition(
            mut self,
            input: std::option::Option<crate::model::StringCondition>,
        ) -> Self {
            self.string_condition = input;
            self
        }
        /// <p>A leaf node condition which can be used to specify a hierarchy group condition.</p>
        pub fn hierarchy_group_condition(
            mut self,
            input: crate::model::HierarchyGroupCondition,
        ) -> Self {
            self.hierarchy_group_condition = Some(input);
            self
        }
        /// <p>A leaf node condition which can be used to specify a hierarchy group condition.</p>
        pub fn set_hierarchy_group_condition(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupCondition>,
        ) -> Self {
            self.hierarchy_group_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`UserSearchCriteria`](crate::model::UserSearchCriteria)
        pub fn build(self) -> crate::model::UserSearchCriteria {
            crate::model::UserSearchCriteria {
                or_conditions: self.or_conditions,
                and_conditions: self.and_conditions,
                string_condition: self.string_condition,
                hierarchy_group_condition: self.hierarchy_group_condition,
            }
        }
    }
}
impl UserSearchCriteria {
    /// Creates a new builder-style object to manufacture [`UserSearchCriteria`](crate::model::UserSearchCriteria)
    pub fn builder() -> crate::model::user_search_criteria::Builder {
        crate::model::user_search_criteria::Builder::default()
    }
}

/// <p>A leaf node condition which can be used to specify a hierarchy group condition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HierarchyGroupCondition {
    /// <p>The value in the hierarchy group condition.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>The type of hierarchy group match.</p>
    pub hierarchy_group_match_type: std::option::Option<crate::model::HierarchyGroupMatchType>,
}
impl HierarchyGroupCondition {
    /// <p>The value in the hierarchy group condition.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The type of hierarchy group match.</p>
    pub fn hierarchy_group_match_type(
        &self,
    ) -> std::option::Option<&crate::model::HierarchyGroupMatchType> {
        self.hierarchy_group_match_type.as_ref()
    }
}
impl std::fmt::Debug for HierarchyGroupCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HierarchyGroupCondition");
        formatter.field("value", &self.value);
        formatter.field(
            "hierarchy_group_match_type",
            &self.hierarchy_group_match_type,
        );
        formatter.finish()
    }
}
/// See [`HierarchyGroupCondition`](crate::model::HierarchyGroupCondition)
pub mod hierarchy_group_condition {

    /// A builder for [`HierarchyGroupCondition`](crate::model::HierarchyGroupCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) hierarchy_group_match_type:
            std::option::Option<crate::model::HierarchyGroupMatchType>,
    }
    impl Builder {
        /// <p>The value in the hierarchy group condition.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value in the hierarchy group condition.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The type of hierarchy group match.</p>
        pub fn hierarchy_group_match_type(
            mut self,
            input: crate::model::HierarchyGroupMatchType,
        ) -> Self {
            self.hierarchy_group_match_type = Some(input);
            self
        }
        /// <p>The type of hierarchy group match.</p>
        pub fn set_hierarchy_group_match_type(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupMatchType>,
        ) -> Self {
            self.hierarchy_group_match_type = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyGroupCondition`](crate::model::HierarchyGroupCondition)
        pub fn build(self) -> crate::model::HierarchyGroupCondition {
            crate::model::HierarchyGroupCondition {
                value: self.value,
                hierarchy_group_match_type: self.hierarchy_group_match_type,
            }
        }
    }
}
impl HierarchyGroupCondition {
    /// Creates a new builder-style object to manufacture [`HierarchyGroupCondition`](crate::model::HierarchyGroupCondition)
    pub fn builder() -> crate::model::hierarchy_group_condition::Builder {
        crate::model::hierarchy_group_condition::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HierarchyGroupMatchType {
    #[allow(missing_docs)] // documentation missing in model
    Exact,
    #[allow(missing_docs)] // documentation missing in model
    WithChildGroups,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HierarchyGroupMatchType {
    fn from(s: &str) -> Self {
        match s {
            "EXACT" => HierarchyGroupMatchType::Exact,
            "WITH_CHILD_GROUPS" => HierarchyGroupMatchType::WithChildGroups,
            other => HierarchyGroupMatchType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HierarchyGroupMatchType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HierarchyGroupMatchType::from(s))
    }
}
impl HierarchyGroupMatchType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HierarchyGroupMatchType::Exact => "EXACT",
            HierarchyGroupMatchType::WithChildGroups => "WITH_CHILD_GROUPS",
            HierarchyGroupMatchType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["EXACT", "WITH_CHILD_GROUPS"]
    }
}
impl AsRef<str> for HierarchyGroupMatchType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A leaf node condition which can be used to specify a string condition, for example, <code>username = 'abc'</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StringCondition {
    /// <p>The name of the field in the string condition.</p>
    pub field_name: std::option::Option<std::string::String>,
    /// <p>The value of the string.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>The type of comparison to be made when evaluating the string condition.</p>
    pub comparison_type: std::option::Option<crate::model::StringComparisonType>,
}
impl StringCondition {
    /// <p>The name of the field in the string condition.</p>
    pub fn field_name(&self) -> std::option::Option<&str> {
        self.field_name.as_deref()
    }
    /// <p>The value of the string.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The type of comparison to be made when evaluating the string condition.</p>
    pub fn comparison_type(&self) -> std::option::Option<&crate::model::StringComparisonType> {
        self.comparison_type.as_ref()
    }
}
impl std::fmt::Debug for StringCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StringCondition");
        formatter.field("field_name", &self.field_name);
        formatter.field("value", &self.value);
        formatter.field("comparison_type", &self.comparison_type);
        formatter.finish()
    }
}
/// See [`StringCondition`](crate::model::StringCondition)
pub mod string_condition {

    /// A builder for [`StringCondition`](crate::model::StringCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) comparison_type: std::option::Option<crate::model::StringComparisonType>,
    }
    impl Builder {
        /// <p>The name of the field in the string condition.</p>
        pub fn field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_name = Some(input.into());
            self
        }
        /// <p>The name of the field in the string condition.</p>
        pub fn set_field_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_name = input;
            self
        }
        /// <p>The value of the string.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the string.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The type of comparison to be made when evaluating the string condition.</p>
        pub fn comparison_type(mut self, input: crate::model::StringComparisonType) -> Self {
            self.comparison_type = Some(input);
            self
        }
        /// <p>The type of comparison to be made when evaluating the string condition.</p>
        pub fn set_comparison_type(
            mut self,
            input: std::option::Option<crate::model::StringComparisonType>,
        ) -> Self {
            self.comparison_type = input;
            self
        }
        /// Consumes the builder and constructs a [`StringCondition`](crate::model::StringCondition)
        pub fn build(self) -> crate::model::StringCondition {
            crate::model::StringCondition {
                field_name: self.field_name,
                value: self.value,
                comparison_type: self.comparison_type,
            }
        }
    }
}
impl StringCondition {
    /// Creates a new builder-style object to manufacture [`StringCondition`](crate::model::StringCondition)
    pub fn builder() -> crate::model::string_condition::Builder {
        crate::model::string_condition::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StringComparisonType {
    #[allow(missing_docs)] // documentation missing in model
    Contains,
    #[allow(missing_docs)] // documentation missing in model
    Exact,
    #[allow(missing_docs)] // documentation missing in model
    StartsWith,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StringComparisonType {
    fn from(s: &str) -> Self {
        match s {
            "CONTAINS" => StringComparisonType::Contains,
            "EXACT" => StringComparisonType::Exact,
            "STARTS_WITH" => StringComparisonType::StartsWith,
            other => StringComparisonType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StringComparisonType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StringComparisonType::from(s))
    }
}
impl StringComparisonType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StringComparisonType::Contains => "CONTAINS",
            StringComparisonType::Exact => "EXACT",
            StringComparisonType::StartsWith => "STARTS_WITH",
            StringComparisonType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CONTAINS", "EXACT", "STARTS_WITH"]
    }
}
impl AsRef<str> for StringComparisonType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Filters to be applied to search results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserSearchFilter {
    /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
    /// <ul>
    /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
    /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
    /// </ul>
    pub tag_filter: std::option::Option<crate::model::ControlPlaneTagFilter>,
}
impl UserSearchFilter {
    /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
    /// <ul>
    /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
    /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
    /// </ul>
    pub fn tag_filter(&self) -> std::option::Option<&crate::model::ControlPlaneTagFilter> {
        self.tag_filter.as_ref()
    }
}
impl std::fmt::Debug for UserSearchFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserSearchFilter");
        formatter.field("tag_filter", &self.tag_filter);
        formatter.finish()
    }
}
/// See [`UserSearchFilter`](crate::model::UserSearchFilter)
pub mod user_search_filter {

    /// A builder for [`UserSearchFilter`](crate::model::UserSearchFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tag_filter: std::option::Option<crate::model::ControlPlaneTagFilter>,
    }
    impl Builder {
        /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
        /// <ul>
        /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
        /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
        /// </ul>
        pub fn tag_filter(mut self, input: crate::model::ControlPlaneTagFilter) -> Self {
            self.tag_filter = Some(input);
            self
        }
        /// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
        /// <ul>
        /// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
        /// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
        /// </ul>
        pub fn set_tag_filter(
            mut self,
            input: std::option::Option<crate::model::ControlPlaneTagFilter>,
        ) -> Self {
            self.tag_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`UserSearchFilter`](crate::model::UserSearchFilter)
        pub fn build(self) -> crate::model::UserSearchFilter {
            crate::model::UserSearchFilter {
                tag_filter: self.tag_filter,
            }
        }
    }
}
impl UserSearchFilter {
    /// Creates a new builder-style object to manufacture [`UserSearchFilter`](crate::model::UserSearchFilter)
    pub fn builder() -> crate::model::user_search_filter::Builder {
        crate::model::user_search_filter::Builder::default()
    }
}

/// <p>An object that can be used to specify Tag conditions inside the <code>SearchFilter</code>. This accepts an <code>OR</code> of <code>AND</code> (List of List) input where: </p>
/// <ul>
/// <li> <p>Top level list specifies conditions that need to be applied with <code>OR</code> operator</p> </li>
/// <li> <p>Inner list specifies conditions that need to be applied with <code>AND</code> operator.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ControlPlaneTagFilter {
    /// <p>A list of conditions which would be applied together with an <code>OR</code> condition. </p>
    pub or_conditions:
        std::option::Option<std::vec::Vec<std::vec::Vec<crate::model::TagCondition>>>,
    /// <p>A list of conditions which would be applied together with an <code>AND</code> condition.</p>
    pub and_conditions: std::option::Option<std::vec::Vec<crate::model::TagCondition>>,
    /// <p>A leaf node condition which can be used to specify a tag condition. </p>
    pub tag_condition: std::option::Option<crate::model::TagCondition>,
}
impl ControlPlaneTagFilter {
    /// <p>A list of conditions which would be applied together with an <code>OR</code> condition. </p>
    pub fn or_conditions(
        &self,
    ) -> std::option::Option<&[std::vec::Vec<crate::model::TagCondition>]> {
        self.or_conditions.as_deref()
    }
    /// <p>A list of conditions which would be applied together with an <code>AND</code> condition.</p>
    pub fn and_conditions(&self) -> std::option::Option<&[crate::model::TagCondition]> {
        self.and_conditions.as_deref()
    }
    /// <p>A leaf node condition which can be used to specify a tag condition. </p>
    pub fn tag_condition(&self) -> std::option::Option<&crate::model::TagCondition> {
        self.tag_condition.as_ref()
    }
}
impl std::fmt::Debug for ControlPlaneTagFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ControlPlaneTagFilter");
        formatter.field("or_conditions", &self.or_conditions);
        formatter.field("and_conditions", &self.and_conditions);
        formatter.field("tag_condition", &self.tag_condition);
        formatter.finish()
    }
}
/// See [`ControlPlaneTagFilter`](crate::model::ControlPlaneTagFilter)
pub mod control_plane_tag_filter {

    /// A builder for [`ControlPlaneTagFilter`](crate::model::ControlPlaneTagFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) or_conditions:
            std::option::Option<std::vec::Vec<std::vec::Vec<crate::model::TagCondition>>>,
        pub(crate) and_conditions: std::option::Option<std::vec::Vec<crate::model::TagCondition>>,
        pub(crate) tag_condition: std::option::Option<crate::model::TagCondition>,
    }
    impl Builder {
        /// Appends an item to `or_conditions`.
        ///
        /// To override the contents of this collection use [`set_or_conditions`](Self::set_or_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an <code>OR</code> condition. </p>
        pub fn or_conditions(mut self, input: std::vec::Vec<crate::model::TagCondition>) -> Self {
            let mut v = self.or_conditions.unwrap_or_default();
            v.push(input);
            self.or_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an <code>OR</code> condition. </p>
        pub fn set_or_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<crate::model::TagCondition>>>,
        ) -> Self {
            self.or_conditions = input;
            self
        }
        /// Appends an item to `and_conditions`.
        ///
        /// To override the contents of this collection use [`set_and_conditions`](Self::set_and_conditions).
        ///
        /// <p>A list of conditions which would be applied together with an <code>AND</code> condition.</p>
        pub fn and_conditions(mut self, input: crate::model::TagCondition) -> Self {
            let mut v = self.and_conditions.unwrap_or_default();
            v.push(input);
            self.and_conditions = Some(v);
            self
        }
        /// <p>A list of conditions which would be applied together with an <code>AND</code> condition.</p>
        pub fn set_and_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagCondition>>,
        ) -> Self {
            self.and_conditions = input;
            self
        }
        /// <p>A leaf node condition which can be used to specify a tag condition. </p>
        pub fn tag_condition(mut self, input: crate::model::TagCondition) -> Self {
            self.tag_condition = Some(input);
            self
        }
        /// <p>A leaf node condition which can be used to specify a tag condition. </p>
        pub fn set_tag_condition(
            mut self,
            input: std::option::Option<crate::model::TagCondition>,
        ) -> Self {
            self.tag_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`ControlPlaneTagFilter`](crate::model::ControlPlaneTagFilter)
        pub fn build(self) -> crate::model::ControlPlaneTagFilter {
            crate::model::ControlPlaneTagFilter {
                or_conditions: self.or_conditions,
                and_conditions: self.and_conditions,
                tag_condition: self.tag_condition,
            }
        }
    }
}
impl ControlPlaneTagFilter {
    /// Creates a new builder-style object to manufacture [`ControlPlaneTagFilter`](crate::model::ControlPlaneTagFilter)
    pub fn builder() -> crate::model::control_plane_tag_filter::Builder {
        crate::model::control_plane_tag_filter::Builder::default()
    }
}

/// <p>A leaf node condition which can be used to specify a tag condition, for example, <code>HAVE BPO = 123</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagCondition {
    /// <p>The tag key in the tag condition.</p>
    pub tag_key: std::option::Option<std::string::String>,
    /// <p>The tag value in the tag condition.</p>
    pub tag_value: std::option::Option<std::string::String>,
}
impl TagCondition {
    /// <p>The tag key in the tag condition.</p>
    pub fn tag_key(&self) -> std::option::Option<&str> {
        self.tag_key.as_deref()
    }
    /// <p>The tag value in the tag condition.</p>
    pub fn tag_value(&self) -> std::option::Option<&str> {
        self.tag_value.as_deref()
    }
}
impl std::fmt::Debug for TagCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagCondition");
        formatter.field("tag_key", &self.tag_key);
        formatter.field("tag_value", &self.tag_value);
        formatter.finish()
    }
}
/// See [`TagCondition`](crate::model::TagCondition)
pub mod tag_condition {

    /// A builder for [`TagCondition`](crate::model::TagCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tag_key: std::option::Option<std::string::String>,
        pub(crate) tag_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag key in the tag condition.</p>
        pub fn tag_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_key = Some(input.into());
            self
        }
        /// <p>The tag key in the tag condition.</p>
        pub fn set_tag_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tag_key = input;
            self
        }
        /// <p>The tag value in the tag condition.</p>
        pub fn tag_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_value = Some(input.into());
            self
        }
        /// <p>The tag value in the tag condition.</p>
        pub fn set_tag_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tag_value = input;
            self
        }
        /// Consumes the builder and constructs a [`TagCondition`](crate::model::TagCondition)
        pub fn build(self) -> crate::model::TagCondition {
            crate::model::TagCondition {
                tag_key: self.tag_key,
                tag_value: self.tag_value,
            }
        }
    }
}
impl TagCondition {
    /// Creates a new builder-style object to manufacture [`TagCondition`](crate::model::TagCondition)
    pub fn builder() -> crate::model::tag_condition::Builder {
        crate::model::tag_condition::Builder::default()
    }
}

/// <p>Information about available phone numbers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AvailableNumberSummary {
    /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    pub phone_number: std::option::Option<std::string::String>,
    /// <p>The ISO country code.</p>
    pub phone_number_country_code: std::option::Option<crate::model::PhoneNumberCountryCode>,
    /// <p>The type of phone number.</p>
    pub phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
}
impl AvailableNumberSummary {
    /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
    /// <p>The ISO country code.</p>
    pub fn phone_number_country_code(
        &self,
    ) -> std::option::Option<&crate::model::PhoneNumberCountryCode> {
        self.phone_number_country_code.as_ref()
    }
    /// <p>The type of phone number.</p>
    pub fn phone_number_type(&self) -> std::option::Option<&crate::model::PhoneNumberType> {
        self.phone_number_type.as_ref()
    }
}
impl std::fmt::Debug for AvailableNumberSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AvailableNumberSummary");
        formatter.field("phone_number", &self.phone_number);
        formatter.field("phone_number_country_code", &self.phone_number_country_code);
        formatter.field("phone_number_type", &self.phone_number_type);
        formatter.finish()
    }
}
/// See [`AvailableNumberSummary`](crate::model::AvailableNumberSummary)
pub mod available_number_summary {

    /// A builder for [`AvailableNumberSummary`](crate::model::AvailableNumberSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) phone_number_country_code:
            std::option::Option<crate::model::PhoneNumberCountryCode>,
        pub(crate) phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
    }
    impl Builder {
        /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// <p>The ISO country code.</p>
        pub fn phone_number_country_code(
            mut self,
            input: crate::model::PhoneNumberCountryCode,
        ) -> Self {
            self.phone_number_country_code = Some(input);
            self
        }
        /// <p>The ISO country code.</p>
        pub fn set_phone_number_country_code(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberCountryCode>,
        ) -> Self {
            self.phone_number_country_code = input;
            self
        }
        /// <p>The type of phone number.</p>
        pub fn phone_number_type(mut self, input: crate::model::PhoneNumberType) -> Self {
            self.phone_number_type = Some(input);
            self
        }
        /// <p>The type of phone number.</p>
        pub fn set_phone_number_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberType>,
        ) -> Self {
            self.phone_number_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AvailableNumberSummary`](crate::model::AvailableNumberSummary)
        pub fn build(self) -> crate::model::AvailableNumberSummary {
            crate::model::AvailableNumberSummary {
                phone_number: self.phone_number,
                phone_number_country_code: self.phone_number_country_code,
                phone_number_type: self.phone_number_type,
            }
        }
    }
}
impl AvailableNumberSummary {
    /// Creates a new builder-style object to manufacture [`AvailableNumberSummary`](crate::model::AvailableNumberSummary)
    pub fn builder() -> crate::model::available_number_summary::Builder {
        crate::model::available_number_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneNumberType {
    #[allow(missing_docs)] // documentation missing in model
    Did,
    #[allow(missing_docs)] // documentation missing in model
    TollFree,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PhoneNumberType {
    fn from(s: &str) -> Self {
        match s {
            "DID" => PhoneNumberType::Did,
            "TOLL_FREE" => PhoneNumberType::TollFree,
            other => PhoneNumberType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PhoneNumberType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneNumberType::from(s))
    }
}
impl PhoneNumberType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneNumberType::Did => "DID",
            PhoneNumberType::TollFree => "TOLL_FREE",
            PhoneNumberType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DID", "TOLL_FREE"]
    }
}
impl AsRef<str> for PhoneNumberType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneNumberCountryCode {
    #[allow(missing_docs)] // documentation missing in model
    Ad,
    #[allow(missing_docs)] // documentation missing in model
    Ae,
    #[allow(missing_docs)] // documentation missing in model
    Af,
    #[allow(missing_docs)] // documentation missing in model
    Ag,
    #[allow(missing_docs)] // documentation missing in model
    Ai,
    #[allow(missing_docs)] // documentation missing in model
    Al,
    #[allow(missing_docs)] // documentation missing in model
    Am,
    #[allow(missing_docs)] // documentation missing in model
    An,
    #[allow(missing_docs)] // documentation missing in model
    Ao,
    #[allow(missing_docs)] // documentation missing in model
    Aq,
    #[allow(missing_docs)] // documentation missing in model
    Ar,
    #[allow(missing_docs)] // documentation missing in model
    As,
    #[allow(missing_docs)] // documentation missing in model
    At,
    #[allow(missing_docs)] // documentation missing in model
    Au,
    #[allow(missing_docs)] // documentation missing in model
    Aw,
    #[allow(missing_docs)] // documentation missing in model
    Az,
    #[allow(missing_docs)] // documentation missing in model
    Ba,
    #[allow(missing_docs)] // documentation missing in model
    Bb,
    #[allow(missing_docs)] // documentation missing in model
    Bd,
    #[allow(missing_docs)] // documentation missing in model
    Be,
    #[allow(missing_docs)] // documentation missing in model
    Bf,
    #[allow(missing_docs)] // documentation missing in model
    Bg,
    #[allow(missing_docs)] // documentation missing in model
    Bh,
    #[allow(missing_docs)] // documentation missing in model
    Bi,
    #[allow(missing_docs)] // documentation missing in model
    Bj,
    #[allow(missing_docs)] // documentation missing in model
    Bl,
    #[allow(missing_docs)] // documentation missing in model
    Bm,
    #[allow(missing_docs)] // documentation missing in model
    Bn,
    #[allow(missing_docs)] // documentation missing in model
    Bo,
    #[allow(missing_docs)] // documentation missing in model
    Br,
    #[allow(missing_docs)] // documentation missing in model
    Bs,
    #[allow(missing_docs)] // documentation missing in model
    Bt,
    #[allow(missing_docs)] // documentation missing in model
    Bw,
    #[allow(missing_docs)] // documentation missing in model
    By,
    #[allow(missing_docs)] // documentation missing in model
    Bz,
    #[allow(missing_docs)] // documentation missing in model
    Ca,
    #[allow(missing_docs)] // documentation missing in model
    Cc,
    #[allow(missing_docs)] // documentation missing in model
    Cd,
    #[allow(missing_docs)] // documentation missing in model
    Cf,
    #[allow(missing_docs)] // documentation missing in model
    Cg,
    #[allow(missing_docs)] // documentation missing in model
    Ch,
    #[allow(missing_docs)] // documentation missing in model
    Ci,
    #[allow(missing_docs)] // documentation missing in model
    Ck,
    #[allow(missing_docs)] // documentation missing in model
    Cl,
    #[allow(missing_docs)] // documentation missing in model
    Cm,
    #[allow(missing_docs)] // documentation missing in model
    Cn,
    #[allow(missing_docs)] // documentation missing in model
    Co,
    #[allow(missing_docs)] // documentation missing in model
    Cr,
    #[allow(missing_docs)] // documentation missing in model
    Cu,
    #[allow(missing_docs)] // documentation missing in model
    Cv,
    #[allow(missing_docs)] // documentation missing in model
    Cw,
    #[allow(missing_docs)] // documentation missing in model
    Cx,
    #[allow(missing_docs)] // documentation missing in model
    Cy,
    #[allow(missing_docs)] // documentation missing in model
    Cz,
    #[allow(missing_docs)] // documentation missing in model
    De,
    #[allow(missing_docs)] // documentation missing in model
    Dj,
    #[allow(missing_docs)] // documentation missing in model
    Dk,
    #[allow(missing_docs)] // documentation missing in model
    Dm,
    #[allow(missing_docs)] // documentation missing in model
    Do,
    #[allow(missing_docs)] // documentation missing in model
    Dz,
    #[allow(missing_docs)] // documentation missing in model
    Ec,
    #[allow(missing_docs)] // documentation missing in model
    Ee,
    #[allow(missing_docs)] // documentation missing in model
    Eg,
    #[allow(missing_docs)] // documentation missing in model
    Eh,
    #[allow(missing_docs)] // documentation missing in model
    Er,
    #[allow(missing_docs)] // documentation missing in model
    Es,
    #[allow(missing_docs)] // documentation missing in model
    Et,
    #[allow(missing_docs)] // documentation missing in model
    Fi,
    #[allow(missing_docs)] // documentation missing in model
    Fj,
    #[allow(missing_docs)] // documentation missing in model
    Fk,
    #[allow(missing_docs)] // documentation missing in model
    Fm,
    #[allow(missing_docs)] // documentation missing in model
    Fo,
    #[allow(missing_docs)] // documentation missing in model
    Fr,
    #[allow(missing_docs)] // documentation missing in model
    Ga,
    #[allow(missing_docs)] // documentation missing in model
    Gb,
    #[allow(missing_docs)] // documentation missing in model
    Gd,
    #[allow(missing_docs)] // documentation missing in model
    Ge,
    #[allow(missing_docs)] // documentation missing in model
    Gg,
    #[allow(missing_docs)] // documentation missing in model
    Gh,
    #[allow(missing_docs)] // documentation missing in model
    Gi,
    #[allow(missing_docs)] // documentation missing in model
    Gl,
    #[allow(missing_docs)] // documentation missing in model
    Gm,
    #[allow(missing_docs)] // documentation missing in model
    Gn,
    #[allow(missing_docs)] // documentation missing in model
    Gq,
    #[allow(missing_docs)] // documentation missing in model
    Gr,
    #[allow(missing_docs)] // documentation missing in model
    Gt,
    #[allow(missing_docs)] // documentation missing in model
    Gu,
    #[allow(missing_docs)] // documentation missing in model
    Gw,
    #[allow(missing_docs)] // documentation missing in model
    Gy,
    #[allow(missing_docs)] // documentation missing in model
    Hk,
    #[allow(missing_docs)] // documentation missing in model
    Hn,
    #[allow(missing_docs)] // documentation missing in model
    Hr,
    #[allow(missing_docs)] // documentation missing in model
    Ht,
    #[allow(missing_docs)] // documentation missing in model
    Hu,
    #[allow(missing_docs)] // documentation missing in model
    Id,
    #[allow(missing_docs)] // documentation missing in model
    Ie,
    #[allow(missing_docs)] // documentation missing in model
    Il,
    #[allow(missing_docs)] // documentation missing in model
    Im,
    #[allow(missing_docs)] // documentation missing in model
    In,
    #[allow(missing_docs)] // documentation missing in model
    Io,
    #[allow(missing_docs)] // documentation missing in model
    Iq,
    #[allow(missing_docs)] // documentation missing in model
    Ir,
    #[allow(missing_docs)] // documentation missing in model
    Is,
    #[allow(missing_docs)] // documentation missing in model
    It,
    #[allow(missing_docs)] // documentation missing in model
    Je,
    #[allow(missing_docs)] // documentation missing in model
    Jm,
    #[allow(missing_docs)] // documentation missing in model
    Jo,
    #[allow(missing_docs)] // documentation missing in model
    Jp,
    #[allow(missing_docs)] // documentation missing in model
    Ke,
    #[allow(missing_docs)] // documentation missing in model
    Kg,
    #[allow(missing_docs)] // documentation missing in model
    Kh,
    #[allow(missing_docs)] // documentation missing in model
    Ki,
    #[allow(missing_docs)] // documentation missing in model
    Km,
    #[allow(missing_docs)] // documentation missing in model
    Kn,
    #[allow(missing_docs)] // documentation missing in model
    Kp,
    #[allow(missing_docs)] // documentation missing in model
    Kr,
    #[allow(missing_docs)] // documentation missing in model
    Kw,
    #[allow(missing_docs)] // documentation missing in model
    Ky,
    #[allow(missing_docs)] // documentation missing in model
    Kz,
    #[allow(missing_docs)] // documentation missing in model
    La,
    #[allow(missing_docs)] // documentation missing in model
    Lb,
    #[allow(missing_docs)] // documentation missing in model
    Lc,
    #[allow(missing_docs)] // documentation missing in model
    Li,
    #[allow(missing_docs)] // documentation missing in model
    Lk,
    #[allow(missing_docs)] // documentation missing in model
    Lr,
    #[allow(missing_docs)] // documentation missing in model
    Ls,
    #[allow(missing_docs)] // documentation missing in model
    Lt,
    #[allow(missing_docs)] // documentation missing in model
    Lu,
    #[allow(missing_docs)] // documentation missing in model
    Lv,
    #[allow(missing_docs)] // documentation missing in model
    Ly,
    #[allow(missing_docs)] // documentation missing in model
    Ma,
    #[allow(missing_docs)] // documentation missing in model
    Mc,
    #[allow(missing_docs)] // documentation missing in model
    Md,
    #[allow(missing_docs)] // documentation missing in model
    Me,
    #[allow(missing_docs)] // documentation missing in model
    Mf,
    #[allow(missing_docs)] // documentation missing in model
    Mg,
    #[allow(missing_docs)] // documentation missing in model
    Mh,
    #[allow(missing_docs)] // documentation missing in model
    Mk,
    #[allow(missing_docs)] // documentation missing in model
    Ml,
    #[allow(missing_docs)] // documentation missing in model
    Mm,
    #[allow(missing_docs)] // documentation missing in model
    Mn,
    #[allow(missing_docs)] // documentation missing in model
    Mo,
    #[allow(missing_docs)] // documentation missing in model
    Mp,
    #[allow(missing_docs)] // documentation missing in model
    Mr,
    #[allow(missing_docs)] // documentation missing in model
    Ms,
    #[allow(missing_docs)] // documentation missing in model
    Mt,
    #[allow(missing_docs)] // documentation missing in model
    Mu,
    #[allow(missing_docs)] // documentation missing in model
    Mv,
    #[allow(missing_docs)] // documentation missing in model
    Mw,
    #[allow(missing_docs)] // documentation missing in model
    Mx,
    #[allow(missing_docs)] // documentation missing in model
    My,
    #[allow(missing_docs)] // documentation missing in model
    Mz,
    #[allow(missing_docs)] // documentation missing in model
    Na,
    #[allow(missing_docs)] // documentation missing in model
    Nc,
    #[allow(missing_docs)] // documentation missing in model
    Ne,
    #[allow(missing_docs)] // documentation missing in model
    Ng,
    #[allow(missing_docs)] // documentation missing in model
    Ni,
    #[allow(missing_docs)] // documentation missing in model
    Nl,
    #[allow(missing_docs)] // documentation missing in model
    No,
    #[allow(missing_docs)] // documentation missing in model
    Np,
    #[allow(missing_docs)] // documentation missing in model
    Nr,
    #[allow(missing_docs)] // documentation missing in model
    Nu,
    #[allow(missing_docs)] // documentation missing in model
    Nz,
    #[allow(missing_docs)] // documentation missing in model
    Om,
    #[allow(missing_docs)] // documentation missing in model
    Pa,
    #[allow(missing_docs)] // documentation missing in model
    Pe,
    #[allow(missing_docs)] // documentation missing in model
    Pf,
    #[allow(missing_docs)] // documentation missing in model
    Pg,
    #[allow(missing_docs)] // documentation missing in model
    Ph,
    #[allow(missing_docs)] // documentation missing in model
    Pk,
    #[allow(missing_docs)] // documentation missing in model
    Pl,
    #[allow(missing_docs)] // documentation missing in model
    Pm,
    #[allow(missing_docs)] // documentation missing in model
    Pn,
    #[allow(missing_docs)] // documentation missing in model
    Pr,
    #[allow(missing_docs)] // documentation missing in model
    Pt,
    #[allow(missing_docs)] // documentation missing in model
    Pw,
    #[allow(missing_docs)] // documentation missing in model
    Py,
    #[allow(missing_docs)] // documentation missing in model
    Qa,
    #[allow(missing_docs)] // documentation missing in model
    Re,
    #[allow(missing_docs)] // documentation missing in model
    Ro,
    #[allow(missing_docs)] // documentation missing in model
    Rs,
    #[allow(missing_docs)] // documentation missing in model
    Ru,
    #[allow(missing_docs)] // documentation missing in model
    Rw,
    #[allow(missing_docs)] // documentation missing in model
    Sa,
    #[allow(missing_docs)] // documentation missing in model
    Sb,
    #[allow(missing_docs)] // documentation missing in model
    Sc,
    #[allow(missing_docs)] // documentation missing in model
    Sd,
    #[allow(missing_docs)] // documentation missing in model
    Se,
    #[allow(missing_docs)] // documentation missing in model
    Sg,
    #[allow(missing_docs)] // documentation missing in model
    Sh,
    #[allow(missing_docs)] // documentation missing in model
    Si,
    #[allow(missing_docs)] // documentation missing in model
    Sj,
    #[allow(missing_docs)] // documentation missing in model
    Sk,
    #[allow(missing_docs)] // documentation missing in model
    Sl,
    #[allow(missing_docs)] // documentation missing in model
    Sm,
    #[allow(missing_docs)] // documentation missing in model
    Sn,
    #[allow(missing_docs)] // documentation missing in model
    So,
    #[allow(missing_docs)] // documentation missing in model
    Sr,
    #[allow(missing_docs)] // documentation missing in model
    St,
    #[allow(missing_docs)] // documentation missing in model
    Sv,
    #[allow(missing_docs)] // documentation missing in model
    Sx,
    #[allow(missing_docs)] // documentation missing in model
    Sy,
    #[allow(missing_docs)] // documentation missing in model
    Sz,
    #[allow(missing_docs)] // documentation missing in model
    Tc,
    #[allow(missing_docs)] // documentation missing in model
    Td,
    #[allow(missing_docs)] // documentation missing in model
    Tg,
    #[allow(missing_docs)] // documentation missing in model
    Th,
    #[allow(missing_docs)] // documentation missing in model
    Tj,
    #[allow(missing_docs)] // documentation missing in model
    Tk,
    #[allow(missing_docs)] // documentation missing in model
    Tl,
    #[allow(missing_docs)] // documentation missing in model
    Tm,
    #[allow(missing_docs)] // documentation missing in model
    Tn,
    #[allow(missing_docs)] // documentation missing in model
    To,
    #[allow(missing_docs)] // documentation missing in model
    Tr,
    #[allow(missing_docs)] // documentation missing in model
    Tt,
    #[allow(missing_docs)] // documentation missing in model
    Tv,
    #[allow(missing_docs)] // documentation missing in model
    Tw,
    #[allow(missing_docs)] // documentation missing in model
    Tz,
    #[allow(missing_docs)] // documentation missing in model
    Ua,
    #[allow(missing_docs)] // documentation missing in model
    Ug,
    #[allow(missing_docs)] // documentation missing in model
    Us,
    #[allow(missing_docs)] // documentation missing in model
    Uy,
    #[allow(missing_docs)] // documentation missing in model
    Uz,
    #[allow(missing_docs)] // documentation missing in model
    Va,
    #[allow(missing_docs)] // documentation missing in model
    Vc,
    #[allow(missing_docs)] // documentation missing in model
    Ve,
    #[allow(missing_docs)] // documentation missing in model
    Vg,
    #[allow(missing_docs)] // documentation missing in model
    Vi,
    #[allow(missing_docs)] // documentation missing in model
    Vn,
    #[allow(missing_docs)] // documentation missing in model
    Vu,
    #[allow(missing_docs)] // documentation missing in model
    Wf,
    #[allow(missing_docs)] // documentation missing in model
    Ws,
    #[allow(missing_docs)] // documentation missing in model
    Ye,
    #[allow(missing_docs)] // documentation missing in model
    Yt,
    #[allow(missing_docs)] // documentation missing in model
    Za,
    #[allow(missing_docs)] // documentation missing in model
    Zm,
    #[allow(missing_docs)] // documentation missing in model
    Zw,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PhoneNumberCountryCode {
    fn from(s: &str) -> Self {
        match s {
            "AD" => PhoneNumberCountryCode::Ad,
            "AE" => PhoneNumberCountryCode::Ae,
            "AF" => PhoneNumberCountryCode::Af,
            "AG" => PhoneNumberCountryCode::Ag,
            "AI" => PhoneNumberCountryCode::Ai,
            "AL" => PhoneNumberCountryCode::Al,
            "AM" => PhoneNumberCountryCode::Am,
            "AN" => PhoneNumberCountryCode::An,
            "AO" => PhoneNumberCountryCode::Ao,
            "AQ" => PhoneNumberCountryCode::Aq,
            "AR" => PhoneNumberCountryCode::Ar,
            "AS" => PhoneNumberCountryCode::As,
            "AT" => PhoneNumberCountryCode::At,
            "AU" => PhoneNumberCountryCode::Au,
            "AW" => PhoneNumberCountryCode::Aw,
            "AZ" => PhoneNumberCountryCode::Az,
            "BA" => PhoneNumberCountryCode::Ba,
            "BB" => PhoneNumberCountryCode::Bb,
            "BD" => PhoneNumberCountryCode::Bd,
            "BE" => PhoneNumberCountryCode::Be,
            "BF" => PhoneNumberCountryCode::Bf,
            "BG" => PhoneNumberCountryCode::Bg,
            "BH" => PhoneNumberCountryCode::Bh,
            "BI" => PhoneNumberCountryCode::Bi,
            "BJ" => PhoneNumberCountryCode::Bj,
            "BL" => PhoneNumberCountryCode::Bl,
            "BM" => PhoneNumberCountryCode::Bm,
            "BN" => PhoneNumberCountryCode::Bn,
            "BO" => PhoneNumberCountryCode::Bo,
            "BR" => PhoneNumberCountryCode::Br,
            "BS" => PhoneNumberCountryCode::Bs,
            "BT" => PhoneNumberCountryCode::Bt,
            "BW" => PhoneNumberCountryCode::Bw,
            "BY" => PhoneNumberCountryCode::By,
            "BZ" => PhoneNumberCountryCode::Bz,
            "CA" => PhoneNumberCountryCode::Ca,
            "CC" => PhoneNumberCountryCode::Cc,
            "CD" => PhoneNumberCountryCode::Cd,
            "CF" => PhoneNumberCountryCode::Cf,
            "CG" => PhoneNumberCountryCode::Cg,
            "CH" => PhoneNumberCountryCode::Ch,
            "CI" => PhoneNumberCountryCode::Ci,
            "CK" => PhoneNumberCountryCode::Ck,
            "CL" => PhoneNumberCountryCode::Cl,
            "CM" => PhoneNumberCountryCode::Cm,
            "CN" => PhoneNumberCountryCode::Cn,
            "CO" => PhoneNumberCountryCode::Co,
            "CR" => PhoneNumberCountryCode::Cr,
            "CU" => PhoneNumberCountryCode::Cu,
            "CV" => PhoneNumberCountryCode::Cv,
            "CW" => PhoneNumberCountryCode::Cw,
            "CX" => PhoneNumberCountryCode::Cx,
            "CY" => PhoneNumberCountryCode::Cy,
            "CZ" => PhoneNumberCountryCode::Cz,
            "DE" => PhoneNumberCountryCode::De,
            "DJ" => PhoneNumberCountryCode::Dj,
            "DK" => PhoneNumberCountryCode::Dk,
            "DM" => PhoneNumberCountryCode::Dm,
            "DO" => PhoneNumberCountryCode::Do,
            "DZ" => PhoneNumberCountryCode::Dz,
            "EC" => PhoneNumberCountryCode::Ec,
            "EE" => PhoneNumberCountryCode::Ee,
            "EG" => PhoneNumberCountryCode::Eg,
            "EH" => PhoneNumberCountryCode::Eh,
            "ER" => PhoneNumberCountryCode::Er,
            "ES" => PhoneNumberCountryCode::Es,
            "ET" => PhoneNumberCountryCode::Et,
            "FI" => PhoneNumberCountryCode::Fi,
            "FJ" => PhoneNumberCountryCode::Fj,
            "FK" => PhoneNumberCountryCode::Fk,
            "FM" => PhoneNumberCountryCode::Fm,
            "FO" => PhoneNumberCountryCode::Fo,
            "FR" => PhoneNumberCountryCode::Fr,
            "GA" => PhoneNumberCountryCode::Ga,
            "GB" => PhoneNumberCountryCode::Gb,
            "GD" => PhoneNumberCountryCode::Gd,
            "GE" => PhoneNumberCountryCode::Ge,
            "GG" => PhoneNumberCountryCode::Gg,
            "GH" => PhoneNumberCountryCode::Gh,
            "GI" => PhoneNumberCountryCode::Gi,
            "GL" => PhoneNumberCountryCode::Gl,
            "GM" => PhoneNumberCountryCode::Gm,
            "GN" => PhoneNumberCountryCode::Gn,
            "GQ" => PhoneNumberCountryCode::Gq,
            "GR" => PhoneNumberCountryCode::Gr,
            "GT" => PhoneNumberCountryCode::Gt,
            "GU" => PhoneNumberCountryCode::Gu,
            "GW" => PhoneNumberCountryCode::Gw,
            "GY" => PhoneNumberCountryCode::Gy,
            "HK" => PhoneNumberCountryCode::Hk,
            "HN" => PhoneNumberCountryCode::Hn,
            "HR" => PhoneNumberCountryCode::Hr,
            "HT" => PhoneNumberCountryCode::Ht,
            "HU" => PhoneNumberCountryCode::Hu,
            "ID" => PhoneNumberCountryCode::Id,
            "IE" => PhoneNumberCountryCode::Ie,
            "IL" => PhoneNumberCountryCode::Il,
            "IM" => PhoneNumberCountryCode::Im,
            "IN" => PhoneNumberCountryCode::In,
            "IO" => PhoneNumberCountryCode::Io,
            "IQ" => PhoneNumberCountryCode::Iq,
            "IR" => PhoneNumberCountryCode::Ir,
            "IS" => PhoneNumberCountryCode::Is,
            "IT" => PhoneNumberCountryCode::It,
            "JE" => PhoneNumberCountryCode::Je,
            "JM" => PhoneNumberCountryCode::Jm,
            "JO" => PhoneNumberCountryCode::Jo,
            "JP" => PhoneNumberCountryCode::Jp,
            "KE" => PhoneNumberCountryCode::Ke,
            "KG" => PhoneNumberCountryCode::Kg,
            "KH" => PhoneNumberCountryCode::Kh,
            "KI" => PhoneNumberCountryCode::Ki,
            "KM" => PhoneNumberCountryCode::Km,
            "KN" => PhoneNumberCountryCode::Kn,
            "KP" => PhoneNumberCountryCode::Kp,
            "KR" => PhoneNumberCountryCode::Kr,
            "KW" => PhoneNumberCountryCode::Kw,
            "KY" => PhoneNumberCountryCode::Ky,
            "KZ" => PhoneNumberCountryCode::Kz,
            "LA" => PhoneNumberCountryCode::La,
            "LB" => PhoneNumberCountryCode::Lb,
            "LC" => PhoneNumberCountryCode::Lc,
            "LI" => PhoneNumberCountryCode::Li,
            "LK" => PhoneNumberCountryCode::Lk,
            "LR" => PhoneNumberCountryCode::Lr,
            "LS" => PhoneNumberCountryCode::Ls,
            "LT" => PhoneNumberCountryCode::Lt,
            "LU" => PhoneNumberCountryCode::Lu,
            "LV" => PhoneNumberCountryCode::Lv,
            "LY" => PhoneNumberCountryCode::Ly,
            "MA" => PhoneNumberCountryCode::Ma,
            "MC" => PhoneNumberCountryCode::Mc,
            "MD" => PhoneNumberCountryCode::Md,
            "ME" => PhoneNumberCountryCode::Me,
            "MF" => PhoneNumberCountryCode::Mf,
            "MG" => PhoneNumberCountryCode::Mg,
            "MH" => PhoneNumberCountryCode::Mh,
            "MK" => PhoneNumberCountryCode::Mk,
            "ML" => PhoneNumberCountryCode::Ml,
            "MM" => PhoneNumberCountryCode::Mm,
            "MN" => PhoneNumberCountryCode::Mn,
            "MO" => PhoneNumberCountryCode::Mo,
            "MP" => PhoneNumberCountryCode::Mp,
            "MR" => PhoneNumberCountryCode::Mr,
            "MS" => PhoneNumberCountryCode::Ms,
            "MT" => PhoneNumberCountryCode::Mt,
            "MU" => PhoneNumberCountryCode::Mu,
            "MV" => PhoneNumberCountryCode::Mv,
            "MW" => PhoneNumberCountryCode::Mw,
            "MX" => PhoneNumberCountryCode::Mx,
            "MY" => PhoneNumberCountryCode::My,
            "MZ" => PhoneNumberCountryCode::Mz,
            "NA" => PhoneNumberCountryCode::Na,
            "NC" => PhoneNumberCountryCode::Nc,
            "NE" => PhoneNumberCountryCode::Ne,
            "NG" => PhoneNumberCountryCode::Ng,
            "NI" => PhoneNumberCountryCode::Ni,
            "NL" => PhoneNumberCountryCode::Nl,
            "NO" => PhoneNumberCountryCode::No,
            "NP" => PhoneNumberCountryCode::Np,
            "NR" => PhoneNumberCountryCode::Nr,
            "NU" => PhoneNumberCountryCode::Nu,
            "NZ" => PhoneNumberCountryCode::Nz,
            "OM" => PhoneNumberCountryCode::Om,
            "PA" => PhoneNumberCountryCode::Pa,
            "PE" => PhoneNumberCountryCode::Pe,
            "PF" => PhoneNumberCountryCode::Pf,
            "PG" => PhoneNumberCountryCode::Pg,
            "PH" => PhoneNumberCountryCode::Ph,
            "PK" => PhoneNumberCountryCode::Pk,
            "PL" => PhoneNumberCountryCode::Pl,
            "PM" => PhoneNumberCountryCode::Pm,
            "PN" => PhoneNumberCountryCode::Pn,
            "PR" => PhoneNumberCountryCode::Pr,
            "PT" => PhoneNumberCountryCode::Pt,
            "PW" => PhoneNumberCountryCode::Pw,
            "PY" => PhoneNumberCountryCode::Py,
            "QA" => PhoneNumberCountryCode::Qa,
            "RE" => PhoneNumberCountryCode::Re,
            "RO" => PhoneNumberCountryCode::Ro,
            "RS" => PhoneNumberCountryCode::Rs,
            "RU" => PhoneNumberCountryCode::Ru,
            "RW" => PhoneNumberCountryCode::Rw,
            "SA" => PhoneNumberCountryCode::Sa,
            "SB" => PhoneNumberCountryCode::Sb,
            "SC" => PhoneNumberCountryCode::Sc,
            "SD" => PhoneNumberCountryCode::Sd,
            "SE" => PhoneNumberCountryCode::Se,
            "SG" => PhoneNumberCountryCode::Sg,
            "SH" => PhoneNumberCountryCode::Sh,
            "SI" => PhoneNumberCountryCode::Si,
            "SJ" => PhoneNumberCountryCode::Sj,
            "SK" => PhoneNumberCountryCode::Sk,
            "SL" => PhoneNumberCountryCode::Sl,
            "SM" => PhoneNumberCountryCode::Sm,
            "SN" => PhoneNumberCountryCode::Sn,
            "SO" => PhoneNumberCountryCode::So,
            "SR" => PhoneNumberCountryCode::Sr,
            "ST" => PhoneNumberCountryCode::St,
            "SV" => PhoneNumberCountryCode::Sv,
            "SX" => PhoneNumberCountryCode::Sx,
            "SY" => PhoneNumberCountryCode::Sy,
            "SZ" => PhoneNumberCountryCode::Sz,
            "TC" => PhoneNumberCountryCode::Tc,
            "TD" => PhoneNumberCountryCode::Td,
            "TG" => PhoneNumberCountryCode::Tg,
            "TH" => PhoneNumberCountryCode::Th,
            "TJ" => PhoneNumberCountryCode::Tj,
            "TK" => PhoneNumberCountryCode::Tk,
            "TL" => PhoneNumberCountryCode::Tl,
            "TM" => PhoneNumberCountryCode::Tm,
            "TN" => PhoneNumberCountryCode::Tn,
            "TO" => PhoneNumberCountryCode::To,
            "TR" => PhoneNumberCountryCode::Tr,
            "TT" => PhoneNumberCountryCode::Tt,
            "TV" => PhoneNumberCountryCode::Tv,
            "TW" => PhoneNumberCountryCode::Tw,
            "TZ" => PhoneNumberCountryCode::Tz,
            "UA" => PhoneNumberCountryCode::Ua,
            "UG" => PhoneNumberCountryCode::Ug,
            "US" => PhoneNumberCountryCode::Us,
            "UY" => PhoneNumberCountryCode::Uy,
            "UZ" => PhoneNumberCountryCode::Uz,
            "VA" => PhoneNumberCountryCode::Va,
            "VC" => PhoneNumberCountryCode::Vc,
            "VE" => PhoneNumberCountryCode::Ve,
            "VG" => PhoneNumberCountryCode::Vg,
            "VI" => PhoneNumberCountryCode::Vi,
            "VN" => PhoneNumberCountryCode::Vn,
            "VU" => PhoneNumberCountryCode::Vu,
            "WF" => PhoneNumberCountryCode::Wf,
            "WS" => PhoneNumberCountryCode::Ws,
            "YE" => PhoneNumberCountryCode::Ye,
            "YT" => PhoneNumberCountryCode::Yt,
            "ZA" => PhoneNumberCountryCode::Za,
            "ZM" => PhoneNumberCountryCode::Zm,
            "ZW" => PhoneNumberCountryCode::Zw,
            other => PhoneNumberCountryCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PhoneNumberCountryCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneNumberCountryCode::from(s))
    }
}
impl PhoneNumberCountryCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneNumberCountryCode::Ad => "AD",
            PhoneNumberCountryCode::Ae => "AE",
            PhoneNumberCountryCode::Af => "AF",
            PhoneNumberCountryCode::Ag => "AG",
            PhoneNumberCountryCode::Ai => "AI",
            PhoneNumberCountryCode::Al => "AL",
            PhoneNumberCountryCode::Am => "AM",
            PhoneNumberCountryCode::An => "AN",
            PhoneNumberCountryCode::Ao => "AO",
            PhoneNumberCountryCode::Aq => "AQ",
            PhoneNumberCountryCode::Ar => "AR",
            PhoneNumberCountryCode::As => "AS",
            PhoneNumberCountryCode::At => "AT",
            PhoneNumberCountryCode::Au => "AU",
            PhoneNumberCountryCode::Aw => "AW",
            PhoneNumberCountryCode::Az => "AZ",
            PhoneNumberCountryCode::Ba => "BA",
            PhoneNumberCountryCode::Bb => "BB",
            PhoneNumberCountryCode::Bd => "BD",
            PhoneNumberCountryCode::Be => "BE",
            PhoneNumberCountryCode::Bf => "BF",
            PhoneNumberCountryCode::Bg => "BG",
            PhoneNumberCountryCode::Bh => "BH",
            PhoneNumberCountryCode::Bi => "BI",
            PhoneNumberCountryCode::Bj => "BJ",
            PhoneNumberCountryCode::Bl => "BL",
            PhoneNumberCountryCode::Bm => "BM",
            PhoneNumberCountryCode::Bn => "BN",
            PhoneNumberCountryCode::Bo => "BO",
            PhoneNumberCountryCode::Br => "BR",
            PhoneNumberCountryCode::Bs => "BS",
            PhoneNumberCountryCode::Bt => "BT",
            PhoneNumberCountryCode::Bw => "BW",
            PhoneNumberCountryCode::By => "BY",
            PhoneNumberCountryCode::Bz => "BZ",
            PhoneNumberCountryCode::Ca => "CA",
            PhoneNumberCountryCode::Cc => "CC",
            PhoneNumberCountryCode::Cd => "CD",
            PhoneNumberCountryCode::Cf => "CF",
            PhoneNumberCountryCode::Cg => "CG",
            PhoneNumberCountryCode::Ch => "CH",
            PhoneNumberCountryCode::Ci => "CI",
            PhoneNumberCountryCode::Ck => "CK",
            PhoneNumberCountryCode::Cl => "CL",
            PhoneNumberCountryCode::Cm => "CM",
            PhoneNumberCountryCode::Cn => "CN",
            PhoneNumberCountryCode::Co => "CO",
            PhoneNumberCountryCode::Cr => "CR",
            PhoneNumberCountryCode::Cu => "CU",
            PhoneNumberCountryCode::Cv => "CV",
            PhoneNumberCountryCode::Cw => "CW",
            PhoneNumberCountryCode::Cx => "CX",
            PhoneNumberCountryCode::Cy => "CY",
            PhoneNumberCountryCode::Cz => "CZ",
            PhoneNumberCountryCode::De => "DE",
            PhoneNumberCountryCode::Dj => "DJ",
            PhoneNumberCountryCode::Dk => "DK",
            PhoneNumberCountryCode::Dm => "DM",
            PhoneNumberCountryCode::Do => "DO",
            PhoneNumberCountryCode::Dz => "DZ",
            PhoneNumberCountryCode::Ec => "EC",
            PhoneNumberCountryCode::Ee => "EE",
            PhoneNumberCountryCode::Eg => "EG",
            PhoneNumberCountryCode::Eh => "EH",
            PhoneNumberCountryCode::Er => "ER",
            PhoneNumberCountryCode::Es => "ES",
            PhoneNumberCountryCode::Et => "ET",
            PhoneNumberCountryCode::Fi => "FI",
            PhoneNumberCountryCode::Fj => "FJ",
            PhoneNumberCountryCode::Fk => "FK",
            PhoneNumberCountryCode::Fm => "FM",
            PhoneNumberCountryCode::Fo => "FO",
            PhoneNumberCountryCode::Fr => "FR",
            PhoneNumberCountryCode::Ga => "GA",
            PhoneNumberCountryCode::Gb => "GB",
            PhoneNumberCountryCode::Gd => "GD",
            PhoneNumberCountryCode::Ge => "GE",
            PhoneNumberCountryCode::Gg => "GG",
            PhoneNumberCountryCode::Gh => "GH",
            PhoneNumberCountryCode::Gi => "GI",
            PhoneNumberCountryCode::Gl => "GL",
            PhoneNumberCountryCode::Gm => "GM",
            PhoneNumberCountryCode::Gn => "GN",
            PhoneNumberCountryCode::Gq => "GQ",
            PhoneNumberCountryCode::Gr => "GR",
            PhoneNumberCountryCode::Gt => "GT",
            PhoneNumberCountryCode::Gu => "GU",
            PhoneNumberCountryCode::Gw => "GW",
            PhoneNumberCountryCode::Gy => "GY",
            PhoneNumberCountryCode::Hk => "HK",
            PhoneNumberCountryCode::Hn => "HN",
            PhoneNumberCountryCode::Hr => "HR",
            PhoneNumberCountryCode::Ht => "HT",
            PhoneNumberCountryCode::Hu => "HU",
            PhoneNumberCountryCode::Id => "ID",
            PhoneNumberCountryCode::Ie => "IE",
            PhoneNumberCountryCode::Il => "IL",
            PhoneNumberCountryCode::Im => "IM",
            PhoneNumberCountryCode::In => "IN",
            PhoneNumberCountryCode::Io => "IO",
            PhoneNumberCountryCode::Iq => "IQ",
            PhoneNumberCountryCode::Ir => "IR",
            PhoneNumberCountryCode::Is => "IS",
            PhoneNumberCountryCode::It => "IT",
            PhoneNumberCountryCode::Je => "JE",
            PhoneNumberCountryCode::Jm => "JM",
            PhoneNumberCountryCode::Jo => "JO",
            PhoneNumberCountryCode::Jp => "JP",
            PhoneNumberCountryCode::Ke => "KE",
            PhoneNumberCountryCode::Kg => "KG",
            PhoneNumberCountryCode::Kh => "KH",
            PhoneNumberCountryCode::Ki => "KI",
            PhoneNumberCountryCode::Km => "KM",
            PhoneNumberCountryCode::Kn => "KN",
            PhoneNumberCountryCode::Kp => "KP",
            PhoneNumberCountryCode::Kr => "KR",
            PhoneNumberCountryCode::Kw => "KW",
            PhoneNumberCountryCode::Ky => "KY",
            PhoneNumberCountryCode::Kz => "KZ",
            PhoneNumberCountryCode::La => "LA",
            PhoneNumberCountryCode::Lb => "LB",
            PhoneNumberCountryCode::Lc => "LC",
            PhoneNumberCountryCode::Li => "LI",
            PhoneNumberCountryCode::Lk => "LK",
            PhoneNumberCountryCode::Lr => "LR",
            PhoneNumberCountryCode::Ls => "LS",
            PhoneNumberCountryCode::Lt => "LT",
            PhoneNumberCountryCode::Lu => "LU",
            PhoneNumberCountryCode::Lv => "LV",
            PhoneNumberCountryCode::Ly => "LY",
            PhoneNumberCountryCode::Ma => "MA",
            PhoneNumberCountryCode::Mc => "MC",
            PhoneNumberCountryCode::Md => "MD",
            PhoneNumberCountryCode::Me => "ME",
            PhoneNumberCountryCode::Mf => "MF",
            PhoneNumberCountryCode::Mg => "MG",
            PhoneNumberCountryCode::Mh => "MH",
            PhoneNumberCountryCode::Mk => "MK",
            PhoneNumberCountryCode::Ml => "ML",
            PhoneNumberCountryCode::Mm => "MM",
            PhoneNumberCountryCode::Mn => "MN",
            PhoneNumberCountryCode::Mo => "MO",
            PhoneNumberCountryCode::Mp => "MP",
            PhoneNumberCountryCode::Mr => "MR",
            PhoneNumberCountryCode::Ms => "MS",
            PhoneNumberCountryCode::Mt => "MT",
            PhoneNumberCountryCode::Mu => "MU",
            PhoneNumberCountryCode::Mv => "MV",
            PhoneNumberCountryCode::Mw => "MW",
            PhoneNumberCountryCode::Mx => "MX",
            PhoneNumberCountryCode::My => "MY",
            PhoneNumberCountryCode::Mz => "MZ",
            PhoneNumberCountryCode::Na => "NA",
            PhoneNumberCountryCode::Nc => "NC",
            PhoneNumberCountryCode::Ne => "NE",
            PhoneNumberCountryCode::Ng => "NG",
            PhoneNumberCountryCode::Ni => "NI",
            PhoneNumberCountryCode::Nl => "NL",
            PhoneNumberCountryCode::No => "NO",
            PhoneNumberCountryCode::Np => "NP",
            PhoneNumberCountryCode::Nr => "NR",
            PhoneNumberCountryCode::Nu => "NU",
            PhoneNumberCountryCode::Nz => "NZ",
            PhoneNumberCountryCode::Om => "OM",
            PhoneNumberCountryCode::Pa => "PA",
            PhoneNumberCountryCode::Pe => "PE",
            PhoneNumberCountryCode::Pf => "PF",
            PhoneNumberCountryCode::Pg => "PG",
            PhoneNumberCountryCode::Ph => "PH",
            PhoneNumberCountryCode::Pk => "PK",
            PhoneNumberCountryCode::Pl => "PL",
            PhoneNumberCountryCode::Pm => "PM",
            PhoneNumberCountryCode::Pn => "PN",
            PhoneNumberCountryCode::Pr => "PR",
            PhoneNumberCountryCode::Pt => "PT",
            PhoneNumberCountryCode::Pw => "PW",
            PhoneNumberCountryCode::Py => "PY",
            PhoneNumberCountryCode::Qa => "QA",
            PhoneNumberCountryCode::Re => "RE",
            PhoneNumberCountryCode::Ro => "RO",
            PhoneNumberCountryCode::Rs => "RS",
            PhoneNumberCountryCode::Ru => "RU",
            PhoneNumberCountryCode::Rw => "RW",
            PhoneNumberCountryCode::Sa => "SA",
            PhoneNumberCountryCode::Sb => "SB",
            PhoneNumberCountryCode::Sc => "SC",
            PhoneNumberCountryCode::Sd => "SD",
            PhoneNumberCountryCode::Se => "SE",
            PhoneNumberCountryCode::Sg => "SG",
            PhoneNumberCountryCode::Sh => "SH",
            PhoneNumberCountryCode::Si => "SI",
            PhoneNumberCountryCode::Sj => "SJ",
            PhoneNumberCountryCode::Sk => "SK",
            PhoneNumberCountryCode::Sl => "SL",
            PhoneNumberCountryCode::Sm => "SM",
            PhoneNumberCountryCode::Sn => "SN",
            PhoneNumberCountryCode::So => "SO",
            PhoneNumberCountryCode::Sr => "SR",
            PhoneNumberCountryCode::St => "ST",
            PhoneNumberCountryCode::Sv => "SV",
            PhoneNumberCountryCode::Sx => "SX",
            PhoneNumberCountryCode::Sy => "SY",
            PhoneNumberCountryCode::Sz => "SZ",
            PhoneNumberCountryCode::Tc => "TC",
            PhoneNumberCountryCode::Td => "TD",
            PhoneNumberCountryCode::Tg => "TG",
            PhoneNumberCountryCode::Th => "TH",
            PhoneNumberCountryCode::Tj => "TJ",
            PhoneNumberCountryCode::Tk => "TK",
            PhoneNumberCountryCode::Tl => "TL",
            PhoneNumberCountryCode::Tm => "TM",
            PhoneNumberCountryCode::Tn => "TN",
            PhoneNumberCountryCode::To => "TO",
            PhoneNumberCountryCode::Tr => "TR",
            PhoneNumberCountryCode::Tt => "TT",
            PhoneNumberCountryCode::Tv => "TV",
            PhoneNumberCountryCode::Tw => "TW",
            PhoneNumberCountryCode::Tz => "TZ",
            PhoneNumberCountryCode::Ua => "UA",
            PhoneNumberCountryCode::Ug => "UG",
            PhoneNumberCountryCode::Us => "US",
            PhoneNumberCountryCode::Uy => "UY",
            PhoneNumberCountryCode::Uz => "UZ",
            PhoneNumberCountryCode::Va => "VA",
            PhoneNumberCountryCode::Vc => "VC",
            PhoneNumberCountryCode::Ve => "VE",
            PhoneNumberCountryCode::Vg => "VG",
            PhoneNumberCountryCode::Vi => "VI",
            PhoneNumberCountryCode::Vn => "VN",
            PhoneNumberCountryCode::Vu => "VU",
            PhoneNumberCountryCode::Wf => "WF",
            PhoneNumberCountryCode::Ws => "WS",
            PhoneNumberCountryCode::Ye => "YE",
            PhoneNumberCountryCode::Yt => "YT",
            PhoneNumberCountryCode::Za => "ZA",
            PhoneNumberCountryCode::Zm => "ZM",
            PhoneNumberCountryCode::Zw => "ZW",
            PhoneNumberCountryCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN", "AO", "AQ", "AR", "AS", "AT", "AU",
            "AW", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN",
            "BO", "BR", "BS", "BT", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI",
            "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ",
            "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK",
            "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GG", "GH", "GI", "GL", "GM", "GN", "GQ",
            "GR", "GT", "GU", "GW", "GY", "HK", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM",
            "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI",
            "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS",
            "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM",
            "MN", "MO", "MP", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC",
            "NE", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG",
            "PH", "PK", "PL", "PM", "PN", "PR", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU",
            "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN",
            "SO", "SR", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TG", "TH", "TJ", "TK", "TL",
            "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "US", "UY", "UZ", "VA",
            "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW",
        ]
    }
}
impl AsRef<str> for PhoneNumberCountryCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains summary information about a user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserSummary {
    /// <p>The identifier of the user account.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the user account.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Connect user name of the user account.</p>
    pub username: std::option::Option<std::string::String>,
}
impl UserSummary {
    /// <p>The identifier of the user account.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the user account.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The Amazon Connect user name of the user account.</p>
    pub fn username(&self) -> std::option::Option<&str> {
        self.username.as_deref()
    }
}
impl std::fmt::Debug for UserSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("username", &self.username);
        formatter.finish()
    }
}
/// See [`UserSummary`](crate::model::UserSummary)
pub mod user_summary {

    /// A builder for [`UserSummary`](crate::model::UserSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) username: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the user account.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user account.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user account.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The Amazon Connect user name of the user account.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        /// <p>The Amazon Connect user name of the user account.</p>
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input;
            self
        }
        /// Consumes the builder and constructs a [`UserSummary`](crate::model::UserSummary)
        pub fn build(self) -> crate::model::UserSummary {
            crate::model::UserSummary {
                id: self.id,
                arn: self.arn,
                username: self.username,
            }
        }
    }
}
impl UserSummary {
    /// Creates a new builder-style object to manufacture [`UserSummary`](crate::model::UserSummary)
    pub fn builder() -> crate::model::user_summary::Builder {
        crate::model::user_summary::Builder::default()
    }
}

/// <p>Contains summary information about a hierarchy group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HierarchyGroupSummary {
    /// <p>The identifier of the hierarchy group.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the hierarchy group.</p>
    pub name: std::option::Option<std::string::String>,
}
impl HierarchyGroupSummary {
    /// <p>The identifier of the hierarchy group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the hierarchy group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for HierarchyGroupSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HierarchyGroupSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`HierarchyGroupSummary`](crate::model::HierarchyGroupSummary)
pub mod hierarchy_group_summary {

    /// A builder for [`HierarchyGroupSummary`](crate::model::HierarchyGroupSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the hierarchy group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the hierarchy group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the hierarchy group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hierarchy group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyGroupSummary`](crate::model::HierarchyGroupSummary)
        pub fn build(self) -> crate::model::HierarchyGroupSummary {
            crate::model::HierarchyGroupSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl HierarchyGroupSummary {
    /// Creates a new builder-style object to manufacture [`HierarchyGroupSummary`](crate::model::HierarchyGroupSummary)
    pub fn builder() -> crate::model::hierarchy_group_summary::Builder {
        crate::model::hierarchy_group_summary::Builder::default()
    }
}

/// <p>Contains the use case.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UseCase {
    /// <p>The identifier for the use case.</p>
    pub use_case_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the use case.</p>
    pub use_case_arn: std::option::Option<std::string::String>,
    /// <p>The type of use case to associate to the integration association. Each integration association can have only one of each use case type.</p>
    pub use_case_type: std::option::Option<crate::model::UseCaseType>,
}
impl UseCase {
    /// <p>The identifier for the use case.</p>
    pub fn use_case_id(&self) -> std::option::Option<&str> {
        self.use_case_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the use case.</p>
    pub fn use_case_arn(&self) -> std::option::Option<&str> {
        self.use_case_arn.as_deref()
    }
    /// <p>The type of use case to associate to the integration association. Each integration association can have only one of each use case type.</p>
    pub fn use_case_type(&self) -> std::option::Option<&crate::model::UseCaseType> {
        self.use_case_type.as_ref()
    }
}
impl std::fmt::Debug for UseCase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UseCase");
        formatter.field("use_case_id", &self.use_case_id);
        formatter.field("use_case_arn", &self.use_case_arn);
        formatter.field("use_case_type", &self.use_case_type);
        formatter.finish()
    }
}
/// See [`UseCase`](crate::model::UseCase)
pub mod use_case {

    /// A builder for [`UseCase`](crate::model::UseCase)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) use_case_id: std::option::Option<std::string::String>,
        pub(crate) use_case_arn: std::option::Option<std::string::String>,
        pub(crate) use_case_type: std::option::Option<crate::model::UseCaseType>,
    }
    impl Builder {
        /// <p>The identifier for the use case.</p>
        pub fn use_case_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.use_case_id = Some(input.into());
            self
        }
        /// <p>The identifier for the use case.</p>
        pub fn set_use_case_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.use_case_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the use case.</p>
        pub fn use_case_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.use_case_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the use case.</p>
        pub fn set_use_case_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.use_case_arn = input;
            self
        }
        /// <p>The type of use case to associate to the integration association. Each integration association can have only one of each use case type.</p>
        pub fn use_case_type(mut self, input: crate::model::UseCaseType) -> Self {
            self.use_case_type = Some(input);
            self
        }
        /// <p>The type of use case to associate to the integration association. Each integration association can have only one of each use case type.</p>
        pub fn set_use_case_type(
            mut self,
            input: std::option::Option<crate::model::UseCaseType>,
        ) -> Self {
            self.use_case_type = input;
            self
        }
        /// Consumes the builder and constructs a [`UseCase`](crate::model::UseCase)
        pub fn build(self) -> crate::model::UseCase {
            crate::model::UseCase {
                use_case_id: self.use_case_id,
                use_case_arn: self.use_case_arn,
                use_case_type: self.use_case_type,
            }
        }
    }
}
impl UseCase {
    /// Creates a new builder-style object to manufacture [`UseCase`](crate::model::UseCase)
    pub fn builder() -> crate::model::use_case::Builder {
        crate::model::use_case::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UseCaseType {
    #[allow(missing_docs)] // documentation missing in model
    ConnectCampaigns,
    #[allow(missing_docs)] // documentation missing in model
    RulesEvaluation,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UseCaseType {
    fn from(s: &str) -> Self {
        match s {
            "CONNECT_CAMPAIGNS" => UseCaseType::ConnectCampaigns,
            "RULES_EVALUATION" => UseCaseType::RulesEvaluation,
            other => UseCaseType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UseCaseType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UseCaseType::from(s))
    }
}
impl UseCaseType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UseCaseType::ConnectCampaigns => "CONNECT_CAMPAIGNS",
            UseCaseType::RulesEvaluation => "RULES_EVALUATION",
            UseCaseType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CONNECT_CAMPAIGNS", "RULES_EVALUATION"]
    }
}
impl AsRef<str> for UseCaseType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains summary information about the task template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TaskTemplateMetadata {
    /// <p>A unique identifier for the task template.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the task template.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the task template.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the task template.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
    pub status: std::option::Option<crate::model::TaskTemplateStatus>,
    /// <p>The timestamp when the task template was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp when the task template was created.</p>
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl TaskTemplateMetadata {
    /// <p>A unique identifier for the task template.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the task template.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the task template.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the task template.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TaskTemplateStatus> {
        self.status.as_ref()
    }
    /// <p>The timestamp when the task template was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The timestamp when the task template was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
}
impl std::fmt::Debug for TaskTemplateMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TaskTemplateMetadata");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("status", &self.status);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("created_time", &self.created_time);
        formatter.finish()
    }
}
/// See [`TaskTemplateMetadata`](crate::model::TaskTemplateMetadata)
pub mod task_template_metadata {

    /// A builder for [`TaskTemplateMetadata`](crate::model::TaskTemplateMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TaskTemplateStatus>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>A unique identifier for the task template.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the task template.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the task template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the task template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the task template.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the task template.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the task template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the task template.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
        pub fn status(mut self, input: crate::model::TaskTemplateStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The timestamp when the task template was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp when the task template was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The timestamp when the task template was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The timestamp when the task template was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskTemplateMetadata`](crate::model::TaskTemplateMetadata)
        pub fn build(self) -> crate::model::TaskTemplateMetadata {
            crate::model::TaskTemplateMetadata {
                id: self.id,
                arn: self.arn,
                name: self.name,
                description: self.description,
                status: self.status,
                last_modified_time: self.last_modified_time,
                created_time: self.created_time,
            }
        }
    }
}
impl TaskTemplateMetadata {
    /// Creates a new builder-style object to manufacture [`TaskTemplateMetadata`](crate::model::TaskTemplateMetadata)
    pub fn builder() -> crate::model::task_template_metadata::Builder {
        crate::model::task_template_metadata::Builder::default()
    }
}

/// <p>Contains information about a security profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecurityProfileSummary {
    /// <p>The identifier of the security profile.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the security profile.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the security profile.</p>
    pub name: std::option::Option<std::string::String>,
}
impl SecurityProfileSummary {
    /// <p>The identifier of the security profile.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the security profile.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the security profile.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for SecurityProfileSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecurityProfileSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`SecurityProfileSummary`](crate::model::SecurityProfileSummary)
pub mod security_profile_summary {

    /// A builder for [`SecurityProfileSummary`](crate::model::SecurityProfileSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the security profile.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the security profile.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the security profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the security profile.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the security profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the security profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityProfileSummary`](crate::model::SecurityProfileSummary)
        pub fn build(self) -> crate::model::SecurityProfileSummary {
            crate::model::SecurityProfileSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl SecurityProfileSummary {
    /// Creates a new builder-style object to manufacture [`SecurityProfileSummary`](crate::model::SecurityProfileSummary)
    pub fn builder() -> crate::model::security_profile_summary::Builder {
        crate::model::security_profile_summary::Builder::default()
    }
}

/// <p>Configuration information of the security key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecurityKey {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The key of the security key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>When the security key was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl SecurityKey {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    pub fn association_id(&self) -> std::option::Option<&str> {
        self.association_id.as_deref()
    }
    /// <p>The key of the security key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>When the security key was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
impl std::fmt::Debug for SecurityKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecurityKey");
        formatter.field("association_id", &self.association_id);
        formatter.field("key", &self.key);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}
/// See [`SecurityKey`](crate::model::SecurityKey)
pub mod security_key {

    /// A builder for [`SecurityKey`](crate::model::SecurityKey)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The key of the security key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key of the security key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>When the security key was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the security key was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityKey`](crate::model::SecurityKey)
        pub fn build(self) -> crate::model::SecurityKey {
            crate::model::SecurityKey {
                association_id: self.association_id,
                key: self.key,
                creation_time: self.creation_time,
            }
        }
    }
}
impl SecurityKey {
    /// Creates a new builder-style object to manufacture [`SecurityKey`](crate::model::SecurityKey)
    pub fn builder() -> crate::model::security_key::Builder {
        crate::model::security_key::Builder::default()
    }
}

/// <p>Contains summary information about a routing profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RoutingProfileSummary {
    /// <p>The identifier of the routing profile.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the routing profile.</p>
    pub name: std::option::Option<std::string::String>,
}
impl RoutingProfileSummary {
    /// <p>The identifier of the routing profile.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the routing profile.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for RoutingProfileSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RoutingProfileSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`RoutingProfileSummary`](crate::model::RoutingProfileSummary)
pub mod routing_profile_summary {

    /// A builder for [`RoutingProfileSummary`](crate::model::RoutingProfileSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the routing profile.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the routing profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the routing profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfileSummary`](crate::model::RoutingProfileSummary)
        pub fn build(self) -> crate::model::RoutingProfileSummary {
            crate::model::RoutingProfileSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl RoutingProfileSummary {
    /// Creates a new builder-style object to manufacture [`RoutingProfileSummary`](crate::model::RoutingProfileSummary)
    pub fn builder() -> crate::model::routing_profile_summary::Builder {
        crate::model::routing_profile_summary::Builder::default()
    }
}

/// <p>Contains summary information about a routing profile queue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RoutingProfileQueueConfigSummary {
    /// <p>The identifier for the queue.</p>
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    pub queue_arn: std::option::Option<std::string::String>,
    /// <p>The name of the queue.</p>
    pub queue_name: std::option::Option<std::string::String>,
    /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
    pub priority: i32,
    /// <p>The delay, in seconds, that a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub delay: i32,
    /// <p>The channels this queue supports.</p>
    pub channel: std::option::Option<crate::model::Channel>,
}
impl RoutingProfileQueueConfigSummary {
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    pub fn queue_arn(&self) -> std::option::Option<&str> {
        self.queue_arn.as_deref()
    }
    /// <p>The name of the queue.</p>
    pub fn queue_name(&self) -> std::option::Option<&str> {
        self.queue_name.as_deref()
    }
    /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>The delay, in seconds, that a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub fn delay(&self) -> i32 {
        self.delay
    }
    /// <p>The channels this queue supports.</p>
    pub fn channel(&self) -> std::option::Option<&crate::model::Channel> {
        self.channel.as_ref()
    }
}
impl std::fmt::Debug for RoutingProfileQueueConfigSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RoutingProfileQueueConfigSummary");
        formatter.field("queue_id", &self.queue_id);
        formatter.field("queue_arn", &self.queue_arn);
        formatter.field("queue_name", &self.queue_name);
        formatter.field("priority", &self.priority);
        formatter.field("delay", &self.delay);
        formatter.field("channel", &self.channel);
        formatter.finish()
    }
}
/// See [`RoutingProfileQueueConfigSummary`](crate::model::RoutingProfileQueueConfigSummary)
pub mod routing_profile_queue_config_summary {

    /// A builder for [`RoutingProfileQueueConfigSummary`](crate::model::RoutingProfileQueueConfigSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) queue_arn: std::option::Option<std::string::String>,
        pub(crate) queue_name: std::option::Option<std::string::String>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) delay: std::option::Option<i32>,
        pub(crate) channel: std::option::Option<crate::model::Channel>,
    }
    impl Builder {
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the queue.</p>
        pub fn queue_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the queue.</p>
        pub fn set_queue_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_arn = input;
            self
        }
        /// <p>The name of the queue.</p>
        pub fn queue_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_name = Some(input.into());
            self
        }
        /// <p>The name of the queue.</p>
        pub fn set_queue_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_name = input;
            self
        }
        /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>The order in which contacts are to be handled for the queue. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a>.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The delay, in seconds, that a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn delay(mut self, input: i32) -> Self {
            self.delay = Some(input);
            self
        }
        /// <p>The delay, in seconds, that a contact should be in the queue before they are routed to an available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn set_delay(mut self, input: std::option::Option<i32>) -> Self {
            self.delay = input;
            self
        }
        /// <p>The channels this queue supports.</p>
        pub fn channel(mut self, input: crate::model::Channel) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>The channels this queue supports.</p>
        pub fn set_channel(mut self, input: std::option::Option<crate::model::Channel>) -> Self {
            self.channel = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfileQueueConfigSummary`](crate::model::RoutingProfileQueueConfigSummary)
        pub fn build(self) -> crate::model::RoutingProfileQueueConfigSummary {
            crate::model::RoutingProfileQueueConfigSummary {
                queue_id: self.queue_id,
                queue_arn: self.queue_arn,
                queue_name: self.queue_name,
                priority: self.priority.unwrap_or_default(),
                delay: self.delay.unwrap_or_default(),
                channel: self.channel,
            }
        }
    }
}
impl RoutingProfileQueueConfigSummary {
    /// Creates a new builder-style object to manufacture [`RoutingProfileQueueConfigSummary`](crate::model::RoutingProfileQueueConfigSummary)
    pub fn builder() -> crate::model::routing_profile_queue_config_summary::Builder {
        crate::model::routing_profile_queue_config_summary::Builder::default()
    }
}

/// <p>Contains summary information about a quick connect.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QuickConnectSummary {
    /// <p>The identifier for the quick connect.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the quick connect.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
    pub quick_connect_type: std::option::Option<crate::model::QuickConnectType>,
}
impl QuickConnectSummary {
    /// <p>The identifier for the quick connect.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the quick connect.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
    pub fn quick_connect_type(&self) -> std::option::Option<&crate::model::QuickConnectType> {
        self.quick_connect_type.as_ref()
    }
}
impl std::fmt::Debug for QuickConnectSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QuickConnectSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("quick_connect_type", &self.quick_connect_type);
        formatter.finish()
    }
}
/// See [`QuickConnectSummary`](crate::model::QuickConnectSummary)
pub mod quick_connect_summary {

    /// A builder for [`QuickConnectSummary`](crate::model::QuickConnectSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) quick_connect_type: std::option::Option<crate::model::QuickConnectType>,
    }
    impl Builder {
        /// <p>The identifier for the quick connect.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the quick connect.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the quick connect.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
        pub fn quick_connect_type(mut self, input: crate::model::QuickConnectType) -> Self {
            self.quick_connect_type = Some(input);
            self
        }
        /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
        pub fn set_quick_connect_type(
            mut self,
            input: std::option::Option<crate::model::QuickConnectType>,
        ) -> Self {
            self.quick_connect_type = input;
            self
        }
        /// Consumes the builder and constructs a [`QuickConnectSummary`](crate::model::QuickConnectSummary)
        pub fn build(self) -> crate::model::QuickConnectSummary {
            crate::model::QuickConnectSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                quick_connect_type: self.quick_connect_type,
            }
        }
    }
}
impl QuickConnectSummary {
    /// Creates a new builder-style object to manufacture [`QuickConnectSummary`](crate::model::QuickConnectSummary)
    pub fn builder() -> crate::model::quick_connect_summary::Builder {
        crate::model::quick_connect_summary::Builder::default()
    }
}

/// <p>Contains summary information about a queue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueueSummary {
    /// <p>The identifier of the queue.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the queue.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of queue.</p>
    pub queue_type: std::option::Option<crate::model::QueueType>,
}
impl QueueSummary {
    /// <p>The identifier of the queue.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the queue.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of queue.</p>
    pub fn queue_type(&self) -> std::option::Option<&crate::model::QueueType> {
        self.queue_type.as_ref()
    }
}
impl std::fmt::Debug for QueueSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueueSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("queue_type", &self.queue_type);
        formatter.finish()
    }
}
/// See [`QueueSummary`](crate::model::QueueSummary)
pub mod queue_summary {

    /// A builder for [`QueueSummary`](crate::model::QueueSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) queue_type: std::option::Option<crate::model::QueueType>,
    }
    impl Builder {
        /// <p>The identifier of the queue.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the queue.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the queue.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the queue.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the queue.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the queue.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of queue.</p>
        pub fn queue_type(mut self, input: crate::model::QueueType) -> Self {
            self.queue_type = Some(input);
            self
        }
        /// <p>The type of queue.</p>
        pub fn set_queue_type(
            mut self,
            input: std::option::Option<crate::model::QueueType>,
        ) -> Self {
            self.queue_type = input;
            self
        }
        /// Consumes the builder and constructs a [`QueueSummary`](crate::model::QueueSummary)
        pub fn build(self) -> crate::model::QueueSummary {
            crate::model::QueueSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                queue_type: self.queue_type,
            }
        }
    }
}
impl QueueSummary {
    /// Creates a new builder-style object to manufacture [`QueueSummary`](crate::model::QueueSummary)
    pub fn builder() -> crate::model::queue_summary::Builder {
        crate::model::queue_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueueType {
    #[allow(missing_docs)] // documentation missing in model
    Agent,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for QueueType {
    fn from(s: &str) -> Self {
        match s {
            "AGENT" => QueueType::Agent,
            "STANDARD" => QueueType::Standard,
            other => QueueType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for QueueType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueueType::from(s))
    }
}
impl QueueType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueueType::Agent => "AGENT",
            QueueType::Standard => "STANDARD",
            QueueType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["AGENT", "STANDARD"]
    }
}
impl AsRef<str> for QueueType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the prompt.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PromptSummary {
    /// <p>The identifier of the prompt.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the prompt.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the prompt.</p>
    pub name: std::option::Option<std::string::String>,
}
impl PromptSummary {
    /// <p>The identifier of the prompt.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the prompt.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the prompt.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for PromptSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PromptSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`PromptSummary`](crate::model::PromptSummary)
pub mod prompt_summary {

    /// A builder for [`PromptSummary`](crate::model::PromptSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the prompt.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the prompt.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the prompt.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the prompt.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the prompt.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the prompt.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`PromptSummary`](crate::model::PromptSummary)
        pub fn build(self) -> crate::model::PromptSummary {
            crate::model::PromptSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl PromptSummary {
    /// Creates a new builder-style object to manufacture [`PromptSummary`](crate::model::PromptSummary)
    pub fn builder() -> crate::model::prompt_summary::Builder {
        crate::model::prompt_summary::Builder::default()
    }
}

/// <p>Information about phone numbers that have been claimed to your Amazon Connect instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPhoneNumbersSummary {
    /// <p>A unique identifier for the phone number.</p>
    pub phone_number_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
    pub phone_number_arn: std::option::Option<std::string::String>,
    /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    pub phone_number: std::option::Option<std::string::String>,
    /// <p>The ISO country code.</p>
    pub phone_number_country_code: std::option::Option<crate::model::PhoneNumberCountryCode>,
    /// <p>The type of phone number.</p>
    pub phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances that phone numbers are claimed to.</p>
    pub target_arn: std::option::Option<std::string::String>,
}
impl ListPhoneNumbersSummary {
    /// <p>A unique identifier for the phone number.</p>
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
    pub fn phone_number_arn(&self) -> std::option::Option<&str> {
        self.phone_number_arn.as_deref()
    }
    /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
    /// <p>The ISO country code.</p>
    pub fn phone_number_country_code(
        &self,
    ) -> std::option::Option<&crate::model::PhoneNumberCountryCode> {
        self.phone_number_country_code.as_ref()
    }
    /// <p>The type of phone number.</p>
    pub fn phone_number_type(&self) -> std::option::Option<&crate::model::PhoneNumberType> {
        self.phone_number_type.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances that phone numbers are claimed to.</p>
    pub fn target_arn(&self) -> std::option::Option<&str> {
        self.target_arn.as_deref()
    }
}
impl std::fmt::Debug for ListPhoneNumbersSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPhoneNumbersSummary");
        formatter.field("phone_number_id", &self.phone_number_id);
        formatter.field("phone_number_arn", &self.phone_number_arn);
        formatter.field("phone_number", &self.phone_number);
        formatter.field("phone_number_country_code", &self.phone_number_country_code);
        formatter.field("phone_number_type", &self.phone_number_type);
        formatter.field("target_arn", &self.target_arn);
        formatter.finish()
    }
}
/// See [`ListPhoneNumbersSummary`](crate::model::ListPhoneNumbersSummary)
pub mod list_phone_numbers_summary {

    /// A builder for [`ListPhoneNumbersSummary`](crate::model::ListPhoneNumbersSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
        pub(crate) phone_number_arn: std::option::Option<std::string::String>,
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) phone_number_country_code:
            std::option::Option<crate::model::PhoneNumberCountryCode>,
        pub(crate) phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
        pub(crate) target_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for the phone number.</p>
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the phone number.</p>
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
        pub fn phone_number_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
        pub fn set_phone_number_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_arn = input;
            self
        }
        /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// <p>The ISO country code.</p>
        pub fn phone_number_country_code(
            mut self,
            input: crate::model::PhoneNumberCountryCode,
        ) -> Self {
            self.phone_number_country_code = Some(input);
            self
        }
        /// <p>The ISO country code.</p>
        pub fn set_phone_number_country_code(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberCountryCode>,
        ) -> Self {
            self.phone_number_country_code = input;
            self
        }
        /// <p>The type of phone number.</p>
        pub fn phone_number_type(mut self, input: crate::model::PhoneNumberType) -> Self {
            self.phone_number_type = Some(input);
            self
        }
        /// <p>The type of phone number.</p>
        pub fn set_phone_number_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberType>,
        ) -> Self {
            self.phone_number_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances that phone numbers are claimed to.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances that phone numbers are claimed to.</p>
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPhoneNumbersSummary`](crate::model::ListPhoneNumbersSummary)
        pub fn build(self) -> crate::model::ListPhoneNumbersSummary {
            crate::model::ListPhoneNumbersSummary {
                phone_number_id: self.phone_number_id,
                phone_number_arn: self.phone_number_arn,
                phone_number: self.phone_number,
                phone_number_country_code: self.phone_number_country_code,
                phone_number_type: self.phone_number_type,
                target_arn: self.target_arn,
            }
        }
    }
}
impl ListPhoneNumbersSummary {
    /// Creates a new builder-style object to manufacture [`ListPhoneNumbersSummary`](crate::model::ListPhoneNumbersSummary)
    pub fn builder() -> crate::model::list_phone_numbers_summary::Builder {
        crate::model::list_phone_numbers_summary::Builder::default()
    }
}

/// <p>Contains summary information about a phone number for a contact center.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PhoneNumberSummary {
    /// <p>The identifier of the phone number.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The phone number.</p>
    pub phone_number: std::option::Option<std::string::String>,
    /// <p>The type of phone number.</p>
    pub phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
    /// <p>The ISO country code.</p>
    pub phone_number_country_code: std::option::Option<crate::model::PhoneNumberCountryCode>,
}
impl PhoneNumberSummary {
    /// <p>The identifier of the phone number.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The phone number.</p>
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
    /// <p>The type of phone number.</p>
    pub fn phone_number_type(&self) -> std::option::Option<&crate::model::PhoneNumberType> {
        self.phone_number_type.as_ref()
    }
    /// <p>The ISO country code.</p>
    pub fn phone_number_country_code(
        &self,
    ) -> std::option::Option<&crate::model::PhoneNumberCountryCode> {
        self.phone_number_country_code.as_ref()
    }
}
impl std::fmt::Debug for PhoneNumberSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PhoneNumberSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("phone_number", &self.phone_number);
        formatter.field("phone_number_type", &self.phone_number_type);
        formatter.field("phone_number_country_code", &self.phone_number_country_code);
        formatter.finish()
    }
}
/// See [`PhoneNumberSummary`](crate::model::PhoneNumberSummary)
pub mod phone_number_summary {

    /// A builder for [`PhoneNumberSummary`](crate::model::PhoneNumberSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
        pub(crate) phone_number_country_code:
            std::option::Option<crate::model::PhoneNumberCountryCode>,
    }
    impl Builder {
        /// <p>The identifier of the phone number.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the phone number.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The phone number.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>The phone number.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// <p>The type of phone number.</p>
        pub fn phone_number_type(mut self, input: crate::model::PhoneNumberType) -> Self {
            self.phone_number_type = Some(input);
            self
        }
        /// <p>The type of phone number.</p>
        pub fn set_phone_number_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberType>,
        ) -> Self {
            self.phone_number_type = input;
            self
        }
        /// <p>The ISO country code.</p>
        pub fn phone_number_country_code(
            mut self,
            input: crate::model::PhoneNumberCountryCode,
        ) -> Self {
            self.phone_number_country_code = Some(input);
            self
        }
        /// <p>The ISO country code.</p>
        pub fn set_phone_number_country_code(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberCountryCode>,
        ) -> Self {
            self.phone_number_country_code = input;
            self
        }
        /// Consumes the builder and constructs a [`PhoneNumberSummary`](crate::model::PhoneNumberSummary)
        pub fn build(self) -> crate::model::PhoneNumberSummary {
            crate::model::PhoneNumberSummary {
                id: self.id,
                arn: self.arn,
                phone_number: self.phone_number,
                phone_number_type: self.phone_number_type,
                phone_number_country_code: self.phone_number_country_code,
            }
        }
    }
}
impl PhoneNumberSummary {
    /// Creates a new builder-style object to manufacture [`PhoneNumberSummary`](crate::model::PhoneNumberSummary)
    pub fn builder() -> crate::model::phone_number_summary::Builder {
        crate::model::phone_number_summary::Builder::default()
    }
}

/// <p>Configuration information of an Amazon Lex bot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LexBot {
    /// <p>The name of the Amazon Lex bot.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Region that the Amazon Lex bot was created in.</p>
    pub lex_region: std::option::Option<std::string::String>,
}
impl LexBot {
    /// <p>The name of the Amazon Lex bot.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Region that the Amazon Lex bot was created in.</p>
    pub fn lex_region(&self) -> std::option::Option<&str> {
        self.lex_region.as_deref()
    }
}
impl std::fmt::Debug for LexBot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LexBot");
        formatter.field("name", &self.name);
        formatter.field("lex_region", &self.lex_region);
        formatter.finish()
    }
}
/// See [`LexBot`](crate::model::LexBot)
pub mod lex_bot {

    /// A builder for [`LexBot`](crate::model::LexBot)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) lex_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon Lex bot.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Lex bot.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Region that the Amazon Lex bot was created in.</p>
        pub fn lex_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.lex_region = Some(input.into());
            self
        }
        /// <p>The Region that the Amazon Lex bot was created in.</p>
        pub fn set_lex_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lex_region = input;
            self
        }
        /// Consumes the builder and constructs a [`LexBot`](crate::model::LexBot)
        pub fn build(self) -> crate::model::LexBot {
            crate::model::LexBot {
                name: self.name,
                lex_region: self.lex_region,
            }
        }
    }
}
impl LexBot {
    /// Creates a new builder-style object to manufacture [`LexBot`](crate::model::LexBot)
    pub fn builder() -> crate::model::lex_bot::Builder {
        crate::model::lex_bot::Builder::default()
    }
}

/// <p>Contains summary information about the associated AppIntegrations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IntegrationAssociationSummary {
    /// <p>The identifier for the AppIntegration association.</p>
    pub integration_association_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the AppIntegration association.</p>
    pub integration_association_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The integration type.</p>
    pub integration_type: std::option::Option<crate::model::IntegrationType>,
    /// <p>The Amazon Resource Name (ARN) for the AppIntegration.</p>
    pub integration_arn: std::option::Option<std::string::String>,
    /// <p>The URL for the external application.</p>
    pub source_application_url: std::option::Option<std::string::String>,
    /// <p>The user-provided, friendly name for the external application.</p>
    pub source_application_name: std::option::Option<std::string::String>,
    /// <p>The name of the source.</p>
    pub source_type: std::option::Option<crate::model::SourceType>,
}
impl IntegrationAssociationSummary {
    /// <p>The identifier for the AppIntegration association.</p>
    pub fn integration_association_id(&self) -> std::option::Option<&str> {
        self.integration_association_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the AppIntegration association.</p>
    pub fn integration_association_arn(&self) -> std::option::Option<&str> {
        self.integration_association_arn.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The integration type.</p>
    pub fn integration_type(&self) -> std::option::Option<&crate::model::IntegrationType> {
        self.integration_type.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) for the AppIntegration.</p>
    pub fn integration_arn(&self) -> std::option::Option<&str> {
        self.integration_arn.as_deref()
    }
    /// <p>The URL for the external application.</p>
    pub fn source_application_url(&self) -> std::option::Option<&str> {
        self.source_application_url.as_deref()
    }
    /// <p>The user-provided, friendly name for the external application.</p>
    pub fn source_application_name(&self) -> std::option::Option<&str> {
        self.source_application_name.as_deref()
    }
    /// <p>The name of the source.</p>
    pub fn source_type(&self) -> std::option::Option<&crate::model::SourceType> {
        self.source_type.as_ref()
    }
}
impl std::fmt::Debug for IntegrationAssociationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IntegrationAssociationSummary");
        formatter.field(
            "integration_association_id",
            &self.integration_association_id,
        );
        formatter.field(
            "integration_association_arn",
            &self.integration_association_arn,
        );
        formatter.field("instance_id", &self.instance_id);
        formatter.field("integration_type", &self.integration_type);
        formatter.field("integration_arn", &self.integration_arn);
        formatter.field("source_application_url", &self.source_application_url);
        formatter.field("source_application_name", &self.source_application_name);
        formatter.field("source_type", &self.source_type);
        formatter.finish()
    }
}
/// See [`IntegrationAssociationSummary`](crate::model::IntegrationAssociationSummary)
pub mod integration_association_summary {

    /// A builder for [`IntegrationAssociationSummary`](crate::model::IntegrationAssociationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) integration_association_id: std::option::Option<std::string::String>,
        pub(crate) integration_association_arn: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) integration_type: std::option::Option<crate::model::IntegrationType>,
        pub(crate) integration_arn: std::option::Option<std::string::String>,
        pub(crate) source_application_url: std::option::Option<std::string::String>,
        pub(crate) source_application_name: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<crate::model::SourceType>,
    }
    impl Builder {
        /// <p>The identifier for the AppIntegration association.</p>
        pub fn integration_association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.integration_association_id = Some(input.into());
            self
        }
        /// <p>The identifier for the AppIntegration association.</p>
        pub fn set_integration_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.integration_association_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the AppIntegration association.</p>
        pub fn integration_association_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.integration_association_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the AppIntegration association.</p>
        pub fn set_integration_association_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.integration_association_arn = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The integration type.</p>
        pub fn integration_type(mut self, input: crate::model::IntegrationType) -> Self {
            self.integration_type = Some(input);
            self
        }
        /// <p>The integration type.</p>
        pub fn set_integration_type(
            mut self,
            input: std::option::Option<crate::model::IntegrationType>,
        ) -> Self {
            self.integration_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the AppIntegration.</p>
        pub fn integration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.integration_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the AppIntegration.</p>
        pub fn set_integration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.integration_arn = input;
            self
        }
        /// <p>The URL for the external application.</p>
        pub fn source_application_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_application_url = Some(input.into());
            self
        }
        /// <p>The URL for the external application.</p>
        pub fn set_source_application_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_application_url = input;
            self
        }
        /// <p>The user-provided, friendly name for the external application.</p>
        pub fn source_application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_application_name = Some(input.into());
            self
        }
        /// <p>The user-provided, friendly name for the external application.</p>
        pub fn set_source_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_application_name = input;
            self
        }
        /// <p>The name of the source.</p>
        pub fn source_type(mut self, input: crate::model::SourceType) -> Self {
            self.source_type = Some(input);
            self
        }
        /// <p>The name of the source.</p>
        pub fn set_source_type(
            mut self,
            input: std::option::Option<crate::model::SourceType>,
        ) -> Self {
            self.source_type = input;
            self
        }
        /// Consumes the builder and constructs a [`IntegrationAssociationSummary`](crate::model::IntegrationAssociationSummary)
        pub fn build(self) -> crate::model::IntegrationAssociationSummary {
            crate::model::IntegrationAssociationSummary {
                integration_association_id: self.integration_association_id,
                integration_association_arn: self.integration_association_arn,
                instance_id: self.instance_id,
                integration_type: self.integration_type,
                integration_arn: self.integration_arn,
                source_application_url: self.source_application_url,
                source_application_name: self.source_application_name,
                source_type: self.source_type,
            }
        }
    }
}
impl IntegrationAssociationSummary {
    /// Creates a new builder-style object to manufacture [`IntegrationAssociationSummary`](crate::model::IntegrationAssociationSummary)
    pub fn builder() -> crate::model::integration_association_summary::Builder {
        crate::model::integration_association_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SourceType {
    #[allow(missing_docs)] // documentation missing in model
    Salesforce,
    #[allow(missing_docs)] // documentation missing in model
    Zendesk,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SourceType {
    fn from(s: &str) -> Self {
        match s {
            "SALESFORCE" => SourceType::Salesforce,
            "ZENDESK" => SourceType::Zendesk,
            other => SourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SourceType::from(s))
    }
}
impl SourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SourceType::Salesforce => "SALESFORCE",
            SourceType::Zendesk => "ZENDESK",
            SourceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["SALESFORCE", "ZENDESK"]
    }
}
impl AsRef<str> for SourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IntegrationType {
    #[allow(missing_docs)] // documentation missing in model
    Event,
    #[allow(missing_docs)] // documentation missing in model
    PinpointApp,
    #[allow(missing_docs)] // documentation missing in model
    VoiceId,
    #[allow(missing_docs)] // documentation missing in model
    WisdomAssistant,
    #[allow(missing_docs)] // documentation missing in model
    WisdomKnowledgeBase,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for IntegrationType {
    fn from(s: &str) -> Self {
        match s {
            "EVENT" => IntegrationType::Event,
            "PINPOINT_APP" => IntegrationType::PinpointApp,
            "VOICE_ID" => IntegrationType::VoiceId,
            "WISDOM_ASSISTANT" => IntegrationType::WisdomAssistant,
            "WISDOM_KNOWLEDGE_BASE" => IntegrationType::WisdomKnowledgeBase,
            other => IntegrationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for IntegrationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IntegrationType::from(s))
    }
}
impl IntegrationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IntegrationType::Event => "EVENT",
            IntegrationType::PinpointApp => "PINPOINT_APP",
            IntegrationType::VoiceId => "VOICE_ID",
            IntegrationType::WisdomAssistant => "WISDOM_ASSISTANT",
            IntegrationType::WisdomKnowledgeBase => "WISDOM_KNOWLEDGE_BASE",
            IntegrationType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "EVENT",
            "PINPOINT_APP",
            "VOICE_ID",
            "WISDOM_ASSISTANT",
            "WISDOM_KNOWLEDGE_BASE",
        ]
    }
}
impl AsRef<str> for IntegrationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceSummary {
    /// <p>The identifier of the instance.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the instance.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The identity management type of the instance.</p>
    pub identity_management_type: std::option::Option<crate::model::DirectoryType>,
    /// <p>The alias of the instance.</p>
    pub instance_alias: std::option::Option<std::string::String>,
    /// <p>When the instance was created.</p>
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The service role of the instance.</p>
    pub service_role: std::option::Option<std::string::String>,
    /// <p>The state of the instance.</p>
    pub instance_status: std::option::Option<crate::model::InstanceStatus>,
    /// <p>Whether inbound calls are enabled.</p>
    pub inbound_calls_enabled: std::option::Option<bool>,
    /// <p>Whether outbound calls are enabled.</p>
    pub outbound_calls_enabled: std::option::Option<bool>,
}
impl InstanceSummary {
    /// <p>The identifier of the instance.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the instance.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The identity management type of the instance.</p>
    pub fn identity_management_type(&self) -> std::option::Option<&crate::model::DirectoryType> {
        self.identity_management_type.as_ref()
    }
    /// <p>The alias of the instance.</p>
    pub fn instance_alias(&self) -> std::option::Option<&str> {
        self.instance_alias.as_deref()
    }
    /// <p>When the instance was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The service role of the instance.</p>
    pub fn service_role(&self) -> std::option::Option<&str> {
        self.service_role.as_deref()
    }
    /// <p>The state of the instance.</p>
    pub fn instance_status(&self) -> std::option::Option<&crate::model::InstanceStatus> {
        self.instance_status.as_ref()
    }
    /// <p>Whether inbound calls are enabled.</p>
    pub fn inbound_calls_enabled(&self) -> std::option::Option<bool> {
        self.inbound_calls_enabled
    }
    /// <p>Whether outbound calls are enabled.</p>
    pub fn outbound_calls_enabled(&self) -> std::option::Option<bool> {
        self.outbound_calls_enabled
    }
}
impl std::fmt::Debug for InstanceSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("identity_management_type", &self.identity_management_type);
        formatter.field("instance_alias", &"*** Sensitive Data Redacted ***");
        formatter.field("created_time", &self.created_time);
        formatter.field("service_role", &self.service_role);
        formatter.field("instance_status", &self.instance_status);
        formatter.field("inbound_calls_enabled", &self.inbound_calls_enabled);
        formatter.field("outbound_calls_enabled", &self.outbound_calls_enabled);
        formatter.finish()
    }
}
/// See [`InstanceSummary`](crate::model::InstanceSummary)
pub mod instance_summary {

    /// A builder for [`InstanceSummary`](crate::model::InstanceSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) identity_management_type: std::option::Option<crate::model::DirectoryType>,
        pub(crate) instance_alias: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) service_role: std::option::Option<std::string::String>,
        pub(crate) instance_status: std::option::Option<crate::model::InstanceStatus>,
        pub(crate) inbound_calls_enabled: std::option::Option<bool>,
        pub(crate) outbound_calls_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The identifier of the instance.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the instance.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the instance.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the instance.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The identity management type of the instance.</p>
        pub fn identity_management_type(mut self, input: crate::model::DirectoryType) -> Self {
            self.identity_management_type = Some(input);
            self
        }
        /// <p>The identity management type of the instance.</p>
        pub fn set_identity_management_type(
            mut self,
            input: std::option::Option<crate::model::DirectoryType>,
        ) -> Self {
            self.identity_management_type = input;
            self
        }
        /// <p>The alias of the instance.</p>
        pub fn instance_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_alias = Some(input.into());
            self
        }
        /// <p>The alias of the instance.</p>
        pub fn set_instance_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_alias = input;
            self
        }
        /// <p>When the instance was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>When the instance was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The service role of the instance.</p>
        pub fn service_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_role = Some(input.into());
            self
        }
        /// <p>The service role of the instance.</p>
        pub fn set_service_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_role = input;
            self
        }
        /// <p>The state of the instance.</p>
        pub fn instance_status(mut self, input: crate::model::InstanceStatus) -> Self {
            self.instance_status = Some(input);
            self
        }
        /// <p>The state of the instance.</p>
        pub fn set_instance_status(
            mut self,
            input: std::option::Option<crate::model::InstanceStatus>,
        ) -> Self {
            self.instance_status = input;
            self
        }
        /// <p>Whether inbound calls are enabled.</p>
        pub fn inbound_calls_enabled(mut self, input: bool) -> Self {
            self.inbound_calls_enabled = Some(input);
            self
        }
        /// <p>Whether inbound calls are enabled.</p>
        pub fn set_inbound_calls_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inbound_calls_enabled = input;
            self
        }
        /// <p>Whether outbound calls are enabled.</p>
        pub fn outbound_calls_enabled(mut self, input: bool) -> Self {
            self.outbound_calls_enabled = Some(input);
            self
        }
        /// <p>Whether outbound calls are enabled.</p>
        pub fn set_outbound_calls_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.outbound_calls_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceSummary`](crate::model::InstanceSummary)
        pub fn build(self) -> crate::model::InstanceSummary {
            crate::model::InstanceSummary {
                id: self.id,
                arn: self.arn,
                identity_management_type: self.identity_management_type,
                instance_alias: self.instance_alias,
                created_time: self.created_time,
                service_role: self.service_role,
                instance_status: self.instance_status,
                inbound_calls_enabled: self.inbound_calls_enabled,
                outbound_calls_enabled: self.outbound_calls_enabled,
            }
        }
    }
}
impl InstanceSummary {
    /// Creates a new builder-style object to manufacture [`InstanceSummary`](crate::model::InstanceSummary)
    pub fn builder() -> crate::model::instance_summary::Builder {
        crate::model::instance_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    CreationFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreationInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => InstanceStatus::Active,
            "CREATION_FAILED" => InstanceStatus::CreationFailed,
            "CREATION_IN_PROGRESS" => InstanceStatus::CreationInProgress,
            other => InstanceStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceStatus::from(s))
    }
}
impl InstanceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InstanceStatus::Active => "ACTIVE",
            InstanceStatus::CreationFailed => "CREATION_FAILED",
            InstanceStatus::CreationInProgress => "CREATION_IN_PROGRESS",
            InstanceStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATION_FAILED", "CREATION_IN_PROGRESS"]
    }
}
impl AsRef<str> for InstanceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DirectoryType {
    #[allow(missing_docs)] // documentation missing in model
    ConnectManaged,
    #[allow(missing_docs)] // documentation missing in model
    ExistingDirectory,
    #[allow(missing_docs)] // documentation missing in model
    Saml,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DirectoryType {
    fn from(s: &str) -> Self {
        match s {
            "CONNECT_MANAGED" => DirectoryType::ConnectManaged,
            "EXISTING_DIRECTORY" => DirectoryType::ExistingDirectory,
            "SAML" => DirectoryType::Saml,
            other => DirectoryType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DirectoryType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DirectoryType::from(s))
    }
}
impl DirectoryType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DirectoryType::ConnectManaged => "CONNECT_MANAGED",
            DirectoryType::ExistingDirectory => "EXISTING_DIRECTORY",
            DirectoryType::Saml => "SAML",
            DirectoryType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CONNECT_MANAGED", "EXISTING_DIRECTORY", "SAML"]
    }
}
impl AsRef<str> for DirectoryType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A toggle for an individual feature at the instance level.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Attribute {
    /// <p>The type of attribute.</p>
    pub attribute_type: std::option::Option<crate::model::InstanceAttributeType>,
    /// <p>The value of the attribute.</p>
    pub value: std::option::Option<std::string::String>,
}
impl Attribute {
    /// <p>The type of attribute.</p>
    pub fn attribute_type(&self) -> std::option::Option<&crate::model::InstanceAttributeType> {
        self.attribute_type.as_ref()
    }
    /// <p>The value of the attribute.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for Attribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Attribute");
        formatter.field("attribute_type", &self.attribute_type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Attribute`](crate::model::Attribute)
pub mod attribute {

    /// A builder for [`Attribute`](crate::model::Attribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_type: std::option::Option<crate::model::InstanceAttributeType>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of attribute.</p>
        pub fn attribute_type(mut self, input: crate::model::InstanceAttributeType) -> Self {
            self.attribute_type = Some(input);
            self
        }
        /// <p>The type of attribute.</p>
        pub fn set_attribute_type(
            mut self,
            input: std::option::Option<crate::model::InstanceAttributeType>,
        ) -> Self {
            self.attribute_type = input;
            self
        }
        /// <p>The value of the attribute.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the attribute.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Attribute`](crate::model::Attribute)
        pub fn build(self) -> crate::model::Attribute {
            crate::model::Attribute {
                attribute_type: self.attribute_type,
                value: self.value,
            }
        }
    }
}
impl Attribute {
    /// Creates a new builder-style object to manufacture [`Attribute`](crate::model::Attribute)
    pub fn builder() -> crate::model::attribute::Builder {
        crate::model::attribute::Builder::default()
    }
}

/// <p>Contains summary information about hours of operation for a contact center.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HoursOfOperationSummary {
    /// <p>The identifier of the hours of operation.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the hours of operation.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the hours of operation.</p>
    pub name: std::option::Option<std::string::String>,
}
impl HoursOfOperationSummary {
    /// <p>The identifier of the hours of operation.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the hours of operation.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the hours of operation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for HoursOfOperationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HoursOfOperationSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`HoursOfOperationSummary`](crate::model::HoursOfOperationSummary)
pub mod hours_of_operation_summary {

    /// A builder for [`HoursOfOperationSummary`](crate::model::HoursOfOperationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the hours of operation.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the hours of operation.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hours of operation.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hours of operation.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the hours of operation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hours of operation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`HoursOfOperationSummary`](crate::model::HoursOfOperationSummary)
        pub fn build(self) -> crate::model::HoursOfOperationSummary {
            crate::model::HoursOfOperationSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl HoursOfOperationSummary {
    /// Creates a new builder-style object to manufacture [`HoursOfOperationSummary`](crate::model::HoursOfOperationSummary)
    pub fn builder() -> crate::model::hours_of_operation_summary::Builder {
        crate::model::hours_of_operation_summary::Builder::default()
    }
}

/// <p>Contains information about a default vocabulary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DefaultVocabulary {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    pub language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
    /// <p>The identifier of the custom vocabulary.</p>
    pub vocabulary_id: std::option::Option<std::string::String>,
    /// <p>A unique name of the custom vocabulary.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
}
impl DefaultVocabulary {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::VocabularyLanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The identifier of the custom vocabulary.</p>
    pub fn vocabulary_id(&self) -> std::option::Option<&str> {
        self.vocabulary_id.as_deref()
    }
    /// <p>A unique name of the custom vocabulary.</p>
    pub fn vocabulary_name(&self) -> std::option::Option<&str> {
        self.vocabulary_name.as_deref()
    }
}
impl std::fmt::Debug for DefaultVocabulary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DefaultVocabulary");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("language_code", &self.language_code);
        formatter.field("vocabulary_id", &self.vocabulary_id);
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.finish()
    }
}
/// See [`DefaultVocabulary`](crate::model::DefaultVocabulary)
pub mod default_vocabulary {

    /// A builder for [`DefaultVocabulary`](crate::model::DefaultVocabulary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
        pub(crate) vocabulary_id: std::option::Option<std::string::String>,
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn language_code(mut self, input: crate::model::VocabularyLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::VocabularyLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn vocabulary_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_id = Some(input.into());
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn set_vocabulary_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_id = input;
            self
        }
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultVocabulary`](crate::model::DefaultVocabulary)
        pub fn build(self) -> crate::model::DefaultVocabulary {
            crate::model::DefaultVocabulary {
                instance_id: self.instance_id,
                language_code: self.language_code,
                vocabulary_id: self.vocabulary_id,
                vocabulary_name: self.vocabulary_name,
            }
        }
    }
}
impl DefaultVocabulary {
    /// Creates a new builder-style object to manufacture [`DefaultVocabulary`](crate::model::DefaultVocabulary)
    pub fn builder() -> crate::model::default_vocabulary::Builder {
        crate::model::default_vocabulary::Builder::default()
    }
}

/// <p>Contains summary information about a reference. <code>ReferenceSummary</code> contains only one non null field between the URL and attachment based on the reference type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ReferenceSummary {
    /// <p>Information about the reference when the <code>referenceType</code> is <code>ATTACHMENT</code>. Otherwise, null.</p>
    Attachment(crate::model::AttachmentReference),
    /// <p>Information about a reference when the <code>referenceType</code> is <code>DATE</code>. Otherwise, null.</p>
    Date(crate::model::DateReference),
    /// <p>Information about a reference when the <code>referenceType</code> is <code>EMAIL</code>. Otherwise, null.</p>
    Email(crate::model::EmailReference),
    /// <p>Information about a reference when the <code>referenceType</code> is <code>NUMBER</code>. Otherwise, null.</p>
    Number(crate::model::NumberReference),
    /// <p>Information about a reference when the <code>referenceType</code> is <code>STRING</code>. Otherwise, null.</p>
    String(crate::model::StringReference),
    /// <p>Information about the reference when the <code>referenceType</code> is <code>URL</code>. Otherwise, null.</p>
    Url(crate::model::UrlReference),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ReferenceSummary {
    /// Tries to convert the enum instance into [`Attachment`](crate::model::ReferenceSummary::Attachment), extracting the inner [`AttachmentReference`](crate::model::AttachmentReference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_attachment(&self) -> std::result::Result<&crate::model::AttachmentReference, &Self> {
        if let ReferenceSummary::Attachment(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Attachment`](crate::model::ReferenceSummary::Attachment).
    pub fn is_attachment(&self) -> bool {
        self.as_attachment().is_ok()
    }
    /// Tries to convert the enum instance into [`Date`](crate::model::ReferenceSummary::Date), extracting the inner [`DateReference`](crate::model::DateReference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_date(&self) -> std::result::Result<&crate::model::DateReference, &Self> {
        if let ReferenceSummary::Date(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Date`](crate::model::ReferenceSummary::Date).
    pub fn is_date(&self) -> bool {
        self.as_date().is_ok()
    }
    /// Tries to convert the enum instance into [`Email`](crate::model::ReferenceSummary::Email), extracting the inner [`EmailReference`](crate::model::EmailReference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_email(&self) -> std::result::Result<&crate::model::EmailReference, &Self> {
        if let ReferenceSummary::Email(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Email`](crate::model::ReferenceSummary::Email).
    pub fn is_email(&self) -> bool {
        self.as_email().is_ok()
    }
    /// Tries to convert the enum instance into [`Number`](crate::model::ReferenceSummary::Number), extracting the inner [`NumberReference`](crate::model::NumberReference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_number(&self) -> std::result::Result<&crate::model::NumberReference, &Self> {
        if let ReferenceSummary::Number(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Number`](crate::model::ReferenceSummary::Number).
    pub fn is_number(&self) -> bool {
        self.as_number().is_ok()
    }
    /// Tries to convert the enum instance into [`String`](crate::model::ReferenceSummary::String), extracting the inner [`StringReference`](crate::model::StringReference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_string(&self) -> std::result::Result<&crate::model::StringReference, &Self> {
        if let ReferenceSummary::String(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`String`](crate::model::ReferenceSummary::String).
    pub fn is_string(&self) -> bool {
        self.as_string().is_ok()
    }
    /// Tries to convert the enum instance into [`Url`](crate::model::ReferenceSummary::Url), extracting the inner [`UrlReference`](crate::model::UrlReference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_url(&self) -> std::result::Result<&crate::model::UrlReference, &Self> {
        if let ReferenceSummary::Url(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Url`](crate::model::ReferenceSummary::Url).
    pub fn is_url(&self) -> bool {
        self.as_url().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Information about a reference when the <code>referenceType</code> is <code>EMAIL</code>. Otherwise, null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EmailReference {
    /// <p>Identifier of the email reference.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A valid email address.</p>
    pub value: std::option::Option<std::string::String>,
}
impl EmailReference {
    /// <p>Identifier of the email reference.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A valid email address.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for EmailReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EmailReference");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`EmailReference`](crate::model::EmailReference)
pub mod email_reference {

    /// A builder for [`EmailReference`](crate::model::EmailReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifier of the email reference.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Identifier of the email reference.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A valid email address.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A valid email address.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`EmailReference`](crate::model::EmailReference)
        pub fn build(self) -> crate::model::EmailReference {
            crate::model::EmailReference {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl EmailReference {
    /// Creates a new builder-style object to manufacture [`EmailReference`](crate::model::EmailReference)
    pub fn builder() -> crate::model::email_reference::Builder {
        crate::model::email_reference::Builder::default()
    }
}

/// <p>Information about a reference when the <code>referenceType</code> is <code>DATE</code>. Otherwise, null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DateReference {
    /// <p>Identifier of the date reference.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A valid date.</p>
    pub value: std::option::Option<std::string::String>,
}
impl DateReference {
    /// <p>Identifier of the date reference.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A valid date.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for DateReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DateReference");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`DateReference`](crate::model::DateReference)
pub mod date_reference {

    /// A builder for [`DateReference`](crate::model::DateReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifier of the date reference.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Identifier of the date reference.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A valid date.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A valid date.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`DateReference`](crate::model::DateReference)
        pub fn build(self) -> crate::model::DateReference {
            crate::model::DateReference {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl DateReference {
    /// Creates a new builder-style object to manufacture [`DateReference`](crate::model::DateReference)
    pub fn builder() -> crate::model::date_reference::Builder {
        crate::model::date_reference::Builder::default()
    }
}

/// <p>Information about a reference when the <code>referenceType</code> is <code>NUMBER</code>. Otherwise, null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NumberReference {
    /// <p>Identifier of the number reference.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A valid number.</p>
    pub value: std::option::Option<std::string::String>,
}
impl NumberReference {
    /// <p>Identifier of the number reference.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A valid number.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for NumberReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NumberReference");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`NumberReference`](crate::model::NumberReference)
pub mod number_reference {

    /// A builder for [`NumberReference`](crate::model::NumberReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifier of the number reference.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Identifier of the number reference.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A valid number.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A valid number.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`NumberReference`](crate::model::NumberReference)
        pub fn build(self) -> crate::model::NumberReference {
            crate::model::NumberReference {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl NumberReference {
    /// Creates a new builder-style object to manufacture [`NumberReference`](crate::model::NumberReference)
    pub fn builder() -> crate::model::number_reference::Builder {
        crate::model::number_reference::Builder::default()
    }
}

/// <p>Information about a reference when the <code>referenceType</code> is <code>STRING</code>. Otherwise, null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StringReference {
    /// <p>Identifier of the string reference.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A valid string.</p>
    pub value: std::option::Option<std::string::String>,
}
impl StringReference {
    /// <p>Identifier of the string reference.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A valid string.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for StringReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StringReference");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`StringReference`](crate::model::StringReference)
pub mod string_reference {

    /// A builder for [`StringReference`](crate::model::StringReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifier of the string reference.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Identifier of the string reference.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A valid string.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A valid string.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`StringReference`](crate::model::StringReference)
        pub fn build(self) -> crate::model::StringReference {
            crate::model::StringReference {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl StringReference {
    /// Creates a new builder-style object to manufacture [`StringReference`](crate::model::StringReference)
    pub fn builder() -> crate::model::string_reference::Builder {
        crate::model::string_reference::Builder::default()
    }
}

/// <p>Information about a reference when the <code>referenceType</code> is <code>ATTACHMENT</code>. Otherwise, null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachmentReference {
    /// <p>Identifier of the attachment reference.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The location path of the attachment reference.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>Status of the attachment reference type.</p>
    pub status: std::option::Option<crate::model::ReferenceStatus>,
}
impl AttachmentReference {
    /// <p>Identifier of the attachment reference.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The location path of the attachment reference.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>Status of the attachment reference type.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReferenceStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for AttachmentReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachmentReference");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AttachmentReference`](crate::model::AttachmentReference)
pub mod attachment_reference {

    /// A builder for [`AttachmentReference`](crate::model::AttachmentReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ReferenceStatus>,
    }
    impl Builder {
        /// <p>Identifier of the attachment reference.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Identifier of the attachment reference.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The location path of the attachment reference.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The location path of the attachment reference.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>Status of the attachment reference type.</p>
        pub fn status(mut self, input: crate::model::ReferenceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status of the attachment reference type.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReferenceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachmentReference`](crate::model::AttachmentReference)
        pub fn build(self) -> crate::model::AttachmentReference {
            crate::model::AttachmentReference {
                name: self.name,
                value: self.value,
                status: self.status,
            }
        }
    }
}
impl AttachmentReference {
    /// Creates a new builder-style object to manufacture [`AttachmentReference`](crate::model::AttachmentReference)
    pub fn builder() -> crate::model::attachment_reference::Builder {
        crate::model::attachment_reference::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReferenceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Approved,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReferenceStatus {
    fn from(s: &str) -> Self {
        match s {
            "APPROVED" => ReferenceStatus::Approved,
            "REJECTED" => ReferenceStatus::Rejected,
            other => ReferenceStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReferenceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReferenceStatus::from(s))
    }
}
impl ReferenceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReferenceStatus::Approved => "APPROVED",
            ReferenceStatus::Rejected => "REJECTED",
            ReferenceStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["APPROVED", "REJECTED"]
    }
}
impl AsRef<str> for ReferenceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The URL reference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UrlReference {
    /// <p>Identifier of the URL reference.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A valid URL.</p>
    pub value: std::option::Option<std::string::String>,
}
impl UrlReference {
    /// <p>Identifier of the URL reference.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A valid URL.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for UrlReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UrlReference");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`UrlReference`](crate::model::UrlReference)
pub mod url_reference {

    /// A builder for [`UrlReference`](crate::model::UrlReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifier of the URL reference.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Identifier of the URL reference.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A valid URL.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A valid URL.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`UrlReference`](crate::model::UrlReference)
        pub fn build(self) -> crate::model::UrlReference {
            crate::model::UrlReference {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl UrlReference {
    /// Creates a new builder-style object to manufacture [`UrlReference`](crate::model::UrlReference)
    pub fn builder() -> crate::model::url_reference::Builder {
        crate::model::url_reference::Builder::default()
    }
}

/// <p>Contains summary information about a contact flow.</p>
/// <p>You can also create and update contact flows using the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html">Amazon Connect Flow language</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContactFlowSummary {
    /// <p>The identifier of the contact flow.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the contact flow.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the contact flow.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of contact flow.</p>
    pub contact_flow_type: std::option::Option<crate::model::ContactFlowType>,
    /// <p>The type of contact flow.</p>
    pub contact_flow_state: std::option::Option<crate::model::ContactFlowState>,
}
impl ContactFlowSummary {
    /// <p>The identifier of the contact flow.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the contact flow.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the contact flow.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of contact flow.</p>
    pub fn contact_flow_type(&self) -> std::option::Option<&crate::model::ContactFlowType> {
        self.contact_flow_type.as_ref()
    }
    /// <p>The type of contact flow.</p>
    pub fn contact_flow_state(&self) -> std::option::Option<&crate::model::ContactFlowState> {
        self.contact_flow_state.as_ref()
    }
}
impl std::fmt::Debug for ContactFlowSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContactFlowSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("contact_flow_type", &self.contact_flow_type);
        formatter.field("contact_flow_state", &self.contact_flow_state);
        formatter.finish()
    }
}
/// See [`ContactFlowSummary`](crate::model::ContactFlowSummary)
pub mod contact_flow_summary {

    /// A builder for [`ContactFlowSummary`](crate::model::ContactFlowSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) contact_flow_type: std::option::Option<crate::model::ContactFlowType>,
        pub(crate) contact_flow_state: std::option::Option<crate::model::ContactFlowState>,
    }
    impl Builder {
        /// <p>The identifier of the contact flow.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact flow.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the contact flow.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the contact flow.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the contact flow.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the contact flow.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of contact flow.</p>
        pub fn contact_flow_type(mut self, input: crate::model::ContactFlowType) -> Self {
            self.contact_flow_type = Some(input);
            self
        }
        /// <p>The type of contact flow.</p>
        pub fn set_contact_flow_type(
            mut self,
            input: std::option::Option<crate::model::ContactFlowType>,
        ) -> Self {
            self.contact_flow_type = input;
            self
        }
        /// <p>The type of contact flow.</p>
        pub fn contact_flow_state(mut self, input: crate::model::ContactFlowState) -> Self {
            self.contact_flow_state = Some(input);
            self
        }
        /// <p>The type of contact flow.</p>
        pub fn set_contact_flow_state(
            mut self,
            input: std::option::Option<crate::model::ContactFlowState>,
        ) -> Self {
            self.contact_flow_state = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactFlowSummary`](crate::model::ContactFlowSummary)
        pub fn build(self) -> crate::model::ContactFlowSummary {
            crate::model::ContactFlowSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                contact_flow_type: self.contact_flow_type,
                contact_flow_state: self.contact_flow_state,
            }
        }
    }
}
impl ContactFlowSummary {
    /// Creates a new builder-style object to manufacture [`ContactFlowSummary`](crate::model::ContactFlowSummary)
    pub fn builder() -> crate::model::contact_flow_summary::Builder {
        crate::model::contact_flow_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContactFlowType {
    #[allow(missing_docs)] // documentation missing in model
    AgentHold,
    #[allow(missing_docs)] // documentation missing in model
    AgentTransfer,
    #[allow(missing_docs)] // documentation missing in model
    AgentWhisper,
    #[allow(missing_docs)] // documentation missing in model
    ContactFlow,
    #[allow(missing_docs)] // documentation missing in model
    CustomerHold,
    #[allow(missing_docs)] // documentation missing in model
    CustomerQueue,
    #[allow(missing_docs)] // documentation missing in model
    CustomerWhisper,
    #[allow(missing_docs)] // documentation missing in model
    OutboundWhisper,
    #[allow(missing_docs)] // documentation missing in model
    QueueTransfer,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContactFlowType {
    fn from(s: &str) -> Self {
        match s {
            "AGENT_HOLD" => ContactFlowType::AgentHold,
            "AGENT_TRANSFER" => ContactFlowType::AgentTransfer,
            "AGENT_WHISPER" => ContactFlowType::AgentWhisper,
            "CONTACT_FLOW" => ContactFlowType::ContactFlow,
            "CUSTOMER_HOLD" => ContactFlowType::CustomerHold,
            "CUSTOMER_QUEUE" => ContactFlowType::CustomerQueue,
            "CUSTOMER_WHISPER" => ContactFlowType::CustomerWhisper,
            "OUTBOUND_WHISPER" => ContactFlowType::OutboundWhisper,
            "QUEUE_TRANSFER" => ContactFlowType::QueueTransfer,
            other => ContactFlowType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContactFlowType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContactFlowType::from(s))
    }
}
impl ContactFlowType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContactFlowType::AgentHold => "AGENT_HOLD",
            ContactFlowType::AgentTransfer => "AGENT_TRANSFER",
            ContactFlowType::AgentWhisper => "AGENT_WHISPER",
            ContactFlowType::ContactFlow => "CONTACT_FLOW",
            ContactFlowType::CustomerHold => "CUSTOMER_HOLD",
            ContactFlowType::CustomerQueue => "CUSTOMER_QUEUE",
            ContactFlowType::CustomerWhisper => "CUSTOMER_WHISPER",
            ContactFlowType::OutboundWhisper => "OUTBOUND_WHISPER",
            ContactFlowType::QueueTransfer => "QUEUE_TRANSFER",
            ContactFlowType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AGENT_HOLD",
            "AGENT_TRANSFER",
            "AGENT_WHISPER",
            "CONTACT_FLOW",
            "CUSTOMER_HOLD",
            "CUSTOMER_QUEUE",
            "CUSTOMER_WHISPER",
            "OUTBOUND_WHISPER",
            "QUEUE_TRANSFER",
        ]
    }
}
impl AsRef<str> for ContactFlowType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains summary information about a contact flow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContactFlowModuleSummary {
    /// <p>The identifier of the contact flow module.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the contact flow module.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the contact flow module.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of contact flow module.</p>
    pub state: std::option::Option<crate::model::ContactFlowModuleState>,
}
impl ContactFlowModuleSummary {
    /// <p>The identifier of the contact flow module.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the contact flow module.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the contact flow module.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of contact flow module.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ContactFlowModuleState> {
        self.state.as_ref()
    }
}
impl std::fmt::Debug for ContactFlowModuleSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContactFlowModuleSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`ContactFlowModuleSummary`](crate::model::ContactFlowModuleSummary)
pub mod contact_flow_module_summary {

    /// A builder for [`ContactFlowModuleSummary`](crate::model::ContactFlowModuleSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ContactFlowModuleState>,
    }
    impl Builder {
        /// <p>The identifier of the contact flow module.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact flow module.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the contact flow module.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the contact flow module.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the contact flow module.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the contact flow module.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of contact flow module.</p>
        pub fn state(mut self, input: crate::model::ContactFlowModuleState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The type of contact flow module.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ContactFlowModuleState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactFlowModuleSummary`](crate::model::ContactFlowModuleSummary)
        pub fn build(self) -> crate::model::ContactFlowModuleSummary {
            crate::model::ContactFlowModuleSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                state: self.state,
            }
        }
    }
}
impl ContactFlowModuleSummary {
    /// Creates a new builder-style object to manufacture [`ContactFlowModuleSummary`](crate::model::ContactFlowModuleSummary)
    pub fn builder() -> crate::model::contact_flow_module_summary::Builder {
        crate::model::contact_flow_module_summary::Builder::default()
    }
}

/// <p>Configuration information of an Amazon Lex or Amazon Lex V2 bot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LexBotConfig {
    /// <p>Configuration information of an Amazon Lex bot.</p>
    pub lex_bot: std::option::Option<crate::model::LexBot>,
    /// <p>Configuration information of an Amazon Lex V2 bot.</p>
    pub lex_v2_bot: std::option::Option<crate::model::LexV2Bot>,
}
impl LexBotConfig {
    /// <p>Configuration information of an Amazon Lex bot.</p>
    pub fn lex_bot(&self) -> std::option::Option<&crate::model::LexBot> {
        self.lex_bot.as_ref()
    }
    /// <p>Configuration information of an Amazon Lex V2 bot.</p>
    pub fn lex_v2_bot(&self) -> std::option::Option<&crate::model::LexV2Bot> {
        self.lex_v2_bot.as_ref()
    }
}
impl std::fmt::Debug for LexBotConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LexBotConfig");
        formatter.field("lex_bot", &self.lex_bot);
        formatter.field("lex_v2_bot", &self.lex_v2_bot);
        formatter.finish()
    }
}
/// See [`LexBotConfig`](crate::model::LexBotConfig)
pub mod lex_bot_config {

    /// A builder for [`LexBotConfig`](crate::model::LexBotConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lex_bot: std::option::Option<crate::model::LexBot>,
        pub(crate) lex_v2_bot: std::option::Option<crate::model::LexV2Bot>,
    }
    impl Builder {
        /// <p>Configuration information of an Amazon Lex bot.</p>
        pub fn lex_bot(mut self, input: crate::model::LexBot) -> Self {
            self.lex_bot = Some(input);
            self
        }
        /// <p>Configuration information of an Amazon Lex bot.</p>
        pub fn set_lex_bot(mut self, input: std::option::Option<crate::model::LexBot>) -> Self {
            self.lex_bot = input;
            self
        }
        /// <p>Configuration information of an Amazon Lex V2 bot.</p>
        pub fn lex_v2_bot(mut self, input: crate::model::LexV2Bot) -> Self {
            self.lex_v2_bot = Some(input);
            self
        }
        /// <p>Configuration information of an Amazon Lex V2 bot.</p>
        pub fn set_lex_v2_bot(
            mut self,
            input: std::option::Option<crate::model::LexV2Bot>,
        ) -> Self {
            self.lex_v2_bot = input;
            self
        }
        /// Consumes the builder and constructs a [`LexBotConfig`](crate::model::LexBotConfig)
        pub fn build(self) -> crate::model::LexBotConfig {
            crate::model::LexBotConfig {
                lex_bot: self.lex_bot,
                lex_v2_bot: self.lex_v2_bot,
            }
        }
    }
}
impl LexBotConfig {
    /// Creates a new builder-style object to manufacture [`LexBotConfig`](crate::model::LexBotConfig)
    pub fn builder() -> crate::model::lex_bot_config::Builder {
        crate::model::lex_bot_config::Builder::default()
    }
}

/// <p>Configuration information of an Amazon Lex V2 bot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LexV2Bot {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.</p>
    pub alias_arn: std::option::Option<std::string::String>,
}
impl LexV2Bot {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.</p>
    pub fn alias_arn(&self) -> std::option::Option<&str> {
        self.alias_arn.as_deref()
    }
}
impl std::fmt::Debug for LexV2Bot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LexV2Bot");
        formatter.field("alias_arn", &self.alias_arn);
        formatter.finish()
    }
}
/// See [`LexV2Bot`](crate::model::LexV2Bot)
pub mod lex_v2_bot {

    /// A builder for [`LexV2Bot`](crate::model::LexV2Bot)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alias_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.</p>
        pub fn alias_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.</p>
        pub fn set_alias_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LexV2Bot`](crate::model::LexV2Bot)
        pub fn build(self) -> crate::model::LexV2Bot {
            crate::model::LexV2Bot {
                alias_arn: self.alias_arn,
            }
        }
    }
}
impl LexV2Bot {
    /// Creates a new builder-style object to manufacture [`LexV2Bot`](crate::model::LexV2Bot)
    pub fn builder() -> crate::model::lex_v2_bot::Builder {
        crate::model::lex_v2_bot::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LexVersion {
    #[allow(missing_docs)] // documentation missing in model
    V1,
    #[allow(missing_docs)] // documentation missing in model
    V2,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LexVersion {
    fn from(s: &str) -> Self {
        match s {
            "V1" => LexVersion::V1,
            "V2" => LexVersion::V2,
            other => LexVersion::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LexVersion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LexVersion::from(s))
    }
}
impl LexVersion {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LexVersion::V1 => "V1",
            LexVersion::V2 => "V2",
            LexVersion::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["V1", "V2"]
    }
}
impl AsRef<str> for LexVersion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information for an agent status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AgentStatusSummary {
    /// <p>The identifier for an agent status.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the agent status.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the agent status.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the agent status.</p>
    pub r#type: std::option::Option<crate::model::AgentStatusType>,
}
impl AgentStatusSummary {
    /// <p>The identifier for an agent status.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the agent status.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the agent status.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the agent status.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::AgentStatusType> {
        self.r#type.as_ref()
    }
}
impl std::fmt::Debug for AgentStatusSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AgentStatusSummary");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AgentStatusSummary`](crate::model::AgentStatusSummary)
pub mod agent_status_summary {

    /// A builder for [`AgentStatusSummary`](crate::model::AgentStatusSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::AgentStatusType>,
    }
    impl Builder {
        /// <p>The identifier for an agent status.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier for an agent status.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the agent status.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the agent status.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the agent status.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the agent status.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the agent status.</p>
        pub fn r#type(mut self, input: crate::model::AgentStatusType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the agent status.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::AgentStatusType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentStatusSummary`](crate::model::AgentStatusSummary)
        pub fn build(self) -> crate::model::AgentStatusSummary {
            crate::model::AgentStatusSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                r#type: self.r#type,
            }
        }
    }
}
impl AgentStatusSummary {
    /// Creates a new builder-style object to manufacture [`AgentStatusSummary`](crate::model::AgentStatusSummary)
    pub fn builder() -> crate::model::agent_status_summary::Builder {
        crate::model::agent_status_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AgentStatusType {
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    Offline,
    #[allow(missing_docs)] // documentation missing in model
    Routable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AgentStatusType {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOM" => AgentStatusType::Custom,
            "OFFLINE" => AgentStatusType::Offline,
            "ROUTABLE" => AgentStatusType::Routable,
            other => AgentStatusType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AgentStatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AgentStatusType::from(s))
    }
}
impl AgentStatusType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AgentStatusType::Custom => "CUSTOM",
            AgentStatusType::Offline => "OFFLINE",
            AgentStatusType::Routable => "ROUTABLE",
            AgentStatusType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CUSTOM", "OFFLINE", "ROUTABLE"]
    }
}
impl AsRef<str> for AgentStatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the historical metrics retrieved.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HistoricalMetricResult {
    /// <p>The dimension for the metrics.</p>
    pub dimensions: std::option::Option<crate::model::Dimensions>,
    /// <p>The set of metrics.</p>
    pub collections: std::option::Option<std::vec::Vec<crate::model::HistoricalMetricData>>,
}
impl HistoricalMetricResult {
    /// <p>The dimension for the metrics.</p>
    pub fn dimensions(&self) -> std::option::Option<&crate::model::Dimensions> {
        self.dimensions.as_ref()
    }
    /// <p>The set of metrics.</p>
    pub fn collections(&self) -> std::option::Option<&[crate::model::HistoricalMetricData]> {
        self.collections.as_deref()
    }
}
impl std::fmt::Debug for HistoricalMetricResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HistoricalMetricResult");
        formatter.field("dimensions", &self.dimensions);
        formatter.field("collections", &self.collections);
        formatter.finish()
    }
}
/// See [`HistoricalMetricResult`](crate::model::HistoricalMetricResult)
pub mod historical_metric_result {

    /// A builder for [`HistoricalMetricResult`](crate::model::HistoricalMetricResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimensions: std::option::Option<crate::model::Dimensions>,
        pub(crate) collections:
            std::option::Option<std::vec::Vec<crate::model::HistoricalMetricData>>,
    }
    impl Builder {
        /// <p>The dimension for the metrics.</p>
        pub fn dimensions(mut self, input: crate::model::Dimensions) -> Self {
            self.dimensions = Some(input);
            self
        }
        /// <p>The dimension for the metrics.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<crate::model::Dimensions>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// Appends an item to `collections`.
        ///
        /// To override the contents of this collection use [`set_collections`](Self::set_collections).
        ///
        /// <p>The set of metrics.</p>
        pub fn collections(mut self, input: crate::model::HistoricalMetricData) -> Self {
            let mut v = self.collections.unwrap_or_default();
            v.push(input);
            self.collections = Some(v);
            self
        }
        /// <p>The set of metrics.</p>
        pub fn set_collections(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HistoricalMetricData>>,
        ) -> Self {
            self.collections = input;
            self
        }
        /// Consumes the builder and constructs a [`HistoricalMetricResult`](crate::model::HistoricalMetricResult)
        pub fn build(self) -> crate::model::HistoricalMetricResult {
            crate::model::HistoricalMetricResult {
                dimensions: self.dimensions,
                collections: self.collections,
            }
        }
    }
}
impl HistoricalMetricResult {
    /// Creates a new builder-style object to manufacture [`HistoricalMetricResult`](crate::model::HistoricalMetricResult)
    pub fn builder() -> crate::model::historical_metric_result::Builder {
        crate::model::historical_metric_result::Builder::default()
    }
}

/// <p>Contains the data for a historical metric.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HistoricalMetricData {
    /// <p>Information about the metric.</p>
    pub metric: std::option::Option<crate::model::HistoricalMetric>,
    /// <p>The value of the metric.</p>
    pub value: std::option::Option<f64>,
}
impl HistoricalMetricData {
    /// <p>Information about the metric.</p>
    pub fn metric(&self) -> std::option::Option<&crate::model::HistoricalMetric> {
        self.metric.as_ref()
    }
    /// <p>The value of the metric.</p>
    pub fn value(&self) -> std::option::Option<f64> {
        self.value
    }
}
impl std::fmt::Debug for HistoricalMetricData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HistoricalMetricData");
        formatter.field("metric", &self.metric);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`HistoricalMetricData`](crate::model::HistoricalMetricData)
pub mod historical_metric_data {

    /// A builder for [`HistoricalMetricData`](crate::model::HistoricalMetricData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric: std::option::Option<crate::model::HistoricalMetric>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>Information about the metric.</p>
        pub fn metric(mut self, input: crate::model::HistoricalMetric) -> Self {
            self.metric = Some(input);
            self
        }
        /// <p>Information about the metric.</p>
        pub fn set_metric(
            mut self,
            input: std::option::Option<crate::model::HistoricalMetric>,
        ) -> Self {
            self.metric = input;
            self
        }
        /// <p>The value of the metric.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the metric.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`HistoricalMetricData`](crate::model::HistoricalMetricData)
        pub fn build(self) -> crate::model::HistoricalMetricData {
            crate::model::HistoricalMetricData {
                metric: self.metric,
                value: self.value,
            }
        }
    }
}
impl HistoricalMetricData {
    /// Creates a new builder-style object to manufacture [`HistoricalMetricData`](crate::model::HistoricalMetricData)
    pub fn builder() -> crate::model::historical_metric_data::Builder {
        crate::model::historical_metric_data::Builder::default()
    }
}

/// <p>Contains information about a historical metric. For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HistoricalMetric {
    /// <p>The name of the metric.</p>
    pub name: std::option::Option<crate::model::HistoricalMetricName>,
    /// <p>The threshold for the metric, used with service level metrics.</p>
    pub threshold: std::option::Option<crate::model::Threshold>,
    /// <p>The statistic for the metric.</p>
    pub statistic: std::option::Option<crate::model::Statistic>,
    /// <p>The unit for the metric.</p>
    pub unit: std::option::Option<crate::model::Unit>,
}
impl HistoricalMetric {
    /// <p>The name of the metric.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::HistoricalMetricName> {
        self.name.as_ref()
    }
    /// <p>The threshold for the metric, used with service level metrics.</p>
    pub fn threshold(&self) -> std::option::Option<&crate::model::Threshold> {
        self.threshold.as_ref()
    }
    /// <p>The statistic for the metric.</p>
    pub fn statistic(&self) -> std::option::Option<&crate::model::Statistic> {
        self.statistic.as_ref()
    }
    /// <p>The unit for the metric.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::Unit> {
        self.unit.as_ref()
    }
}
impl std::fmt::Debug for HistoricalMetric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HistoricalMetric");
        formatter.field("name", &self.name);
        formatter.field("threshold", &self.threshold);
        formatter.field("statistic", &self.statistic);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}
/// See [`HistoricalMetric`](crate::model::HistoricalMetric)
pub mod historical_metric {

    /// A builder for [`HistoricalMetric`](crate::model::HistoricalMetric)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::HistoricalMetricName>,
        pub(crate) threshold: std::option::Option<crate::model::Threshold>,
        pub(crate) statistic: std::option::Option<crate::model::Statistic>,
        pub(crate) unit: std::option::Option<crate::model::Unit>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn name(mut self, input: crate::model::HistoricalMetricName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the metric.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::HistoricalMetricName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The threshold for the metric, used with service level metrics.</p>
        pub fn threshold(mut self, input: crate::model::Threshold) -> Self {
            self.threshold = Some(input);
            self
        }
        /// <p>The threshold for the metric, used with service level metrics.</p>
        pub fn set_threshold(
            mut self,
            input: std::option::Option<crate::model::Threshold>,
        ) -> Self {
            self.threshold = input;
            self
        }
        /// <p>The statistic for the metric.</p>
        pub fn statistic(mut self, input: crate::model::Statistic) -> Self {
            self.statistic = Some(input);
            self
        }
        /// <p>The statistic for the metric.</p>
        pub fn set_statistic(
            mut self,
            input: std::option::Option<crate::model::Statistic>,
        ) -> Self {
            self.statistic = input;
            self
        }
        /// <p>The unit for the metric.</p>
        pub fn unit(mut self, input: crate::model::Unit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit for the metric.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::Unit>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`HistoricalMetric`](crate::model::HistoricalMetric)
        pub fn build(self) -> crate::model::HistoricalMetric {
            crate::model::HistoricalMetric {
                name: self.name,
                threshold: self.threshold,
                statistic: self.statistic,
                unit: self.unit,
            }
        }
    }
}
impl HistoricalMetric {
    /// Creates a new builder-style object to manufacture [`HistoricalMetric`](crate::model::HistoricalMetric)
    pub fn builder() -> crate::model::historical_metric::Builder {
        crate::model::historical_metric::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Unit {
    #[allow(missing_docs)] // documentation missing in model
    Count,
    #[allow(missing_docs)] // documentation missing in model
    Percent,
    #[allow(missing_docs)] // documentation missing in model
    Seconds,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Unit {
    fn from(s: &str) -> Self {
        match s {
            "COUNT" => Unit::Count,
            "PERCENT" => Unit::Percent,
            "SECONDS" => Unit::Seconds,
            other => Unit::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Unit {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Unit::from(s))
    }
}
impl Unit {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Unit::Count => "COUNT",
            Unit::Percent => "PERCENT",
            Unit::Seconds => "SECONDS",
            Unit::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["COUNT", "PERCENT", "SECONDS"]
    }
}
impl AsRef<str> for Unit {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Statistic {
    #[allow(missing_docs)] // documentation missing in model
    Avg,
    #[allow(missing_docs)] // documentation missing in model
    Max,
    #[allow(missing_docs)] // documentation missing in model
    Sum,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Statistic {
    fn from(s: &str) -> Self {
        match s {
            "AVG" => Statistic::Avg,
            "MAX" => Statistic::Max,
            "SUM" => Statistic::Sum,
            other => Statistic::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Statistic {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Statistic::from(s))
    }
}
impl Statistic {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Statistic::Avg => "AVG",
            Statistic::Max => "MAX",
            Statistic::Sum => "SUM",
            Statistic::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["AVG", "MAX", "SUM"]
    }
}
impl AsRef<str> for Statistic {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the threshold for service level metrics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Threshold {
    /// <p>The type of comparison. Only "less than" (LT) comparisons are supported.</p>
    pub comparison: std::option::Option<crate::model::Comparison>,
    /// <p>The threshold value to compare.</p>
    pub threshold_value: std::option::Option<f64>,
}
impl Threshold {
    /// <p>The type of comparison. Only "less than" (LT) comparisons are supported.</p>
    pub fn comparison(&self) -> std::option::Option<&crate::model::Comparison> {
        self.comparison.as_ref()
    }
    /// <p>The threshold value to compare.</p>
    pub fn threshold_value(&self) -> std::option::Option<f64> {
        self.threshold_value
    }
}
impl std::fmt::Debug for Threshold {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Threshold");
        formatter.field("comparison", &self.comparison);
        formatter.field("threshold_value", &self.threshold_value);
        formatter.finish()
    }
}
/// See [`Threshold`](crate::model::Threshold)
pub mod threshold {

    /// A builder for [`Threshold`](crate::model::Threshold)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comparison: std::option::Option<crate::model::Comparison>,
        pub(crate) threshold_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The type of comparison. Only "less than" (LT) comparisons are supported.</p>
        pub fn comparison(mut self, input: crate::model::Comparison) -> Self {
            self.comparison = Some(input);
            self
        }
        /// <p>The type of comparison. Only "less than" (LT) comparisons are supported.</p>
        pub fn set_comparison(
            mut self,
            input: std::option::Option<crate::model::Comparison>,
        ) -> Self {
            self.comparison = input;
            self
        }
        /// <p>The threshold value to compare.</p>
        pub fn threshold_value(mut self, input: f64) -> Self {
            self.threshold_value = Some(input);
            self
        }
        /// <p>The threshold value to compare.</p>
        pub fn set_threshold_value(mut self, input: std::option::Option<f64>) -> Self {
            self.threshold_value = input;
            self
        }
        /// Consumes the builder and constructs a [`Threshold`](crate::model::Threshold)
        pub fn build(self) -> crate::model::Threshold {
            crate::model::Threshold {
                comparison: self.comparison,
                threshold_value: self.threshold_value,
            }
        }
    }
}
impl Threshold {
    /// Creates a new builder-style object to manufacture [`Threshold`](crate::model::Threshold)
    pub fn builder() -> crate::model::threshold::Builder {
        crate::model::threshold::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Comparison {
    #[allow(missing_docs)] // documentation missing in model
    Lt,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Comparison {
    fn from(s: &str) -> Self {
        match s {
            "LT" => Comparison::Lt,
            other => Comparison::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Comparison {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Comparison::from(s))
    }
}
impl Comparison {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Comparison::Lt => "LT",
            Comparison::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["LT"]
    }
}
impl AsRef<str> for Comparison {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The historical metric names.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HistoricalMetricName {
    #[allow(missing_docs)] // documentation missing in model
    AbandonTime,
    #[allow(missing_docs)] // documentation missing in model
    AfterContactWorkTime,
    #[allow(missing_docs)] // documentation missing in model
    ApiContactsHandled,
    #[allow(missing_docs)] // documentation missing in model
    CallbackContactsHandled,
    #[allow(missing_docs)] // documentation missing in model
    ContactsAbandoned,
    #[allow(missing_docs)] // documentation missing in model
    ContactsAgentHungUpFirst,
    #[allow(missing_docs)] // documentation missing in model
    ContactsConsulted,
    #[allow(missing_docs)] // documentation missing in model
    ContactsHandled,
    #[allow(missing_docs)] // documentation missing in model
    ContactsHandledIncoming,
    #[allow(missing_docs)] // documentation missing in model
    ContactsHandledOutbound,
    #[allow(missing_docs)] // documentation missing in model
    ContactsHoldAbandons,
    #[allow(missing_docs)] // documentation missing in model
    ContactsMissed,
    #[allow(missing_docs)] // documentation missing in model
    ContactsQueued,
    #[allow(missing_docs)] // documentation missing in model
    ContactsTransferredIn,
    #[allow(missing_docs)] // documentation missing in model
    ContactsTransferredInFromQueue,
    #[allow(missing_docs)] // documentation missing in model
    ContactsTransferredOut,
    #[allow(missing_docs)] // documentation missing in model
    ContactsTransferredOutFromQueue,
    #[allow(missing_docs)] // documentation missing in model
    HandleTime,
    #[allow(missing_docs)] // documentation missing in model
    HoldTime,
    #[allow(missing_docs)] // documentation missing in model
    InteractionAndHoldTime,
    #[allow(missing_docs)] // documentation missing in model
    InteractionTime,
    #[allow(missing_docs)] // documentation missing in model
    Occupancy,
    #[allow(missing_docs)] // documentation missing in model
    QueuedTime,
    #[allow(missing_docs)] // documentation missing in model
    QueueAnswerTime,
    #[allow(missing_docs)] // documentation missing in model
    ServiceLevel,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HistoricalMetricName {
    fn from(s: &str) -> Self {
        match s {
            "ABANDON_TIME" => HistoricalMetricName::AbandonTime,
            "AFTER_CONTACT_WORK_TIME" => HistoricalMetricName::AfterContactWorkTime,
            "API_CONTACTS_HANDLED" => HistoricalMetricName::ApiContactsHandled,
            "CALLBACK_CONTACTS_HANDLED" => HistoricalMetricName::CallbackContactsHandled,
            "CONTACTS_ABANDONED" => HistoricalMetricName::ContactsAbandoned,
            "CONTACTS_AGENT_HUNG_UP_FIRST" => HistoricalMetricName::ContactsAgentHungUpFirst,
            "CONTACTS_CONSULTED" => HistoricalMetricName::ContactsConsulted,
            "CONTACTS_HANDLED" => HistoricalMetricName::ContactsHandled,
            "CONTACTS_HANDLED_INCOMING" => HistoricalMetricName::ContactsHandledIncoming,
            "CONTACTS_HANDLED_OUTBOUND" => HistoricalMetricName::ContactsHandledOutbound,
            "CONTACTS_HOLD_ABANDONS" => HistoricalMetricName::ContactsHoldAbandons,
            "CONTACTS_MISSED" => HistoricalMetricName::ContactsMissed,
            "CONTACTS_QUEUED" => HistoricalMetricName::ContactsQueued,
            "CONTACTS_TRANSFERRED_IN" => HistoricalMetricName::ContactsTransferredIn,
            "CONTACTS_TRANSFERRED_IN_FROM_QUEUE" => {
                HistoricalMetricName::ContactsTransferredInFromQueue
            }
            "CONTACTS_TRANSFERRED_OUT" => HistoricalMetricName::ContactsTransferredOut,
            "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE" => {
                HistoricalMetricName::ContactsTransferredOutFromQueue
            }
            "HANDLE_TIME" => HistoricalMetricName::HandleTime,
            "HOLD_TIME" => HistoricalMetricName::HoldTime,
            "INTERACTION_AND_HOLD_TIME" => HistoricalMetricName::InteractionAndHoldTime,
            "INTERACTION_TIME" => HistoricalMetricName::InteractionTime,
            "OCCUPANCY" => HistoricalMetricName::Occupancy,
            "QUEUED_TIME" => HistoricalMetricName::QueuedTime,
            "QUEUE_ANSWER_TIME" => HistoricalMetricName::QueueAnswerTime,
            "SERVICE_LEVEL" => HistoricalMetricName::ServiceLevel,
            other => HistoricalMetricName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HistoricalMetricName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HistoricalMetricName::from(s))
    }
}
impl HistoricalMetricName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HistoricalMetricName::AbandonTime => "ABANDON_TIME",
            HistoricalMetricName::AfterContactWorkTime => "AFTER_CONTACT_WORK_TIME",
            HistoricalMetricName::ApiContactsHandled => "API_CONTACTS_HANDLED",
            HistoricalMetricName::CallbackContactsHandled => "CALLBACK_CONTACTS_HANDLED",
            HistoricalMetricName::ContactsAbandoned => "CONTACTS_ABANDONED",
            HistoricalMetricName::ContactsAgentHungUpFirst => "CONTACTS_AGENT_HUNG_UP_FIRST",
            HistoricalMetricName::ContactsConsulted => "CONTACTS_CONSULTED",
            HistoricalMetricName::ContactsHandled => "CONTACTS_HANDLED",
            HistoricalMetricName::ContactsHandledIncoming => "CONTACTS_HANDLED_INCOMING",
            HistoricalMetricName::ContactsHandledOutbound => "CONTACTS_HANDLED_OUTBOUND",
            HistoricalMetricName::ContactsHoldAbandons => "CONTACTS_HOLD_ABANDONS",
            HistoricalMetricName::ContactsMissed => "CONTACTS_MISSED",
            HistoricalMetricName::ContactsQueued => "CONTACTS_QUEUED",
            HistoricalMetricName::ContactsTransferredIn => "CONTACTS_TRANSFERRED_IN",
            HistoricalMetricName::ContactsTransferredInFromQueue => {
                "CONTACTS_TRANSFERRED_IN_FROM_QUEUE"
            }
            HistoricalMetricName::ContactsTransferredOut => "CONTACTS_TRANSFERRED_OUT",
            HistoricalMetricName::ContactsTransferredOutFromQueue => {
                "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE"
            }
            HistoricalMetricName::HandleTime => "HANDLE_TIME",
            HistoricalMetricName::HoldTime => "HOLD_TIME",
            HistoricalMetricName::InteractionAndHoldTime => "INTERACTION_AND_HOLD_TIME",
            HistoricalMetricName::InteractionTime => "INTERACTION_TIME",
            HistoricalMetricName::Occupancy => "OCCUPANCY",
            HistoricalMetricName::QueuedTime => "QUEUED_TIME",
            HistoricalMetricName::QueueAnswerTime => "QUEUE_ANSWER_TIME",
            HistoricalMetricName::ServiceLevel => "SERVICE_LEVEL",
            HistoricalMetricName::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ABANDON_TIME",
            "AFTER_CONTACT_WORK_TIME",
            "API_CONTACTS_HANDLED",
            "CALLBACK_CONTACTS_HANDLED",
            "CONTACTS_ABANDONED",
            "CONTACTS_AGENT_HUNG_UP_FIRST",
            "CONTACTS_CONSULTED",
            "CONTACTS_HANDLED",
            "CONTACTS_HANDLED_INCOMING",
            "CONTACTS_HANDLED_OUTBOUND",
            "CONTACTS_HOLD_ABANDONS",
            "CONTACTS_MISSED",
            "CONTACTS_QUEUED",
            "CONTACTS_TRANSFERRED_IN",
            "CONTACTS_TRANSFERRED_IN_FROM_QUEUE",
            "CONTACTS_TRANSFERRED_OUT",
            "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE",
            "HANDLE_TIME",
            "HOLD_TIME",
            "INTERACTION_AND_HOLD_TIME",
            "INTERACTION_TIME",
            "OCCUPANCY",
            "QUEUED_TIME",
            "QUEUE_ANSWER_TIME",
            "SERVICE_LEVEL",
        ]
    }
}
impl AsRef<str> for HistoricalMetricName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the dimensions for a set of metrics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Dimensions {
    /// <p>Information about the queue for which metrics are returned.</p>
    pub queue: std::option::Option<crate::model::QueueReference>,
    /// <p>The channel used for grouping and filters.</p>
    pub channel: std::option::Option<crate::model::Channel>,
}
impl Dimensions {
    /// <p>Information about the queue for which metrics are returned.</p>
    pub fn queue(&self) -> std::option::Option<&crate::model::QueueReference> {
        self.queue.as_ref()
    }
    /// <p>The channel used for grouping and filters.</p>
    pub fn channel(&self) -> std::option::Option<&crate::model::Channel> {
        self.channel.as_ref()
    }
}
impl std::fmt::Debug for Dimensions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Dimensions");
        formatter.field("queue", &self.queue);
        formatter.field("channel", &self.channel);
        formatter.finish()
    }
}
/// See [`Dimensions`](crate::model::Dimensions)
pub mod dimensions {

    /// A builder for [`Dimensions`](crate::model::Dimensions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queue: std::option::Option<crate::model::QueueReference>,
        pub(crate) channel: std::option::Option<crate::model::Channel>,
    }
    impl Builder {
        /// <p>Information about the queue for which metrics are returned.</p>
        pub fn queue(mut self, input: crate::model::QueueReference) -> Self {
            self.queue = Some(input);
            self
        }
        /// <p>Information about the queue for which metrics are returned.</p>
        pub fn set_queue(
            mut self,
            input: std::option::Option<crate::model::QueueReference>,
        ) -> Self {
            self.queue = input;
            self
        }
        /// <p>The channel used for grouping and filters.</p>
        pub fn channel(mut self, input: crate::model::Channel) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>The channel used for grouping and filters.</p>
        pub fn set_channel(mut self, input: std::option::Option<crate::model::Channel>) -> Self {
            self.channel = input;
            self
        }
        /// Consumes the builder and constructs a [`Dimensions`](crate::model::Dimensions)
        pub fn build(self) -> crate::model::Dimensions {
            crate::model::Dimensions {
                queue: self.queue,
                channel: self.channel,
            }
        }
    }
}
impl Dimensions {
    /// Creates a new builder-style object to manufacture [`Dimensions`](crate::model::Dimensions)
    pub fn builder() -> crate::model::dimensions::Builder {
        crate::model::dimensions::Builder::default()
    }
}

/// <p>Contains information about a queue resource for which metrics are returned.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueueReference {
    /// <p>The identifier of the queue.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl QueueReference {
    /// <p>The identifier of the queue.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for QueueReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueueReference");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`QueueReference`](crate::model::QueueReference)
pub mod queue_reference {

    /// A builder for [`QueueReference`](crate::model::QueueReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the queue.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the queue.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the queue.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the queue.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`QueueReference`](crate::model::QueueReference)
        pub fn build(self) -> crate::model::QueueReference {
            crate::model::QueueReference {
                id: self.id,
                arn: self.arn,
            }
        }
    }
}
impl QueueReference {
    /// Creates a new builder-style object to manufacture [`QueueReference`](crate::model::QueueReference)
    pub fn builder() -> crate::model::queue_reference::Builder {
        crate::model::queue_reference::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Grouping {
    #[allow(missing_docs)] // documentation missing in model
    Channel,
    #[allow(missing_docs)] // documentation missing in model
    Queue,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Grouping {
    fn from(s: &str) -> Self {
        match s {
            "CHANNEL" => Grouping::Channel,
            "QUEUE" => Grouping::Queue,
            other => Grouping::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Grouping {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Grouping::from(s))
    }
}
impl Grouping {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Grouping::Channel => "CHANNEL",
            Grouping::Queue => "QUEUE",
            Grouping::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CHANNEL", "QUEUE"]
    }
}
impl AsRef<str> for Grouping {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains the filter to apply when retrieving metrics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Filters {
    /// <p>The queues to use to filter the metrics. You should specify at least one queue, and can specify up to 100 queues per request. The <code>GetCurrentMetricsData</code> API in particular requires a queue when you include a <code>Filter</code> in your request. </p>
    pub queues: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The channel to use to filter the metrics.</p>
    pub channels: std::option::Option<std::vec::Vec<crate::model::Channel>>,
}
impl Filters {
    /// <p>The queues to use to filter the metrics. You should specify at least one queue, and can specify up to 100 queues per request. The <code>GetCurrentMetricsData</code> API in particular requires a queue when you include a <code>Filter</code> in your request. </p>
    pub fn queues(&self) -> std::option::Option<&[std::string::String]> {
        self.queues.as_deref()
    }
    /// <p>The channel to use to filter the metrics.</p>
    pub fn channels(&self) -> std::option::Option<&[crate::model::Channel]> {
        self.channels.as_deref()
    }
}
impl std::fmt::Debug for Filters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Filters");
        formatter.field("queues", &self.queues);
        formatter.field("channels", &self.channels);
        formatter.finish()
    }
}
/// See [`Filters`](crate::model::Filters)
pub mod filters {

    /// A builder for [`Filters`](crate::model::Filters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queues: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) channels: std::option::Option<std::vec::Vec<crate::model::Channel>>,
    }
    impl Builder {
        /// Appends an item to `queues`.
        ///
        /// To override the contents of this collection use [`set_queues`](Self::set_queues).
        ///
        /// <p>The queues to use to filter the metrics. You should specify at least one queue, and can specify up to 100 queues per request. The <code>GetCurrentMetricsData</code> API in particular requires a queue when you include a <code>Filter</code> in your request. </p>
        pub fn queues(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.queues.unwrap_or_default();
            v.push(input.into());
            self.queues = Some(v);
            self
        }
        /// <p>The queues to use to filter the metrics. You should specify at least one queue, and can specify up to 100 queues per request. The <code>GetCurrentMetricsData</code> API in particular requires a queue when you include a <code>Filter</code> in your request. </p>
        pub fn set_queues(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.queues = input;
            self
        }
        /// Appends an item to `channels`.
        ///
        /// To override the contents of this collection use [`set_channels`](Self::set_channels).
        ///
        /// <p>The channel to use to filter the metrics.</p>
        pub fn channels(mut self, input: crate::model::Channel) -> Self {
            let mut v = self.channels.unwrap_or_default();
            v.push(input);
            self.channels = Some(v);
            self
        }
        /// <p>The channel to use to filter the metrics.</p>
        pub fn set_channels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        ) -> Self {
            self.channels = input;
            self
        }
        /// Consumes the builder and constructs a [`Filters`](crate::model::Filters)
        pub fn build(self) -> crate::model::Filters {
            crate::model::Filters {
                queues: self.queues,
                channels: self.channels,
            }
        }
    }
}
impl Filters {
    /// Creates a new builder-style object to manufacture [`Filters`](crate::model::Filters)
    pub fn builder() -> crate::model::filters::Builder {
        crate::model::filters::Builder::default()
    }
}

/// <p>Contains credentials to use for federation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Credentials {
    /// <p>An access token generated for a federated user to access Amazon Connect.</p>
    pub access_token: std::option::Option<std::string::String>,
    /// <p>A token generated with an expiration time for the session a user is logged in to Amazon Connect.</p>
    pub access_token_expiration: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Renews a token generated for a user to access the Amazon Connect instance.</p>
    pub refresh_token: std::option::Option<std::string::String>,
    /// <p>Renews the expiration timer for a generated token.</p>
    pub refresh_token_expiration: std::option::Option<aws_smithy_types::DateTime>,
}
impl Credentials {
    /// <p>An access token generated for a federated user to access Amazon Connect.</p>
    pub fn access_token(&self) -> std::option::Option<&str> {
        self.access_token.as_deref()
    }
    /// <p>A token generated with an expiration time for the session a user is logged in to Amazon Connect.</p>
    pub fn access_token_expiration(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.access_token_expiration.as_ref()
    }
    /// <p>Renews a token generated for a user to access the Amazon Connect instance.</p>
    pub fn refresh_token(&self) -> std::option::Option<&str> {
        self.refresh_token.as_deref()
    }
    /// <p>Renews the expiration timer for a generated token.</p>
    pub fn refresh_token_expiration(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.refresh_token_expiration.as_ref()
    }
}
impl std::fmt::Debug for Credentials {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Credentials");
        formatter.field("access_token", &"*** Sensitive Data Redacted ***");
        formatter.field("access_token_expiration", &self.access_token_expiration);
        formatter.field("refresh_token", &"*** Sensitive Data Redacted ***");
        formatter.field("refresh_token_expiration", &self.refresh_token_expiration);
        formatter.finish()
    }
}
/// See [`Credentials`](crate::model::Credentials)
pub mod credentials {

    /// A builder for [`Credentials`](crate::model::Credentials)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_token: std::option::Option<std::string::String>,
        pub(crate) access_token_expiration: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) refresh_token: std::option::Option<std::string::String>,
        pub(crate) refresh_token_expiration: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>An access token generated for a federated user to access Amazon Connect.</p>
        pub fn access_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_token = Some(input.into());
            self
        }
        /// <p>An access token generated for a federated user to access Amazon Connect.</p>
        pub fn set_access_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.access_token = input;
            self
        }
        /// <p>A token generated with an expiration time for the session a user is logged in to Amazon Connect.</p>
        pub fn access_token_expiration(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.access_token_expiration = Some(input);
            self
        }
        /// <p>A token generated with an expiration time for the session a user is logged in to Amazon Connect.</p>
        pub fn set_access_token_expiration(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.access_token_expiration = input;
            self
        }
        /// <p>Renews a token generated for a user to access the Amazon Connect instance.</p>
        pub fn refresh_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.refresh_token = Some(input.into());
            self
        }
        /// <p>Renews a token generated for a user to access the Amazon Connect instance.</p>
        pub fn set_refresh_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.refresh_token = input;
            self
        }
        /// <p>Renews the expiration timer for a generated token.</p>
        pub fn refresh_token_expiration(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.refresh_token_expiration = Some(input);
            self
        }
        /// <p>Renews the expiration timer for a generated token.</p>
        pub fn set_refresh_token_expiration(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.refresh_token_expiration = input;
            self
        }
        /// Consumes the builder and constructs a [`Credentials`](crate::model::Credentials)
        pub fn build(self) -> crate::model::Credentials {
            crate::model::Credentials {
                access_token: self.access_token,
                access_token_expiration: self.access_token_expiration,
                refresh_token: self.refresh_token,
                refresh_token_expiration: self.refresh_token_expiration,
            }
        }
    }
}
impl Credentials {
    /// Creates a new builder-style object to manufacture [`Credentials`](crate::model::Credentials)
    pub fn builder() -> crate::model::credentials::Builder {
        crate::model::credentials::Builder::default()
    }
}

/// <p>Data for a user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserData {
    /// <p>Information about the user for the data that is returned. It contains resourceId and ARN of the user. </p>
    pub user: std::option::Option<crate::model::UserReference>,
    /// <p>Information about the routing profile that is assigned to the user.</p>
    pub routing_profile: std::option::Option<crate::model::RoutingProfileReference>,
    /// <p>Contains information about the levels of a hierarchy group assigned to a user.</p>
    pub hierarchy_path: std::option::Option<crate::model::HierarchyPathReference>,
    /// <p>The status of the agent that they manually set in their Contact Control Panel (CCP), or that the supervisor manually changes in the real-time metrics report.</p>
    pub status: std::option::Option<crate::model::AgentStatusReference>,
    /// <p>A map of available slots by channel. The key is a channel name. The value is an integer: the available number of slots. </p>
    pub available_slots_by_channel:
        std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
    /// <p>A map of maximum slots by channel. The key is a channel name. The value is an integer: the maximum number of slots. This is calculated from <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_MediaConcurrency.html">MediaConcurrency</a> of the RoutingProfile assigned to the agent. </p>
    pub max_slots_by_channel:
        std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
    /// <p> A map of active slots by channel. The key is a channel name. The value is an integer: the number of active slots. </p>
    pub active_slots_by_channel:
        std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
    /// <p>A list of contact reference information.</p>
    pub contacts: std::option::Option<std::vec::Vec<crate::model::AgentContactReference>>,
}
impl UserData {
    /// <p>Information about the user for the data that is returned. It contains resourceId and ARN of the user. </p>
    pub fn user(&self) -> std::option::Option<&crate::model::UserReference> {
        self.user.as_ref()
    }
    /// <p>Information about the routing profile that is assigned to the user.</p>
    pub fn routing_profile(&self) -> std::option::Option<&crate::model::RoutingProfileReference> {
        self.routing_profile.as_ref()
    }
    /// <p>Contains information about the levels of a hierarchy group assigned to a user.</p>
    pub fn hierarchy_path(&self) -> std::option::Option<&crate::model::HierarchyPathReference> {
        self.hierarchy_path.as_ref()
    }
    /// <p>The status of the agent that they manually set in their Contact Control Panel (CCP), or that the supervisor manually changes in the real-time metrics report.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AgentStatusReference> {
        self.status.as_ref()
    }
    /// <p>A map of available slots by channel. The key is a channel name. The value is an integer: the available number of slots. </p>
    pub fn available_slots_by_channel(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::Channel, i32>> {
        self.available_slots_by_channel.as_ref()
    }
    /// <p>A map of maximum slots by channel. The key is a channel name. The value is an integer: the maximum number of slots. This is calculated from <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_MediaConcurrency.html">MediaConcurrency</a> of the RoutingProfile assigned to the agent. </p>
    pub fn max_slots_by_channel(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::Channel, i32>> {
        self.max_slots_by_channel.as_ref()
    }
    /// <p> A map of active slots by channel. The key is a channel name. The value is an integer: the number of active slots. </p>
    pub fn active_slots_by_channel(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::Channel, i32>> {
        self.active_slots_by_channel.as_ref()
    }
    /// <p>A list of contact reference information.</p>
    pub fn contacts(&self) -> std::option::Option<&[crate::model::AgentContactReference]> {
        self.contacts.as_deref()
    }
}
impl std::fmt::Debug for UserData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserData");
        formatter.field("user", &self.user);
        formatter.field("routing_profile", &self.routing_profile);
        formatter.field("hierarchy_path", &self.hierarchy_path);
        formatter.field("status", &self.status);
        formatter.field(
            "available_slots_by_channel",
            &self.available_slots_by_channel,
        );
        formatter.field("max_slots_by_channel", &self.max_slots_by_channel);
        formatter.field("active_slots_by_channel", &self.active_slots_by_channel);
        formatter.field("contacts", &self.contacts);
        formatter.finish()
    }
}
/// See [`UserData`](crate::model::UserData)
pub mod user_data {

    /// A builder for [`UserData`](crate::model::UserData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user: std::option::Option<crate::model::UserReference>,
        pub(crate) routing_profile: std::option::Option<crate::model::RoutingProfileReference>,
        pub(crate) hierarchy_path: std::option::Option<crate::model::HierarchyPathReference>,
        pub(crate) status: std::option::Option<crate::model::AgentStatusReference>,
        pub(crate) available_slots_by_channel:
            std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
        pub(crate) max_slots_by_channel:
            std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
        pub(crate) active_slots_by_channel:
            std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
        pub(crate) contacts:
            std::option::Option<std::vec::Vec<crate::model::AgentContactReference>>,
    }
    impl Builder {
        /// <p>Information about the user for the data that is returned. It contains resourceId and ARN of the user. </p>
        pub fn user(mut self, input: crate::model::UserReference) -> Self {
            self.user = Some(input);
            self
        }
        /// <p>Information about the user for the data that is returned. It contains resourceId and ARN of the user. </p>
        pub fn set_user(mut self, input: std::option::Option<crate::model::UserReference>) -> Self {
            self.user = input;
            self
        }
        /// <p>Information about the routing profile that is assigned to the user.</p>
        pub fn routing_profile(mut self, input: crate::model::RoutingProfileReference) -> Self {
            self.routing_profile = Some(input);
            self
        }
        /// <p>Information about the routing profile that is assigned to the user.</p>
        pub fn set_routing_profile(
            mut self,
            input: std::option::Option<crate::model::RoutingProfileReference>,
        ) -> Self {
            self.routing_profile = input;
            self
        }
        /// <p>Contains information about the levels of a hierarchy group assigned to a user.</p>
        pub fn hierarchy_path(mut self, input: crate::model::HierarchyPathReference) -> Self {
            self.hierarchy_path = Some(input);
            self
        }
        /// <p>Contains information about the levels of a hierarchy group assigned to a user.</p>
        pub fn set_hierarchy_path(
            mut self,
            input: std::option::Option<crate::model::HierarchyPathReference>,
        ) -> Self {
            self.hierarchy_path = input;
            self
        }
        /// <p>The status of the agent that they manually set in their Contact Control Panel (CCP), or that the supervisor manually changes in the real-time metrics report.</p>
        pub fn status(mut self, input: crate::model::AgentStatusReference) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the agent that they manually set in their Contact Control Panel (CCP), or that the supervisor manually changes in the real-time metrics report.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AgentStatusReference>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Adds a key-value pair to `available_slots_by_channel`.
        ///
        /// To override the contents of this collection use [`set_available_slots_by_channel`](Self::set_available_slots_by_channel).
        ///
        /// <p>A map of available slots by channel. The key is a channel name. The value is an integer: the available number of slots. </p>
        pub fn available_slots_by_channel(mut self, k: crate::model::Channel, v: i32) -> Self {
            let mut hash_map = self.available_slots_by_channel.unwrap_or_default();
            hash_map.insert(k, v);
            self.available_slots_by_channel = Some(hash_map);
            self
        }
        /// <p>A map of available slots by channel. The key is a channel name. The value is an integer: the available number of slots. </p>
        pub fn set_available_slots_by_channel(
            mut self,
            input: std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
        ) -> Self {
            self.available_slots_by_channel = input;
            self
        }
        /// Adds a key-value pair to `max_slots_by_channel`.
        ///
        /// To override the contents of this collection use [`set_max_slots_by_channel`](Self::set_max_slots_by_channel).
        ///
        /// <p>A map of maximum slots by channel. The key is a channel name. The value is an integer: the maximum number of slots. This is calculated from <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_MediaConcurrency.html">MediaConcurrency</a> of the RoutingProfile assigned to the agent. </p>
        pub fn max_slots_by_channel(mut self, k: crate::model::Channel, v: i32) -> Self {
            let mut hash_map = self.max_slots_by_channel.unwrap_or_default();
            hash_map.insert(k, v);
            self.max_slots_by_channel = Some(hash_map);
            self
        }
        /// <p>A map of maximum slots by channel. The key is a channel name. The value is an integer: the maximum number of slots. This is calculated from <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_MediaConcurrency.html">MediaConcurrency</a> of the RoutingProfile assigned to the agent. </p>
        pub fn set_max_slots_by_channel(
            mut self,
            input: std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
        ) -> Self {
            self.max_slots_by_channel = input;
            self
        }
        /// Adds a key-value pair to `active_slots_by_channel`.
        ///
        /// To override the contents of this collection use [`set_active_slots_by_channel`](Self::set_active_slots_by_channel).
        ///
        /// <p> A map of active slots by channel. The key is a channel name. The value is an integer: the number of active slots. </p>
        pub fn active_slots_by_channel(mut self, k: crate::model::Channel, v: i32) -> Self {
            let mut hash_map = self.active_slots_by_channel.unwrap_or_default();
            hash_map.insert(k, v);
            self.active_slots_by_channel = Some(hash_map);
            self
        }
        /// <p> A map of active slots by channel. The key is a channel name. The value is an integer: the number of active slots. </p>
        pub fn set_active_slots_by_channel(
            mut self,
            input: std::option::Option<std::collections::HashMap<crate::model::Channel, i32>>,
        ) -> Self {
            self.active_slots_by_channel = input;
            self
        }
        /// Appends an item to `contacts`.
        ///
        /// To override the contents of this collection use [`set_contacts`](Self::set_contacts).
        ///
        /// <p>A list of contact reference information.</p>
        pub fn contacts(mut self, input: crate::model::AgentContactReference) -> Self {
            let mut v = self.contacts.unwrap_or_default();
            v.push(input);
            self.contacts = Some(v);
            self
        }
        /// <p>A list of contact reference information.</p>
        pub fn set_contacts(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AgentContactReference>>,
        ) -> Self {
            self.contacts = input;
            self
        }
        /// Consumes the builder and constructs a [`UserData`](crate::model::UserData)
        pub fn build(self) -> crate::model::UserData {
            crate::model::UserData {
                user: self.user,
                routing_profile: self.routing_profile,
                hierarchy_path: self.hierarchy_path,
                status: self.status,
                available_slots_by_channel: self.available_slots_by_channel,
                max_slots_by_channel: self.max_slots_by_channel,
                active_slots_by_channel: self.active_slots_by_channel,
                contacts: self.contacts,
            }
        }
    }
}
impl UserData {
    /// Creates a new builder-style object to manufacture [`UserData`](crate::model::UserData)
    pub fn builder() -> crate::model::user_data::Builder {
        crate::model::user_data::Builder::default()
    }
}

/// <p>Information about the <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_Contact.html">contact</a> associated to the user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AgentContactReference {
    /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The channel of the contact.</p>
    pub channel: std::option::Option<crate::model::Channel>,
    /// <p>How the contact was initiated.</p>
    pub initiation_method: std::option::Option<crate::model::ContactInitiationMethod>,
    /// <p>The <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">state of the contact</a>.</p>
    pub agent_contact_state: std::option::Option<crate::model::ContactState>,
    /// <p>The epoch timestamp when the contact state started.</p>
    pub state_start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the contact was connected to an agent.</p>
    pub connected_to_agent_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Contains information about a queue resource for which metrics are returned.</p>
    pub queue: std::option::Option<crate::model::QueueReference>,
}
impl AgentContactReference {
    /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The channel of the contact.</p>
    pub fn channel(&self) -> std::option::Option<&crate::model::Channel> {
        self.channel.as_ref()
    }
    /// <p>How the contact was initiated.</p>
    pub fn initiation_method(&self) -> std::option::Option<&crate::model::ContactInitiationMethod> {
        self.initiation_method.as_ref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">state of the contact</a>.</p>
    pub fn agent_contact_state(&self) -> std::option::Option<&crate::model::ContactState> {
        self.agent_contact_state.as_ref()
    }
    /// <p>The epoch timestamp when the contact state started.</p>
    pub fn state_start_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.state_start_timestamp.as_ref()
    }
    /// <p>The time at which the contact was connected to an agent.</p>
    pub fn connected_to_agent_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.connected_to_agent_timestamp.as_ref()
    }
    /// <p>Contains information about a queue resource for which metrics are returned.</p>
    pub fn queue(&self) -> std::option::Option<&crate::model::QueueReference> {
        self.queue.as_ref()
    }
}
impl std::fmt::Debug for AgentContactReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AgentContactReference");
        formatter.field("contact_id", &self.contact_id);
        formatter.field("channel", &self.channel);
        formatter.field("initiation_method", &self.initiation_method);
        formatter.field("agent_contact_state", &self.agent_contact_state);
        formatter.field("state_start_timestamp", &self.state_start_timestamp);
        formatter.field(
            "connected_to_agent_timestamp",
            &self.connected_to_agent_timestamp,
        );
        formatter.field("queue", &self.queue);
        formatter.finish()
    }
}
/// See [`AgentContactReference`](crate::model::AgentContactReference)
pub mod agent_contact_reference {

    /// A builder for [`AgentContactReference`](crate::model::AgentContactReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) channel: std::option::Option<crate::model::Channel>,
        pub(crate) initiation_method: std::option::Option<crate::model::ContactInitiationMethod>,
        pub(crate) agent_contact_state: std::option::Option<crate::model::ContactState>,
        pub(crate) state_start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) connected_to_agent_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) queue: std::option::Option<crate::model::QueueReference>,
    }
    impl Builder {
        /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The channel of the contact.</p>
        pub fn channel(mut self, input: crate::model::Channel) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>The channel of the contact.</p>
        pub fn set_channel(mut self, input: std::option::Option<crate::model::Channel>) -> Self {
            self.channel = input;
            self
        }
        /// <p>How the contact was initiated.</p>
        pub fn initiation_method(mut self, input: crate::model::ContactInitiationMethod) -> Self {
            self.initiation_method = Some(input);
            self
        }
        /// <p>How the contact was initiated.</p>
        pub fn set_initiation_method(
            mut self,
            input: std::option::Option<crate::model::ContactInitiationMethod>,
        ) -> Self {
            self.initiation_method = input;
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">state of the contact</a>.</p>
        pub fn agent_contact_state(mut self, input: crate::model::ContactState) -> Self {
            self.agent_contact_state = Some(input);
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">state of the contact</a>.</p>
        pub fn set_agent_contact_state(
            mut self,
            input: std::option::Option<crate::model::ContactState>,
        ) -> Self {
            self.agent_contact_state = input;
            self
        }
        /// <p>The epoch timestamp when the contact state started.</p>
        pub fn state_start_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.state_start_timestamp = Some(input);
            self
        }
        /// <p>The epoch timestamp when the contact state started.</p>
        pub fn set_state_start_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.state_start_timestamp = input;
            self
        }
        /// <p>The time at which the contact was connected to an agent.</p>
        pub fn connected_to_agent_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.connected_to_agent_timestamp = Some(input);
            self
        }
        /// <p>The time at which the contact was connected to an agent.</p>
        pub fn set_connected_to_agent_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.connected_to_agent_timestamp = input;
            self
        }
        /// <p>Contains information about a queue resource for which metrics are returned.</p>
        pub fn queue(mut self, input: crate::model::QueueReference) -> Self {
            self.queue = Some(input);
            self
        }
        /// <p>Contains information about a queue resource for which metrics are returned.</p>
        pub fn set_queue(
            mut self,
            input: std::option::Option<crate::model::QueueReference>,
        ) -> Self {
            self.queue = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentContactReference`](crate::model::AgentContactReference)
        pub fn build(self) -> crate::model::AgentContactReference {
            crate::model::AgentContactReference {
                contact_id: self.contact_id,
                channel: self.channel,
                initiation_method: self.initiation_method,
                agent_contact_state: self.agent_contact_state,
                state_start_timestamp: self.state_start_timestamp,
                connected_to_agent_timestamp: self.connected_to_agent_timestamp,
                queue: self.queue,
            }
        }
    }
}
impl AgentContactReference {
    /// Creates a new builder-style object to manufacture [`AgentContactReference`](crate::model::AgentContactReference)
    pub fn builder() -> crate::model::agent_contact_reference::Builder {
        crate::model::agent_contact_reference::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContactState {
    #[allow(missing_docs)] // documentation missing in model
    Connected,
    #[allow(missing_docs)] // documentation missing in model
    ConnectedOnhold,
    #[allow(missing_docs)] // documentation missing in model
    Connecting,
    #[allow(missing_docs)] // documentation missing in model
    Ended,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Incoming,
    #[allow(missing_docs)] // documentation missing in model
    Missed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContactState {
    fn from(s: &str) -> Self {
        match s {
            "CONNECTED" => ContactState::Connected,
            "CONNECTED_ONHOLD" => ContactState::ConnectedOnhold,
            "CONNECTING" => ContactState::Connecting,
            "ENDED" => ContactState::Ended,
            "ERROR" => ContactState::Error,
            "INCOMING" => ContactState::Incoming,
            "MISSED" => ContactState::Missed,
            "PENDING" => ContactState::Pending,
            "REJECTED" => ContactState::Rejected,
            other => ContactState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContactState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContactState::from(s))
    }
}
impl ContactState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContactState::Connected => "CONNECTED",
            ContactState::ConnectedOnhold => "CONNECTED_ONHOLD",
            ContactState::Connecting => "CONNECTING",
            ContactState::Ended => "ENDED",
            ContactState::Error => "ERROR",
            ContactState::Incoming => "INCOMING",
            ContactState::Missed => "MISSED",
            ContactState::Pending => "PENDING",
            ContactState::Rejected => "REJECTED",
            ContactState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CONNECTED",
            "CONNECTED_ONHOLD",
            "CONNECTING",
            "ENDED",
            "ERROR",
            "INCOMING",
            "MISSED",
            "PENDING",
            "REJECTED",
        ]
    }
}
impl AsRef<str> for ContactState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContactInitiationMethod {
    #[allow(missing_docs)] // documentation missing in model
    Api,
    #[allow(missing_docs)] // documentation missing in model
    Callback,
    #[allow(missing_docs)] // documentation missing in model
    Inbound,
    #[allow(missing_docs)] // documentation missing in model
    Outbound,
    #[allow(missing_docs)] // documentation missing in model
    QueueTransfer,
    #[allow(missing_docs)] // documentation missing in model
    Transfer,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContactInitiationMethod {
    fn from(s: &str) -> Self {
        match s {
            "API" => ContactInitiationMethod::Api,
            "CALLBACK" => ContactInitiationMethod::Callback,
            "INBOUND" => ContactInitiationMethod::Inbound,
            "OUTBOUND" => ContactInitiationMethod::Outbound,
            "QUEUE_TRANSFER" => ContactInitiationMethod::QueueTransfer,
            "TRANSFER" => ContactInitiationMethod::Transfer,
            other => ContactInitiationMethod::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContactInitiationMethod {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContactInitiationMethod::from(s))
    }
}
impl ContactInitiationMethod {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContactInitiationMethod::Api => "API",
            ContactInitiationMethod::Callback => "CALLBACK",
            ContactInitiationMethod::Inbound => "INBOUND",
            ContactInitiationMethod::Outbound => "OUTBOUND",
            ContactInitiationMethod::QueueTransfer => "QUEUE_TRANSFER",
            ContactInitiationMethod::Transfer => "TRANSFER",
            ContactInitiationMethod::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "API",
            "CALLBACK",
            "INBOUND",
            "OUTBOUND",
            "QUEUE_TRANSFER",
            "TRANSFER",
        ]
    }
}
impl AsRef<str> for ContactInitiationMethod {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the agent's status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AgentStatusReference {
    /// <p>The start timestamp of the agent's status.</p>
    pub status_start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) of the agent's status.</p>
    pub status_arn: std::option::Option<std::string::String>,
}
impl AgentStatusReference {
    /// <p>The start timestamp of the agent's status.</p>
    pub fn status_start_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.status_start_timestamp.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the agent's status.</p>
    pub fn status_arn(&self) -> std::option::Option<&str> {
        self.status_arn.as_deref()
    }
}
impl std::fmt::Debug for AgentStatusReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AgentStatusReference");
        formatter.field("status_start_timestamp", &self.status_start_timestamp);
        formatter.field("status_arn", &self.status_arn);
        formatter.finish()
    }
}
/// See [`AgentStatusReference`](crate::model::AgentStatusReference)
pub mod agent_status_reference {

    /// A builder for [`AgentStatusReference`](crate::model::AgentStatusReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status_start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The start timestamp of the agent's status.</p>
        pub fn status_start_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.status_start_timestamp = Some(input);
            self
        }
        /// <p>The start timestamp of the agent's status.</p>
        pub fn set_status_start_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.status_start_timestamp = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the agent's status.</p>
        pub fn status_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the agent's status.</p>
        pub fn set_status_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentStatusReference`](crate::model::AgentStatusReference)
        pub fn build(self) -> crate::model::AgentStatusReference {
            crate::model::AgentStatusReference {
                status_start_timestamp: self.status_start_timestamp,
                status_arn: self.status_arn,
            }
        }
    }
}
impl AgentStatusReference {
    /// Creates a new builder-style object to manufacture [`AgentStatusReference`](crate::model::AgentStatusReference)
    pub fn builder() -> crate::model::agent_status_reference::Builder {
        crate::model::agent_status_reference::Builder::default()
    }
}

/// <p>Information about the levels in the hierarchy group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HierarchyPathReference {
    /// <p>Information about level one.</p>
    pub level_one: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
    /// <p>Information about level two.</p>
    pub level_two: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
    /// <p>Information about level three.</p>
    pub level_three: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
    /// <p>Information about level four.</p>
    pub level_four: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
    /// <p>Information about level five.</p>
    pub level_five: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
}
impl HierarchyPathReference {
    /// <p>Information about level one.</p>
    pub fn level_one(&self) -> std::option::Option<&crate::model::HierarchyGroupSummaryReference> {
        self.level_one.as_ref()
    }
    /// <p>Information about level two.</p>
    pub fn level_two(&self) -> std::option::Option<&crate::model::HierarchyGroupSummaryReference> {
        self.level_two.as_ref()
    }
    /// <p>Information about level three.</p>
    pub fn level_three(
        &self,
    ) -> std::option::Option<&crate::model::HierarchyGroupSummaryReference> {
        self.level_three.as_ref()
    }
    /// <p>Information about level four.</p>
    pub fn level_four(&self) -> std::option::Option<&crate::model::HierarchyGroupSummaryReference> {
        self.level_four.as_ref()
    }
    /// <p>Information about level five.</p>
    pub fn level_five(&self) -> std::option::Option<&crate::model::HierarchyGroupSummaryReference> {
        self.level_five.as_ref()
    }
}
impl std::fmt::Debug for HierarchyPathReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HierarchyPathReference");
        formatter.field("level_one", &self.level_one);
        formatter.field("level_two", &self.level_two);
        formatter.field("level_three", &self.level_three);
        formatter.field("level_four", &self.level_four);
        formatter.field("level_five", &self.level_five);
        formatter.finish()
    }
}
/// See [`HierarchyPathReference`](crate::model::HierarchyPathReference)
pub mod hierarchy_path_reference {

    /// A builder for [`HierarchyPathReference`](crate::model::HierarchyPathReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) level_one: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        pub(crate) level_two: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        pub(crate) level_three: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        pub(crate) level_four: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        pub(crate) level_five: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
    }
    impl Builder {
        /// <p>Information about level one.</p>
        pub fn level_one(mut self, input: crate::model::HierarchyGroupSummaryReference) -> Self {
            self.level_one = Some(input);
            self
        }
        /// <p>Information about level one.</p>
        pub fn set_level_one(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        ) -> Self {
            self.level_one = input;
            self
        }
        /// <p>Information about level two.</p>
        pub fn level_two(mut self, input: crate::model::HierarchyGroupSummaryReference) -> Self {
            self.level_two = Some(input);
            self
        }
        /// <p>Information about level two.</p>
        pub fn set_level_two(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        ) -> Self {
            self.level_two = input;
            self
        }
        /// <p>Information about level three.</p>
        pub fn level_three(mut self, input: crate::model::HierarchyGroupSummaryReference) -> Self {
            self.level_three = Some(input);
            self
        }
        /// <p>Information about level three.</p>
        pub fn set_level_three(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        ) -> Self {
            self.level_three = input;
            self
        }
        /// <p>Information about level four.</p>
        pub fn level_four(mut self, input: crate::model::HierarchyGroupSummaryReference) -> Self {
            self.level_four = Some(input);
            self
        }
        /// <p>Information about level four.</p>
        pub fn set_level_four(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        ) -> Self {
            self.level_four = input;
            self
        }
        /// <p>Information about level five.</p>
        pub fn level_five(mut self, input: crate::model::HierarchyGroupSummaryReference) -> Self {
            self.level_five = Some(input);
            self
        }
        /// <p>Information about level five.</p>
        pub fn set_level_five(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummaryReference>,
        ) -> Self {
            self.level_five = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyPathReference`](crate::model::HierarchyPathReference)
        pub fn build(self) -> crate::model::HierarchyPathReference {
            crate::model::HierarchyPathReference {
                level_one: self.level_one,
                level_two: self.level_two,
                level_three: self.level_three,
                level_four: self.level_four,
                level_five: self.level_five,
            }
        }
    }
}
impl HierarchyPathReference {
    /// Creates a new builder-style object to manufacture [`HierarchyPathReference`](crate::model::HierarchyPathReference)
    pub fn builder() -> crate::model::hierarchy_path_reference::Builder {
        crate::model::hierarchy_path_reference::Builder::default()
    }
}

/// <p>Information about the hierarchy group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HierarchyGroupSummaryReference {
    /// <p>The unique identifier for the hierarchy group.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the hierarchy group. </p>
    pub arn: std::option::Option<std::string::String>,
}
impl HierarchyGroupSummaryReference {
    /// <p>The unique identifier for the hierarchy group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the hierarchy group. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for HierarchyGroupSummaryReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HierarchyGroupSummaryReference");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`HierarchyGroupSummaryReference`](crate::model::HierarchyGroupSummaryReference)
pub mod hierarchy_group_summary_reference {

    /// A builder for [`HierarchyGroupSummaryReference`](crate::model::HierarchyGroupSummaryReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the hierarchy group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the hierarchy group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the hierarchy group. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the hierarchy group. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyGroupSummaryReference`](crate::model::HierarchyGroupSummaryReference)
        pub fn build(self) -> crate::model::HierarchyGroupSummaryReference {
            crate::model::HierarchyGroupSummaryReference {
                id: self.id,
                arn: self.arn,
            }
        }
    }
}
impl HierarchyGroupSummaryReference {
    /// Creates a new builder-style object to manufacture [`HierarchyGroupSummaryReference`](crate::model::HierarchyGroupSummaryReference)
    pub fn builder() -> crate::model::hierarchy_group_summary_reference::Builder {
        crate::model::hierarchy_group_summary_reference::Builder::default()
    }
}

/// <p>Information about the routing profile assigned to the user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RoutingProfileReference {
    /// <p>The identifier of the routing profile.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl RoutingProfileReference {
    /// <p>The identifier of the routing profile.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for RoutingProfileReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RoutingProfileReference");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`RoutingProfileReference`](crate::model::RoutingProfileReference)
pub mod routing_profile_reference {

    /// A builder for [`RoutingProfileReference`](crate::model::RoutingProfileReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the routing profile.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfileReference`](crate::model::RoutingProfileReference)
        pub fn build(self) -> crate::model::RoutingProfileReference {
            crate::model::RoutingProfileReference {
                id: self.id,
                arn: self.arn,
            }
        }
    }
}
impl RoutingProfileReference {
    /// Creates a new builder-style object to manufacture [`RoutingProfileReference`](crate::model::RoutingProfileReference)
    pub fn builder() -> crate::model::routing_profile_reference::Builder {
        crate::model::routing_profile_reference::Builder::default()
    }
}

/// <p>Information about the user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserReference {
    /// <p>The unique identifier for the user.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the user.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl UserReference {
    /// <p>The unique identifier for the user.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the user.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for UserReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserReference");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`UserReference`](crate::model::UserReference)
pub mod user_reference {

    /// A builder for [`UserReference`](crate::model::UserReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the user.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the user.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the user.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the user.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`UserReference`](crate::model::UserReference)
        pub fn build(self) -> crate::model::UserReference {
            crate::model::UserReference {
                id: self.id,
                arn: self.arn,
            }
        }
    }
}
impl UserReference {
    /// Creates a new builder-style object to manufacture [`UserReference`](crate::model::UserReference)
    pub fn builder() -> crate::model::user_reference::Builder {
        crate::model::user_reference::Builder::default()
    }
}

/// <p>A filter for the user data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserDataFilters {
    /// <p>Contains information about a queue resource for which metrics are returned.</p>
    pub queues: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A filter for the user data based on the contact information that is associated to the user. It contains a list of contact states. </p>
    pub contact_filter: std::option::Option<crate::model::ContactFilter>,
}
impl UserDataFilters {
    /// <p>Contains information about a queue resource for which metrics are returned.</p>
    pub fn queues(&self) -> std::option::Option<&[std::string::String]> {
        self.queues.as_deref()
    }
    /// <p>A filter for the user data based on the contact information that is associated to the user. It contains a list of contact states. </p>
    pub fn contact_filter(&self) -> std::option::Option<&crate::model::ContactFilter> {
        self.contact_filter.as_ref()
    }
}
impl std::fmt::Debug for UserDataFilters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserDataFilters");
        formatter.field("queues", &self.queues);
        formatter.field("contact_filter", &self.contact_filter);
        formatter.finish()
    }
}
/// See [`UserDataFilters`](crate::model::UserDataFilters)
pub mod user_data_filters {

    /// A builder for [`UserDataFilters`](crate::model::UserDataFilters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) queues: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) contact_filter: std::option::Option<crate::model::ContactFilter>,
    }
    impl Builder {
        /// Appends an item to `queues`.
        ///
        /// To override the contents of this collection use [`set_queues`](Self::set_queues).
        ///
        /// <p>Contains information about a queue resource for which metrics are returned.</p>
        pub fn queues(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.queues.unwrap_or_default();
            v.push(input.into());
            self.queues = Some(v);
            self
        }
        /// <p>Contains information about a queue resource for which metrics are returned.</p>
        pub fn set_queues(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.queues = input;
            self
        }
        /// <p>A filter for the user data based on the contact information that is associated to the user. It contains a list of contact states. </p>
        pub fn contact_filter(mut self, input: crate::model::ContactFilter) -> Self {
            self.contact_filter = Some(input);
            self
        }
        /// <p>A filter for the user data based on the contact information that is associated to the user. It contains a list of contact states. </p>
        pub fn set_contact_filter(
            mut self,
            input: std::option::Option<crate::model::ContactFilter>,
        ) -> Self {
            self.contact_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`UserDataFilters`](crate::model::UserDataFilters)
        pub fn build(self) -> crate::model::UserDataFilters {
            crate::model::UserDataFilters {
                queues: self.queues,
                contact_filter: self.contact_filter,
            }
        }
    }
}
impl UserDataFilters {
    /// Creates a new builder-style object to manufacture [`UserDataFilters`](crate::model::UserDataFilters)
    pub fn builder() -> crate::model::user_data_filters::Builder {
        crate::model::user_data_filters::Builder::default()
    }
}

/// <p>Filters user data based on the contact information that is associated to the users. It contains a list of <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">contact states</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContactFilter {
    /// <p>A list of up to 9 <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">contact states</a>.</p>
    pub contact_states: std::option::Option<std::vec::Vec<crate::model::ContactState>>,
}
impl ContactFilter {
    /// <p>A list of up to 9 <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">contact states</a>.</p>
    pub fn contact_states(&self) -> std::option::Option<&[crate::model::ContactState]> {
        self.contact_states.as_deref()
    }
}
impl std::fmt::Debug for ContactFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContactFilter");
        formatter.field("contact_states", &self.contact_states);
        formatter.finish()
    }
}
/// See [`ContactFilter`](crate::model::ContactFilter)
pub mod contact_filter {

    /// A builder for [`ContactFilter`](crate::model::ContactFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) contact_states: std::option::Option<std::vec::Vec<crate::model::ContactState>>,
    }
    impl Builder {
        /// Appends an item to `contact_states`.
        ///
        /// To override the contents of this collection use [`set_contact_states`](Self::set_contact_states).
        ///
        /// <p>A list of up to 9 <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">contact states</a>.</p>
        pub fn contact_states(mut self, input: crate::model::ContactState) -> Self {
            let mut v = self.contact_states.unwrap_or_default();
            v.push(input);
            self.contact_states = Some(v);
            self
        }
        /// <p>A list of up to 9 <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">contact states</a>.</p>
        pub fn set_contact_states(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContactState>>,
        ) -> Self {
            self.contact_states = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactFilter`](crate::model::ContactFilter)
        pub fn build(self) -> crate::model::ContactFilter {
            crate::model::ContactFilter {
                contact_states: self.contact_states,
            }
        }
    }
}
impl ContactFilter {
    /// Creates a new builder-style object to manufacture [`ContactFilter`](crate::model::ContactFilter)
    pub fn builder() -> crate::model::contact_filter::Builder {
        crate::model::contact_filter::Builder::default()
    }
}

/// <p>Contains information about a set of real-time metrics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CurrentMetricResult {
    /// <p>The dimensions for the metrics.</p>
    pub dimensions: std::option::Option<crate::model::Dimensions>,
    /// <p>The set of metrics.</p>
    pub collections: std::option::Option<std::vec::Vec<crate::model::CurrentMetricData>>,
}
impl CurrentMetricResult {
    /// <p>The dimensions for the metrics.</p>
    pub fn dimensions(&self) -> std::option::Option<&crate::model::Dimensions> {
        self.dimensions.as_ref()
    }
    /// <p>The set of metrics.</p>
    pub fn collections(&self) -> std::option::Option<&[crate::model::CurrentMetricData]> {
        self.collections.as_deref()
    }
}
impl std::fmt::Debug for CurrentMetricResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CurrentMetricResult");
        formatter.field("dimensions", &self.dimensions);
        formatter.field("collections", &self.collections);
        formatter.finish()
    }
}
/// See [`CurrentMetricResult`](crate::model::CurrentMetricResult)
pub mod current_metric_result {

    /// A builder for [`CurrentMetricResult`](crate::model::CurrentMetricResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimensions: std::option::Option<crate::model::Dimensions>,
        pub(crate) collections: std::option::Option<std::vec::Vec<crate::model::CurrentMetricData>>,
    }
    impl Builder {
        /// <p>The dimensions for the metrics.</p>
        pub fn dimensions(mut self, input: crate::model::Dimensions) -> Self {
            self.dimensions = Some(input);
            self
        }
        /// <p>The dimensions for the metrics.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<crate::model::Dimensions>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// Appends an item to `collections`.
        ///
        /// To override the contents of this collection use [`set_collections`](Self::set_collections).
        ///
        /// <p>The set of metrics.</p>
        pub fn collections(mut self, input: crate::model::CurrentMetricData) -> Self {
            let mut v = self.collections.unwrap_or_default();
            v.push(input);
            self.collections = Some(v);
            self
        }
        /// <p>The set of metrics.</p>
        pub fn set_collections(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CurrentMetricData>>,
        ) -> Self {
            self.collections = input;
            self
        }
        /// Consumes the builder and constructs a [`CurrentMetricResult`](crate::model::CurrentMetricResult)
        pub fn build(self) -> crate::model::CurrentMetricResult {
            crate::model::CurrentMetricResult {
                dimensions: self.dimensions,
                collections: self.collections,
            }
        }
    }
}
impl CurrentMetricResult {
    /// Creates a new builder-style object to manufacture [`CurrentMetricResult`](crate::model::CurrentMetricResult)
    pub fn builder() -> crate::model::current_metric_result::Builder {
        crate::model::current_metric_result::Builder::default()
    }
}

/// <p>Contains the data for a real-time metric.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CurrentMetricData {
    /// <p>Information about the metric.</p>
    pub metric: std::option::Option<crate::model::CurrentMetric>,
    /// <p>The value of the metric.</p>
    pub value: std::option::Option<f64>,
}
impl CurrentMetricData {
    /// <p>Information about the metric.</p>
    pub fn metric(&self) -> std::option::Option<&crate::model::CurrentMetric> {
        self.metric.as_ref()
    }
    /// <p>The value of the metric.</p>
    pub fn value(&self) -> std::option::Option<f64> {
        self.value
    }
}
impl std::fmt::Debug for CurrentMetricData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CurrentMetricData");
        formatter.field("metric", &self.metric);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`CurrentMetricData`](crate::model::CurrentMetricData)
pub mod current_metric_data {

    /// A builder for [`CurrentMetricData`](crate::model::CurrentMetricData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric: std::option::Option<crate::model::CurrentMetric>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>Information about the metric.</p>
        pub fn metric(mut self, input: crate::model::CurrentMetric) -> Self {
            self.metric = Some(input);
            self
        }
        /// <p>Information about the metric.</p>
        pub fn set_metric(
            mut self,
            input: std::option::Option<crate::model::CurrentMetric>,
        ) -> Self {
            self.metric = input;
            self
        }
        /// <p>The value of the metric.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the metric.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`CurrentMetricData`](crate::model::CurrentMetricData)
        pub fn build(self) -> crate::model::CurrentMetricData {
            crate::model::CurrentMetricData {
                metric: self.metric,
                value: self.value,
            }
        }
    }
}
impl CurrentMetricData {
    /// Creates a new builder-style object to manufacture [`CurrentMetricData`](crate::model::CurrentMetricData)
    pub fn builder() -> crate::model::current_metric_data::Builder {
        crate::model::current_metric_data::Builder::default()
    }
}

/// <p>Contains information about a real-time metric. For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CurrentMetric {
    /// <p>The name of the metric.</p>
    pub name: std::option::Option<crate::model::CurrentMetricName>,
    /// <p>The unit for the metric.</p>
    pub unit: std::option::Option<crate::model::Unit>,
}
impl CurrentMetric {
    /// <p>The name of the metric.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::CurrentMetricName> {
        self.name.as_ref()
    }
    /// <p>The unit for the metric.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::Unit> {
        self.unit.as_ref()
    }
}
impl std::fmt::Debug for CurrentMetric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CurrentMetric");
        formatter.field("name", &self.name);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}
/// See [`CurrentMetric`](crate::model::CurrentMetric)
pub mod current_metric {

    /// A builder for [`CurrentMetric`](crate::model::CurrentMetric)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::CurrentMetricName>,
        pub(crate) unit: std::option::Option<crate::model::Unit>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn name(mut self, input: crate::model::CurrentMetricName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the metric.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::CurrentMetricName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The unit for the metric.</p>
        pub fn unit(mut self, input: crate::model::Unit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit for the metric.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::Unit>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`CurrentMetric`](crate::model::CurrentMetric)
        pub fn build(self) -> crate::model::CurrentMetric {
            crate::model::CurrentMetric {
                name: self.name,
                unit: self.unit,
            }
        }
    }
}
impl CurrentMetric {
    /// Creates a new builder-style object to manufacture [`CurrentMetric`](crate::model::CurrentMetric)
    pub fn builder() -> crate::model::current_metric::Builder {
        crate::model::current_metric::Builder::default()
    }
}

/// <p>The current metric names.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CurrentMetricName {
    #[allow(missing_docs)] // documentation missing in model
    AgentsAfterContactWork,
    #[allow(missing_docs)] // documentation missing in model
    AgentsAvailable,
    #[allow(missing_docs)] // documentation missing in model
    AgentsError,
    #[allow(missing_docs)] // documentation missing in model
    AgentsNonProductive,
    #[allow(missing_docs)] // documentation missing in model
    AgentsOnline,
    #[allow(missing_docs)] // documentation missing in model
    AgentsOnCall,
    #[allow(missing_docs)] // documentation missing in model
    AgentsOnContact,
    #[allow(missing_docs)] // documentation missing in model
    AgentsStaffed,
    #[allow(missing_docs)] // documentation missing in model
    ContactsInQueue,
    #[allow(missing_docs)] // documentation missing in model
    ContactsScheduled,
    #[allow(missing_docs)] // documentation missing in model
    OldestContactAge,
    #[allow(missing_docs)] // documentation missing in model
    SlotsActive,
    #[allow(missing_docs)] // documentation missing in model
    SlotsAvailable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CurrentMetricName {
    fn from(s: &str) -> Self {
        match s {
            "AGENTS_AFTER_CONTACT_WORK" => CurrentMetricName::AgentsAfterContactWork,
            "AGENTS_AVAILABLE" => CurrentMetricName::AgentsAvailable,
            "AGENTS_ERROR" => CurrentMetricName::AgentsError,
            "AGENTS_NON_PRODUCTIVE" => CurrentMetricName::AgentsNonProductive,
            "AGENTS_ONLINE" => CurrentMetricName::AgentsOnline,
            "AGENTS_ON_CALL" => CurrentMetricName::AgentsOnCall,
            "AGENTS_ON_CONTACT" => CurrentMetricName::AgentsOnContact,
            "AGENTS_STAFFED" => CurrentMetricName::AgentsStaffed,
            "CONTACTS_IN_QUEUE" => CurrentMetricName::ContactsInQueue,
            "CONTACTS_SCHEDULED" => CurrentMetricName::ContactsScheduled,
            "OLDEST_CONTACT_AGE" => CurrentMetricName::OldestContactAge,
            "SLOTS_ACTIVE" => CurrentMetricName::SlotsActive,
            "SLOTS_AVAILABLE" => CurrentMetricName::SlotsAvailable,
            other => CurrentMetricName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CurrentMetricName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CurrentMetricName::from(s))
    }
}
impl CurrentMetricName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CurrentMetricName::AgentsAfterContactWork => "AGENTS_AFTER_CONTACT_WORK",
            CurrentMetricName::AgentsAvailable => "AGENTS_AVAILABLE",
            CurrentMetricName::AgentsError => "AGENTS_ERROR",
            CurrentMetricName::AgentsNonProductive => "AGENTS_NON_PRODUCTIVE",
            CurrentMetricName::AgentsOnline => "AGENTS_ONLINE",
            CurrentMetricName::AgentsOnCall => "AGENTS_ON_CALL",
            CurrentMetricName::AgentsOnContact => "AGENTS_ON_CONTACT",
            CurrentMetricName::AgentsStaffed => "AGENTS_STAFFED",
            CurrentMetricName::ContactsInQueue => "CONTACTS_IN_QUEUE",
            CurrentMetricName::ContactsScheduled => "CONTACTS_SCHEDULED",
            CurrentMetricName::OldestContactAge => "OLDEST_CONTACT_AGE",
            CurrentMetricName::SlotsActive => "SLOTS_ACTIVE",
            CurrentMetricName::SlotsAvailable => "SLOTS_AVAILABLE",
            CurrentMetricName::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AGENTS_AFTER_CONTACT_WORK",
            "AGENTS_AVAILABLE",
            "AGENTS_ERROR",
            "AGENTS_NON_PRODUCTIVE",
            "AGENTS_ONLINE",
            "AGENTS_ON_CALL",
            "AGENTS_ON_CONTACT",
            "AGENTS_STAFFED",
            "CONTACTS_IN_QUEUE",
            "CONTACTS_SCHEDULED",
            "OLDEST_CONTACT_AGE",
            "SLOTS_ACTIVE",
            "SLOTS_AVAILABLE",
        ]
    }
}
impl AsRef<str> for CurrentMetricName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about a custom vocabulary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Vocabulary {
    /// <p>A unique name of the custom vocabulary.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier of the custom vocabulary.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    pub language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
    /// <p>The current state of the custom vocabulary.</p>
    pub state: std::option::Option<crate::model::VocabularyState>,
    /// <p>The timestamp when the custom vocabulary was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The reason why the custom vocabulary was not created.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and <code>DisplayAs</code> fields. Separate the fields with TAB characters. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create a custom vocabulary using a table</a>.</p>
    pub content: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Vocabulary {
    /// <p>A unique name of the custom vocabulary.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier of the custom vocabulary.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::VocabularyLanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The current state of the custom vocabulary.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::VocabularyState> {
        self.state.as_ref()
    }
    /// <p>The timestamp when the custom vocabulary was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The reason why the custom vocabulary was not created.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and <code>DisplayAs</code> fields. Separate the fields with TAB characters. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create a custom vocabulary using a table</a>.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for Vocabulary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Vocabulary");
        formatter.field("name", &self.name);
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("language_code", &self.language_code);
        formatter.field("state", &self.state);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("content", &self.content);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Vocabulary`](crate::model::Vocabulary)
pub mod vocabulary {

    /// A builder for [`Vocabulary`](crate::model::Vocabulary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
        pub(crate) state: std::option::Option<crate::model::VocabularyState>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the custom vocabulary.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn language_code(mut self, input: crate::model::VocabularyLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::VocabularyLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The current state of the custom vocabulary.</p>
        pub fn state(mut self, input: crate::model::VocabularyState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the custom vocabulary.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The timestamp when the custom vocabulary was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp when the custom vocabulary was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The reason why the custom vocabulary was not created.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason why the custom vocabulary was not created.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and <code>DisplayAs</code> fields. Separate the fields with TAB characters. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create a custom vocabulary using a table</a>.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and <code>DisplayAs</code> fields. Separate the fields with TAB characters. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create a custom vocabulary using a table</a>.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Vocabulary`](crate::model::Vocabulary)
        pub fn build(self) -> crate::model::Vocabulary {
            crate::model::Vocabulary {
                name: self.name,
                id: self.id,
                arn: self.arn,
                language_code: self.language_code,
                state: self.state,
                last_modified_time: self.last_modified_time,
                failure_reason: self.failure_reason,
                content: self.content,
                tags: self.tags,
            }
        }
    }
}
impl Vocabulary {
    /// Creates a new builder-style object to manufacture [`Vocabulary`](crate::model::Vocabulary)
    pub fn builder() -> crate::model::vocabulary::Builder {
        crate::model::vocabulary::Builder::default()
    }
}

/// <p>Contains information about a hierarchy structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HierarchyStructure {
    /// <p>Information about level one.</p>
    pub level_one: std::option::Option<crate::model::HierarchyLevel>,
    /// <p>Information about level two.</p>
    pub level_two: std::option::Option<crate::model::HierarchyLevel>,
    /// <p>Information about level three.</p>
    pub level_three: std::option::Option<crate::model::HierarchyLevel>,
    /// <p>Information about level four.</p>
    pub level_four: std::option::Option<crate::model::HierarchyLevel>,
    /// <p>Information about level five.</p>
    pub level_five: std::option::Option<crate::model::HierarchyLevel>,
}
impl HierarchyStructure {
    /// <p>Information about level one.</p>
    pub fn level_one(&self) -> std::option::Option<&crate::model::HierarchyLevel> {
        self.level_one.as_ref()
    }
    /// <p>Information about level two.</p>
    pub fn level_two(&self) -> std::option::Option<&crate::model::HierarchyLevel> {
        self.level_two.as_ref()
    }
    /// <p>Information about level three.</p>
    pub fn level_three(&self) -> std::option::Option<&crate::model::HierarchyLevel> {
        self.level_three.as_ref()
    }
    /// <p>Information about level four.</p>
    pub fn level_four(&self) -> std::option::Option<&crate::model::HierarchyLevel> {
        self.level_four.as_ref()
    }
    /// <p>Information about level five.</p>
    pub fn level_five(&self) -> std::option::Option<&crate::model::HierarchyLevel> {
        self.level_five.as_ref()
    }
}
impl std::fmt::Debug for HierarchyStructure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HierarchyStructure");
        formatter.field("level_one", &self.level_one);
        formatter.field("level_two", &self.level_two);
        formatter.field("level_three", &self.level_three);
        formatter.field("level_four", &self.level_four);
        formatter.field("level_five", &self.level_five);
        formatter.finish()
    }
}
/// See [`HierarchyStructure`](crate::model::HierarchyStructure)
pub mod hierarchy_structure {

    /// A builder for [`HierarchyStructure`](crate::model::HierarchyStructure)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) level_one: std::option::Option<crate::model::HierarchyLevel>,
        pub(crate) level_two: std::option::Option<crate::model::HierarchyLevel>,
        pub(crate) level_three: std::option::Option<crate::model::HierarchyLevel>,
        pub(crate) level_four: std::option::Option<crate::model::HierarchyLevel>,
        pub(crate) level_five: std::option::Option<crate::model::HierarchyLevel>,
    }
    impl Builder {
        /// <p>Information about level one.</p>
        pub fn level_one(mut self, input: crate::model::HierarchyLevel) -> Self {
            self.level_one = Some(input);
            self
        }
        /// <p>Information about level one.</p>
        pub fn set_level_one(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevel>,
        ) -> Self {
            self.level_one = input;
            self
        }
        /// <p>Information about level two.</p>
        pub fn level_two(mut self, input: crate::model::HierarchyLevel) -> Self {
            self.level_two = Some(input);
            self
        }
        /// <p>Information about level two.</p>
        pub fn set_level_two(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevel>,
        ) -> Self {
            self.level_two = input;
            self
        }
        /// <p>Information about level three.</p>
        pub fn level_three(mut self, input: crate::model::HierarchyLevel) -> Self {
            self.level_three = Some(input);
            self
        }
        /// <p>Information about level three.</p>
        pub fn set_level_three(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevel>,
        ) -> Self {
            self.level_three = input;
            self
        }
        /// <p>Information about level four.</p>
        pub fn level_four(mut self, input: crate::model::HierarchyLevel) -> Self {
            self.level_four = Some(input);
            self
        }
        /// <p>Information about level four.</p>
        pub fn set_level_four(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevel>,
        ) -> Self {
            self.level_four = input;
            self
        }
        /// <p>Information about level five.</p>
        pub fn level_five(mut self, input: crate::model::HierarchyLevel) -> Self {
            self.level_five = Some(input);
            self
        }
        /// <p>Information about level five.</p>
        pub fn set_level_five(
            mut self,
            input: std::option::Option<crate::model::HierarchyLevel>,
        ) -> Self {
            self.level_five = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyStructure`](crate::model::HierarchyStructure)
        pub fn build(self) -> crate::model::HierarchyStructure {
            crate::model::HierarchyStructure {
                level_one: self.level_one,
                level_two: self.level_two,
                level_three: self.level_three,
                level_four: self.level_four,
                level_five: self.level_five,
            }
        }
    }
}
impl HierarchyStructure {
    /// Creates a new builder-style object to manufacture [`HierarchyStructure`](crate::model::HierarchyStructure)
    pub fn builder() -> crate::model::hierarchy_structure::Builder {
        crate::model::hierarchy_structure::Builder::default()
    }
}

/// <p>Contains information about a hierarchy level.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HierarchyLevel {
    /// <p>The identifier of the hierarchy level.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the hierarchy level.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the hierarchy level.</p>
    pub name: std::option::Option<std::string::String>,
}
impl HierarchyLevel {
    /// <p>The identifier of the hierarchy level.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the hierarchy level.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the hierarchy level.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for HierarchyLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HierarchyLevel");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`HierarchyLevel`](crate::model::HierarchyLevel)
pub mod hierarchy_level {

    /// A builder for [`HierarchyLevel`](crate::model::HierarchyLevel)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the hierarchy level.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the hierarchy level.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hierarchy level.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hierarchy level.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the hierarchy level.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hierarchy level.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyLevel`](crate::model::HierarchyLevel)
        pub fn build(self) -> crate::model::HierarchyLevel {
            crate::model::HierarchyLevel {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl HierarchyLevel {
    /// Creates a new builder-style object to manufacture [`HierarchyLevel`](crate::model::HierarchyLevel)
    pub fn builder() -> crate::model::hierarchy_level::Builder {
        crate::model::hierarchy_level::Builder::default()
    }
}

/// <p>Contains information about a hierarchy group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HierarchyGroup {
    /// <p>The identifier of the hierarchy group.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the hierarchy group.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier of the level in the hierarchy group.</p>
    pub level_id: std::option::Option<std::string::String>,
    /// <p>Information about the levels in the hierarchy group.</p>
    pub hierarchy_path: std::option::Option<crate::model::HierarchyPath>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl HierarchyGroup {
    /// <p>The identifier of the hierarchy group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the hierarchy group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier of the level in the hierarchy group.</p>
    pub fn level_id(&self) -> std::option::Option<&str> {
        self.level_id.as_deref()
    }
    /// <p>Information about the levels in the hierarchy group.</p>
    pub fn hierarchy_path(&self) -> std::option::Option<&crate::model::HierarchyPath> {
        self.hierarchy_path.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for HierarchyGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HierarchyGroup");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("level_id", &self.level_id);
        formatter.field("hierarchy_path", &self.hierarchy_path);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`HierarchyGroup`](crate::model::HierarchyGroup)
pub mod hierarchy_group {

    /// A builder for [`HierarchyGroup`](crate::model::HierarchyGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) level_id: std::option::Option<std::string::String>,
        pub(crate) hierarchy_path: std::option::Option<crate::model::HierarchyPath>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the hierarchy group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the hierarchy group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the hierarchy group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hierarchy group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The identifier of the level in the hierarchy group.</p>
        pub fn level_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.level_id = Some(input.into());
            self
        }
        /// <p>The identifier of the level in the hierarchy group.</p>
        pub fn set_level_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.level_id = input;
            self
        }
        /// <p>Information about the levels in the hierarchy group.</p>
        pub fn hierarchy_path(mut self, input: crate::model::HierarchyPath) -> Self {
            self.hierarchy_path = Some(input);
            self
        }
        /// <p>Information about the levels in the hierarchy group.</p>
        pub fn set_hierarchy_path(
            mut self,
            input: std::option::Option<crate::model::HierarchyPath>,
        ) -> Self {
            self.hierarchy_path = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyGroup`](crate::model::HierarchyGroup)
        pub fn build(self) -> crate::model::HierarchyGroup {
            crate::model::HierarchyGroup {
                id: self.id,
                arn: self.arn,
                name: self.name,
                level_id: self.level_id,
                hierarchy_path: self.hierarchy_path,
                tags: self.tags,
            }
        }
    }
}
impl HierarchyGroup {
    /// Creates a new builder-style object to manufacture [`HierarchyGroup`](crate::model::HierarchyGroup)
    pub fn builder() -> crate::model::hierarchy_group::Builder {
        crate::model::hierarchy_group::Builder::default()
    }
}

/// <p>Contains information about the levels of a hierarchy group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HierarchyPath {
    /// <p>Information about level one.</p>
    pub level_one: std::option::Option<crate::model::HierarchyGroupSummary>,
    /// <p>Information about level two.</p>
    pub level_two: std::option::Option<crate::model::HierarchyGroupSummary>,
    /// <p>Information about level three.</p>
    pub level_three: std::option::Option<crate::model::HierarchyGroupSummary>,
    /// <p>Information about level four.</p>
    pub level_four: std::option::Option<crate::model::HierarchyGroupSummary>,
    /// <p>Information about level five.</p>
    pub level_five: std::option::Option<crate::model::HierarchyGroupSummary>,
}
impl HierarchyPath {
    /// <p>Information about level one.</p>
    pub fn level_one(&self) -> std::option::Option<&crate::model::HierarchyGroupSummary> {
        self.level_one.as_ref()
    }
    /// <p>Information about level two.</p>
    pub fn level_two(&self) -> std::option::Option<&crate::model::HierarchyGroupSummary> {
        self.level_two.as_ref()
    }
    /// <p>Information about level three.</p>
    pub fn level_three(&self) -> std::option::Option<&crate::model::HierarchyGroupSummary> {
        self.level_three.as_ref()
    }
    /// <p>Information about level four.</p>
    pub fn level_four(&self) -> std::option::Option<&crate::model::HierarchyGroupSummary> {
        self.level_four.as_ref()
    }
    /// <p>Information about level five.</p>
    pub fn level_five(&self) -> std::option::Option<&crate::model::HierarchyGroupSummary> {
        self.level_five.as_ref()
    }
}
impl std::fmt::Debug for HierarchyPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HierarchyPath");
        formatter.field("level_one", &self.level_one);
        formatter.field("level_two", &self.level_two);
        formatter.field("level_three", &self.level_three);
        formatter.field("level_four", &self.level_four);
        formatter.field("level_five", &self.level_five);
        formatter.finish()
    }
}
/// See [`HierarchyPath`](crate::model::HierarchyPath)
pub mod hierarchy_path {

    /// A builder for [`HierarchyPath`](crate::model::HierarchyPath)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) level_one: std::option::Option<crate::model::HierarchyGroupSummary>,
        pub(crate) level_two: std::option::Option<crate::model::HierarchyGroupSummary>,
        pub(crate) level_three: std::option::Option<crate::model::HierarchyGroupSummary>,
        pub(crate) level_four: std::option::Option<crate::model::HierarchyGroupSummary>,
        pub(crate) level_five: std::option::Option<crate::model::HierarchyGroupSummary>,
    }
    impl Builder {
        /// <p>Information about level one.</p>
        pub fn level_one(mut self, input: crate::model::HierarchyGroupSummary) -> Self {
            self.level_one = Some(input);
            self
        }
        /// <p>Information about level one.</p>
        pub fn set_level_one(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummary>,
        ) -> Self {
            self.level_one = input;
            self
        }
        /// <p>Information about level two.</p>
        pub fn level_two(mut self, input: crate::model::HierarchyGroupSummary) -> Self {
            self.level_two = Some(input);
            self
        }
        /// <p>Information about level two.</p>
        pub fn set_level_two(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummary>,
        ) -> Self {
            self.level_two = input;
            self
        }
        /// <p>Information about level three.</p>
        pub fn level_three(mut self, input: crate::model::HierarchyGroupSummary) -> Self {
            self.level_three = Some(input);
            self
        }
        /// <p>Information about level three.</p>
        pub fn set_level_three(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummary>,
        ) -> Self {
            self.level_three = input;
            self
        }
        /// <p>Information about level four.</p>
        pub fn level_four(mut self, input: crate::model::HierarchyGroupSummary) -> Self {
            self.level_four = Some(input);
            self
        }
        /// <p>Information about level four.</p>
        pub fn set_level_four(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummary>,
        ) -> Self {
            self.level_four = input;
            self
        }
        /// <p>Information about level five.</p>
        pub fn level_five(mut self, input: crate::model::HierarchyGroupSummary) -> Self {
            self.level_five = Some(input);
            self
        }
        /// <p>Information about level five.</p>
        pub fn set_level_five(
            mut self,
            input: std::option::Option<crate::model::HierarchyGroupSummary>,
        ) -> Self {
            self.level_five = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchyPath`](crate::model::HierarchyPath)
        pub fn build(self) -> crate::model::HierarchyPath {
            crate::model::HierarchyPath {
                level_one: self.level_one,
                level_two: self.level_two,
                level_three: self.level_three,
                level_four: self.level_four,
                level_five: self.level_five,
            }
        }
    }
}
impl HierarchyPath {
    /// Creates a new builder-style object to manufacture [`HierarchyPath`](crate::model::HierarchyPath)
    pub fn builder() -> crate::model::hierarchy_path::Builder {
        crate::model::hierarchy_path::Builder::default()
    }
}

/// <p>Contains information about a user account for a Amazon Connect instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct User {
    /// <p>The identifier of the user account.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the user account.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The user name assigned to the user account.</p>
    pub username: std::option::Option<std::string::String>,
    /// <p>Information about the user identity.</p>
    pub identity_info: std::option::Option<crate::model::UserIdentityInfo>,
    /// <p>Information about the phone configuration for the user.</p>
    pub phone_config: std::option::Option<crate::model::UserPhoneConfig>,
    /// <p>The identifier of the user account in the directory used for identity management.</p>
    pub directory_user_id: std::option::Option<std::string::String>,
    /// <p>The identifiers of the security profiles for the user.</p>
    pub security_profile_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The identifier of the routing profile for the user.</p>
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the hierarchy group for the user.</p>
    pub hierarchy_group_id: std::option::Option<std::string::String>,
    /// <p>The tags.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl User {
    /// <p>The identifier of the user account.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the user account.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The user name assigned to the user account.</p>
    pub fn username(&self) -> std::option::Option<&str> {
        self.username.as_deref()
    }
    /// <p>Information about the user identity.</p>
    pub fn identity_info(&self) -> std::option::Option<&crate::model::UserIdentityInfo> {
        self.identity_info.as_ref()
    }
    /// <p>Information about the phone configuration for the user.</p>
    pub fn phone_config(&self) -> std::option::Option<&crate::model::UserPhoneConfig> {
        self.phone_config.as_ref()
    }
    /// <p>The identifier of the user account in the directory used for identity management.</p>
    pub fn directory_user_id(&self) -> std::option::Option<&str> {
        self.directory_user_id.as_deref()
    }
    /// <p>The identifiers of the security profiles for the user.</p>
    pub fn security_profile_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_profile_ids.as_deref()
    }
    /// <p>The identifier of the routing profile for the user.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The identifier of the hierarchy group for the user.</p>
    pub fn hierarchy_group_id(&self) -> std::option::Option<&str> {
        self.hierarchy_group_id.as_deref()
    }
    /// <p>The tags.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for User {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("User");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("username", &self.username);
        formatter.field("identity_info", &self.identity_info);
        formatter.field("phone_config", &self.phone_config);
        formatter.field("directory_user_id", &self.directory_user_id);
        formatter.field("security_profile_ids", &self.security_profile_ids);
        formatter.field("routing_profile_id", &self.routing_profile_id);
        formatter.field("hierarchy_group_id", &self.hierarchy_group_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`User`](crate::model::User)
pub mod user {

    /// A builder for [`User`](crate::model::User)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) username: std::option::Option<std::string::String>,
        pub(crate) identity_info: std::option::Option<crate::model::UserIdentityInfo>,
        pub(crate) phone_config: std::option::Option<crate::model::UserPhoneConfig>,
        pub(crate) directory_user_id: std::option::Option<std::string::String>,
        pub(crate) security_profile_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) hierarchy_group_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the user account.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user account.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user account.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The user name assigned to the user account.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        /// <p>The user name assigned to the user account.</p>
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input;
            self
        }
        /// <p>Information about the user identity.</p>
        pub fn identity_info(mut self, input: crate::model::UserIdentityInfo) -> Self {
            self.identity_info = Some(input);
            self
        }
        /// <p>Information about the user identity.</p>
        pub fn set_identity_info(
            mut self,
            input: std::option::Option<crate::model::UserIdentityInfo>,
        ) -> Self {
            self.identity_info = input;
            self
        }
        /// <p>Information about the phone configuration for the user.</p>
        pub fn phone_config(mut self, input: crate::model::UserPhoneConfig) -> Self {
            self.phone_config = Some(input);
            self
        }
        /// <p>Information about the phone configuration for the user.</p>
        pub fn set_phone_config(
            mut self,
            input: std::option::Option<crate::model::UserPhoneConfig>,
        ) -> Self {
            self.phone_config = input;
            self
        }
        /// <p>The identifier of the user account in the directory used for identity management.</p>
        pub fn directory_user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account in the directory used for identity management.</p>
        pub fn set_directory_user_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.directory_user_id = input;
            self
        }
        /// Appends an item to `security_profile_ids`.
        ///
        /// To override the contents of this collection use [`set_security_profile_ids`](Self::set_security_profile_ids).
        ///
        /// <p>The identifiers of the security profiles for the user.</p>
        pub fn security_profile_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_profile_ids.unwrap_or_default();
            v.push(input.into());
            self.security_profile_ids = Some(v);
            self
        }
        /// <p>The identifiers of the security profiles for the user.</p>
        pub fn set_security_profile_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_profile_ids = input;
            self
        }
        /// <p>The identifier of the routing profile for the user.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile for the user.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// <p>The identifier of the hierarchy group for the user.</p>
        pub fn hierarchy_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the hierarchy group for the user.</p>
        pub fn set_hierarchy_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hierarchy_group_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`User`](crate::model::User)
        pub fn build(self) -> crate::model::User {
            crate::model::User {
                id: self.id,
                arn: self.arn,
                username: self.username,
                identity_info: self.identity_info,
                phone_config: self.phone_config,
                directory_user_id: self.directory_user_id,
                security_profile_ids: self.security_profile_ids,
                routing_profile_id: self.routing_profile_id,
                hierarchy_group_id: self.hierarchy_group_id,
                tags: self.tags,
            }
        }
    }
}
impl User {
    /// Creates a new builder-style object to manufacture [`User`](crate::model::User)
    pub fn builder() -> crate::model::user::Builder {
        crate::model::user::Builder::default()
    }
}

/// <p>Contains information about a security profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecurityProfile {
    /// <p>The identifier for the security profile.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The organization resource identifier for the security profile.</p>
    pub organization_resource_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the secruity profile.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name for the security profile.</p>
    pub security_profile_name: std::option::Option<std::string::String>,
    /// <p>The description of the security profile.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl SecurityProfile {
    /// <p>The identifier for the security profile.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The organization resource identifier for the security profile.</p>
    pub fn organization_resource_id(&self) -> std::option::Option<&str> {
        self.organization_resource_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the secruity profile.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name for the security profile.</p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
    /// <p>The description of the security profile.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for SecurityProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecurityProfile");
        formatter.field("id", &self.id);
        formatter.field("organization_resource_id", &self.organization_resource_id);
        formatter.field("arn", &self.arn);
        formatter.field("security_profile_name", &self.security_profile_name);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`SecurityProfile`](crate::model::SecurityProfile)
pub mod security_profile {

    /// A builder for [`SecurityProfile`](crate::model::SecurityProfile)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) organization_resource_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier for the security profile.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier for the security profile.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The organization resource identifier for the security profile.</p>
        pub fn organization_resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.organization_resource_id = Some(input.into());
            self
        }
        /// <p>The organization resource identifier for the security profile.</p>
        pub fn set_organization_resource_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_resource_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the secruity profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the secruity profile.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name for the security profile.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p>The name for the security profile.</p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// <p>The description of the security profile.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the security profile.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityProfile`](crate::model::SecurityProfile)
        pub fn build(self) -> crate::model::SecurityProfile {
            crate::model::SecurityProfile {
                id: self.id,
                organization_resource_id: self.organization_resource_id,
                arn: self.arn,
                security_profile_name: self.security_profile_name,
                description: self.description,
                tags: self.tags,
            }
        }
    }
}
impl SecurityProfile {
    /// Creates a new builder-style object to manufacture [`SecurityProfile`](crate::model::SecurityProfile)
    pub fn builder() -> crate::model::security_profile::Builder {
        crate::model::security_profile::Builder::default()
    }
}

/// <p>Contains information about a routing profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RoutingProfile {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the routing profile.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    pub routing_profile_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the routing profile.</p>
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The description of the routing profile.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
    pub media_concurrencies: std::option::Option<std::vec::Vec<crate::model::MediaConcurrency>>,
    /// <p>The identifier of the default outbound queue for this routing profile.</p>
    pub default_outbound_queue_id: std::option::Option<std::string::String>,
    /// <p>One or more tags.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl RoutingProfile {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the routing profile.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    pub fn routing_profile_arn(&self) -> std::option::Option<&str> {
        self.routing_profile_arn.as_deref()
    }
    /// <p>The identifier of the routing profile.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The description of the routing profile.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
    pub fn media_concurrencies(&self) -> std::option::Option<&[crate::model::MediaConcurrency]> {
        self.media_concurrencies.as_deref()
    }
    /// <p>The identifier of the default outbound queue for this routing profile.</p>
    pub fn default_outbound_queue_id(&self) -> std::option::Option<&str> {
        self.default_outbound_queue_id.as_deref()
    }
    /// <p>One or more tags.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for RoutingProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RoutingProfile");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("name", &self.name);
        formatter.field("routing_profile_arn", &self.routing_profile_arn);
        formatter.field("routing_profile_id", &self.routing_profile_id);
        formatter.field("description", &self.description);
        formatter.field("media_concurrencies", &self.media_concurrencies);
        formatter.field("default_outbound_queue_id", &self.default_outbound_queue_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`RoutingProfile`](crate::model::RoutingProfile)
pub mod routing_profile {

    /// A builder for [`RoutingProfile`](crate::model::RoutingProfile)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) routing_profile_arn: std::option::Option<std::string::String>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) media_concurrencies:
            std::option::Option<std::vec::Vec<crate::model::MediaConcurrency>>,
        pub(crate) default_outbound_queue_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the routing profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the routing profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
        pub fn routing_profile_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
        pub fn set_routing_profile_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_arn = input;
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// <p>The description of the routing profile.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the routing profile.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `media_concurrencies`.
        ///
        /// To override the contents of this collection use [`set_media_concurrencies`](Self::set_media_concurrencies).
        ///
        /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
        pub fn media_concurrencies(mut self, input: crate::model::MediaConcurrency) -> Self {
            let mut v = self.media_concurrencies.unwrap_or_default();
            v.push(input);
            self.media_concurrencies = Some(v);
            self
        }
        /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
        pub fn set_media_concurrencies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MediaConcurrency>>,
        ) -> Self {
            self.media_concurrencies = input;
            self
        }
        /// <p>The identifier of the default outbound queue for this routing profile.</p>
        pub fn default_outbound_queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_outbound_queue_id = Some(input.into());
            self
        }
        /// <p>The identifier of the default outbound queue for this routing profile.</p>
        pub fn set_default_outbound_queue_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_outbound_queue_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>One or more tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>One or more tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`RoutingProfile`](crate::model::RoutingProfile)
        pub fn build(self) -> crate::model::RoutingProfile {
            crate::model::RoutingProfile {
                instance_id: self.instance_id,
                name: self.name,
                routing_profile_arn: self.routing_profile_arn,
                routing_profile_id: self.routing_profile_id,
                description: self.description,
                media_concurrencies: self.media_concurrencies,
                default_outbound_queue_id: self.default_outbound_queue_id,
                tags: self.tags,
            }
        }
    }
}
impl RoutingProfile {
    /// Creates a new builder-style object to manufacture [`RoutingProfile`](crate::model::RoutingProfile)
    pub fn builder() -> crate::model::routing_profile::Builder {
        crate::model::routing_profile::Builder::default()
    }
}

/// <p>Contains information about a quick connect.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QuickConnect {
    /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
    pub quick_connect_arn: std::option::Option<std::string::String>,
    /// <p>The identifier for the quick connect.</p>
    pub quick_connect_id: std::option::Option<std::string::String>,
    /// <p>The name of the quick connect.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The description.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Contains information about the quick connect.</p>
    pub quick_connect_config: std::option::Option<crate::model::QuickConnectConfig>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl QuickConnect {
    /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
    pub fn quick_connect_arn(&self) -> std::option::Option<&str> {
        self.quick_connect_arn.as_deref()
    }
    /// <p>The identifier for the quick connect.</p>
    pub fn quick_connect_id(&self) -> std::option::Option<&str> {
        self.quick_connect_id.as_deref()
    }
    /// <p>The name of the quick connect.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Contains information about the quick connect.</p>
    pub fn quick_connect_config(&self) -> std::option::Option<&crate::model::QuickConnectConfig> {
        self.quick_connect_config.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for QuickConnect {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QuickConnect");
        formatter.field("quick_connect_arn", &self.quick_connect_arn);
        formatter.field("quick_connect_id", &self.quick_connect_id);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("quick_connect_config", &self.quick_connect_config);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`QuickConnect`](crate::model::QuickConnect)
pub mod quick_connect {

    /// A builder for [`QuickConnect`](crate::model::QuickConnect)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) quick_connect_arn: std::option::Option<std::string::String>,
        pub(crate) quick_connect_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) quick_connect_config: std::option::Option<crate::model::QuickConnectConfig>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
        pub fn quick_connect_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.quick_connect_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
        pub fn set_quick_connect_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.quick_connect_arn = input;
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn quick_connect_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.quick_connect_id = Some(input.into());
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn set_quick_connect_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.quick_connect_id = input;
            self
        }
        /// <p>The name of the quick connect.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the quick connect.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Contains information about the quick connect.</p>
        pub fn quick_connect_config(mut self, input: crate::model::QuickConnectConfig) -> Self {
            self.quick_connect_config = Some(input);
            self
        }
        /// <p>Contains information about the quick connect.</p>
        pub fn set_quick_connect_config(
            mut self,
            input: std::option::Option<crate::model::QuickConnectConfig>,
        ) -> Self {
            self.quick_connect_config = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`QuickConnect`](crate::model::QuickConnect)
        pub fn build(self) -> crate::model::QuickConnect {
            crate::model::QuickConnect {
                quick_connect_arn: self.quick_connect_arn,
                quick_connect_id: self.quick_connect_id,
                name: self.name,
                description: self.description,
                quick_connect_config: self.quick_connect_config,
                tags: self.tags,
            }
        }
    }
}
impl QuickConnect {
    /// Creates a new builder-style object to manufacture [`QuickConnect`](crate::model::QuickConnect)
    pub fn builder() -> crate::model::quick_connect::Builder {
        crate::model::quick_connect::Builder::default()
    }
}

/// <p>Contains information about a queue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Queue {
    /// <p>The name of the queue.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the queue.</p>
    pub queue_arn: std::option::Option<std::string::String>,
    /// <p>The identifier for the queue.</p>
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The description of the queue.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
    pub outbound_caller_config: std::option::Option<crate::model::OutboundCallerConfig>,
    /// <p>The identifier for the hours of operation.</p>
    pub hours_of_operation_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
    pub max_contacts: std::option::Option<i32>,
    /// <p>The status of the queue.</p>
    pub status: std::option::Option<crate::model::QueueStatus>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Queue {
    /// <p>The name of the queue.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the queue.</p>
    pub fn queue_arn(&self) -> std::option::Option<&str> {
        self.queue_arn.as_deref()
    }
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The description of the queue.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
    pub fn outbound_caller_config(
        &self,
    ) -> std::option::Option<&crate::model::OutboundCallerConfig> {
        self.outbound_caller_config.as_ref()
    }
    /// <p>The identifier for the hours of operation.</p>
    pub fn hours_of_operation_id(&self) -> std::option::Option<&str> {
        self.hours_of_operation_id.as_deref()
    }
    /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
    pub fn max_contacts(&self) -> std::option::Option<i32> {
        self.max_contacts
    }
    /// <p>The status of the queue.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::QueueStatus> {
        self.status.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for Queue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Queue");
        formatter.field("name", &self.name);
        formatter.field("queue_arn", &self.queue_arn);
        formatter.field("queue_id", &self.queue_id);
        formatter.field("description", &self.description);
        formatter.field("outbound_caller_config", &self.outbound_caller_config);
        formatter.field("hours_of_operation_id", &self.hours_of_operation_id);
        formatter.field("max_contacts", &self.max_contacts);
        formatter.field("status", &self.status);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Queue`](crate::model::Queue)
pub mod queue {

    /// A builder for [`Queue`](crate::model::Queue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) queue_arn: std::option::Option<std::string::String>,
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) outbound_caller_config: std::option::Option<crate::model::OutboundCallerConfig>,
        pub(crate) hours_of_operation_id: std::option::Option<std::string::String>,
        pub(crate) max_contacts: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::QueueStatus>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the queue.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the queue.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the queue.</p>
        pub fn queue_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the queue.</p>
        pub fn set_queue_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_arn = input;
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The description of the queue.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the queue.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
        pub fn outbound_caller_config(mut self, input: crate::model::OutboundCallerConfig) -> Self {
            self.outbound_caller_config = Some(input);
            self
        }
        /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
        pub fn set_outbound_caller_config(
            mut self,
            input: std::option::Option<crate::model::OutboundCallerConfig>,
        ) -> Self {
            self.outbound_caller_config = input;
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn hours_of_operation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hours_of_operation_id = Some(input.into());
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn set_hours_of_operation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hours_of_operation_id = input;
            self
        }
        /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
        pub fn max_contacts(mut self, input: i32) -> Self {
            self.max_contacts = Some(input);
            self
        }
        /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
        pub fn set_max_contacts(mut self, input: std::option::Option<i32>) -> Self {
            self.max_contacts = input;
            self
        }
        /// <p>The status of the queue.</p>
        pub fn status(mut self, input: crate::model::QueueStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the queue.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::QueueStatus>) -> Self {
            self.status = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Queue`](crate::model::Queue)
        pub fn build(self) -> crate::model::Queue {
            crate::model::Queue {
                name: self.name,
                queue_arn: self.queue_arn,
                queue_id: self.queue_id,
                description: self.description,
                outbound_caller_config: self.outbound_caller_config,
                hours_of_operation_id: self.hours_of_operation_id,
                max_contacts: self.max_contacts,
                status: self.status,
                tags: self.tags,
            }
        }
    }
}
impl Queue {
    /// Creates a new builder-style object to manufacture [`Queue`](crate::model::Queue)
    pub fn builder() -> crate::model::queue::Builder {
        crate::model::queue::Builder::default()
    }
}

/// <p>Information about a phone number that has been claimed to your Amazon Connect instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClaimedPhoneNumberSummary {
    /// <p>A unique identifier for the phone number.</p>
    pub phone_number_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
    pub phone_number_arn: std::option::Option<std::string::String>,
    /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    pub phone_number: std::option::Option<std::string::String>,
    /// <p>The ISO country code.</p>
    pub phone_number_country_code: std::option::Option<crate::model::PhoneNumberCountryCode>,
    /// <p>The type of phone number.</p>
    pub phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
    /// <p>The description of the phone number.</p>
    pub phone_number_description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances that phone numbers are claimed to.</p>
    pub target_arn: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The status of the phone number.</p>
    pub phone_number_status: std::option::Option<crate::model::PhoneNumberStatus>,
}
impl ClaimedPhoneNumberSummary {
    /// <p>A unique identifier for the phone number.</p>
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
    pub fn phone_number_arn(&self) -> std::option::Option<&str> {
        self.phone_number_arn.as_deref()
    }
    /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
    /// <p>The ISO country code.</p>
    pub fn phone_number_country_code(
        &self,
    ) -> std::option::Option<&crate::model::PhoneNumberCountryCode> {
        self.phone_number_country_code.as_ref()
    }
    /// <p>The type of phone number.</p>
    pub fn phone_number_type(&self) -> std::option::Option<&crate::model::PhoneNumberType> {
        self.phone_number_type.as_ref()
    }
    /// <p>The description of the phone number.</p>
    pub fn phone_number_description(&self) -> std::option::Option<&str> {
        self.phone_number_description.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances that phone numbers are claimed to.</p>
    pub fn target_arn(&self) -> std::option::Option<&str> {
        self.target_arn.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The status of the phone number.</p>
    pub fn phone_number_status(&self) -> std::option::Option<&crate::model::PhoneNumberStatus> {
        self.phone_number_status.as_ref()
    }
}
impl std::fmt::Debug for ClaimedPhoneNumberSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClaimedPhoneNumberSummary");
        formatter.field("phone_number_id", &self.phone_number_id);
        formatter.field("phone_number_arn", &self.phone_number_arn);
        formatter.field("phone_number", &self.phone_number);
        formatter.field("phone_number_country_code", &self.phone_number_country_code);
        formatter.field("phone_number_type", &self.phone_number_type);
        formatter.field("phone_number_description", &self.phone_number_description);
        formatter.field("target_arn", &self.target_arn);
        formatter.field("tags", &self.tags);
        formatter.field("phone_number_status", &self.phone_number_status);
        formatter.finish()
    }
}
/// See [`ClaimedPhoneNumberSummary`](crate::model::ClaimedPhoneNumberSummary)
pub mod claimed_phone_number_summary {

    /// A builder for [`ClaimedPhoneNumberSummary`](crate::model::ClaimedPhoneNumberSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
        pub(crate) phone_number_arn: std::option::Option<std::string::String>,
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) phone_number_country_code:
            std::option::Option<crate::model::PhoneNumberCountryCode>,
        pub(crate) phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
        pub(crate) phone_number_description: std::option::Option<std::string::String>,
        pub(crate) target_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) phone_number_status: std::option::Option<crate::model::PhoneNumberStatus>,
    }
    impl Builder {
        /// <p>A unique identifier for the phone number.</p>
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the phone number.</p>
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
        pub fn phone_number_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
        pub fn set_phone_number_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_arn = input;
            self
        }
        /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>The phone number. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// <p>The ISO country code.</p>
        pub fn phone_number_country_code(
            mut self,
            input: crate::model::PhoneNumberCountryCode,
        ) -> Self {
            self.phone_number_country_code = Some(input);
            self
        }
        /// <p>The ISO country code.</p>
        pub fn set_phone_number_country_code(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberCountryCode>,
        ) -> Self {
            self.phone_number_country_code = input;
            self
        }
        /// <p>The type of phone number.</p>
        pub fn phone_number_type(mut self, input: crate::model::PhoneNumberType) -> Self {
            self.phone_number_type = Some(input);
            self
        }
        /// <p>The type of phone number.</p>
        pub fn set_phone_number_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberType>,
        ) -> Self {
            self.phone_number_type = input;
            self
        }
        /// <p>The description of the phone number.</p>
        pub fn phone_number_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_description = Some(input.into());
            self
        }
        /// <p>The description of the phone number.</p>
        pub fn set_phone_number_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_description = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances that phone numbers are claimed to.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances that phone numbers are claimed to.</p>
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The status of the phone number.</p>
        pub fn phone_number_status(mut self, input: crate::model::PhoneNumberStatus) -> Self {
            self.phone_number_status = Some(input);
            self
        }
        /// <p>The status of the phone number.</p>
        pub fn set_phone_number_status(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberStatus>,
        ) -> Self {
            self.phone_number_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ClaimedPhoneNumberSummary`](crate::model::ClaimedPhoneNumberSummary)
        pub fn build(self) -> crate::model::ClaimedPhoneNumberSummary {
            crate::model::ClaimedPhoneNumberSummary {
                phone_number_id: self.phone_number_id,
                phone_number_arn: self.phone_number_arn,
                phone_number: self.phone_number,
                phone_number_country_code: self.phone_number_country_code,
                phone_number_type: self.phone_number_type,
                phone_number_description: self.phone_number_description,
                target_arn: self.target_arn,
                tags: self.tags,
                phone_number_status: self.phone_number_status,
            }
        }
    }
}
impl ClaimedPhoneNumberSummary {
    /// Creates a new builder-style object to manufacture [`ClaimedPhoneNumberSummary`](crate::model::ClaimedPhoneNumberSummary)
    pub fn builder() -> crate::model::claimed_phone_number_summary::Builder {
        crate::model::claimed_phone_number_summary::Builder::default()
    }
}

/// <p>The status of the phone number.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PhoneNumberStatus {
    /// <p>The status.</p>
    pub status: std::option::Option<crate::model::PhoneNumberWorkflowStatus>,
    /// <p>The status message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl PhoneNumberStatus {
    /// <p>The status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::PhoneNumberWorkflowStatus> {
        self.status.as_ref()
    }
    /// <p>The status message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for PhoneNumberStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PhoneNumberStatus");
        formatter.field("status", &self.status);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`PhoneNumberStatus`](crate::model::PhoneNumberStatus)
pub mod phone_number_status {

    /// A builder for [`PhoneNumberStatus`](crate::model::PhoneNumberStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::PhoneNumberWorkflowStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status.</p>
        pub fn status(mut self, input: crate::model::PhoneNumberWorkflowStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberWorkflowStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The status message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The status message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PhoneNumberStatus`](crate::model::PhoneNumberStatus)
        pub fn build(self) -> crate::model::PhoneNumberStatus {
            crate::model::PhoneNumberStatus {
                status: self.status,
                message: self.message,
            }
        }
    }
}
impl PhoneNumberStatus {
    /// Creates a new builder-style object to manufacture [`PhoneNumberStatus`](crate::model::PhoneNumberStatus)
    pub fn builder() -> crate::model::phone_number_status::Builder {
        crate::model::phone_number_status::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneNumberWorkflowStatus {
    #[allow(missing_docs)] // documentation missing in model
    Claimed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PhoneNumberWorkflowStatus {
    fn from(s: &str) -> Self {
        match s {
            "CLAIMED" => PhoneNumberWorkflowStatus::Claimed,
            "FAILED" => PhoneNumberWorkflowStatus::Failed,
            "IN_PROGRESS" => PhoneNumberWorkflowStatus::InProgress,
            other => PhoneNumberWorkflowStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PhoneNumberWorkflowStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneNumberWorkflowStatus::from(s))
    }
}
impl PhoneNumberWorkflowStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneNumberWorkflowStatus::Claimed => "CLAIMED",
            PhoneNumberWorkflowStatus::Failed => "FAILED",
            PhoneNumberWorkflowStatus::InProgress => "IN_PROGRESS",
            PhoneNumberWorkflowStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CLAIMED", "FAILED", "IN_PROGRESS"]
    }
}
impl AsRef<str> for PhoneNumberWorkflowStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Amazon Connect instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Instance {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the instance.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The identity management type.</p>
    pub identity_management_type: std::option::Option<crate::model::DirectoryType>,
    /// <p>The alias of instance.</p>
    pub instance_alias: std::option::Option<std::string::String>,
    /// <p>When the instance was created.</p>
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The service role of the instance.</p>
    pub service_role: std::option::Option<std::string::String>,
    /// <p>The state of the instance.</p>
    pub instance_status: std::option::Option<crate::model::InstanceStatus>,
    /// <p>Relevant details why the instance was not successfully created. </p>
    pub status_reason: std::option::Option<crate::model::InstanceStatusReason>,
    /// <p>Whether inbound calls are enabled.</p>
    pub inbound_calls_enabled: std::option::Option<bool>,
    /// <p>Whether outbound calls are enabled.</p>
    pub outbound_calls_enabled: std::option::Option<bool>,
}
impl Instance {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the instance.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The identity management type.</p>
    pub fn identity_management_type(&self) -> std::option::Option<&crate::model::DirectoryType> {
        self.identity_management_type.as_ref()
    }
    /// <p>The alias of instance.</p>
    pub fn instance_alias(&self) -> std::option::Option<&str> {
        self.instance_alias.as_deref()
    }
    /// <p>When the instance was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The service role of the instance.</p>
    pub fn service_role(&self) -> std::option::Option<&str> {
        self.service_role.as_deref()
    }
    /// <p>The state of the instance.</p>
    pub fn instance_status(&self) -> std::option::Option<&crate::model::InstanceStatus> {
        self.instance_status.as_ref()
    }
    /// <p>Relevant details why the instance was not successfully created. </p>
    pub fn status_reason(&self) -> std::option::Option<&crate::model::InstanceStatusReason> {
        self.status_reason.as_ref()
    }
    /// <p>Whether inbound calls are enabled.</p>
    pub fn inbound_calls_enabled(&self) -> std::option::Option<bool> {
        self.inbound_calls_enabled
    }
    /// <p>Whether outbound calls are enabled.</p>
    pub fn outbound_calls_enabled(&self) -> std::option::Option<bool> {
        self.outbound_calls_enabled
    }
}
impl std::fmt::Debug for Instance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Instance");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("identity_management_type", &self.identity_management_type);
        formatter.field("instance_alias", &"*** Sensitive Data Redacted ***");
        formatter.field("created_time", &self.created_time);
        formatter.field("service_role", &self.service_role);
        formatter.field("instance_status", &self.instance_status);
        formatter.field("status_reason", &self.status_reason);
        formatter.field("inbound_calls_enabled", &self.inbound_calls_enabled);
        formatter.field("outbound_calls_enabled", &self.outbound_calls_enabled);
        formatter.finish()
    }
}
/// See [`Instance`](crate::model::Instance)
pub mod instance {

    /// A builder for [`Instance`](crate::model::Instance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) identity_management_type: std::option::Option<crate::model::DirectoryType>,
        pub(crate) instance_alias: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) service_role: std::option::Option<std::string::String>,
        pub(crate) instance_status: std::option::Option<crate::model::InstanceStatus>,
        pub(crate) status_reason: std::option::Option<crate::model::InstanceStatusReason>,
        pub(crate) inbound_calls_enabled: std::option::Option<bool>,
        pub(crate) outbound_calls_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the instance.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the instance.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The identity management type.</p>
        pub fn identity_management_type(mut self, input: crate::model::DirectoryType) -> Self {
            self.identity_management_type = Some(input);
            self
        }
        /// <p>The identity management type.</p>
        pub fn set_identity_management_type(
            mut self,
            input: std::option::Option<crate::model::DirectoryType>,
        ) -> Self {
            self.identity_management_type = input;
            self
        }
        /// <p>The alias of instance.</p>
        pub fn instance_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_alias = Some(input.into());
            self
        }
        /// <p>The alias of instance.</p>
        pub fn set_instance_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_alias = input;
            self
        }
        /// <p>When the instance was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>When the instance was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The service role of the instance.</p>
        pub fn service_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_role = Some(input.into());
            self
        }
        /// <p>The service role of the instance.</p>
        pub fn set_service_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_role = input;
            self
        }
        /// <p>The state of the instance.</p>
        pub fn instance_status(mut self, input: crate::model::InstanceStatus) -> Self {
            self.instance_status = Some(input);
            self
        }
        /// <p>The state of the instance.</p>
        pub fn set_instance_status(
            mut self,
            input: std::option::Option<crate::model::InstanceStatus>,
        ) -> Self {
            self.instance_status = input;
            self
        }
        /// <p>Relevant details why the instance was not successfully created. </p>
        pub fn status_reason(mut self, input: crate::model::InstanceStatusReason) -> Self {
            self.status_reason = Some(input);
            self
        }
        /// <p>Relevant details why the instance was not successfully created. </p>
        pub fn set_status_reason(
            mut self,
            input: std::option::Option<crate::model::InstanceStatusReason>,
        ) -> Self {
            self.status_reason = input;
            self
        }
        /// <p>Whether inbound calls are enabled.</p>
        pub fn inbound_calls_enabled(mut self, input: bool) -> Self {
            self.inbound_calls_enabled = Some(input);
            self
        }
        /// <p>Whether inbound calls are enabled.</p>
        pub fn set_inbound_calls_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inbound_calls_enabled = input;
            self
        }
        /// <p>Whether outbound calls are enabled.</p>
        pub fn outbound_calls_enabled(mut self, input: bool) -> Self {
            self.outbound_calls_enabled = Some(input);
            self
        }
        /// <p>Whether outbound calls are enabled.</p>
        pub fn set_outbound_calls_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.outbound_calls_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Instance`](crate::model::Instance)
        pub fn build(self) -> crate::model::Instance {
            crate::model::Instance {
                id: self.id,
                arn: self.arn,
                identity_management_type: self.identity_management_type,
                instance_alias: self.instance_alias,
                created_time: self.created_time,
                service_role: self.service_role,
                instance_status: self.instance_status,
                status_reason: self.status_reason,
                inbound_calls_enabled: self.inbound_calls_enabled,
                outbound_calls_enabled: self.outbound_calls_enabled,
            }
        }
    }
}
impl Instance {
    /// Creates a new builder-style object to manufacture [`Instance`](crate::model::Instance)
    pub fn builder() -> crate::model::instance::Builder {
        crate::model::instance::Builder::default()
    }
}

/// <p>Relevant details why the instance was not successfully created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceStatusReason {
    /// <p>The message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl InstanceStatusReason {
    /// <p>The message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for InstanceStatusReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceStatusReason");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`InstanceStatusReason`](crate::model::InstanceStatusReason)
pub mod instance_status_reason {

    /// A builder for [`InstanceStatusReason`](crate::model::InstanceStatusReason)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceStatusReason`](crate::model::InstanceStatusReason)
        pub fn build(self) -> crate::model::InstanceStatusReason {
            crate::model::InstanceStatusReason {
                message: self.message,
            }
        }
    }
}
impl InstanceStatusReason {
    /// Creates a new builder-style object to manufacture [`InstanceStatusReason`](crate::model::InstanceStatusReason)
    pub fn builder() -> crate::model::instance_status_reason::Builder {
        crate::model::instance_status_reason::Builder::default()
    }
}

/// <p>Information about of the hours of operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HoursOfOperation {
    /// <p>The identifier for the hours of operation.</p>
    pub hours_of_operation_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the hours of operation.</p>
    pub hours_of_operation_arn: std::option::Option<std::string::String>,
    /// <p>The name for the hours of operation.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The description for the hours of operation.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The time zone for the hours of operation.</p>
    pub time_zone: std::option::Option<std::string::String>,
    /// <p>Configuration information for the hours of operation.</p>
    pub config: std::option::Option<std::vec::Vec<crate::model::HoursOfOperationConfig>>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl HoursOfOperation {
    /// <p>The identifier for the hours of operation.</p>
    pub fn hours_of_operation_id(&self) -> std::option::Option<&str> {
        self.hours_of_operation_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the hours of operation.</p>
    pub fn hours_of_operation_arn(&self) -> std::option::Option<&str> {
        self.hours_of_operation_arn.as_deref()
    }
    /// <p>The name for the hours of operation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description for the hours of operation.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The time zone for the hours of operation.</p>
    pub fn time_zone(&self) -> std::option::Option<&str> {
        self.time_zone.as_deref()
    }
    /// <p>Configuration information for the hours of operation.</p>
    pub fn config(&self) -> std::option::Option<&[crate::model::HoursOfOperationConfig]> {
        self.config.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for HoursOfOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HoursOfOperation");
        formatter.field("hours_of_operation_id", &self.hours_of_operation_id);
        formatter.field("hours_of_operation_arn", &self.hours_of_operation_arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("time_zone", &self.time_zone);
        formatter.field("config", &self.config);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`HoursOfOperation`](crate::model::HoursOfOperation)
pub mod hours_of_operation {

    /// A builder for [`HoursOfOperation`](crate::model::HoursOfOperation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hours_of_operation_id: std::option::Option<std::string::String>,
        pub(crate) hours_of_operation_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) time_zone: std::option::Option<std::string::String>,
        pub(crate) config: std::option::Option<std::vec::Vec<crate::model::HoursOfOperationConfig>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier for the hours of operation.</p>
        pub fn hours_of_operation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hours_of_operation_id = Some(input.into());
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn set_hours_of_operation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hours_of_operation_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the hours of operation.</p>
        pub fn hours_of_operation_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.hours_of_operation_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the hours of operation.</p>
        pub fn set_hours_of_operation_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hours_of_operation_arn = input;
            self
        }
        /// <p>The name for the hours of operation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the hours of operation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description for the hours of operation.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description for the hours of operation.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The time zone for the hours of operation.</p>
        pub fn time_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.time_zone = Some(input.into());
            self
        }
        /// <p>The time zone for the hours of operation.</p>
        pub fn set_time_zone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.time_zone = input;
            self
        }
        /// Appends an item to `config`.
        ///
        /// To override the contents of this collection use [`set_config`](Self::set_config).
        ///
        /// <p>Configuration information for the hours of operation.</p>
        pub fn config(mut self, input: crate::model::HoursOfOperationConfig) -> Self {
            let mut v = self.config.unwrap_or_default();
            v.push(input);
            self.config = Some(v);
            self
        }
        /// <p>Configuration information for the hours of operation.</p>
        pub fn set_config(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HoursOfOperationConfig>>,
        ) -> Self {
            self.config = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`HoursOfOperation`](crate::model::HoursOfOperation)
        pub fn build(self) -> crate::model::HoursOfOperation {
            crate::model::HoursOfOperation {
                hours_of_operation_id: self.hours_of_operation_id,
                hours_of_operation_arn: self.hours_of_operation_arn,
                name: self.name,
                description: self.description,
                time_zone: self.time_zone,
                config: self.config,
                tags: self.tags,
            }
        }
    }
}
impl HoursOfOperation {
    /// Creates a new builder-style object to manufacture [`HoursOfOperation`](crate::model::HoursOfOperation)
    pub fn builder() -> crate::model::hours_of_operation::Builder {
        crate::model::hours_of_operation::Builder::default()
    }
}

/// <p>Contains information about a contact flow module.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContactFlowModule {
    /// <p>The Amazon Resource Name (ARN).</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact flow module.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the contact flow module.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The content of the contact flow module.</p>
    pub content: std::option::Option<std::string::String>,
    /// <p>The description of the contact flow module.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of contact flow module.</p>
    pub state: std::option::Option<crate::model::ContactFlowModuleState>,
    /// <p>The status of the contact flow module.</p>
    pub status: std::option::Option<crate::model::ContactFlowModuleStatus>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ContactFlowModule {
    /// <p>The Amazon Resource Name (ARN).</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The identifier of the contact flow module.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the contact flow module.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The content of the contact flow module.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The description of the contact flow module.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of contact flow module.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ContactFlowModuleState> {
        self.state.as_ref()
    }
    /// <p>The status of the contact flow module.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ContactFlowModuleStatus> {
        self.status.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for ContactFlowModule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContactFlowModule");
        formatter.field("arn", &self.arn);
        formatter.field("id", &self.id);
        formatter.field("name", &self.name);
        formatter.field("content", &self.content);
        formatter.field("description", &self.description);
        formatter.field("state", &self.state);
        formatter.field("status", &self.status);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ContactFlowModule`](crate::model::ContactFlowModule)
pub mod contact_flow_module {

    /// A builder for [`ContactFlowModule`](crate::model::ContactFlowModule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ContactFlowModuleState>,
        pub(crate) status: std::option::Option<crate::model::ContactFlowModuleStatus>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN).</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN).</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The identifier of the contact flow module.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact flow module.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the contact flow module.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the contact flow module.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The content of the contact flow module.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the contact flow module.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The description of the contact flow module.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the contact flow module.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of contact flow module.</p>
        pub fn state(mut self, input: crate::model::ContactFlowModuleState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The type of contact flow module.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ContactFlowModuleState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status of the contact flow module.</p>
        pub fn status(mut self, input: crate::model::ContactFlowModuleStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the contact flow module.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ContactFlowModuleStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactFlowModule`](crate::model::ContactFlowModule)
        pub fn build(self) -> crate::model::ContactFlowModule {
            crate::model::ContactFlowModule {
                arn: self.arn,
                id: self.id,
                name: self.name,
                content: self.content,
                description: self.description,
                state: self.state,
                status: self.status,
                tags: self.tags,
            }
        }
    }
}
impl ContactFlowModule {
    /// Creates a new builder-style object to manufacture [`ContactFlowModule`](crate::model::ContactFlowModule)
    pub fn builder() -> crate::model::contact_flow_module::Builder {
        crate::model::contact_flow_module::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContactFlowModuleStatus {
    #[allow(missing_docs)] // documentation missing in model
    Published,
    #[allow(missing_docs)] // documentation missing in model
    Saved,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContactFlowModuleStatus {
    fn from(s: &str) -> Self {
        match s {
            "PUBLISHED" => ContactFlowModuleStatus::Published,
            "SAVED" => ContactFlowModuleStatus::Saved,
            other => ContactFlowModuleStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContactFlowModuleStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContactFlowModuleStatus::from(s))
    }
}
impl ContactFlowModuleStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContactFlowModuleStatus::Published => "PUBLISHED",
            ContactFlowModuleStatus::Saved => "SAVED",
            ContactFlowModuleStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["PUBLISHED", "SAVED"]
    }
}
impl AsRef<str> for ContactFlowModuleStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about a contact flow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContactFlow {
    /// <p>The Amazon Resource Name (ARN) of the contact flow.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact flow.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the contact flow.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the contact flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a Contact Flow Type</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub r#type: std::option::Option<crate::model::ContactFlowType>,
    /// <p>The type of contact flow.</p>
    pub state: std::option::Option<crate::model::ContactFlowState>,
    /// <p>The description of the contact flow.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The content of the contact flow.</p>
    pub content: std::option::Option<std::string::String>,
    /// <p>One or more tags.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ContactFlow {
    /// <p>The Amazon Resource Name (ARN) of the contact flow.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The identifier of the contact flow.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the contact flow.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the contact flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a Contact Flow Type</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ContactFlowType> {
        self.r#type.as_ref()
    }
    /// <p>The type of contact flow.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ContactFlowState> {
        self.state.as_ref()
    }
    /// <p>The description of the contact flow.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The content of the contact flow.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>One or more tags.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for ContactFlow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContactFlow");
        formatter.field("arn", &self.arn);
        formatter.field("id", &self.id);
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.field("state", &self.state);
        formatter.field("description", &self.description);
        formatter.field("content", &self.content);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ContactFlow`](crate::model::ContactFlow)
pub mod contact_flow {

    /// A builder for [`ContactFlow`](crate::model::ContactFlow)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ContactFlowType>,
        pub(crate) state: std::option::Option<crate::model::ContactFlowState>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the contact flow.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the contact flow.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The identifier of the contact flow.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact flow.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the contact flow.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the contact flow.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the contact flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a Contact Flow Type</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn r#type(mut self, input: crate::model::ContactFlowType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the contact flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a Contact Flow Type</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ContactFlowType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The type of contact flow.</p>
        pub fn state(mut self, input: crate::model::ContactFlowState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The type of contact flow.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ContactFlowState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The description of the contact flow.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the contact flow.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The content of the contact flow.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the contact flow.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>One or more tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>One or more tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactFlow`](crate::model::ContactFlow)
        pub fn build(self) -> crate::model::ContactFlow {
            crate::model::ContactFlow {
                arn: self.arn,
                id: self.id,
                name: self.name,
                r#type: self.r#type,
                state: self.state,
                description: self.description,
                content: self.content,
                tags: self.tags,
            }
        }
    }
}
impl ContactFlow {
    /// Creates a new builder-style object to manufacture [`ContactFlow`](crate::model::ContactFlow)
    pub fn builder() -> crate::model::contact_flow::Builder {
        crate::model::contact_flow::Builder::default()
    }
}

/// <p>Contains information about a contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Contact {
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The identifier for the contact.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    pub initial_contact_id: std::option::Option<std::string::String>,
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    pub previous_contact_id: std::option::Option<std::string::String>,
    /// <p>Indicates how the contact was initiated.</p>
    pub initiation_method: std::option::Option<crate::model::ContactInitiationMethod>,
    /// <p>The name of the contact.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the contact.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>How the contact reached your contact center.</p>
    pub channel: std::option::Option<crate::model::Channel>,
    /// <p>If this contact was queued, this contains information about the queue. </p>
    pub queue_info: std::option::Option<crate::model::QueueInfo>,
    /// <p>Information about the agent who accepted the contact.</p>
    pub agent_info: std::option::Option<crate::model::AgentInfo>,
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived.</p>
    pub initiation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp when the customer endpoint disconnected from Amazon Connect.</p>
    pub disconnect_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp when contact was last updated.</p>
    pub last_update_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow. </p>
    pub scheduled_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl Contact {
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The identifier for the contact.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    pub fn initial_contact_id(&self) -> std::option::Option<&str> {
        self.initial_contact_id.as_deref()
    }
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    pub fn previous_contact_id(&self) -> std::option::Option<&str> {
        self.previous_contact_id.as_deref()
    }
    /// <p>Indicates how the contact was initiated.</p>
    pub fn initiation_method(&self) -> std::option::Option<&crate::model::ContactInitiationMethod> {
        self.initiation_method.as_ref()
    }
    /// <p>The name of the contact.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the contact.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>How the contact reached your contact center.</p>
    pub fn channel(&self) -> std::option::Option<&crate::model::Channel> {
        self.channel.as_ref()
    }
    /// <p>If this contact was queued, this contains information about the queue. </p>
    pub fn queue_info(&self) -> std::option::Option<&crate::model::QueueInfo> {
        self.queue_info.as_ref()
    }
    /// <p>Information about the agent who accepted the contact.</p>
    pub fn agent_info(&self) -> std::option::Option<&crate::model::AgentInfo> {
        self.agent_info.as_ref()
    }
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived.</p>
    pub fn initiation_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.initiation_timestamp.as_ref()
    }
    /// <p>The timestamp when the customer endpoint disconnected from Amazon Connect.</p>
    pub fn disconnect_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.disconnect_timestamp.as_ref()
    }
    /// <p>The timestamp when contact was last updated.</p>
    pub fn last_update_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_timestamp.as_ref()
    }
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow. </p>
    pub fn scheduled_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.scheduled_timestamp.as_ref()
    }
}
impl std::fmt::Debug for Contact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Contact");
        formatter.field("arn", &self.arn);
        formatter.field("id", &self.id);
        formatter.field("initial_contact_id", &self.initial_contact_id);
        formatter.field("previous_contact_id", &self.previous_contact_id);
        formatter.field("initiation_method", &self.initiation_method);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("channel", &self.channel);
        formatter.field("queue_info", &self.queue_info);
        formatter.field("agent_info", &self.agent_info);
        formatter.field("initiation_timestamp", &self.initiation_timestamp);
        formatter.field("disconnect_timestamp", &self.disconnect_timestamp);
        formatter.field("last_update_timestamp", &self.last_update_timestamp);
        formatter.field("scheduled_timestamp", &self.scheduled_timestamp);
        formatter.finish()
    }
}
/// See [`Contact`](crate::model::Contact)
pub mod contact {

    /// A builder for [`Contact`](crate::model::Contact)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) initial_contact_id: std::option::Option<std::string::String>,
        pub(crate) previous_contact_id: std::option::Option<std::string::String>,
        pub(crate) initiation_method: std::option::Option<crate::model::ContactInitiationMethod>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) channel: std::option::Option<crate::model::Channel>,
        pub(crate) queue_info: std::option::Option<crate::model::QueueInfo>,
        pub(crate) agent_info: std::option::Option<crate::model::AgentInfo>,
        pub(crate) initiation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) disconnect_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_update_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) scheduled_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the contact.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the contact.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The identifier for the contact.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier for the contact.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
        pub fn initial_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.initial_contact_id = Some(input.into());
            self
        }
        /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
        pub fn set_initial_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_contact_id = input;
            self
        }
        /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
        pub fn previous_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.previous_contact_id = Some(input.into());
            self
        }
        /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
        pub fn set_previous_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.previous_contact_id = input;
            self
        }
        /// <p>Indicates how the contact was initiated.</p>
        pub fn initiation_method(mut self, input: crate::model::ContactInitiationMethod) -> Self {
            self.initiation_method = Some(input);
            self
        }
        /// <p>Indicates how the contact was initiated.</p>
        pub fn set_initiation_method(
            mut self,
            input: std::option::Option<crate::model::ContactInitiationMethod>,
        ) -> Self {
            self.initiation_method = input;
            self
        }
        /// <p>The name of the contact.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the contact.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the contact.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the contact.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>How the contact reached your contact center.</p>
        pub fn channel(mut self, input: crate::model::Channel) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>How the contact reached your contact center.</p>
        pub fn set_channel(mut self, input: std::option::Option<crate::model::Channel>) -> Self {
            self.channel = input;
            self
        }
        /// <p>If this contact was queued, this contains information about the queue. </p>
        pub fn queue_info(mut self, input: crate::model::QueueInfo) -> Self {
            self.queue_info = Some(input);
            self
        }
        /// <p>If this contact was queued, this contains information about the queue. </p>
        pub fn set_queue_info(
            mut self,
            input: std::option::Option<crate::model::QueueInfo>,
        ) -> Self {
            self.queue_info = input;
            self
        }
        /// <p>Information about the agent who accepted the contact.</p>
        pub fn agent_info(mut self, input: crate::model::AgentInfo) -> Self {
            self.agent_info = Some(input);
            self
        }
        /// <p>Information about the agent who accepted the contact.</p>
        pub fn set_agent_info(
            mut self,
            input: std::option::Option<crate::model::AgentInfo>,
        ) -> Self {
            self.agent_info = input;
            self
        }
        /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived.</p>
        pub fn initiation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.initiation_timestamp = Some(input);
            self
        }
        /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived.</p>
        pub fn set_initiation_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.initiation_timestamp = input;
            self
        }
        /// <p>The timestamp when the customer endpoint disconnected from Amazon Connect.</p>
        pub fn disconnect_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.disconnect_timestamp = Some(input);
            self
        }
        /// <p>The timestamp when the customer endpoint disconnected from Amazon Connect.</p>
        pub fn set_disconnect_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.disconnect_timestamp = input;
            self
        }
        /// <p>The timestamp when contact was last updated.</p>
        pub fn last_update_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_timestamp = Some(input);
            self
        }
        /// <p>The timestamp when contact was last updated.</p>
        pub fn set_last_update_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_timestamp = input;
            self
        }
        /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow. </p>
        pub fn scheduled_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.scheduled_timestamp = Some(input);
            self
        }
        /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow. </p>
        pub fn set_scheduled_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.scheduled_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`Contact`](crate::model::Contact)
        pub fn build(self) -> crate::model::Contact {
            crate::model::Contact {
                arn: self.arn,
                id: self.id,
                initial_contact_id: self.initial_contact_id,
                previous_contact_id: self.previous_contact_id,
                initiation_method: self.initiation_method,
                name: self.name,
                description: self.description,
                channel: self.channel,
                queue_info: self.queue_info,
                agent_info: self.agent_info,
                initiation_timestamp: self.initiation_timestamp,
                disconnect_timestamp: self.disconnect_timestamp,
                last_update_timestamp: self.last_update_timestamp,
                scheduled_timestamp: self.scheduled_timestamp,
            }
        }
    }
}
impl Contact {
    /// Creates a new builder-style object to manufacture [`Contact`](crate::model::Contact)
    pub fn builder() -> crate::model::contact::Builder {
        crate::model::contact::Builder::default()
    }
}

/// <p>Information about the agent who accepted the contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AgentInfo {
    /// <p>The identifier of the agent who accepted the contact.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The timestamp when the contact was connected to the agent.</p>
    pub connected_to_agent_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl AgentInfo {
    /// <p>The identifier of the agent who accepted the contact.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The timestamp when the contact was connected to the agent.</p>
    pub fn connected_to_agent_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.connected_to_agent_timestamp.as_ref()
    }
}
impl std::fmt::Debug for AgentInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AgentInfo");
        formatter.field("id", &self.id);
        formatter.field(
            "connected_to_agent_timestamp",
            &self.connected_to_agent_timestamp,
        );
        formatter.finish()
    }
}
/// See [`AgentInfo`](crate::model::AgentInfo)
pub mod agent_info {

    /// A builder for [`AgentInfo`](crate::model::AgentInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) connected_to_agent_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the agent who accepted the contact.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the agent who accepted the contact.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The timestamp when the contact was connected to the agent.</p>
        pub fn connected_to_agent_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.connected_to_agent_timestamp = Some(input);
            self
        }
        /// <p>The timestamp when the contact was connected to the agent.</p>
        pub fn set_connected_to_agent_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.connected_to_agent_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentInfo`](crate::model::AgentInfo)
        pub fn build(self) -> crate::model::AgentInfo {
            crate::model::AgentInfo {
                id: self.id,
                connected_to_agent_timestamp: self.connected_to_agent_timestamp,
            }
        }
    }
}
impl AgentInfo {
    /// Creates a new builder-style object to manufacture [`AgentInfo`](crate::model::AgentInfo)
    pub fn builder() -> crate::model::agent_info::Builder {
        crate::model::agent_info::Builder::default()
    }
}

/// <p>If this contact was queued, this contains information about the queue. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueueInfo {
    /// <p>The identifier of the agent who accepted the contact.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The timestamp when the contact was added to the queue.</p>
    pub enqueue_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl QueueInfo {
    /// <p>The identifier of the agent who accepted the contact.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The timestamp when the contact was added to the queue.</p>
    pub fn enqueue_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.enqueue_timestamp.as_ref()
    }
}
impl std::fmt::Debug for QueueInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueueInfo");
        formatter.field("id", &self.id);
        formatter.field("enqueue_timestamp", &self.enqueue_timestamp);
        formatter.finish()
    }
}
/// See [`QueueInfo`](crate::model::QueueInfo)
pub mod queue_info {

    /// A builder for [`QueueInfo`](crate::model::QueueInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) enqueue_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the agent who accepted the contact.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the agent who accepted the contact.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The timestamp when the contact was added to the queue.</p>
        pub fn enqueue_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.enqueue_timestamp = Some(input);
            self
        }
        /// <p>The timestamp when the contact was added to the queue.</p>
        pub fn set_enqueue_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.enqueue_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`QueueInfo`](crate::model::QueueInfo)
        pub fn build(self) -> crate::model::QueueInfo {
            crate::model::QueueInfo {
                id: self.id,
                enqueue_timestamp: self.enqueue_timestamp,
            }
        }
    }
}
impl QueueInfo {
    /// Creates a new builder-style object to manufacture [`QueueInfo`](crate::model::QueueInfo)
    pub fn builder() -> crate::model::queue_info::Builder {
        crate::model::queue_info::Builder::default()
    }
}

/// <p>Contains information about an agent status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AgentStatus {
    /// <p>The Amazon Resource Name (ARN) of the agent status.</p>
    pub agent_status_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the agent status.</p>
    pub agent_status_id: std::option::Option<std::string::String>,
    /// <p>The name of the agent status.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the agent status.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of agent status.</p>
    pub r#type: std::option::Option<crate::model::AgentStatusType>,
    /// <p>The display order of the agent status.</p>
    pub display_order: std::option::Option<i32>,
    /// <p>The state of the agent status.</p>
    pub state: std::option::Option<crate::model::AgentStatusState>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl AgentStatus {
    /// <p>The Amazon Resource Name (ARN) of the agent status.</p>
    pub fn agent_status_arn(&self) -> std::option::Option<&str> {
        self.agent_status_arn.as_deref()
    }
    /// <p>The identifier of the agent status.</p>
    pub fn agent_status_id(&self) -> std::option::Option<&str> {
        self.agent_status_id.as_deref()
    }
    /// <p>The name of the agent status.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the agent status.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of agent status.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::AgentStatusType> {
        self.r#type.as_ref()
    }
    /// <p>The display order of the agent status.</p>
    pub fn display_order(&self) -> std::option::Option<i32> {
        self.display_order
    }
    /// <p>The state of the agent status.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::AgentStatusState> {
        self.state.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for AgentStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AgentStatus");
        formatter.field("agent_status_arn", &self.agent_status_arn);
        formatter.field("agent_status_id", &self.agent_status_id);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("r#type", &self.r#type);
        formatter.field("display_order", &self.display_order);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`AgentStatus`](crate::model::AgentStatus)
pub mod agent_status {

    /// A builder for [`AgentStatus`](crate::model::AgentStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) agent_status_arn: std::option::Option<std::string::String>,
        pub(crate) agent_status_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::AgentStatusType>,
        pub(crate) display_order: std::option::Option<i32>,
        pub(crate) state: std::option::Option<crate::model::AgentStatusState>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the agent status.</p>
        pub fn agent_status_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_status_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the agent status.</p>
        pub fn set_agent_status_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.agent_status_arn = input;
            self
        }
        /// <p>The identifier of the agent status.</p>
        pub fn agent_status_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_status_id = Some(input.into());
            self
        }
        /// <p>The identifier of the agent status.</p>
        pub fn set_agent_status_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.agent_status_id = input;
            self
        }
        /// <p>The name of the agent status.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the agent status.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the agent status.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the agent status.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of agent status.</p>
        pub fn r#type(mut self, input: crate::model::AgentStatusType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of agent status.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::AgentStatusType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The display order of the agent status.</p>
        pub fn display_order(mut self, input: i32) -> Self {
            self.display_order = Some(input);
            self
        }
        /// <p>The display order of the agent status.</p>
        pub fn set_display_order(mut self, input: std::option::Option<i32>) -> Self {
            self.display_order = input;
            self
        }
        /// <p>The state of the agent status.</p>
        pub fn state(mut self, input: crate::model::AgentStatusState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the agent status.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AgentStatusState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentStatus`](crate::model::AgentStatus)
        pub fn build(self) -> crate::model::AgentStatus {
            crate::model::AgentStatus {
                agent_status_arn: self.agent_status_arn,
                agent_status_id: self.agent_status_id,
                name: self.name,
                description: self.description,
                r#type: self.r#type,
                display_order: self.display_order,
                state: self.state,
                tags: self.tags,
            }
        }
    }
}
impl AgentStatus {
    /// Creates a new builder-style object to manufacture [`AgentStatus`](crate::model::AgentStatus)
    pub fn builder() -> crate::model::agent_status::Builder {
        crate::model::agent_status::Builder::default()
    }
}
