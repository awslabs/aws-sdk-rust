// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains information about a contact.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct Contact {
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    pub arn: ::std::option::Option<::std::string::String>,
    /// <p>The identifier for the contact.</p>
    pub id: ::std::option::Option<::std::string::String>,
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    pub initial_contact_id: ::std::option::Option<::std::string::String>,
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    pub previous_contact_id: ::std::option::Option<::std::string::String>,
    /// <p>This is the root contactId which is used as a unique identifier for all subsequent contacts in a contact tree.</p>
    pub contact_association_id: ::std::option::Option<::std::string::String>,
    /// <p>Indicates how the contact was initiated.</p>
    pub initiation_method: ::std::option::Option<crate::types::ContactInitiationMethod>,
    /// <p>The name of the contact.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The description of the contact.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>How the contact reached your contact center.</p>
    pub channel: ::std::option::Option<crate::types::Channel>,
    /// <p>If this contact was queued, this contains information about the queue.</p>
    pub queue_info: ::std::option::Option<crate::types::QueueInfo>,
    /// <p>Information about the agent who accepted the contact.</p>
    pub agent_info: ::std::option::Option<crate::types::AgentInfo>,
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived. For <code>EXTERNAL_OUTBOUND</code>, this is when the agent started dialing the external participant. For <code>MONITOR</code>, this is when the supervisor started listening to a contact.</p>
    pub initiation_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The date and time that the customer endpoint disconnected from the current contact, in UTC time. In transfer scenarios, the DisconnectTimestamp of the previous contact indicates the date and time when that contact ended.</p>
    pub disconnect_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The timestamp when contact was last updated.</p>
    pub last_update_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The timestamp when the contact was last paused.</p>
    pub last_paused_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The timestamp when the contact was last resumed.</p>
    pub last_resumed_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The timestamp when ringing started for a campaign call.</p>
    pub ring_start_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>Total pause count for a contact.</p>
    pub total_pause_count: ::std::option::Option<i32>,
    /// <p>Total pause duration for a contact in seconds.</p>
    pub total_pause_duration_in_seconds: ::std::option::Option<i32>,
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow.</p>
    pub scheduled_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
    pub related_contact_id: ::std::option::Option<::std::string::String>,
    /// <p>Information about Amazon Connect Wisdom.</p>
    pub wisdom_info: ::std::option::Option<crate::types::WisdomInfo>,
    /// <p>The customer's identification number. For example, the <code>CustomerId</code> may be a customer number from your CRM. You can create a Lambda function to pull the unique customer ID of the caller from your CRM system. If you enable Amazon Connect Voice ID capability, this attribute is populated with the <code>CustomerSpeakerId</code> of the caller.</p>
    pub customer_id: ::std::option::Option<::std::string::String>,
    /// <p>The customer or external third party participant endpoint.</p>
    pub customer_endpoint: ::std::option::Option<crate::types::EndpointInfo>,
    /// <p>The system endpoint. For <code>INBOUND</code>, this is the phone number or email address that the customer dialed. For <code>OUTBOUND</code> and <code>EXTERNAL_OUTBOUND</code>, this is the outbound caller ID number assigned to the outbound queue that is used to dial the customer. For callback, this shows up as Softphone for calls handled by agents with softphone.</p>
    pub system_endpoint: ::std::option::Option<crate::types::EndpointInfo>,
    /// <p>An integer that represents the queue time adjust to be applied to the contact, in seconds (longer / larger queue time are routed preferentially). Cannot be specified if the QueuePriority is specified. Must be statically defined and a valid integer value.</p>
    pub queue_time_adjustment_seconds: ::std::option::Option<i32>,
    /// <p>An integer that represents the queue priority to be applied to the contact (lower priorities are routed preferentially). Cannot be specified if the QueueTimeAdjustmentSeconds is specified. Must be statically defined, must be larger than zero, and a valid integer value. Default Value is 5.</p>
    pub queue_priority: ::std::option::Option<i64>,
    /// <p>Tags associated with the contact. This contains both Amazon Web Services generated and user-defined tags.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The timestamp when customer endpoint connected to Amazon Connect.</p>
    pub connected_to_system_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>Latest routing criteria on the contact.</p>
    pub routing_criteria: ::std::option::Option<crate::types::RoutingCriteria>,
    /// <p>Information about the Customer on the contact.</p>
    pub customer: ::std::option::Option<crate::types::Customer>,
    /// <p>Information associated with a campaign.</p>
    pub campaign: ::std::option::Option<crate::types::Campaign>,
    /// <p>Indicates how an <a href="https://docs.aws.amazon.com/connect/latest/adminguide/how-to-create-campaigns.html">outbound campaign</a> call is actually disposed if the contact is connected to Amazon Connect.</p>
    pub answering_machine_detection_status: ::std::option::Option<crate::types::AnsweringMachineDetectionStatus>,
    /// <p>Information about customer’s voice activity.</p>
    pub customer_voice_activity: ::std::option::Option<crate::types::CustomerVoiceActivity>,
    /// <p>Information about the quality of the participant's media connection.</p>
    pub quality_metrics: ::std::option::Option<crate::types::QualityMetrics>,
    /// <p>Information about how agent, bot, and customer interact in a chat contact.</p>
    pub chat_metrics: ::std::option::Option<crate::types::ChatMetrics>,
    /// <p>Information about the call disconnect experience.</p>
    pub disconnect_details: ::std::option::Option<crate::types::DisconnectDetails>,
    /// <p>List of additional email addresses for an email contact.</p>
    pub additional_email_recipients: ::std::option::Option<crate::types::AdditionalEmailRecipients>,
    /// <p>A set of system defined key-value pairs stored on individual contact segments using an attribute map. The attributes are standard Amazon Connect attributes and can be accessed in flows. Attribute keys can include only alphanumeric, -, and _ characters. This field can be used to show channel subtype. For example, <code>connect:Guide</code> or <code>connect:SMS</code>.</p>
    pub segment_attributes: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::SegmentAttributeValue>>,
    /// <p>If recording was enabled, this is information about the recordings.</p>
    pub recordings: ::std::option::Option<::std::vec::Vec<crate::types::RecordingInfo>>,
    /// <p>The disconnect reason for the contact. For a list and description of all the possible disconnect reasons by channel, see DisconnectReason under <a href="https://docs.aws.amazon.com/connect/latest/adminguide/ctr-data-model.html#ctr-ContactTraceRecord">ContactTraceRecord</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub disconnect_reason: ::std::option::Option<::std::string::String>,
    /// <p>Information about the contact evaluations where the key is the FormId, which is a unique identifier for the form.</p>
    pub contact_evaluations: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::ContactEvaluation>>,
    /// <p>If this contact was created using a task template, this contains information about the task template.</p>
    pub task_template_info: ::std::option::Option<crate::types::TaskTemplateInfoV2>,
    /// <p>A map of string key/value pairs that contain user-defined attributes which are lightly typed within the contact. This object is used only for task contacts.</p>
    pub contact_details: ::std::option::Option<crate::types::ContactDetails>,
    /// <p>Information about the outbound strategy.</p>
    pub outbound_strategy: ::std::option::Option<crate::types::OutboundStrategy>,
    /// <p>The attributes of the contact.</p>
    pub attributes: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl Contact {
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    pub fn arn(&self) -> ::std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The identifier for the contact.</p>
    pub fn id(&self) -> ::std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    pub fn initial_contact_id(&self) -> ::std::option::Option<&str> {
        self.initial_contact_id.as_deref()
    }
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    pub fn previous_contact_id(&self) -> ::std::option::Option<&str> {
        self.previous_contact_id.as_deref()
    }
    /// <p>This is the root contactId which is used as a unique identifier for all subsequent contacts in a contact tree.</p>
    pub fn contact_association_id(&self) -> ::std::option::Option<&str> {
        self.contact_association_id.as_deref()
    }
    /// <p>Indicates how the contact was initiated.</p>
    pub fn initiation_method(&self) -> ::std::option::Option<&crate::types::ContactInitiationMethod> {
        self.initiation_method.as_ref()
    }
    /// <p>The name of the contact.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the contact.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>How the contact reached your contact center.</p>
    pub fn channel(&self) -> ::std::option::Option<&crate::types::Channel> {
        self.channel.as_ref()
    }
    /// <p>If this contact was queued, this contains information about the queue.</p>
    pub fn queue_info(&self) -> ::std::option::Option<&crate::types::QueueInfo> {
        self.queue_info.as_ref()
    }
    /// <p>Information about the agent who accepted the contact.</p>
    pub fn agent_info(&self) -> ::std::option::Option<&crate::types::AgentInfo> {
        self.agent_info.as_ref()
    }
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived. For <code>EXTERNAL_OUTBOUND</code>, this is when the agent started dialing the external participant. For <code>MONITOR</code>, this is when the supervisor started listening to a contact.</p>
    pub fn initiation_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.initiation_timestamp.as_ref()
    }
    /// <p>The date and time that the customer endpoint disconnected from the current contact, in UTC time. In transfer scenarios, the DisconnectTimestamp of the previous contact indicates the date and time when that contact ended.</p>
    pub fn disconnect_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.disconnect_timestamp.as_ref()
    }
    /// <p>The timestamp when contact was last updated.</p>
    pub fn last_update_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.last_update_timestamp.as_ref()
    }
    /// <p>The timestamp when the contact was last paused.</p>
    pub fn last_paused_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.last_paused_timestamp.as_ref()
    }
    /// <p>The timestamp when the contact was last resumed.</p>
    pub fn last_resumed_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.last_resumed_timestamp.as_ref()
    }
    /// <p>The timestamp when ringing started for a campaign call.</p>
    pub fn ring_start_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.ring_start_timestamp.as_ref()
    }
    /// <p>Total pause count for a contact.</p>
    pub fn total_pause_count(&self) -> ::std::option::Option<i32> {
        self.total_pause_count
    }
    /// <p>Total pause duration for a contact in seconds.</p>
    pub fn total_pause_duration_in_seconds(&self) -> ::std::option::Option<i32> {
        self.total_pause_duration_in_seconds
    }
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow.</p>
    pub fn scheduled_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.scheduled_timestamp.as_ref()
    }
    /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
    pub fn related_contact_id(&self) -> ::std::option::Option<&str> {
        self.related_contact_id.as_deref()
    }
    /// <p>Information about Amazon Connect Wisdom.</p>
    pub fn wisdom_info(&self) -> ::std::option::Option<&crate::types::WisdomInfo> {
        self.wisdom_info.as_ref()
    }
    /// <p>The customer's identification number. For example, the <code>CustomerId</code> may be a customer number from your CRM. You can create a Lambda function to pull the unique customer ID of the caller from your CRM system. If you enable Amazon Connect Voice ID capability, this attribute is populated with the <code>CustomerSpeakerId</code> of the caller.</p>
    pub fn customer_id(&self) -> ::std::option::Option<&str> {
        self.customer_id.as_deref()
    }
    /// <p>The customer or external third party participant endpoint.</p>
    pub fn customer_endpoint(&self) -> ::std::option::Option<&crate::types::EndpointInfo> {
        self.customer_endpoint.as_ref()
    }
    /// <p>The system endpoint. For <code>INBOUND</code>, this is the phone number or email address that the customer dialed. For <code>OUTBOUND</code> and <code>EXTERNAL_OUTBOUND</code>, this is the outbound caller ID number assigned to the outbound queue that is used to dial the customer. For callback, this shows up as Softphone for calls handled by agents with softphone.</p>
    pub fn system_endpoint(&self) -> ::std::option::Option<&crate::types::EndpointInfo> {
        self.system_endpoint.as_ref()
    }
    /// <p>An integer that represents the queue time adjust to be applied to the contact, in seconds (longer / larger queue time are routed preferentially). Cannot be specified if the QueuePriority is specified. Must be statically defined and a valid integer value.</p>
    pub fn queue_time_adjustment_seconds(&self) -> ::std::option::Option<i32> {
        self.queue_time_adjustment_seconds
    }
    /// <p>An integer that represents the queue priority to be applied to the contact (lower priorities are routed preferentially). Cannot be specified if the QueueTimeAdjustmentSeconds is specified. Must be statically defined, must be larger than zero, and a valid integer value. Default Value is 5.</p>
    pub fn queue_priority(&self) -> ::std::option::Option<i64> {
        self.queue_priority
    }
    /// <p>Tags associated with the contact. This contains both Amazon Web Services generated and user-defined tags.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>The timestamp when customer endpoint connected to Amazon Connect.</p>
    pub fn connected_to_system_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.connected_to_system_timestamp.as_ref()
    }
    /// <p>Latest routing criteria on the contact.</p>
    pub fn routing_criteria(&self) -> ::std::option::Option<&crate::types::RoutingCriteria> {
        self.routing_criteria.as_ref()
    }
    /// <p>Information about the Customer on the contact.</p>
    pub fn customer(&self) -> ::std::option::Option<&crate::types::Customer> {
        self.customer.as_ref()
    }
    /// <p>Information associated with a campaign.</p>
    pub fn campaign(&self) -> ::std::option::Option<&crate::types::Campaign> {
        self.campaign.as_ref()
    }
    /// <p>Indicates how an <a href="https://docs.aws.amazon.com/connect/latest/adminguide/how-to-create-campaigns.html">outbound campaign</a> call is actually disposed if the contact is connected to Amazon Connect.</p>
    pub fn answering_machine_detection_status(&self) -> ::std::option::Option<&crate::types::AnsweringMachineDetectionStatus> {
        self.answering_machine_detection_status.as_ref()
    }
    /// <p>Information about customer’s voice activity.</p>
    pub fn customer_voice_activity(&self) -> ::std::option::Option<&crate::types::CustomerVoiceActivity> {
        self.customer_voice_activity.as_ref()
    }
    /// <p>Information about the quality of the participant's media connection.</p>
    pub fn quality_metrics(&self) -> ::std::option::Option<&crate::types::QualityMetrics> {
        self.quality_metrics.as_ref()
    }
    /// <p>Information about how agent, bot, and customer interact in a chat contact.</p>
    pub fn chat_metrics(&self) -> ::std::option::Option<&crate::types::ChatMetrics> {
        self.chat_metrics.as_ref()
    }
    /// <p>Information about the call disconnect experience.</p>
    pub fn disconnect_details(&self) -> ::std::option::Option<&crate::types::DisconnectDetails> {
        self.disconnect_details.as_ref()
    }
    /// <p>List of additional email addresses for an email contact.</p>
    pub fn additional_email_recipients(&self) -> ::std::option::Option<&crate::types::AdditionalEmailRecipients> {
        self.additional_email_recipients.as_ref()
    }
    /// <p>A set of system defined key-value pairs stored on individual contact segments using an attribute map. The attributes are standard Amazon Connect attributes and can be accessed in flows. Attribute keys can include only alphanumeric, -, and _ characters. This field can be used to show channel subtype. For example, <code>connect:Guide</code> or <code>connect:SMS</code>.</p>
    pub fn segment_attributes(
        &self,
    ) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, crate::types::SegmentAttributeValue>> {
        self.segment_attributes.as_ref()
    }
    /// <p>If recording was enabled, this is information about the recordings.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.recordings.is_none()`.
    pub fn recordings(&self) -> &[crate::types::RecordingInfo] {
        self.recordings.as_deref().unwrap_or_default()
    }
    /// <p>The disconnect reason for the contact. For a list and description of all the possible disconnect reasons by channel, see DisconnectReason under <a href="https://docs.aws.amazon.com/connect/latest/adminguide/ctr-data-model.html#ctr-ContactTraceRecord">ContactTraceRecord</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub fn disconnect_reason(&self) -> ::std::option::Option<&str> {
        self.disconnect_reason.as_deref()
    }
    /// <p>Information about the contact evaluations where the key is the FormId, which is a unique identifier for the form.</p>
    pub fn contact_evaluations(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, crate::types::ContactEvaluation>> {
        self.contact_evaluations.as_ref()
    }
    /// <p>If this contact was created using a task template, this contains information about the task template.</p>
    pub fn task_template_info(&self) -> ::std::option::Option<&crate::types::TaskTemplateInfoV2> {
        self.task_template_info.as_ref()
    }
    /// <p>A map of string key/value pairs that contain user-defined attributes which are lightly typed within the contact. This object is used only for task contacts.</p>
    pub fn contact_details(&self) -> ::std::option::Option<&crate::types::ContactDetails> {
        self.contact_details.as_ref()
    }
    /// <p>Information about the outbound strategy.</p>
    pub fn outbound_strategy(&self) -> ::std::option::Option<&crate::types::OutboundStrategy> {
        self.outbound_strategy.as_ref()
    }
    /// <p>The attributes of the contact.</p>
    pub fn attributes(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.attributes.as_ref()
    }
}
impl ::std::fmt::Debug for Contact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("Contact");
        formatter.field("arn", &self.arn);
        formatter.field("id", &self.id);
        formatter.field("initial_contact_id", &self.initial_contact_id);
        formatter.field("previous_contact_id", &self.previous_contact_id);
        formatter.field("contact_association_id", &self.contact_association_id);
        formatter.field("initiation_method", &self.initiation_method);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("channel", &self.channel);
        formatter.field("queue_info", &self.queue_info);
        formatter.field("agent_info", &self.agent_info);
        formatter.field("initiation_timestamp", &self.initiation_timestamp);
        formatter.field("disconnect_timestamp", &self.disconnect_timestamp);
        formatter.field("last_update_timestamp", &self.last_update_timestamp);
        formatter.field("last_paused_timestamp", &self.last_paused_timestamp);
        formatter.field("last_resumed_timestamp", &self.last_resumed_timestamp);
        formatter.field("ring_start_timestamp", &self.ring_start_timestamp);
        formatter.field("total_pause_count", &self.total_pause_count);
        formatter.field("total_pause_duration_in_seconds", &self.total_pause_duration_in_seconds);
        formatter.field("scheduled_timestamp", &self.scheduled_timestamp);
        formatter.field("related_contact_id", &self.related_contact_id);
        formatter.field("wisdom_info", &self.wisdom_info);
        formatter.field("customer_id", &self.customer_id);
        formatter.field("customer_endpoint", &self.customer_endpoint);
        formatter.field("system_endpoint", &self.system_endpoint);
        formatter.field("queue_time_adjustment_seconds", &self.queue_time_adjustment_seconds);
        formatter.field("queue_priority", &self.queue_priority);
        formatter.field("tags", &self.tags);
        formatter.field("connected_to_system_timestamp", &self.connected_to_system_timestamp);
        formatter.field("routing_criteria", &self.routing_criteria);
        formatter.field("customer", &self.customer);
        formatter.field("campaign", &self.campaign);
        formatter.field("answering_machine_detection_status", &self.answering_machine_detection_status);
        formatter.field("customer_voice_activity", &self.customer_voice_activity);
        formatter.field("quality_metrics", &self.quality_metrics);
        formatter.field("chat_metrics", &self.chat_metrics);
        formatter.field("disconnect_details", &self.disconnect_details);
        formatter.field("additional_email_recipients", &self.additional_email_recipients);
        formatter.field("segment_attributes", &self.segment_attributes);
        formatter.field("recordings", &self.recordings);
        formatter.field("disconnect_reason", &self.disconnect_reason);
        formatter.field("contact_evaluations", &self.contact_evaluations);
        formatter.field("task_template_info", &self.task_template_info);
        formatter.field("contact_details", &self.contact_details);
        formatter.field("outbound_strategy", &self.outbound_strategy);
        formatter.field("attributes", &self.attributes);
        formatter.finish()
    }
}
impl Contact {
    /// Creates a new builder-style object to manufacture [`Contact`](crate::types::Contact).
    pub fn builder() -> crate::types::builders::ContactBuilder {
        crate::types::builders::ContactBuilder::default()
    }
}

/// A builder for [`Contact`](crate::types::Contact).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct ContactBuilder {
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) id: ::std::option::Option<::std::string::String>,
    pub(crate) initial_contact_id: ::std::option::Option<::std::string::String>,
    pub(crate) previous_contact_id: ::std::option::Option<::std::string::String>,
    pub(crate) contact_association_id: ::std::option::Option<::std::string::String>,
    pub(crate) initiation_method: ::std::option::Option<crate::types::ContactInitiationMethod>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) channel: ::std::option::Option<crate::types::Channel>,
    pub(crate) queue_info: ::std::option::Option<crate::types::QueueInfo>,
    pub(crate) agent_info: ::std::option::Option<crate::types::AgentInfo>,
    pub(crate) initiation_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) disconnect_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) last_update_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) last_paused_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) last_resumed_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) ring_start_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) total_pause_count: ::std::option::Option<i32>,
    pub(crate) total_pause_duration_in_seconds: ::std::option::Option<i32>,
    pub(crate) scheduled_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) related_contact_id: ::std::option::Option<::std::string::String>,
    pub(crate) wisdom_info: ::std::option::Option<crate::types::WisdomInfo>,
    pub(crate) customer_id: ::std::option::Option<::std::string::String>,
    pub(crate) customer_endpoint: ::std::option::Option<crate::types::EndpointInfo>,
    pub(crate) system_endpoint: ::std::option::Option<crate::types::EndpointInfo>,
    pub(crate) queue_time_adjustment_seconds: ::std::option::Option<i32>,
    pub(crate) queue_priority: ::std::option::Option<i64>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) connected_to_system_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) routing_criteria: ::std::option::Option<crate::types::RoutingCriteria>,
    pub(crate) customer: ::std::option::Option<crate::types::Customer>,
    pub(crate) campaign: ::std::option::Option<crate::types::Campaign>,
    pub(crate) answering_machine_detection_status: ::std::option::Option<crate::types::AnsweringMachineDetectionStatus>,
    pub(crate) customer_voice_activity: ::std::option::Option<crate::types::CustomerVoiceActivity>,
    pub(crate) quality_metrics: ::std::option::Option<crate::types::QualityMetrics>,
    pub(crate) chat_metrics: ::std::option::Option<crate::types::ChatMetrics>,
    pub(crate) disconnect_details: ::std::option::Option<crate::types::DisconnectDetails>,
    pub(crate) additional_email_recipients: ::std::option::Option<crate::types::AdditionalEmailRecipients>,
    pub(crate) segment_attributes: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::SegmentAttributeValue>>,
    pub(crate) recordings: ::std::option::Option<::std::vec::Vec<crate::types::RecordingInfo>>,
    pub(crate) disconnect_reason: ::std::option::Option<::std::string::String>,
    pub(crate) contact_evaluations: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::ContactEvaluation>>,
    pub(crate) task_template_info: ::std::option::Option<crate::types::TaskTemplateInfoV2>,
    pub(crate) contact_details: ::std::option::Option<crate::types::ContactDetails>,
    pub(crate) outbound_strategy: ::std::option::Option<crate::types::OutboundStrategy>,
    pub(crate) attributes: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl ContactBuilder {
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>The identifier for the contact.</p>
    pub fn id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier for the contact.</p>
    pub fn set_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.id = input;
        self
    }
    /// <p>The identifier for the contact.</p>
    pub fn get_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.id
    }
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    pub fn initial_contact_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.initial_contact_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    pub fn set_initial_contact_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.initial_contact_id = input;
        self
    }
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    pub fn get_initial_contact_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.initial_contact_id
    }
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    pub fn previous_contact_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.previous_contact_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    pub fn set_previous_contact_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.previous_contact_id = input;
        self
    }
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    pub fn get_previous_contact_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.previous_contact_id
    }
    /// <p>This is the root contactId which is used as a unique identifier for all subsequent contacts in a contact tree.</p>
    pub fn contact_association_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.contact_association_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>This is the root contactId which is used as a unique identifier for all subsequent contacts in a contact tree.</p>
    pub fn set_contact_association_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.contact_association_id = input;
        self
    }
    /// <p>This is the root contactId which is used as a unique identifier for all subsequent contacts in a contact tree.</p>
    pub fn get_contact_association_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.contact_association_id
    }
    /// <p>Indicates how the contact was initiated.</p>
    pub fn initiation_method(mut self, input: crate::types::ContactInitiationMethod) -> Self {
        self.initiation_method = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates how the contact was initiated.</p>
    pub fn set_initiation_method(mut self, input: ::std::option::Option<crate::types::ContactInitiationMethod>) -> Self {
        self.initiation_method = input;
        self
    }
    /// <p>Indicates how the contact was initiated.</p>
    pub fn get_initiation_method(&self) -> &::std::option::Option<crate::types::ContactInitiationMethod> {
        &self.initiation_method
    }
    /// <p>The name of the contact.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the contact.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the contact.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The description of the contact.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The description of the contact.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The description of the contact.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>How the contact reached your contact center.</p>
    pub fn channel(mut self, input: crate::types::Channel) -> Self {
        self.channel = ::std::option::Option::Some(input);
        self
    }
    /// <p>How the contact reached your contact center.</p>
    pub fn set_channel(mut self, input: ::std::option::Option<crate::types::Channel>) -> Self {
        self.channel = input;
        self
    }
    /// <p>How the contact reached your contact center.</p>
    pub fn get_channel(&self) -> &::std::option::Option<crate::types::Channel> {
        &self.channel
    }
    /// <p>If this contact was queued, this contains information about the queue.</p>
    pub fn queue_info(mut self, input: crate::types::QueueInfo) -> Self {
        self.queue_info = ::std::option::Option::Some(input);
        self
    }
    /// <p>If this contact was queued, this contains information about the queue.</p>
    pub fn set_queue_info(mut self, input: ::std::option::Option<crate::types::QueueInfo>) -> Self {
        self.queue_info = input;
        self
    }
    /// <p>If this contact was queued, this contains information about the queue.</p>
    pub fn get_queue_info(&self) -> &::std::option::Option<crate::types::QueueInfo> {
        &self.queue_info
    }
    /// <p>Information about the agent who accepted the contact.</p>
    pub fn agent_info(mut self, input: crate::types::AgentInfo) -> Self {
        self.agent_info = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the agent who accepted the contact.</p>
    pub fn set_agent_info(mut self, input: ::std::option::Option<crate::types::AgentInfo>) -> Self {
        self.agent_info = input;
        self
    }
    /// <p>Information about the agent who accepted the contact.</p>
    pub fn get_agent_info(&self) -> &::std::option::Option<crate::types::AgentInfo> {
        &self.agent_info
    }
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived. For <code>EXTERNAL_OUTBOUND</code>, this is when the agent started dialing the external participant. For <code>MONITOR</code>, this is when the supervisor started listening to a contact.</p>
    pub fn initiation_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.initiation_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived. For <code>EXTERNAL_OUTBOUND</code>, this is when the agent started dialing the external participant. For <code>MONITOR</code>, this is when the supervisor started listening to a contact.</p>
    pub fn set_initiation_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.initiation_timestamp = input;
        self
    }
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived. For <code>EXTERNAL_OUTBOUND</code>, this is when the agent started dialing the external participant. For <code>MONITOR</code>, this is when the supervisor started listening to a contact.</p>
    pub fn get_initiation_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.initiation_timestamp
    }
    /// <p>The date and time that the customer endpoint disconnected from the current contact, in UTC time. In transfer scenarios, the DisconnectTimestamp of the previous contact indicates the date and time when that contact ended.</p>
    pub fn disconnect_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.disconnect_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time that the customer endpoint disconnected from the current contact, in UTC time. In transfer scenarios, the DisconnectTimestamp of the previous contact indicates the date and time when that contact ended.</p>
    pub fn set_disconnect_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.disconnect_timestamp = input;
        self
    }
    /// <p>The date and time that the customer endpoint disconnected from the current contact, in UTC time. In transfer scenarios, the DisconnectTimestamp of the previous contact indicates the date and time when that contact ended.</p>
    pub fn get_disconnect_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.disconnect_timestamp
    }
    /// <p>The timestamp when contact was last updated.</p>
    pub fn last_update_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.last_update_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when contact was last updated.</p>
    pub fn set_last_update_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.last_update_timestamp = input;
        self
    }
    /// <p>The timestamp when contact was last updated.</p>
    pub fn get_last_update_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.last_update_timestamp
    }
    /// <p>The timestamp when the contact was last paused.</p>
    pub fn last_paused_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.last_paused_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when the contact was last paused.</p>
    pub fn set_last_paused_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.last_paused_timestamp = input;
        self
    }
    /// <p>The timestamp when the contact was last paused.</p>
    pub fn get_last_paused_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.last_paused_timestamp
    }
    /// <p>The timestamp when the contact was last resumed.</p>
    pub fn last_resumed_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.last_resumed_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when the contact was last resumed.</p>
    pub fn set_last_resumed_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.last_resumed_timestamp = input;
        self
    }
    /// <p>The timestamp when the contact was last resumed.</p>
    pub fn get_last_resumed_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.last_resumed_timestamp
    }
    /// <p>The timestamp when ringing started for a campaign call.</p>
    pub fn ring_start_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.ring_start_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when ringing started for a campaign call.</p>
    pub fn set_ring_start_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.ring_start_timestamp = input;
        self
    }
    /// <p>The timestamp when ringing started for a campaign call.</p>
    pub fn get_ring_start_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.ring_start_timestamp
    }
    /// <p>Total pause count for a contact.</p>
    pub fn total_pause_count(mut self, input: i32) -> Self {
        self.total_pause_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>Total pause count for a contact.</p>
    pub fn set_total_pause_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_pause_count = input;
        self
    }
    /// <p>Total pause count for a contact.</p>
    pub fn get_total_pause_count(&self) -> &::std::option::Option<i32> {
        &self.total_pause_count
    }
    /// <p>Total pause duration for a contact in seconds.</p>
    pub fn total_pause_duration_in_seconds(mut self, input: i32) -> Self {
        self.total_pause_duration_in_seconds = ::std::option::Option::Some(input);
        self
    }
    /// <p>Total pause duration for a contact in seconds.</p>
    pub fn set_total_pause_duration_in_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_pause_duration_in_seconds = input;
        self
    }
    /// <p>Total pause duration for a contact in seconds.</p>
    pub fn get_total_pause_duration_in_seconds(&self) -> &::std::option::Option<i32> {
        &self.total_pause_duration_in_seconds
    }
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow.</p>
    pub fn scheduled_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.scheduled_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow.</p>
    pub fn set_scheduled_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.scheduled_timestamp = input;
        self
    }
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow.</p>
    pub fn get_scheduled_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.scheduled_timestamp
    }
    /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
    pub fn related_contact_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.related_contact_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
    pub fn set_related_contact_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.related_contact_id = input;
        self
    }
    /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
    pub fn get_related_contact_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.related_contact_id
    }
    /// <p>Information about Amazon Connect Wisdom.</p>
    pub fn wisdom_info(mut self, input: crate::types::WisdomInfo) -> Self {
        self.wisdom_info = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about Amazon Connect Wisdom.</p>
    pub fn set_wisdom_info(mut self, input: ::std::option::Option<crate::types::WisdomInfo>) -> Self {
        self.wisdom_info = input;
        self
    }
    /// <p>Information about Amazon Connect Wisdom.</p>
    pub fn get_wisdom_info(&self) -> &::std::option::Option<crate::types::WisdomInfo> {
        &self.wisdom_info
    }
    /// <p>The customer's identification number. For example, the <code>CustomerId</code> may be a customer number from your CRM. You can create a Lambda function to pull the unique customer ID of the caller from your CRM system. If you enable Amazon Connect Voice ID capability, this attribute is populated with the <code>CustomerSpeakerId</code> of the caller.</p>
    pub fn customer_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.customer_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The customer's identification number. For example, the <code>CustomerId</code> may be a customer number from your CRM. You can create a Lambda function to pull the unique customer ID of the caller from your CRM system. If you enable Amazon Connect Voice ID capability, this attribute is populated with the <code>CustomerSpeakerId</code> of the caller.</p>
    pub fn set_customer_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.customer_id = input;
        self
    }
    /// <p>The customer's identification number. For example, the <code>CustomerId</code> may be a customer number from your CRM. You can create a Lambda function to pull the unique customer ID of the caller from your CRM system. If you enable Amazon Connect Voice ID capability, this attribute is populated with the <code>CustomerSpeakerId</code> of the caller.</p>
    pub fn get_customer_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.customer_id
    }
    /// <p>The customer or external third party participant endpoint.</p>
    pub fn customer_endpoint(mut self, input: crate::types::EndpointInfo) -> Self {
        self.customer_endpoint = ::std::option::Option::Some(input);
        self
    }
    /// <p>The customer or external third party participant endpoint.</p>
    pub fn set_customer_endpoint(mut self, input: ::std::option::Option<crate::types::EndpointInfo>) -> Self {
        self.customer_endpoint = input;
        self
    }
    /// <p>The customer or external third party participant endpoint.</p>
    pub fn get_customer_endpoint(&self) -> &::std::option::Option<crate::types::EndpointInfo> {
        &self.customer_endpoint
    }
    /// <p>The system endpoint. For <code>INBOUND</code>, this is the phone number or email address that the customer dialed. For <code>OUTBOUND</code> and <code>EXTERNAL_OUTBOUND</code>, this is the outbound caller ID number assigned to the outbound queue that is used to dial the customer. For callback, this shows up as Softphone for calls handled by agents with softphone.</p>
    pub fn system_endpoint(mut self, input: crate::types::EndpointInfo) -> Self {
        self.system_endpoint = ::std::option::Option::Some(input);
        self
    }
    /// <p>The system endpoint. For <code>INBOUND</code>, this is the phone number or email address that the customer dialed. For <code>OUTBOUND</code> and <code>EXTERNAL_OUTBOUND</code>, this is the outbound caller ID number assigned to the outbound queue that is used to dial the customer. For callback, this shows up as Softphone for calls handled by agents with softphone.</p>
    pub fn set_system_endpoint(mut self, input: ::std::option::Option<crate::types::EndpointInfo>) -> Self {
        self.system_endpoint = input;
        self
    }
    /// <p>The system endpoint. For <code>INBOUND</code>, this is the phone number or email address that the customer dialed. For <code>OUTBOUND</code> and <code>EXTERNAL_OUTBOUND</code>, this is the outbound caller ID number assigned to the outbound queue that is used to dial the customer. For callback, this shows up as Softphone for calls handled by agents with softphone.</p>
    pub fn get_system_endpoint(&self) -> &::std::option::Option<crate::types::EndpointInfo> {
        &self.system_endpoint
    }
    /// <p>An integer that represents the queue time adjust to be applied to the contact, in seconds (longer / larger queue time are routed preferentially). Cannot be specified if the QueuePriority is specified. Must be statically defined and a valid integer value.</p>
    pub fn queue_time_adjustment_seconds(mut self, input: i32) -> Self {
        self.queue_time_adjustment_seconds = ::std::option::Option::Some(input);
        self
    }
    /// <p>An integer that represents the queue time adjust to be applied to the contact, in seconds (longer / larger queue time are routed preferentially). Cannot be specified if the QueuePriority is specified. Must be statically defined and a valid integer value.</p>
    pub fn set_queue_time_adjustment_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.queue_time_adjustment_seconds = input;
        self
    }
    /// <p>An integer that represents the queue time adjust to be applied to the contact, in seconds (longer / larger queue time are routed preferentially). Cannot be specified if the QueuePriority is specified. Must be statically defined and a valid integer value.</p>
    pub fn get_queue_time_adjustment_seconds(&self) -> &::std::option::Option<i32> {
        &self.queue_time_adjustment_seconds
    }
    /// <p>An integer that represents the queue priority to be applied to the contact (lower priorities are routed preferentially). Cannot be specified if the QueueTimeAdjustmentSeconds is specified. Must be statically defined, must be larger than zero, and a valid integer value. Default Value is 5.</p>
    pub fn queue_priority(mut self, input: i64) -> Self {
        self.queue_priority = ::std::option::Option::Some(input);
        self
    }
    /// <p>An integer that represents the queue priority to be applied to the contact (lower priorities are routed preferentially). Cannot be specified if the QueueTimeAdjustmentSeconds is specified. Must be statically defined, must be larger than zero, and a valid integer value. Default Value is 5.</p>
    pub fn set_queue_priority(mut self, input: ::std::option::Option<i64>) -> Self {
        self.queue_priority = input;
        self
    }
    /// <p>An integer that represents the queue priority to be applied to the contact (lower priorities are routed preferentially). Cannot be specified if the QueueTimeAdjustmentSeconds is specified. Must be statically defined, must be larger than zero, and a valid integer value. Default Value is 5.</p>
    pub fn get_queue_priority(&self) -> &::std::option::Option<i64> {
        &self.queue_priority
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Tags associated with the contact. This contains both Amazon Web Services generated and user-defined tags.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>Tags associated with the contact. This contains both Amazon Web Services generated and user-defined tags.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>Tags associated with the contact. This contains both Amazon Web Services generated and user-defined tags.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// <p>The timestamp when customer endpoint connected to Amazon Connect.</p>
    pub fn connected_to_system_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.connected_to_system_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when customer endpoint connected to Amazon Connect.</p>
    pub fn set_connected_to_system_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.connected_to_system_timestamp = input;
        self
    }
    /// <p>The timestamp when customer endpoint connected to Amazon Connect.</p>
    pub fn get_connected_to_system_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.connected_to_system_timestamp
    }
    /// <p>Latest routing criteria on the contact.</p>
    pub fn routing_criteria(mut self, input: crate::types::RoutingCriteria) -> Self {
        self.routing_criteria = ::std::option::Option::Some(input);
        self
    }
    /// <p>Latest routing criteria on the contact.</p>
    pub fn set_routing_criteria(mut self, input: ::std::option::Option<crate::types::RoutingCriteria>) -> Self {
        self.routing_criteria = input;
        self
    }
    /// <p>Latest routing criteria on the contact.</p>
    pub fn get_routing_criteria(&self) -> &::std::option::Option<crate::types::RoutingCriteria> {
        &self.routing_criteria
    }
    /// <p>Information about the Customer on the contact.</p>
    pub fn customer(mut self, input: crate::types::Customer) -> Self {
        self.customer = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the Customer on the contact.</p>
    pub fn set_customer(mut self, input: ::std::option::Option<crate::types::Customer>) -> Self {
        self.customer = input;
        self
    }
    /// <p>Information about the Customer on the contact.</p>
    pub fn get_customer(&self) -> &::std::option::Option<crate::types::Customer> {
        &self.customer
    }
    /// <p>Information associated with a campaign.</p>
    pub fn campaign(mut self, input: crate::types::Campaign) -> Self {
        self.campaign = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information associated with a campaign.</p>
    pub fn set_campaign(mut self, input: ::std::option::Option<crate::types::Campaign>) -> Self {
        self.campaign = input;
        self
    }
    /// <p>Information associated with a campaign.</p>
    pub fn get_campaign(&self) -> &::std::option::Option<crate::types::Campaign> {
        &self.campaign
    }
    /// <p>Indicates how an <a href="https://docs.aws.amazon.com/connect/latest/adminguide/how-to-create-campaigns.html">outbound campaign</a> call is actually disposed if the contact is connected to Amazon Connect.</p>
    pub fn answering_machine_detection_status(mut self, input: crate::types::AnsweringMachineDetectionStatus) -> Self {
        self.answering_machine_detection_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates how an <a href="https://docs.aws.amazon.com/connect/latest/adminguide/how-to-create-campaigns.html">outbound campaign</a> call is actually disposed if the contact is connected to Amazon Connect.</p>
    pub fn set_answering_machine_detection_status(mut self, input: ::std::option::Option<crate::types::AnsweringMachineDetectionStatus>) -> Self {
        self.answering_machine_detection_status = input;
        self
    }
    /// <p>Indicates how an <a href="https://docs.aws.amazon.com/connect/latest/adminguide/how-to-create-campaigns.html">outbound campaign</a> call is actually disposed if the contact is connected to Amazon Connect.</p>
    pub fn get_answering_machine_detection_status(&self) -> &::std::option::Option<crate::types::AnsweringMachineDetectionStatus> {
        &self.answering_machine_detection_status
    }
    /// <p>Information about customer’s voice activity.</p>
    pub fn customer_voice_activity(mut self, input: crate::types::CustomerVoiceActivity) -> Self {
        self.customer_voice_activity = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about customer’s voice activity.</p>
    pub fn set_customer_voice_activity(mut self, input: ::std::option::Option<crate::types::CustomerVoiceActivity>) -> Self {
        self.customer_voice_activity = input;
        self
    }
    /// <p>Information about customer’s voice activity.</p>
    pub fn get_customer_voice_activity(&self) -> &::std::option::Option<crate::types::CustomerVoiceActivity> {
        &self.customer_voice_activity
    }
    /// <p>Information about the quality of the participant's media connection.</p>
    pub fn quality_metrics(mut self, input: crate::types::QualityMetrics) -> Self {
        self.quality_metrics = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the quality of the participant's media connection.</p>
    pub fn set_quality_metrics(mut self, input: ::std::option::Option<crate::types::QualityMetrics>) -> Self {
        self.quality_metrics = input;
        self
    }
    /// <p>Information about the quality of the participant's media connection.</p>
    pub fn get_quality_metrics(&self) -> &::std::option::Option<crate::types::QualityMetrics> {
        &self.quality_metrics
    }
    /// <p>Information about how agent, bot, and customer interact in a chat contact.</p>
    pub fn chat_metrics(mut self, input: crate::types::ChatMetrics) -> Self {
        self.chat_metrics = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about how agent, bot, and customer interact in a chat contact.</p>
    pub fn set_chat_metrics(mut self, input: ::std::option::Option<crate::types::ChatMetrics>) -> Self {
        self.chat_metrics = input;
        self
    }
    /// <p>Information about how agent, bot, and customer interact in a chat contact.</p>
    pub fn get_chat_metrics(&self) -> &::std::option::Option<crate::types::ChatMetrics> {
        &self.chat_metrics
    }
    /// <p>Information about the call disconnect experience.</p>
    pub fn disconnect_details(mut self, input: crate::types::DisconnectDetails) -> Self {
        self.disconnect_details = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the call disconnect experience.</p>
    pub fn set_disconnect_details(mut self, input: ::std::option::Option<crate::types::DisconnectDetails>) -> Self {
        self.disconnect_details = input;
        self
    }
    /// <p>Information about the call disconnect experience.</p>
    pub fn get_disconnect_details(&self) -> &::std::option::Option<crate::types::DisconnectDetails> {
        &self.disconnect_details
    }
    /// <p>List of additional email addresses for an email contact.</p>
    pub fn additional_email_recipients(mut self, input: crate::types::AdditionalEmailRecipients) -> Self {
        self.additional_email_recipients = ::std::option::Option::Some(input);
        self
    }
    /// <p>List of additional email addresses for an email contact.</p>
    pub fn set_additional_email_recipients(mut self, input: ::std::option::Option<crate::types::AdditionalEmailRecipients>) -> Self {
        self.additional_email_recipients = input;
        self
    }
    /// <p>List of additional email addresses for an email contact.</p>
    pub fn get_additional_email_recipients(&self) -> &::std::option::Option<crate::types::AdditionalEmailRecipients> {
        &self.additional_email_recipients
    }
    /// Adds a key-value pair to `segment_attributes`.
    ///
    /// To override the contents of this collection use [`set_segment_attributes`](Self::set_segment_attributes).
    ///
    /// <p>A set of system defined key-value pairs stored on individual contact segments using an attribute map. The attributes are standard Amazon Connect attributes and can be accessed in flows. Attribute keys can include only alphanumeric, -, and _ characters. This field can be used to show channel subtype. For example, <code>connect:Guide</code> or <code>connect:SMS</code>.</p>
    pub fn segment_attributes(mut self, k: impl ::std::convert::Into<::std::string::String>, v: crate::types::SegmentAttributeValue) -> Self {
        let mut hash_map = self.segment_attributes.unwrap_or_default();
        hash_map.insert(k.into(), v);
        self.segment_attributes = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>A set of system defined key-value pairs stored on individual contact segments using an attribute map. The attributes are standard Amazon Connect attributes and can be accessed in flows. Attribute keys can include only alphanumeric, -, and _ characters. This field can be used to show channel subtype. For example, <code>connect:Guide</code> or <code>connect:SMS</code>.</p>
    pub fn set_segment_attributes(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::SegmentAttributeValue>>,
    ) -> Self {
        self.segment_attributes = input;
        self
    }
    /// <p>A set of system defined key-value pairs stored on individual contact segments using an attribute map. The attributes are standard Amazon Connect attributes and can be accessed in flows. Attribute keys can include only alphanumeric, -, and _ characters. This field can be used to show channel subtype. For example, <code>connect:Guide</code> or <code>connect:SMS</code>.</p>
    pub fn get_segment_attributes(
        &self,
    ) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::SegmentAttributeValue>> {
        &self.segment_attributes
    }
    /// Appends an item to `recordings`.
    ///
    /// To override the contents of this collection use [`set_recordings`](Self::set_recordings).
    ///
    /// <p>If recording was enabled, this is information about the recordings.</p>
    pub fn recordings(mut self, input: crate::types::RecordingInfo) -> Self {
        let mut v = self.recordings.unwrap_or_default();
        v.push(input);
        self.recordings = ::std::option::Option::Some(v);
        self
    }
    /// <p>If recording was enabled, this is information about the recordings.</p>
    pub fn set_recordings(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RecordingInfo>>) -> Self {
        self.recordings = input;
        self
    }
    /// <p>If recording was enabled, this is information about the recordings.</p>
    pub fn get_recordings(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RecordingInfo>> {
        &self.recordings
    }
    /// <p>The disconnect reason for the contact. For a list and description of all the possible disconnect reasons by channel, see DisconnectReason under <a href="https://docs.aws.amazon.com/connect/latest/adminguide/ctr-data-model.html#ctr-ContactTraceRecord">ContactTraceRecord</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub fn disconnect_reason(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.disconnect_reason = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The disconnect reason for the contact. For a list and description of all the possible disconnect reasons by channel, see DisconnectReason under <a href="https://docs.aws.amazon.com/connect/latest/adminguide/ctr-data-model.html#ctr-ContactTraceRecord">ContactTraceRecord</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub fn set_disconnect_reason(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.disconnect_reason = input;
        self
    }
    /// <p>The disconnect reason for the contact. For a list and description of all the possible disconnect reasons by channel, see DisconnectReason under <a href="https://docs.aws.amazon.com/connect/latest/adminguide/ctr-data-model.html#ctr-ContactTraceRecord">ContactTraceRecord</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub fn get_disconnect_reason(&self) -> &::std::option::Option<::std::string::String> {
        &self.disconnect_reason
    }
    /// Adds a key-value pair to `contact_evaluations`.
    ///
    /// To override the contents of this collection use [`set_contact_evaluations`](Self::set_contact_evaluations).
    ///
    /// <p>Information about the contact evaluations where the key is the FormId, which is a unique identifier for the form.</p>
    pub fn contact_evaluations(mut self, k: impl ::std::convert::Into<::std::string::String>, v: crate::types::ContactEvaluation) -> Self {
        let mut hash_map = self.contact_evaluations.unwrap_or_default();
        hash_map.insert(k.into(), v);
        self.contact_evaluations = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>Information about the contact evaluations where the key is the FormId, which is a unique identifier for the form.</p>
    pub fn set_contact_evaluations(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::ContactEvaluation>>,
    ) -> Self {
        self.contact_evaluations = input;
        self
    }
    /// <p>Information about the contact evaluations where the key is the FormId, which is a unique identifier for the form.</p>
    pub fn get_contact_evaluations(
        &self,
    ) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::ContactEvaluation>> {
        &self.contact_evaluations
    }
    /// <p>If this contact was created using a task template, this contains information about the task template.</p>
    pub fn task_template_info(mut self, input: crate::types::TaskTemplateInfoV2) -> Self {
        self.task_template_info = ::std::option::Option::Some(input);
        self
    }
    /// <p>If this contact was created using a task template, this contains information about the task template.</p>
    pub fn set_task_template_info(mut self, input: ::std::option::Option<crate::types::TaskTemplateInfoV2>) -> Self {
        self.task_template_info = input;
        self
    }
    /// <p>If this contact was created using a task template, this contains information about the task template.</p>
    pub fn get_task_template_info(&self) -> &::std::option::Option<crate::types::TaskTemplateInfoV2> {
        &self.task_template_info
    }
    /// <p>A map of string key/value pairs that contain user-defined attributes which are lightly typed within the contact. This object is used only for task contacts.</p>
    pub fn contact_details(mut self, input: crate::types::ContactDetails) -> Self {
        self.contact_details = ::std::option::Option::Some(input);
        self
    }
    /// <p>A map of string key/value pairs that contain user-defined attributes which are lightly typed within the contact. This object is used only for task contacts.</p>
    pub fn set_contact_details(mut self, input: ::std::option::Option<crate::types::ContactDetails>) -> Self {
        self.contact_details = input;
        self
    }
    /// <p>A map of string key/value pairs that contain user-defined attributes which are lightly typed within the contact. This object is used only for task contacts.</p>
    pub fn get_contact_details(&self) -> &::std::option::Option<crate::types::ContactDetails> {
        &self.contact_details
    }
    /// <p>Information about the outbound strategy.</p>
    pub fn outbound_strategy(mut self, input: crate::types::OutboundStrategy) -> Self {
        self.outbound_strategy = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the outbound strategy.</p>
    pub fn set_outbound_strategy(mut self, input: ::std::option::Option<crate::types::OutboundStrategy>) -> Self {
        self.outbound_strategy = input;
        self
    }
    /// <p>Information about the outbound strategy.</p>
    pub fn get_outbound_strategy(&self) -> &::std::option::Option<crate::types::OutboundStrategy> {
        &self.outbound_strategy
    }
    /// Adds a key-value pair to `attributes`.
    ///
    /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
    ///
    /// <p>The attributes of the contact.</p>
    pub fn attributes(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.attributes.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.attributes = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The attributes of the contact.</p>
    pub fn set_attributes(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.attributes = input;
        self
    }
    /// <p>The attributes of the contact.</p>
    pub fn get_attributes(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.attributes
    }
    /// Consumes the builder and constructs a [`Contact`](crate::types::Contact).
    pub fn build(self) -> crate::types::Contact {
        crate::types::Contact {
            arn: self.arn,
            id: self.id,
            initial_contact_id: self.initial_contact_id,
            previous_contact_id: self.previous_contact_id,
            contact_association_id: self.contact_association_id,
            initiation_method: self.initiation_method,
            name: self.name,
            description: self.description,
            channel: self.channel,
            queue_info: self.queue_info,
            agent_info: self.agent_info,
            initiation_timestamp: self.initiation_timestamp,
            disconnect_timestamp: self.disconnect_timestamp,
            last_update_timestamp: self.last_update_timestamp,
            last_paused_timestamp: self.last_paused_timestamp,
            last_resumed_timestamp: self.last_resumed_timestamp,
            ring_start_timestamp: self.ring_start_timestamp,
            total_pause_count: self.total_pause_count,
            total_pause_duration_in_seconds: self.total_pause_duration_in_seconds,
            scheduled_timestamp: self.scheduled_timestamp,
            related_contact_id: self.related_contact_id,
            wisdom_info: self.wisdom_info,
            customer_id: self.customer_id,
            customer_endpoint: self.customer_endpoint,
            system_endpoint: self.system_endpoint,
            queue_time_adjustment_seconds: self.queue_time_adjustment_seconds,
            queue_priority: self.queue_priority,
            tags: self.tags,
            connected_to_system_timestamp: self.connected_to_system_timestamp,
            routing_criteria: self.routing_criteria,
            customer: self.customer,
            campaign: self.campaign,
            answering_machine_detection_status: self.answering_machine_detection_status,
            customer_voice_activity: self.customer_voice_activity,
            quality_metrics: self.quality_metrics,
            chat_metrics: self.chat_metrics,
            disconnect_details: self.disconnect_details,
            additional_email_recipients: self.additional_email_recipients,
            segment_attributes: self.segment_attributes,
            recordings: self.recordings,
            disconnect_reason: self.disconnect_reason,
            contact_evaluations: self.contact_evaluations,
            task_template_info: self.task_template_info,
            contact_details: self.contact_details,
            outbound_strategy: self.outbound_strategy,
            attributes: self.attributes,
        }
    }
}
impl ::std::fmt::Debug for ContactBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("ContactBuilder");
        formatter.field("arn", &self.arn);
        formatter.field("id", &self.id);
        formatter.field("initial_contact_id", &self.initial_contact_id);
        formatter.field("previous_contact_id", &self.previous_contact_id);
        formatter.field("contact_association_id", &self.contact_association_id);
        formatter.field("initiation_method", &self.initiation_method);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("channel", &self.channel);
        formatter.field("queue_info", &self.queue_info);
        formatter.field("agent_info", &self.agent_info);
        formatter.field("initiation_timestamp", &self.initiation_timestamp);
        formatter.field("disconnect_timestamp", &self.disconnect_timestamp);
        formatter.field("last_update_timestamp", &self.last_update_timestamp);
        formatter.field("last_paused_timestamp", &self.last_paused_timestamp);
        formatter.field("last_resumed_timestamp", &self.last_resumed_timestamp);
        formatter.field("ring_start_timestamp", &self.ring_start_timestamp);
        formatter.field("total_pause_count", &self.total_pause_count);
        formatter.field("total_pause_duration_in_seconds", &self.total_pause_duration_in_seconds);
        formatter.field("scheduled_timestamp", &self.scheduled_timestamp);
        formatter.field("related_contact_id", &self.related_contact_id);
        formatter.field("wisdom_info", &self.wisdom_info);
        formatter.field("customer_id", &self.customer_id);
        formatter.field("customer_endpoint", &self.customer_endpoint);
        formatter.field("system_endpoint", &self.system_endpoint);
        formatter.field("queue_time_adjustment_seconds", &self.queue_time_adjustment_seconds);
        formatter.field("queue_priority", &self.queue_priority);
        formatter.field("tags", &self.tags);
        formatter.field("connected_to_system_timestamp", &self.connected_to_system_timestamp);
        formatter.field("routing_criteria", &self.routing_criteria);
        formatter.field("customer", &self.customer);
        formatter.field("campaign", &self.campaign);
        formatter.field("answering_machine_detection_status", &self.answering_machine_detection_status);
        formatter.field("customer_voice_activity", &self.customer_voice_activity);
        formatter.field("quality_metrics", &self.quality_metrics);
        formatter.field("chat_metrics", &self.chat_metrics);
        formatter.field("disconnect_details", &self.disconnect_details);
        formatter.field("additional_email_recipients", &self.additional_email_recipients);
        formatter.field("segment_attributes", &self.segment_attributes);
        formatter.field("recordings", &self.recordings);
        formatter.field("disconnect_reason", &self.disconnect_reason);
        formatter.field("contact_evaluations", &self.contact_evaluations);
        formatter.field("task_template_info", &self.task_template_info);
        formatter.field("contact_details", &self.contact_details);
        formatter.field("outbound_strategy", &self.outbound_strategy);
        formatter.field("attributes", &self.attributes);
        formatter.finish()
    }
}
