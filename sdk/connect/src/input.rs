// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
impl AssociateApprovedOriginInput {
    /// Consumes the builder and constructs an Operation<[`AssociateApprovedOrigin`](crate::operation::AssociateApprovedOrigin)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateApprovedOrigin,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateApprovedOriginInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.instance_id;
                let input_1 = input_1.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_1,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/approved-origin",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateApprovedOriginInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_associate_approved_origin::ser_associate_approved_origin_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateApprovedOrigin::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateApprovedOrigin",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl AssociateBotInput {
    /// Consumes the builder and constructs an Operation<[`AssociateBot`](crate::operation::AssociateBot)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateBot,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateBotInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_2 = &_input.instance_id;
                let input_2 = input_2.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_2,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/bot",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateBotInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_associate_bot::ser_associate_bot_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateBot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateBot",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl AssociateDefaultVocabularyInput {
    /// Consumes the builder and constructs an Operation<[`AssociateDefaultVocabulary`](crate::operation::AssociateDefaultVocabulary)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateDefaultVocabulary,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateDefaultVocabularyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_3 = &_input.instance_id;
                let input_3 = input_3.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_3,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_4 = &_input.language_code;
                let input_4 = input_4.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "language_code",
                        "cannot be empty or unset",
                    )
                })?;
                let language_code = aws_smithy_http::label::fmt_string(
                    input_4,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if language_code.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "language_code",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/default-vocabulary/{InstanceId}/{LanguageCode}",
                    InstanceId = instance_id,
                    LanguageCode = language_code
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateDefaultVocabularyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_associate_default_vocabulary::ser_associate_default_vocabulary_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateDefaultVocabulary::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateDefaultVocabulary",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl AssociateInstanceStorageConfigInput {
    /// Consumes the builder and constructs an Operation<[`AssociateInstanceStorageConfig`](crate::operation::AssociateInstanceStorageConfig)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateInstanceStorageConfig,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateInstanceStorageConfigInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_5 = &_input.instance_id;
                let input_5 = input_5.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_5,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/storage-config",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateInstanceStorageConfigInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_associate_instance_storage_config::ser_associate_instance_storage_config_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateInstanceStorageConfig::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateInstanceStorageConfig",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl AssociateLambdaFunctionInput {
    /// Consumes the builder and constructs an Operation<[`AssociateLambdaFunction`](crate::operation::AssociateLambdaFunction)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateLambdaFunction,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateLambdaFunctionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_6 = &_input.instance_id;
                let input_6 = input_6.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_6,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/lambda-function",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateLambdaFunctionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_associate_lambda_function::ser_associate_lambda_function_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateLambdaFunction::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateLambdaFunction",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl AssociateLexBotInput {
    /// Consumes the builder and constructs an Operation<[`AssociateLexBot`](crate::operation::AssociateLexBot)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateLexBot,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateLexBotInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_7 = &_input.instance_id;
                let input_7 = input_7.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_7,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/lex-bot",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateLexBotInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_associate_lex_bot::ser_associate_lex_bot_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateLexBot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateLexBot",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl AssociatePhoneNumberContactFlowInput {
    /// Consumes the builder and constructs an Operation<[`AssociatePhoneNumberContactFlow`](crate::operation::AssociatePhoneNumberContactFlow)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociatePhoneNumberContactFlow,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociatePhoneNumberContactFlowInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_8 = &_input.phone_number_id;
                let input_8 = input_8.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "phone_number_id",
                        "cannot be empty or unset",
                    )
                })?;
                let phone_number_id = aws_smithy_http::label::fmt_string(
                    input_8,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if phone_number_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "phone_number_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/phone-number/{PhoneNumberId}/contact-flow",
                    PhoneNumberId = phone_number_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociatePhoneNumberContactFlowInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_associate_phone_number_contact_flow::ser_associate_phone_number_contact_flow_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociatePhoneNumberContactFlow::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociatePhoneNumberContactFlow",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl AssociateQueueQuickConnectsInput {
    /// Consumes the builder and constructs an Operation<[`AssociateQueueQuickConnects`](crate::operation::AssociateQueueQuickConnects)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateQueueQuickConnects,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateQueueQuickConnectsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_9 = &_input.instance_id;
                let input_9 = input_9.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_9,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_10 = &_input.queue_id;
                let input_10 = input_10.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "queue_id",
                        "cannot be empty or unset",
                    )
                })?;
                let queue_id = aws_smithy_http::label::fmt_string(
                    input_10,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if queue_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "queue_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/queues/{InstanceId}/{QueueId}/associate-quick-connects",
                    InstanceId = instance_id,
                    QueueId = queue_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateQueueQuickConnectsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_associate_queue_quick_connects::ser_associate_queue_quick_connects_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateQueueQuickConnects::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateQueueQuickConnects",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl AssociateRoutingProfileQueuesInput {
    /// Consumes the builder and constructs an Operation<[`AssociateRoutingProfileQueues`](crate::operation::AssociateRoutingProfileQueues)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateRoutingProfileQueues,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateRoutingProfileQueuesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_11 = &_input.instance_id;
                let input_11 = input_11.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_11,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_12 = &_input.routing_profile_id;
                let input_12 = input_12.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "routing_profile_id",
                        "cannot be empty or unset",
                    )
                })?;
                let routing_profile_id = aws_smithy_http::label::fmt_string(
                    input_12,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if routing_profile_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "routing_profile_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/routing-profiles/{InstanceId}/{RoutingProfileId}/associate-queues",
                    InstanceId = instance_id,
                    RoutingProfileId = routing_profile_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateRoutingProfileQueuesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_associate_routing_profile_queues::ser_associate_routing_profile_queues_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateRoutingProfileQueues::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateRoutingProfileQueues",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl AssociateSecurityKeyInput {
    /// Consumes the builder and constructs an Operation<[`AssociateSecurityKey`](crate::operation::AssociateSecurityKey)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateSecurityKey,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateSecurityKeyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_13 = &_input.instance_id;
                let input_13 = input_13.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_13,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/security-key",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateSecurityKeyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_associate_security_key::ser_associate_security_key_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateSecurityKey::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateSecurityKey",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ClaimPhoneNumberInput {
    /// Consumes the builder and constructs an Operation<[`ClaimPhoneNumber`](crate::operation::ClaimPhoneNumber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ClaimPhoneNumber,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::ClaimPhoneNumberInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/phone-number/claim").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ClaimPhoneNumberInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_claim_phone_number::ser_claim_phone_number_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ClaimPhoneNumber::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ClaimPhoneNumber",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateAgentStatusInput {
    /// Consumes the builder and constructs an Operation<[`CreateAgentStatus`](crate::operation::CreateAgentStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAgentStatus,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAgentStatusInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_14 = &_input.instance_id;
                let input_14 = input_14.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_14,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/agent-status/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAgentStatusInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_agent_status::ser_create_agent_status_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAgentStatus::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAgentStatus",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateContactFlowInput {
    /// Consumes the builder and constructs an Operation<[`CreateContactFlow`](crate::operation::CreateContactFlow)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateContactFlow,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateContactFlowInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_15 = &_input.instance_id;
                let input_15 = input_15.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_15,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact-flows/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateContactFlowInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_contact_flow::ser_create_contact_flow_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateContactFlow::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateContactFlow",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateContactFlowModuleInput {
    /// Consumes the builder and constructs an Operation<[`CreateContactFlowModule`](crate::operation::CreateContactFlowModule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateContactFlowModule,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateContactFlowModuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_16 = &_input.instance_id;
                let input_16 = input_16.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_16,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact-flow-modules/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateContactFlowModuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_contact_flow_module::ser_create_contact_flow_module_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateContactFlowModule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateContactFlowModule",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateHoursOfOperationInput {
    /// Consumes the builder and constructs an Operation<[`CreateHoursOfOperation`](crate::operation::CreateHoursOfOperation)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateHoursOfOperation,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateHoursOfOperationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_17 = &_input.instance_id;
                let input_17 = input_17.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_17,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/hours-of-operations/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateHoursOfOperationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_hours_of_operation::ser_create_hours_of_operation_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateHoursOfOperation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateHoursOfOperation",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateInstanceInput {
    /// Consumes the builder and constructs an Operation<[`CreateInstance`](crate::operation::CreateInstance)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateInstance,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateInstanceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/instance").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateInstanceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_instance::ser_create_instance_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateInstance::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateInstance",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateIntegrationAssociationInput {
    /// Consumes the builder and constructs an Operation<[`CreateIntegrationAssociation`](crate::operation::CreateIntegrationAssociation)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateIntegrationAssociation,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateIntegrationAssociationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_18 = &_input.instance_id;
                let input_18 = input_18.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_18,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/integration-associations",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateIntegrationAssociationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_integration_association::ser_create_integration_association_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateIntegrationAssociation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateIntegrationAssociation",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateQueueInput {
    /// Consumes the builder and constructs an Operation<[`CreateQueue`](crate::operation::CreateQueue)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateQueue,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateQueueInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_19 = &_input.instance_id;
                let input_19 = input_19.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_19,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/queues/{InstanceId}", InstanceId = instance_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateQueueInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_queue::ser_create_queue_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateQueue::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateQueue",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateQuickConnectInput {
    /// Consumes the builder and constructs an Operation<[`CreateQuickConnect`](crate::operation::CreateQuickConnect)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateQuickConnect,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateQuickConnectInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_20 = &_input.instance_id;
                let input_20 = input_20.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_20,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/quick-connects/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateQuickConnectInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_quick_connect::ser_create_quick_connect_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateQuickConnect::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateQuickConnect",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateRoutingProfileInput {
    /// Consumes the builder and constructs an Operation<[`CreateRoutingProfile`](crate::operation::CreateRoutingProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateRoutingProfile,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateRoutingProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_21 = &_input.instance_id;
                let input_21 = input_21.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_21,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/routing-profiles/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateRoutingProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_routing_profile::ser_create_routing_profile_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateRoutingProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateRoutingProfile",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateRuleInput {
    /// Consumes the builder and constructs an Operation<[`CreateRule`](crate::operation::CreateRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateRule,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_22 = &_input.instance_id;
                let input_22 = input_22.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_22,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/rules/{InstanceId}", InstanceId = instance_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_rule::ser_create_rule_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateRule",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateSecurityProfileInput {
    /// Consumes the builder and constructs an Operation<[`CreateSecurityProfile`](crate::operation::CreateSecurityProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateSecurityProfile,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateSecurityProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_23 = &_input.instance_id;
                let input_23 = input_23.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_23,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/security-profiles/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateSecurityProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_security_profile::ser_create_security_profile_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateSecurityProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateSecurityProfile",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateTaskTemplateInput {
    /// Consumes the builder and constructs an Operation<[`CreateTaskTemplate`](crate::operation::CreateTaskTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateTaskTemplate,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateTaskTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_24 = &_input.instance_id;
                let input_24 = input_24.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_24,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/task/template",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateTaskTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_task_template::ser_create_task_template_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateTaskTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateTaskTemplate",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateTrafficDistributionGroupInput {
    /// Consumes the builder and constructs an Operation<[`CreateTrafficDistributionGroup`](crate::operation::CreateTrafficDistributionGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateTrafficDistributionGroup,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateTrafficDistributionGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/traffic-distribution-group").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateTrafficDistributionGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_traffic_distribution_group::ser_create_traffic_distribution_group_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateTrafficDistributionGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateTrafficDistributionGroup",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateUseCaseInput {
    /// Consumes the builder and constructs an Operation<[`CreateUseCase`](crate::operation::CreateUseCase)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateUseCase,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateUseCaseInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_25 = &_input.instance_id;
                let input_25 = input_25.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_25,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_26 = &_input.integration_association_id;
                let input_26 = input_26.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "integration_association_id",
                        "cannot be empty or unset",
                    )
                })?;
                let integration_association_id = aws_smithy_http::label::fmt_string(
                    input_26,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if integration_association_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "integration_association_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/instance/{InstanceId}/integration-associations/{IntegrationAssociationId}/use-cases", InstanceId = instance_id, IntegrationAssociationId = integration_association_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateUseCaseInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_use_case::ser_create_use_case_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateUseCase::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateUseCase",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateUserInput {
    /// Consumes the builder and constructs an Operation<[`CreateUser`](crate::operation::CreateUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateUser,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_27 = &_input.instance_id;
                let input_27 = input_27.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_27,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/users/{InstanceId}", InstanceId = instance_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_user::ser_create_user_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateUser",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateUserHierarchyGroupInput {
    /// Consumes the builder and constructs an Operation<[`CreateUserHierarchyGroup`](crate::operation::CreateUserHierarchyGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateUserHierarchyGroup,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateUserHierarchyGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_28 = &_input.instance_id;
                let input_28 = input_28.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_28,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/user-hierarchy-groups/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateUserHierarchyGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_user_hierarchy_group::ser_create_user_hierarchy_group_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateUserHierarchyGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateUserHierarchyGroup",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateVocabularyInput {
    /// Consumes the builder and constructs an Operation<[`CreateVocabulary`](crate::operation::CreateVocabulary)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateVocabulary,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateVocabularyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_29 = &_input.instance_id;
                let input_29 = input_29.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_29,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/vocabulary/{InstanceId}", InstanceId = instance_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateVocabularyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_vocabulary::ser_create_vocabulary_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateVocabulary::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateVocabulary",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteContactFlowInput {
    /// Consumes the builder and constructs an Operation<[`DeleteContactFlow`](crate::operation::DeleteContactFlow)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteContactFlow,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteContactFlowInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_30 = &_input.instance_id;
                let input_30 = input_30.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_30,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_31 = &_input.contact_flow_id;
                let input_31 = input_31.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "contact_flow_id",
                        "cannot be empty or unset",
                    )
                })?;
                let contact_flow_id = aws_smithy_http::label::fmt_string(
                    input_31,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if contact_flow_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "contact_flow_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact-flows/{InstanceId}/{ContactFlowId}",
                    InstanceId = instance_id,
                    ContactFlowId = contact_flow_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteContactFlowInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteContactFlow::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteContactFlow",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteContactFlowModuleInput {
    /// Consumes the builder and constructs an Operation<[`DeleteContactFlowModule`](crate::operation::DeleteContactFlowModule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteContactFlowModule,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteContactFlowModuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_32 = &_input.instance_id;
                let input_32 = input_32.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_32,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_33 = &_input.contact_flow_module_id;
                let input_33 = input_33.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "contact_flow_module_id",
                        "cannot be empty or unset",
                    )
                })?;
                let contact_flow_module_id = aws_smithy_http::label::fmt_string(
                    input_33,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if contact_flow_module_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "contact_flow_module_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}",
                    InstanceId = instance_id,
                    ContactFlowModuleId = contact_flow_module_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteContactFlowModuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteContactFlowModule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteContactFlowModule",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteHoursOfOperationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteHoursOfOperation`](crate::operation::DeleteHoursOfOperation)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteHoursOfOperation,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteHoursOfOperationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_34 = &_input.instance_id;
                let input_34 = input_34.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_34,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_35 = &_input.hours_of_operation_id;
                let input_35 = input_35.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "hours_of_operation_id",
                        "cannot be empty or unset",
                    )
                })?;
                let hours_of_operation_id = aws_smithy_http::label::fmt_string(
                    input_35,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if hours_of_operation_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "hours_of_operation_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/hours-of-operations/{InstanceId}/{HoursOfOperationId}",
                    InstanceId = instance_id,
                    HoursOfOperationId = hours_of_operation_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteHoursOfOperationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteHoursOfOperation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteHoursOfOperation",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteInstanceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteInstance`](crate::operation::DeleteInstance)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteInstance,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteInstanceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_36 = &_input.instance_id;
                let input_36 = input_36.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_36,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/instance/{InstanceId}", InstanceId = instance_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteInstanceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteInstance::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteInstance",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteIntegrationAssociationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteIntegrationAssociation`](crate::operation::DeleteIntegrationAssociation)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteIntegrationAssociation,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteIntegrationAssociationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_37 = &_input.instance_id;
                let input_37 = input_37.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_37,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_38 = &_input.integration_association_id;
                let input_38 = input_38.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "integration_association_id",
                        "cannot be empty or unset",
                    )
                })?;
                let integration_association_id = aws_smithy_http::label::fmt_string(
                    input_38,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if integration_association_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "integration_association_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/integration-associations/{IntegrationAssociationId}",
                    InstanceId = instance_id,
                    IntegrationAssociationId = integration_association_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteIntegrationAssociationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteIntegrationAssociation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteIntegrationAssociation",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteQuickConnectInput {
    /// Consumes the builder and constructs an Operation<[`DeleteQuickConnect`](crate::operation::DeleteQuickConnect)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteQuickConnect,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteQuickConnectInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_39 = &_input.instance_id;
                let input_39 = input_39.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_39,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_40 = &_input.quick_connect_id;
                let input_40 = input_40.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "quick_connect_id",
                        "cannot be empty or unset",
                    )
                })?;
                let quick_connect_id = aws_smithy_http::label::fmt_string(
                    input_40,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if quick_connect_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "quick_connect_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/quick-connects/{InstanceId}/{QuickConnectId}",
                    InstanceId = instance_id,
                    QuickConnectId = quick_connect_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteQuickConnectInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteQuickConnect::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteQuickConnect",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteRuleInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRule`](crate::operation::DeleteRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteRule,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_41 = &_input.instance_id;
                let input_41 = input_41.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_41,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_42 = &_input.rule_id;
                let input_42 = input_42.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "rule_id",
                        "cannot be empty or unset",
                    )
                })?;
                let rule_id = aws_smithy_http::label::fmt_string(
                    input_42,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if rule_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "rule_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/rules/{InstanceId}/{RuleId}",
                    InstanceId = instance_id,
                    RuleId = rule_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteRule",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteSecurityProfileInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSecurityProfile`](crate::operation::DeleteSecurityProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteSecurityProfile,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteSecurityProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_43 = &_input.instance_id;
                let input_43 = input_43.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_43,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_44 = &_input.security_profile_id;
                let input_44 = input_44.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "security_profile_id",
                        "cannot be empty or unset",
                    )
                })?;
                let security_profile_id = aws_smithy_http::label::fmt_string(
                    input_44,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if security_profile_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "security_profile_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/security-profiles/{InstanceId}/{SecurityProfileId}",
                    InstanceId = instance_id,
                    SecurityProfileId = security_profile_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteSecurityProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteSecurityProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteSecurityProfile",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteTaskTemplateInput {
    /// Consumes the builder and constructs an Operation<[`DeleteTaskTemplate`](crate::operation::DeleteTaskTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteTaskTemplate,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteTaskTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_45 = &_input.instance_id;
                let input_45 = input_45.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_45,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_46 = &_input.task_template_id;
                let input_46 = input_46.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "task_template_id",
                        "cannot be empty or unset",
                    )
                })?;
                let task_template_id = aws_smithy_http::label::fmt_string(
                    input_46,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if task_template_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "task_template_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/task/template/{TaskTemplateId}",
                    InstanceId = instance_id,
                    TaskTemplateId = task_template_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteTaskTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteTaskTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteTaskTemplate",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteTrafficDistributionGroupInput {
    /// Consumes the builder and constructs an Operation<[`DeleteTrafficDistributionGroup`](crate::operation::DeleteTrafficDistributionGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteTrafficDistributionGroup,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteTrafficDistributionGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_47 = &_input.traffic_distribution_group_id;
                let input_47 = input_47.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "traffic_distribution_group_id",
                        "cannot be empty or unset",
                    )
                })?;
                let traffic_distribution_group_id = aws_smithy_http::label::fmt_string(
                    input_47,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if traffic_distribution_group_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "traffic_distribution_group_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/traffic-distribution-group/{TrafficDistributionGroupId}",
                    TrafficDistributionGroupId = traffic_distribution_group_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteTrafficDistributionGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteTrafficDistributionGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteTrafficDistributionGroup",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteUseCaseInput {
    /// Consumes the builder and constructs an Operation<[`DeleteUseCase`](crate::operation::DeleteUseCase)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteUseCase,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteUseCaseInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_48 = &_input.instance_id;
                let input_48 = input_48.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_48,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_49 = &_input.integration_association_id;
                let input_49 = input_49.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "integration_association_id",
                        "cannot be empty or unset",
                    )
                })?;
                let integration_association_id = aws_smithy_http::label::fmt_string(
                    input_49,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if integration_association_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "integration_association_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_50 = &_input.use_case_id;
                let input_50 = input_50.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "use_case_id",
                        "cannot be empty or unset",
                    )
                })?;
                let use_case_id = aws_smithy_http::label::fmt_string(
                    input_50,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if use_case_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "use_case_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/instance/{InstanceId}/integration-associations/{IntegrationAssociationId}/use-cases/{UseCaseId}", InstanceId = instance_id, IntegrationAssociationId = integration_association_id, UseCaseId = use_case_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteUseCaseInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteUseCase::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteUseCase",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteUserInput {
    /// Consumes the builder and constructs an Operation<[`DeleteUser`](crate::operation::DeleteUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteUser,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_51 = &_input.instance_id;
                let input_51 = input_51.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_51,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_52 = &_input.user_id;
                let input_52 = input_52.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "user_id",
                        "cannot be empty or unset",
                    )
                })?;
                let user_id = aws_smithy_http::label::fmt_string(
                    input_52,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if user_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "user_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/users/{InstanceId}/{UserId}",
                    InstanceId = instance_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteUser",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteUserHierarchyGroupInput {
    /// Consumes the builder and constructs an Operation<[`DeleteUserHierarchyGroup`](crate::operation::DeleteUserHierarchyGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteUserHierarchyGroup,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteUserHierarchyGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_53 = &_input.instance_id;
                let input_53 = input_53.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_53,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_54 = &_input.hierarchy_group_id;
                let input_54 = input_54.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "hierarchy_group_id",
                        "cannot be empty or unset",
                    )
                })?;
                let hierarchy_group_id = aws_smithy_http::label::fmt_string(
                    input_54,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if hierarchy_group_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "hierarchy_group_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/user-hierarchy-groups/{InstanceId}/{HierarchyGroupId}",
                    InstanceId = instance_id,
                    HierarchyGroupId = hierarchy_group_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteUserHierarchyGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteUserHierarchyGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteUserHierarchyGroup",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteVocabularyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVocabulary`](crate::operation::DeleteVocabulary)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteVocabulary,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteVocabularyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_55 = &_input.instance_id;
                let input_55 = input_55.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_55,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_56 = &_input.vocabulary_id;
                let input_56 = input_56.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "vocabulary_id",
                        "cannot be empty or unset",
                    )
                })?;
                let vocabulary_id = aws_smithy_http::label::fmt_string(
                    input_56,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if vocabulary_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "vocabulary_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/vocabulary-remove/{InstanceId}/{VocabularyId}",
                    InstanceId = instance_id,
                    VocabularyId = vocabulary_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteVocabularyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteVocabulary::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteVocabulary",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeAgentStatusInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAgentStatus`](crate::operation::DescribeAgentStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAgentStatus,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeAgentStatusInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_57 = &_input.instance_id;
                let input_57 = input_57.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_57,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_58 = &_input.agent_status_id;
                let input_58 = input_58.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "agent_status_id",
                        "cannot be empty or unset",
                    )
                })?;
                let agent_status_id = aws_smithy_http::label::fmt_string(
                    input_58,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if agent_status_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "agent_status_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/agent-status/{InstanceId}/{AgentStatusId}",
                    InstanceId = instance_id,
                    AgentStatusId = agent_status_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeAgentStatusInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAgentStatus::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAgentStatus",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeContactInput {
    /// Consumes the builder and constructs an Operation<[`DescribeContact`](crate::operation::DescribeContact)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeContact,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeContactInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_59 = &_input.instance_id;
                let input_59 = input_59.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_59,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_60 = &_input.contact_id;
                let input_60 = input_60.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "contact_id",
                        "cannot be empty or unset",
                    )
                })?;
                let contact_id = aws_smithy_http::label::fmt_string(
                    input_60,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if contact_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "contact_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contacts/{InstanceId}/{ContactId}",
                    InstanceId = instance_id,
                    ContactId = contact_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeContactInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeContact::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeContact",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeContactFlowInput {
    /// Consumes the builder and constructs an Operation<[`DescribeContactFlow`](crate::operation::DescribeContactFlow)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeContactFlow,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeContactFlowInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_61 = &_input.instance_id;
                let input_61 = input_61.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_61,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_62 = &_input.contact_flow_id;
                let input_62 = input_62.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "contact_flow_id",
                        "cannot be empty or unset",
                    )
                })?;
                let contact_flow_id = aws_smithy_http::label::fmt_string(
                    input_62,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if contact_flow_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "contact_flow_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact-flows/{InstanceId}/{ContactFlowId}",
                    InstanceId = instance_id,
                    ContactFlowId = contact_flow_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeContactFlowInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeContactFlow::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeContactFlow",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeContactFlowModuleInput {
    /// Consumes the builder and constructs an Operation<[`DescribeContactFlowModule`](crate::operation::DescribeContactFlowModule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeContactFlowModule,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeContactFlowModuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_63 = &_input.instance_id;
                let input_63 = input_63.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_63,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_64 = &_input.contact_flow_module_id;
                let input_64 = input_64.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "contact_flow_module_id",
                        "cannot be empty or unset",
                    )
                })?;
                let contact_flow_module_id = aws_smithy_http::label::fmt_string(
                    input_64,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if contact_flow_module_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "contact_flow_module_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}",
                    InstanceId = instance_id,
                    ContactFlowModuleId = contact_flow_module_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeContactFlowModuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeContactFlowModule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeContactFlowModule",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeHoursOfOperationInput {
    /// Consumes the builder and constructs an Operation<[`DescribeHoursOfOperation`](crate::operation::DescribeHoursOfOperation)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeHoursOfOperation,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeHoursOfOperationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_65 = &_input.instance_id;
                let input_65 = input_65.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_65,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_66 = &_input.hours_of_operation_id;
                let input_66 = input_66.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "hours_of_operation_id",
                        "cannot be empty or unset",
                    )
                })?;
                let hours_of_operation_id = aws_smithy_http::label::fmt_string(
                    input_66,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if hours_of_operation_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "hours_of_operation_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/hours-of-operations/{InstanceId}/{HoursOfOperationId}",
                    InstanceId = instance_id,
                    HoursOfOperationId = hours_of_operation_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeHoursOfOperationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeHoursOfOperation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeHoursOfOperation",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeInstanceInput {
    /// Consumes the builder and constructs an Operation<[`DescribeInstance`](crate::operation::DescribeInstance)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeInstance,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeInstanceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_67 = &_input.instance_id;
                let input_67 = input_67.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_67,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/instance/{InstanceId}", InstanceId = instance_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeInstanceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeInstance::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeInstance",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeInstanceAttributeInput {
    /// Consumes the builder and constructs an Operation<[`DescribeInstanceAttribute`](crate::operation::DescribeInstanceAttribute)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeInstanceAttribute,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeInstanceAttributeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_68 = &_input.instance_id;
                let input_68 = input_68.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_68,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_69 = &_input.attribute_type;
                let input_69 = input_69.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "attribute_type",
                        "cannot be empty or unset",
                    )
                })?;
                let attribute_type = aws_smithy_http::label::fmt_string(
                    input_69,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if attribute_type.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "attribute_type",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/attribute/{AttributeType}",
                    InstanceId = instance_id,
                    AttributeType = attribute_type
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeInstanceAttributeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeInstanceAttribute::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeInstanceAttribute",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeInstanceStorageConfigInput {
    /// Consumes the builder and constructs an Operation<[`DescribeInstanceStorageConfig`](crate::operation::DescribeInstanceStorageConfig)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeInstanceStorageConfig,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeInstanceStorageConfigInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_70 = &_input.instance_id;
                let input_70 = input_70.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_70,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_71 = &_input.association_id;
                let input_71 = input_71.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "association_id",
                        "cannot be empty or unset",
                    )
                })?;
                let association_id = aws_smithy_http::label::fmt_string(
                    input_71,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if association_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "association_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/storage-config/{AssociationId}",
                    InstanceId = instance_id,
                    AssociationId = association_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DescribeInstanceStorageConfigInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_72 = &_input.resource_type;
                let inner_72 = inner_72.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_type",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv(
                    "resourceType",
                    &aws_smithy_http::query::fmt_string(&inner_72),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeInstanceStorageConfigInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeInstanceStorageConfig::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeInstanceStorageConfig",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribePhoneNumberInput {
    /// Consumes the builder and constructs an Operation<[`DescribePhoneNumber`](crate::operation::DescribePhoneNumber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribePhoneNumber,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribePhoneNumberInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_73 = &_input.phone_number_id;
                let input_73 = input_73.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "phone_number_id",
                        "cannot be empty or unset",
                    )
                })?;
                let phone_number_id = aws_smithy_http::label::fmt_string(
                    input_73,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if phone_number_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "phone_number_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/phone-number/{PhoneNumberId}",
                    PhoneNumberId = phone_number_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribePhoneNumberInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribePhoneNumber::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribePhoneNumber",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeQueueInput {
    /// Consumes the builder and constructs an Operation<[`DescribeQueue`](crate::operation::DescribeQueue)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeQueue,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeQueueInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_74 = &_input.instance_id;
                let input_74 = input_74.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_74,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_75 = &_input.queue_id;
                let input_75 = input_75.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "queue_id",
                        "cannot be empty or unset",
                    )
                })?;
                let queue_id = aws_smithy_http::label::fmt_string(
                    input_75,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if queue_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "queue_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/queues/{InstanceId}/{QueueId}",
                    InstanceId = instance_id,
                    QueueId = queue_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeQueueInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeQueue::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeQueue",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeQuickConnectInput {
    /// Consumes the builder and constructs an Operation<[`DescribeQuickConnect`](crate::operation::DescribeQuickConnect)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeQuickConnect,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeQuickConnectInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_76 = &_input.instance_id;
                let input_76 = input_76.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_76,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_77 = &_input.quick_connect_id;
                let input_77 = input_77.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "quick_connect_id",
                        "cannot be empty or unset",
                    )
                })?;
                let quick_connect_id = aws_smithy_http::label::fmt_string(
                    input_77,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if quick_connect_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "quick_connect_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/quick-connects/{InstanceId}/{QuickConnectId}",
                    InstanceId = instance_id,
                    QuickConnectId = quick_connect_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeQuickConnectInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeQuickConnect::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeQuickConnect",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeRoutingProfileInput {
    /// Consumes the builder and constructs an Operation<[`DescribeRoutingProfile`](crate::operation::DescribeRoutingProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeRoutingProfile,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeRoutingProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_78 = &_input.instance_id;
                let input_78 = input_78.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_78,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_79 = &_input.routing_profile_id;
                let input_79 = input_79.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "routing_profile_id",
                        "cannot be empty or unset",
                    )
                })?;
                let routing_profile_id = aws_smithy_http::label::fmt_string(
                    input_79,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if routing_profile_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "routing_profile_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/routing-profiles/{InstanceId}/{RoutingProfileId}",
                    InstanceId = instance_id,
                    RoutingProfileId = routing_profile_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeRoutingProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeRoutingProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeRoutingProfile",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeRuleInput {
    /// Consumes the builder and constructs an Operation<[`DescribeRule`](crate::operation::DescribeRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeRule,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_80 = &_input.instance_id;
                let input_80 = input_80.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_80,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_81 = &_input.rule_id;
                let input_81 = input_81.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "rule_id",
                        "cannot be empty or unset",
                    )
                })?;
                let rule_id = aws_smithy_http::label::fmt_string(
                    input_81,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if rule_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "rule_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/rules/{InstanceId}/{RuleId}",
                    InstanceId = instance_id,
                    RuleId = rule_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeRule",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeSecurityProfileInput {
    /// Consumes the builder and constructs an Operation<[`DescribeSecurityProfile`](crate::operation::DescribeSecurityProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeSecurityProfile,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeSecurityProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_82 = &_input.instance_id;
                let input_82 = input_82.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_82,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_83 = &_input.security_profile_id;
                let input_83 = input_83.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "security_profile_id",
                        "cannot be empty or unset",
                    )
                })?;
                let security_profile_id = aws_smithy_http::label::fmt_string(
                    input_83,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if security_profile_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "security_profile_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/security-profiles/{InstanceId}/{SecurityProfileId}",
                    InstanceId = instance_id,
                    SecurityProfileId = security_profile_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeSecurityProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeSecurityProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeSecurityProfile",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeTrafficDistributionGroupInput {
    /// Consumes the builder and constructs an Operation<[`DescribeTrafficDistributionGroup`](crate::operation::DescribeTrafficDistributionGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeTrafficDistributionGroup,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeTrafficDistributionGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_84 = &_input.traffic_distribution_group_id;
                let input_84 = input_84.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "traffic_distribution_group_id",
                        "cannot be empty or unset",
                    )
                })?;
                let traffic_distribution_group_id = aws_smithy_http::label::fmt_string(
                    input_84,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if traffic_distribution_group_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "traffic_distribution_group_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/traffic-distribution-group/{TrafficDistributionGroupId}",
                    TrafficDistributionGroupId = traffic_distribution_group_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeTrafficDistributionGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeTrafficDistributionGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeTrafficDistributionGroup",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeUserInput {
    /// Consumes the builder and constructs an Operation<[`DescribeUser`](crate::operation::DescribeUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeUser,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_85 = &_input.instance_id;
                let input_85 = input_85.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_85,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_86 = &_input.user_id;
                let input_86 = input_86.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "user_id",
                        "cannot be empty or unset",
                    )
                })?;
                let user_id = aws_smithy_http::label::fmt_string(
                    input_86,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if user_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "user_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/users/{InstanceId}/{UserId}",
                    InstanceId = instance_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeUser",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeUserHierarchyGroupInput {
    /// Consumes the builder and constructs an Operation<[`DescribeUserHierarchyGroup`](crate::operation::DescribeUserHierarchyGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeUserHierarchyGroup,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeUserHierarchyGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_87 = &_input.instance_id;
                let input_87 = input_87.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_87,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_88 = &_input.hierarchy_group_id;
                let input_88 = input_88.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "hierarchy_group_id",
                        "cannot be empty or unset",
                    )
                })?;
                let hierarchy_group_id = aws_smithy_http::label::fmt_string(
                    input_88,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if hierarchy_group_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "hierarchy_group_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/user-hierarchy-groups/{InstanceId}/{HierarchyGroupId}",
                    InstanceId = instance_id,
                    HierarchyGroupId = hierarchy_group_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeUserHierarchyGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeUserHierarchyGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeUserHierarchyGroup",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeUserHierarchyStructureInput {
    /// Consumes the builder and constructs an Operation<[`DescribeUserHierarchyStructure`](crate::operation::DescribeUserHierarchyStructure)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeUserHierarchyStructure,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeUserHierarchyStructureInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_89 = &_input.instance_id;
                let input_89 = input_89.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_89,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/user-hierarchy-structure/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeUserHierarchyStructureInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeUserHierarchyStructure::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeUserHierarchyStructure",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeVocabularyInput {
    /// Consumes the builder and constructs an Operation<[`DescribeVocabulary`](crate::operation::DescribeVocabulary)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeVocabulary,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeVocabularyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_90 = &_input.instance_id;
                let input_90 = input_90.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_90,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_91 = &_input.vocabulary_id;
                let input_91 = input_91.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "vocabulary_id",
                        "cannot be empty or unset",
                    )
                })?;
                let vocabulary_id = aws_smithy_http::label::fmt_string(
                    input_91,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if vocabulary_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "vocabulary_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/vocabulary/{InstanceId}/{VocabularyId}",
                    InstanceId = instance_id,
                    VocabularyId = vocabulary_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeVocabularyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeVocabulary::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeVocabulary",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateApprovedOriginInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateApprovedOrigin`](crate::operation::DisassociateApprovedOrigin)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateApprovedOrigin,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateApprovedOriginInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_92 = &_input.instance_id;
                let input_92 = input_92.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_92,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/approved-origin",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DisassociateApprovedOriginInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_93 = &_input.origin;
                let inner_93 = inner_93.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "origin",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_93.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "origin",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("origin", &aws_smithy_http::query::fmt_string(&inner_93));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateApprovedOriginInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateApprovedOrigin::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateApprovedOrigin",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateBotInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateBot`](crate::operation::DisassociateBot)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateBot,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateBotInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_94 = &_input.instance_id;
                let input_94 = input_94.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_94,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/bot",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateBotInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_disassociate_bot::ser_disassociate_bot_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateBot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateBot",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateInstanceStorageConfigInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateInstanceStorageConfig`](crate::operation::DisassociateInstanceStorageConfig)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateInstanceStorageConfig,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateInstanceStorageConfigInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_95 = &_input.instance_id;
                let input_95 = input_95.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_95,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_96 = &_input.association_id;
                let input_96 = input_96.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "association_id",
                        "cannot be empty or unset",
                    )
                })?;
                let association_id = aws_smithy_http::label::fmt_string(
                    input_96,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if association_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "association_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/storage-config/{AssociationId}",
                    InstanceId = instance_id,
                    AssociationId = association_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DisassociateInstanceStorageConfigInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_97 = &_input.resource_type;
                let inner_97 = inner_97.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_type",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv(
                    "resourceType",
                    &aws_smithy_http::query::fmt_string(&inner_97),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateInstanceStorageConfigInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateInstanceStorageConfig::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateInstanceStorageConfig",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateLambdaFunctionInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateLambdaFunction`](crate::operation::DisassociateLambdaFunction)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateLambdaFunction,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateLambdaFunctionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_98 = &_input.instance_id;
                let input_98 = input_98.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_98,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/lambda-function",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DisassociateLambdaFunctionInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_99 = &_input.function_arn;
                let inner_99 = inner_99.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "function_arn",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_99.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "function_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "functionArn",
                    &aws_smithy_http::query::fmt_string(&inner_99),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateLambdaFunctionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateLambdaFunction::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateLambdaFunction",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateLexBotInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateLexBot`](crate::operation::DisassociateLexBot)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateLexBot,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateLexBotInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_100 = &_input.instance_id;
                let input_100 = input_100.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_100,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/lex-bot",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DisassociateLexBotInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_101 = &_input.bot_name;
                let inner_101 = inner_101.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "bot_name",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_101.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "bot_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("botName", &aws_smithy_http::query::fmt_string(&inner_101));
                let inner_102 = &_input.lex_region;
                let inner_102 = inner_102.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "lex_region",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_102.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "lex_region",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("lexRegion", &aws_smithy_http::query::fmt_string(&inner_102));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateLexBotInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateLexBot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateLexBot",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociatePhoneNumberContactFlowInput {
    /// Consumes the builder and constructs an Operation<[`DisassociatePhoneNumberContactFlow`](crate::operation::DisassociatePhoneNumberContactFlow)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociatePhoneNumberContactFlow,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociatePhoneNumberContactFlowInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_103 = &_input.phone_number_id;
                let input_103 = input_103.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "phone_number_id",
                        "cannot be empty or unset",
                    )
                })?;
                let phone_number_id = aws_smithy_http::label::fmt_string(
                    input_103,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if phone_number_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "phone_number_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/phone-number/{PhoneNumberId}/contact-flow",
                    PhoneNumberId = phone_number_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DisassociatePhoneNumberContactFlowInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_104 = &_input.instance_id;
                let inner_104 = inner_104.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_104.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "instanceId",
                    &aws_smithy_http::query::fmt_string(&inner_104),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociatePhoneNumberContactFlowInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociatePhoneNumberContactFlow::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociatePhoneNumberContactFlow",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateQueueQuickConnectsInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateQueueQuickConnects`](crate::operation::DisassociateQueueQuickConnects)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateQueueQuickConnects,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateQueueQuickConnectsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_105 = &_input.instance_id;
                let input_105 = input_105.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_105,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_106 = &_input.queue_id;
                let input_106 = input_106.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "queue_id",
                        "cannot be empty or unset",
                    )
                })?;
                let queue_id = aws_smithy_http::label::fmt_string(
                    input_106,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if queue_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "queue_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/queues/{InstanceId}/{QueueId}/disassociate-quick-connects",
                    InstanceId = instance_id,
                    QueueId = queue_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateQueueQuickConnectsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_disassociate_queue_quick_connects::ser_disassociate_queue_quick_connects_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateQueueQuickConnects::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateQueueQuickConnects",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateRoutingProfileQueuesInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateRoutingProfileQueues`](crate::operation::DisassociateRoutingProfileQueues)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateRoutingProfileQueues,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateRoutingProfileQueuesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_107 = &_input.instance_id;
                let input_107 = input_107.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_107,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_108 = &_input.routing_profile_id;
                let input_108 = input_108.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "routing_profile_id",
                        "cannot be empty or unset",
                    )
                })?;
                let routing_profile_id = aws_smithy_http::label::fmt_string(
                    input_108,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if routing_profile_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "routing_profile_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/routing-profiles/{InstanceId}/{RoutingProfileId}/disassociate-queues",
                    InstanceId = instance_id,
                    RoutingProfileId = routing_profile_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateRoutingProfileQueuesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_disassociate_routing_profile_queues::ser_disassociate_routing_profile_queues_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateRoutingProfileQueues::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateRoutingProfileQueues",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateSecurityKeyInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateSecurityKey`](crate::operation::DisassociateSecurityKey)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateSecurityKey,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateSecurityKeyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_109 = &_input.instance_id;
                let input_109 = input_109.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_109,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_110 = &_input.association_id;
                let input_110 = input_110.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "association_id",
                        "cannot be empty or unset",
                    )
                })?;
                let association_id = aws_smithy_http::label::fmt_string(
                    input_110,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if association_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "association_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/security-key/{AssociationId}",
                    InstanceId = instance_id,
                    AssociationId = association_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateSecurityKeyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateSecurityKey::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateSecurityKey",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DismissUserContactInput {
    /// Consumes the builder and constructs an Operation<[`DismissUserContact`](crate::operation::DismissUserContact)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DismissUserContact,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DismissUserContactInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_111 = &_input.instance_id;
                let input_111 = input_111.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_111,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_112 = &_input.user_id;
                let input_112 = input_112.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "user_id",
                        "cannot be empty or unset",
                    )
                })?;
                let user_id = aws_smithy_http::label::fmt_string(
                    input_112,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if user_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "user_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/users/{InstanceId}/{UserId}/contact",
                    InstanceId = instance_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DismissUserContactInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_dismiss_user_contact::ser_dismiss_user_contact_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DismissUserContact::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DismissUserContact",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetContactAttributesInput {
    /// Consumes the builder and constructs an Operation<[`GetContactAttributes`](crate::operation::GetContactAttributes)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetContactAttributes,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetContactAttributesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_113 = &_input.instance_id;
                let input_113 = input_113.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_113,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_114 = &_input.initial_contact_id;
                let input_114 = input_114.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "initial_contact_id",
                        "cannot be empty or unset",
                    )
                })?;
                let initial_contact_id = aws_smithy_http::label::fmt_string(
                    input_114,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if initial_contact_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "initial_contact_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact/attributes/{InstanceId}/{InitialContactId}",
                    InstanceId = instance_id,
                    InitialContactId = initial_contact_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetContactAttributesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetContactAttributes::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetContactAttributes",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCurrentMetricDataInput {
    /// Consumes the builder and constructs an Operation<[`GetCurrentMetricData`](crate::operation::GetCurrentMetricData)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCurrentMetricData,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCurrentMetricDataInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_115 = &_input.instance_id;
                let input_115 = input_115.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_115,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/metrics/current/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCurrentMetricDataInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_current_metric_data::ser_get_current_metric_data_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCurrentMetricData::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCurrentMetricData",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCurrentUserDataInput {
    /// Consumes the builder and constructs an Operation<[`GetCurrentUserData`](crate::operation::GetCurrentUserData)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCurrentUserData,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCurrentUserDataInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_116 = &_input.instance_id;
                let input_116 = input_116.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_116,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/metrics/userdata/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCurrentUserDataInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_current_user_data::ser_get_current_user_data_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCurrentUserData::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCurrentUserData",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetFederationTokenInput {
    /// Consumes the builder and constructs an Operation<[`GetFederationToken`](crate::operation::GetFederationToken)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetFederationToken,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetFederationTokenInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_117 = &_input.instance_id;
                let input_117 = input_117.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_117,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/user/federate/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetFederationTokenInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetFederationToken::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetFederationToken",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetMetricDataInput {
    /// Consumes the builder and constructs an Operation<[`GetMetricData`](crate::operation::GetMetricData)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetMetricData,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetMetricDataInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_118 = &_input.instance_id;
                let input_118 = input_118.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_118,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/metrics/historical/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetMetricDataInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_metric_data::ser_get_metric_data_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetMetricData::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetMetricData",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetTaskTemplateInput {
    /// Consumes the builder and constructs an Operation<[`GetTaskTemplate`](crate::operation::GetTaskTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTaskTemplate,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetTaskTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_119 = &_input.instance_id;
                let input_119 = input_119.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_119,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_120 = &_input.task_template_id;
                let input_120 = input_120.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "task_template_id",
                        "cannot be empty or unset",
                    )
                })?;
                let task_template_id = aws_smithy_http::label::fmt_string(
                    input_120,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if task_template_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "task_template_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/task/template/{TaskTemplateId}",
                    InstanceId = instance_id,
                    TaskTemplateId = task_template_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetTaskTemplateInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_121) = &_input.snapshot_version {
                    {
                        query.push_kv(
                            "snapshotVersion",
                            &aws_smithy_http::query::fmt_string(&inner_121),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetTaskTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetTaskTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetTaskTemplate",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetTrafficDistributionInput {
    /// Consumes the builder and constructs an Operation<[`GetTrafficDistribution`](crate::operation::GetTrafficDistribution)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTrafficDistribution,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetTrafficDistributionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_122 = &_input.id;
                let input_122 = input_122.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "id",
                        "cannot be empty or unset",
                    )
                })?;
                let id = aws_smithy_http::label::fmt_string(
                    input_122,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/traffic-distribution/{Id}", Id = id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetTrafficDistributionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetTrafficDistribution::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetTrafficDistribution",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListAgentStatusesInput {
    /// Consumes the builder and constructs an Operation<[`ListAgentStatuses`](crate::operation::ListAgentStatuses)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAgentStatuses,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAgentStatusesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_123 = &_input.instance_id;
                let input_123 = input_123.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_123,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/agent-status/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAgentStatusesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_124) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_124));
                    }
                }
                if let Some(inner_125) = &_input.max_results {
                    if *inner_125 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_125).encode(),
                        );
                    }
                }
                if let Some(inner_126) = &_input.agent_status_types {
                    {
                        for inner_127 in inner_126 {
                            query.push_kv(
                                "AgentStatusTypes",
                                &aws_smithy_http::query::fmt_string(&inner_127),
                            );
                        }
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAgentStatusesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAgentStatuses::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAgentStatuses",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListApprovedOriginsInput {
    /// Consumes the builder and constructs an Operation<[`ListApprovedOrigins`](crate::operation::ListApprovedOrigins)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListApprovedOrigins,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListApprovedOriginsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_128 = &_input.instance_id;
                let input_128 = input_128.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_128,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/approved-origins",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListApprovedOriginsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_129) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_129));
                    }
                }
                if let Some(inner_130) = &_input.max_results {
                    if *inner_130 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_130).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListApprovedOriginsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListApprovedOrigins::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListApprovedOrigins",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListBotsInput {
    /// Consumes the builder and constructs an Operation<[`ListBots`](crate::operation::ListBots)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListBots,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListBotsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_131 = &_input.instance_id;
                let input_131 = input_131.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_131,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/bots",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListBotsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_132) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_132));
                    }
                }
                if let Some(inner_133) = &_input.max_results {
                    if *inner_133 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_133).encode(),
                        );
                    }
                }
                let inner_134 = &_input.lex_version;
                let inner_134 = inner_134.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "lex_version",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv(
                    "lexVersion",
                    &aws_smithy_http::query::fmt_string(&inner_134),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListBotsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::ListBots::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "ListBots", "connect",
                ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListContactFlowModulesInput {
    /// Consumes the builder and constructs an Operation<[`ListContactFlowModules`](crate::operation::ListContactFlowModules)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListContactFlowModules,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListContactFlowModulesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_135 = &_input.instance_id;
                let input_135 = input_135.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_135,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact-flow-modules-summary/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListContactFlowModulesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_136) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_136));
                    }
                }
                if let Some(inner_137) = &_input.max_results {
                    if *inner_137 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_137).encode(),
                        );
                    }
                }
                if let Some(inner_138) = &_input.contact_flow_module_state {
                    {
                        query.push_kv("state", &aws_smithy_http::query::fmt_string(&inner_138));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListContactFlowModulesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListContactFlowModules::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListContactFlowModules",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListContactFlowsInput {
    /// Consumes the builder and constructs an Operation<[`ListContactFlows`](crate::operation::ListContactFlows)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListContactFlows,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListContactFlowsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_139 = &_input.instance_id;
                let input_139 = input_139.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_139,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact-flows-summary/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListContactFlowsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_140) = &_input.contact_flow_types {
                    {
                        for inner_141 in inner_140 {
                            query.push_kv(
                                "contactFlowTypes",
                                &aws_smithy_http::query::fmt_string(&inner_141),
                            );
                        }
                    }
                }
                if let Some(inner_142) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_142));
                    }
                }
                if _input.max_results != 0 {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListContactFlowsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListContactFlows::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListContactFlows",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListContactReferencesInput {
    /// Consumes the builder and constructs an Operation<[`ListContactReferences`](crate::operation::ListContactReferences)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListContactReferences,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListContactReferencesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_143 = &_input.instance_id;
                let input_143 = input_143.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_143,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_144 = &_input.contact_id;
                let input_144 = input_144.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "contact_id",
                        "cannot be empty or unset",
                    )
                })?;
                let contact_id = aws_smithy_http::label::fmt_string(
                    input_144,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if contact_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "contact_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact/references/{InstanceId}/{ContactId}",
                    InstanceId = instance_id,
                    ContactId = contact_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListContactReferencesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_145 = &_input.reference_types;
                let inner_145 = inner_145.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "reference_types",
                        "cannot be empty or unset",
                    )
                })?;
                for inner_146 in inner_145 {
                    query.push_kv(
                        "referenceTypes",
                        &aws_smithy_http::query::fmt_string(&inner_146),
                    );
                }
                if let Some(inner_147) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_147));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListContactReferencesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListContactReferences::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListContactReferences",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListDefaultVocabulariesInput {
    /// Consumes the builder and constructs an Operation<[`ListDefaultVocabularies`](crate::operation::ListDefaultVocabularies)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListDefaultVocabularies,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListDefaultVocabulariesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_148 = &_input.instance_id;
                let input_148 = input_148.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_148,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/default-vocabulary-summary/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListDefaultVocabulariesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_default_vocabularies::ser_list_default_vocabularies_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListDefaultVocabularies::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListDefaultVocabularies",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListHoursOfOperationsInput {
    /// Consumes the builder and constructs an Operation<[`ListHoursOfOperations`](crate::operation::ListHoursOfOperations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListHoursOfOperations,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListHoursOfOperationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_149 = &_input.instance_id;
                let input_149 = input_149.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_149,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/hours-of-operations-summary/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListHoursOfOperationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_150) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_150));
                    }
                }
                if _input.max_results != 0 {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListHoursOfOperationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListHoursOfOperations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListHoursOfOperations",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListInstanceAttributesInput {
    /// Consumes the builder and constructs an Operation<[`ListInstanceAttributes`](crate::operation::ListInstanceAttributes)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListInstanceAttributes,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListInstanceAttributesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_151 = &_input.instance_id;
                let input_151 = input_151.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_151,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/attributes",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListInstanceAttributesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_152) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_152));
                    }
                }
                if let Some(inner_153) = &_input.max_results {
                    if *inner_153 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_153).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListInstanceAttributesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListInstanceAttributes::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListInstanceAttributes",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListInstancesInput {
    /// Consumes the builder and constructs an Operation<[`ListInstances`](crate::operation::ListInstances)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListInstances,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListInstancesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/instance").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListInstancesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_154) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_154));
                    }
                }
                if let Some(inner_155) = &_input.max_results {
                    if *inner_155 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_155).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListInstancesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListInstances::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListInstances",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListInstanceStorageConfigsInput {
    /// Consumes the builder and constructs an Operation<[`ListInstanceStorageConfigs`](crate::operation::ListInstanceStorageConfigs)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListInstanceStorageConfigs,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListInstanceStorageConfigsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_156 = &_input.instance_id;
                let input_156 = input_156.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_156,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/storage-configs",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListInstanceStorageConfigsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_157 = &_input.resource_type;
                let inner_157 = inner_157.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_type",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv(
                    "resourceType",
                    &aws_smithy_http::query::fmt_string(&inner_157),
                );
                if let Some(inner_158) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_158));
                    }
                }
                if let Some(inner_159) = &_input.max_results {
                    if *inner_159 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_159).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListInstanceStorageConfigsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListInstanceStorageConfigs::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListInstanceStorageConfigs",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListIntegrationAssociationsInput {
    /// Consumes the builder and constructs an Operation<[`ListIntegrationAssociations`](crate::operation::ListIntegrationAssociations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListIntegrationAssociations,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListIntegrationAssociationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_160 = &_input.instance_id;
                let input_160 = input_160.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_160,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/integration-associations",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListIntegrationAssociationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_161) = &_input.integration_type {
                    {
                        query.push_kv(
                            "integrationType",
                            &aws_smithy_http::query::fmt_string(&inner_161),
                        );
                    }
                }
                if let Some(inner_162) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_162));
                    }
                }
                if let Some(inner_163) = &_input.max_results {
                    if *inner_163 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_163).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListIntegrationAssociationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListIntegrationAssociations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListIntegrationAssociations",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListLambdaFunctionsInput {
    /// Consumes the builder and constructs an Operation<[`ListLambdaFunctions`](crate::operation::ListLambdaFunctions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListLambdaFunctions,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListLambdaFunctionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_164 = &_input.instance_id;
                let input_164 = input_164.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_164,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/lambda-functions",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListLambdaFunctionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_165) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_165));
                    }
                }
                if let Some(inner_166) = &_input.max_results {
                    if *inner_166 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_166).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListLambdaFunctionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListLambdaFunctions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListLambdaFunctions",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListLexBotsInput {
    /// Consumes the builder and constructs an Operation<[`ListLexBots`](crate::operation::ListLexBots)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListLexBots,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListLexBotsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_167 = &_input.instance_id;
                let input_167 = input_167.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_167,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/lex-bots",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListLexBotsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_168) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_168));
                    }
                }
                if let Some(inner_169) = &_input.max_results {
                    if *inner_169 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_169).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListLexBotsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListLexBots::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListLexBots",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListPhoneNumbersInput {
    /// Consumes the builder and constructs an Operation<[`ListPhoneNumbers`](crate::operation::ListPhoneNumbers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPhoneNumbers,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPhoneNumbersInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_170 = &_input.instance_id;
                let input_170 = input_170.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_170,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/phone-numbers-summary/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListPhoneNumbersInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_171) = &_input.phone_number_types {
                    {
                        for inner_172 in inner_171 {
                            query.push_kv(
                                "phoneNumberTypes",
                                &aws_smithy_http::query::fmt_string(&inner_172),
                            );
                        }
                    }
                }
                if let Some(inner_173) = &_input.phone_number_country_codes {
                    {
                        for inner_174 in inner_173 {
                            query.push_kv(
                                "phoneNumberCountryCodes",
                                &aws_smithy_http::query::fmt_string(&inner_174),
                            );
                        }
                    }
                }
                if let Some(inner_175) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_175));
                    }
                }
                if _input.max_results != 0 {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPhoneNumbersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPhoneNumbers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPhoneNumbers",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListPhoneNumbersV2Input {
    /// Consumes the builder and constructs an Operation<[`ListPhoneNumbersV2`](crate::operation::ListPhoneNumbersV2)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPhoneNumbersV2,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPhoneNumbersV2Input,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/phone-number/list").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPhoneNumbersV2Input,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_phone_numbers_v2::ser_list_phone_numbers_v2_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPhoneNumbersV2::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPhoneNumbersV2",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListPromptsInput {
    /// Consumes the builder and constructs an Operation<[`ListPrompts`](crate::operation::ListPrompts)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPrompts,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPromptsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_176 = &_input.instance_id;
                let input_176 = input_176.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_176,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/prompts-summary/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListPromptsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_177) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_177));
                    }
                }
                if let Some(inner_178) = &_input.max_results {
                    if *inner_178 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_178).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPromptsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPrompts::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPrompts",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListQueueQuickConnectsInput {
    /// Consumes the builder and constructs an Operation<[`ListQueueQuickConnects`](crate::operation::ListQueueQuickConnects)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListQueueQuickConnects,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListQueueQuickConnectsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_179 = &_input.instance_id;
                let input_179 = input_179.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_179,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_180 = &_input.queue_id;
                let input_180 = input_180.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "queue_id",
                        "cannot be empty or unset",
                    )
                })?;
                let queue_id = aws_smithy_http::label::fmt_string(
                    input_180,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if queue_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "queue_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/queues/{InstanceId}/{QueueId}/quick-connects",
                    InstanceId = instance_id,
                    QueueId = queue_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListQueueQuickConnectsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_181) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_181));
                    }
                }
                if let Some(inner_182) = &_input.max_results {
                    if *inner_182 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_182).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListQueueQuickConnectsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListQueueQuickConnects::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListQueueQuickConnects",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListQueuesInput {
    /// Consumes the builder and constructs an Operation<[`ListQueues`](crate::operation::ListQueues)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListQueues,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListQueuesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_183 = &_input.instance_id;
                let input_183 = input_183.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_183,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/queues-summary/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListQueuesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_184) = &_input.queue_types {
                    {
                        for inner_185 in inner_184 {
                            query.push_kv(
                                "queueTypes",
                                &aws_smithy_http::query::fmt_string(&inner_185),
                            );
                        }
                    }
                }
                if let Some(inner_186) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_186));
                    }
                }
                if _input.max_results != 0 {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListQueuesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListQueues::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListQueues",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListQuickConnectsInput {
    /// Consumes the builder and constructs an Operation<[`ListQuickConnects`](crate::operation::ListQuickConnects)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListQuickConnects,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListQuickConnectsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_187 = &_input.instance_id;
                let input_187 = input_187.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_187,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/quick-connects/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListQuickConnectsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_188) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_188));
                    }
                }
                if let Some(inner_189) = &_input.max_results {
                    if *inner_189 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_189).encode(),
                        );
                    }
                }
                if let Some(inner_190) = &_input.quick_connect_types {
                    {
                        for inner_191 in inner_190 {
                            query.push_kv(
                                "QuickConnectTypes",
                                &aws_smithy_http::query::fmt_string(&inner_191),
                            );
                        }
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListQuickConnectsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListQuickConnects::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListQuickConnects",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListRoutingProfileQueuesInput {
    /// Consumes the builder and constructs an Operation<[`ListRoutingProfileQueues`](crate::operation::ListRoutingProfileQueues)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListRoutingProfileQueues,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListRoutingProfileQueuesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_192 = &_input.instance_id;
                let input_192 = input_192.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_192,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_193 = &_input.routing_profile_id;
                let input_193 = input_193.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "routing_profile_id",
                        "cannot be empty or unset",
                    )
                })?;
                let routing_profile_id = aws_smithy_http::label::fmt_string(
                    input_193,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if routing_profile_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "routing_profile_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/routing-profiles/{InstanceId}/{RoutingProfileId}/queues",
                    InstanceId = instance_id,
                    RoutingProfileId = routing_profile_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListRoutingProfileQueuesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_194) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_194));
                    }
                }
                if let Some(inner_195) = &_input.max_results {
                    if *inner_195 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_195).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListRoutingProfileQueuesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListRoutingProfileQueues::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListRoutingProfileQueues",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListRoutingProfilesInput {
    /// Consumes the builder and constructs an Operation<[`ListRoutingProfiles`](crate::operation::ListRoutingProfiles)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListRoutingProfiles,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListRoutingProfilesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_196 = &_input.instance_id;
                let input_196 = input_196.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_196,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/routing-profiles-summary/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListRoutingProfilesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_197) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_197));
                    }
                }
                if let Some(inner_198) = &_input.max_results {
                    if *inner_198 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_198).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListRoutingProfilesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListRoutingProfiles::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListRoutingProfiles",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListRulesInput {
    /// Consumes the builder and constructs an Operation<[`ListRules`](crate::operation::ListRules)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListRules,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListRulesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_199 = &_input.instance_id;
                let input_199 = input_199.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_199,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/rules/{InstanceId}", InstanceId = instance_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListRulesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_200) = &_input.publish_status {
                    {
                        query.push_kv(
                            "publishStatus",
                            &aws_smithy_http::query::fmt_string(&inner_200),
                        );
                    }
                }
                if let Some(inner_201) = &_input.event_source_name {
                    {
                        query.push_kv(
                            "eventSourceName",
                            &aws_smithy_http::query::fmt_string(&inner_201),
                        );
                    }
                }
                if let Some(inner_202) = &_input.max_results {
                    if *inner_202 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_202).encode(),
                        );
                    }
                }
                if let Some(inner_203) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_203));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListRulesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::ListRules::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "ListRules",
                    "connect",
                ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListSecurityKeysInput {
    /// Consumes the builder and constructs an Operation<[`ListSecurityKeys`](crate::operation::ListSecurityKeys)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSecurityKeys,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSecurityKeysInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_204 = &_input.instance_id;
                let input_204 = input_204.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_204,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/security-keys",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListSecurityKeysInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_205) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_205));
                    }
                }
                if let Some(inner_206) = &_input.max_results {
                    if *inner_206 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_206).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSecurityKeysInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSecurityKeys::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSecurityKeys",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListSecurityProfilePermissionsInput {
    /// Consumes the builder and constructs an Operation<[`ListSecurityProfilePermissions`](crate::operation::ListSecurityProfilePermissions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSecurityProfilePermissions,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSecurityProfilePermissionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_207 = &_input.instance_id;
                let input_207 = input_207.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_207,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_208 = &_input.security_profile_id;
                let input_208 = input_208.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "security_profile_id",
                        "cannot be empty or unset",
                    )
                })?;
                let security_profile_id = aws_smithy_http::label::fmt_string(
                    input_208,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if security_profile_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "security_profile_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/security-profiles-permissions/{InstanceId}/{SecurityProfileId}",
                    InstanceId = instance_id,
                    SecurityProfileId = security_profile_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListSecurityProfilePermissionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_209) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_209));
                    }
                }
                if let Some(inner_210) = &_input.max_results {
                    if *inner_210 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_210).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSecurityProfilePermissionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSecurityProfilePermissions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSecurityProfilePermissions",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListSecurityProfilesInput {
    /// Consumes the builder and constructs an Operation<[`ListSecurityProfiles`](crate::operation::ListSecurityProfiles)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSecurityProfiles,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSecurityProfilesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_211 = &_input.instance_id;
                let input_211 = input_211.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_211,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/security-profiles-summary/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListSecurityProfilesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_212) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_212));
                    }
                }
                if let Some(inner_213) = &_input.max_results {
                    if *inner_213 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_213).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSecurityProfilesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSecurityProfiles::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSecurityProfiles",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTagsForResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_214 = &_input.resource_arn;
                let input_214 = input_214.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let resource_arn = aws_smithy_http::label::fmt_string(
                    input_214,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if resource_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/tags/{resourceArn}", resourceArn = resource_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTagsForResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListTaskTemplatesInput {
    /// Consumes the builder and constructs an Operation<[`ListTaskTemplates`](crate::operation::ListTaskTemplates)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTaskTemplates,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTaskTemplatesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_215 = &_input.instance_id;
                let input_215 = input_215.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_215,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/task/template",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListTaskTemplatesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_216) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_216));
                    }
                }
                if let Some(inner_217) = &_input.max_results {
                    if *inner_217 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_217).encode(),
                        );
                    }
                }
                if let Some(inner_218) = &_input.status {
                    {
                        query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_218));
                    }
                }
                if let Some(inner_219) = &_input.name {
                    {
                        query.push_kv("name", &aws_smithy_http::query::fmt_string(&inner_219));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTaskTemplatesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTaskTemplates::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTaskTemplates",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListTrafficDistributionGroupsInput {
    /// Consumes the builder and constructs an Operation<[`ListTrafficDistributionGroups`](crate::operation::ListTrafficDistributionGroups)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTrafficDistributionGroups,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTrafficDistributionGroupsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/traffic-distribution-groups").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListTrafficDistributionGroupsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.max_results != 0 {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                    );
                }
                if let Some(inner_220) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_220));
                    }
                }
                if let Some(inner_221) = &_input.instance_id {
                    {
                        query.push_kv(
                            "instanceId",
                            &aws_smithy_http::query::fmt_string(&inner_221),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTrafficDistributionGroupsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTrafficDistributionGroups::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTrafficDistributionGroups",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListUseCasesInput {
    /// Consumes the builder and constructs an Operation<[`ListUseCases`](crate::operation::ListUseCases)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListUseCases,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListUseCasesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_222 = &_input.instance_id;
                let input_222 = input_222.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_222,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_223 = &_input.integration_association_id;
                let input_223 = input_223.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "integration_association_id",
                        "cannot be empty or unset",
                    )
                })?;
                let integration_association_id = aws_smithy_http::label::fmt_string(
                    input_223,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if integration_association_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "integration_association_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/instance/{InstanceId}/integration-associations/{IntegrationAssociationId}/use-cases", InstanceId = instance_id, IntegrationAssociationId = integration_association_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListUseCasesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_224) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_224));
                    }
                }
                if let Some(inner_225) = &_input.max_results {
                    if *inner_225 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_225).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListUseCasesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListUseCases::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListUseCases",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListUserHierarchyGroupsInput {
    /// Consumes the builder and constructs an Operation<[`ListUserHierarchyGroups`](crate::operation::ListUserHierarchyGroups)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListUserHierarchyGroups,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListUserHierarchyGroupsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_226 = &_input.instance_id;
                let input_226 = input_226.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_226,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/user-hierarchy-groups-summary/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListUserHierarchyGroupsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_227) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_227));
                    }
                }
                if let Some(inner_228) = &_input.max_results {
                    if *inner_228 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_228).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListUserHierarchyGroupsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListUserHierarchyGroups::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListUserHierarchyGroups",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListUsersInput {
    /// Consumes the builder and constructs an Operation<[`ListUsers`](crate::operation::ListUsers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListUsers,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListUsersInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_229 = &_input.instance_id;
                let input_229 = input_229.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_229,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/users-summary/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListUsersInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_230) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_230));
                    }
                }
                if let Some(inner_231) = &_input.max_results {
                    if *inner_231 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_231).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListUsersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::ListUsers::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "ListUsers",
                    "connect",
                ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl MonitorContactInput {
    /// Consumes the builder and constructs an Operation<[`MonitorContact`](crate::operation::MonitorContact)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::MonitorContact,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::MonitorContactInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/monitor").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::MonitorContactInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_monitor_contact::ser_monitor_contact_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::MonitorContact::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "MonitorContact",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl PutUserStatusInput {
    /// Consumes the builder and constructs an Operation<[`PutUserStatus`](crate::operation::PutUserStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutUserStatus,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutUserStatusInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_232 = &_input.instance_id;
                let input_232 = input_232.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_232,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_233 = &_input.user_id;
                let input_233 = input_233.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "user_id",
                        "cannot be empty or unset",
                    )
                })?;
                let user_id = aws_smithy_http::label::fmt_string(
                    input_233,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if user_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "user_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/users/{InstanceId}/{UserId}/status",
                    InstanceId = instance_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutUserStatusInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_put_user_status::ser_put_user_status_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutUserStatus::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutUserStatus",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ReleasePhoneNumberInput {
    /// Consumes the builder and constructs an Operation<[`ReleasePhoneNumber`](crate::operation::ReleasePhoneNumber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ReleasePhoneNumber,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::ReleasePhoneNumberInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_234 = &_input.phone_number_id;
                let input_234 = input_234.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "phone_number_id",
                        "cannot be empty or unset",
                    )
                })?;
                let phone_number_id = aws_smithy_http::label::fmt_string(
                    input_234,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if phone_number_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "phone_number_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/phone-number/{PhoneNumberId}",
                    PhoneNumberId = phone_number_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ReleasePhoneNumberInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_235) = &_input.client_token {
                    {
                        query.push_kv(
                            "clientToken",
                            &aws_smithy_http::query::fmt_string(&inner_235),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ReleasePhoneNumberInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ReleasePhoneNumber::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ReleasePhoneNumber",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ReplicateInstanceInput {
    /// Consumes the builder and constructs an Operation<[`ReplicateInstance`](crate::operation::ReplicateInstance)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ReplicateInstance,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::ReplicateInstanceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_236 = &_input.instance_id;
                let input_236 = input_236.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_236,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/replicate",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ReplicateInstanceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_replicate_instance::ser_replicate_instance_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ReplicateInstance::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ReplicateInstance",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ResumeContactRecordingInput {
    /// Consumes the builder and constructs an Operation<[`ResumeContactRecording`](crate::operation::ResumeContactRecording)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ResumeContactRecording,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ResumeContactRecordingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/resume-recording").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ResumeContactRecordingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_resume_contact_recording::ser_resume_contact_recording_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ResumeContactRecording::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ResumeContactRecording",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl SearchAvailablePhoneNumbersInput {
    /// Consumes the builder and constructs an Operation<[`SearchAvailablePhoneNumbers`](crate::operation::SearchAvailablePhoneNumbers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SearchAvailablePhoneNumbers,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::SearchAvailablePhoneNumbersInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/phone-number/search-available")
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SearchAvailablePhoneNumbersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_search_available_phone_numbers::ser_search_available_phone_numbers_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SearchAvailablePhoneNumbers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SearchAvailablePhoneNumbers",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl SearchQueuesInput {
    /// Consumes the builder and constructs an Operation<[`SearchQueues`](crate::operation::SearchQueues)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SearchQueues,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::SearchQueuesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/search-queues").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SearchQueuesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_search_queues::ser_search_queues_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SearchQueues::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SearchQueues",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl SearchRoutingProfilesInput {
    /// Consumes the builder and constructs an Operation<[`SearchRoutingProfiles`](crate::operation::SearchRoutingProfiles)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SearchRoutingProfiles,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::SearchRoutingProfilesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/search-routing-profiles").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SearchRoutingProfilesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_search_routing_profiles::ser_search_routing_profiles_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SearchRoutingProfiles::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SearchRoutingProfiles",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl SearchSecurityProfilesInput {
    /// Consumes the builder and constructs an Operation<[`SearchSecurityProfiles`](crate::operation::SearchSecurityProfiles)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SearchSecurityProfiles,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::SearchSecurityProfilesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/search-security-profiles").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SearchSecurityProfilesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_search_security_profiles::ser_search_security_profiles_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SearchSecurityProfiles::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SearchSecurityProfiles",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl SearchUsersInput {
    /// Consumes the builder and constructs an Operation<[`SearchUsers`](crate::operation::SearchUsers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SearchUsers,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::SearchUsersInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/search-users").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SearchUsersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_search_users::ser_search_users_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SearchUsers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SearchUsers",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl SearchVocabulariesInput {
    /// Consumes the builder and constructs an Operation<[`SearchVocabularies`](crate::operation::SearchVocabularies)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SearchVocabularies,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::SearchVocabulariesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_237 = &_input.instance_id;
                let input_237 = input_237.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_237,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/vocabulary-summary/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SearchVocabulariesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_search_vocabularies::ser_search_vocabularies_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SearchVocabularies::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SearchVocabularies",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl StartChatContactInput {
    /// Consumes the builder and constructs an Operation<[`StartChatContact`](crate::operation::StartChatContact)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartChatContact,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartChatContactInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/chat").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartChatContactInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_start_chat_contact::ser_start_chat_contact_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartChatContact::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartChatContact",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl StartContactRecordingInput {
    /// Consumes the builder and constructs an Operation<[`StartContactRecording`](crate::operation::StartContactRecording)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartContactRecording,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartContactRecordingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/start-recording").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartContactRecordingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_start_contact_recording::ser_start_contact_recording_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartContactRecording::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartContactRecording",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl StartContactStreamingInput {
    /// Consumes the builder and constructs an Operation<[`StartContactStreaming`](crate::operation::StartContactStreaming)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartContactStreaming,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartContactStreamingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/start-streaming").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartContactStreamingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_start_contact_streaming::ser_start_contact_streaming_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartContactStreaming::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartContactStreaming",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl StartOutboundVoiceContactInput {
    /// Consumes the builder and constructs an Operation<[`StartOutboundVoiceContact`](crate::operation::StartOutboundVoiceContact)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartOutboundVoiceContact,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartOutboundVoiceContactInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/outbound-voice").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartOutboundVoiceContactInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_start_outbound_voice_contact::ser_start_outbound_voice_contact_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartOutboundVoiceContact::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartOutboundVoiceContact",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl StartTaskContactInput {
    /// Consumes the builder and constructs an Operation<[`StartTaskContact`](crate::operation::StartTaskContact)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartTaskContact,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartTaskContactInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/task").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartTaskContactInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_start_task_contact::ser_start_task_contact_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartTaskContact::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartTaskContact",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl StopContactInput {
    /// Consumes the builder and constructs an Operation<[`StopContact`](crate::operation::StopContact)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StopContact,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::StopContactInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/stop").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StopContactInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_stop_contact::ser_stop_contact_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StopContact::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StopContact",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl StopContactRecordingInput {
    /// Consumes the builder and constructs an Operation<[`StopContactRecording`](crate::operation::StopContactRecording)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StopContactRecording,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::StopContactRecordingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/stop-recording").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StopContactRecordingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_stop_contact_recording::ser_stop_contact_recording_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StopContactRecording::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StopContactRecording",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl StopContactStreamingInput {
    /// Consumes the builder and constructs an Operation<[`StopContactStreaming`](crate::operation::StopContactStreaming)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StopContactStreaming,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::StopContactStreamingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/stop-streaming").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StopContactStreamingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_stop_contact_streaming::ser_stop_contact_streaming_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StopContactStreaming::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StopContactStreaming",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl SuspendContactRecordingInput {
    /// Consumes the builder and constructs an Operation<[`SuspendContactRecording`](crate::operation::SuspendContactRecording)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SuspendContactRecording,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::SuspendContactRecordingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/suspend-recording").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SuspendContactRecordingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_suspend_contact_recording::ser_suspend_contact_recording_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SuspendContactRecording::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SuspendContactRecording",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::TagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_238 = &_input.resource_arn;
                let input_238 = input_238.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let resource_arn = aws_smithy_http::label::fmt_string(
                    input_238,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if resource_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/tags/{resourceArn}", resourceArn = resource_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_tag_resource::ser_tag_resource_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl TransferContactInput {
    /// Consumes the builder and constructs an Operation<[`TransferContact`](crate::operation::TransferContact)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TransferContact,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::TransferContactInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/transfer").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TransferContactInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_transfer_contact::ser_transfer_contact_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TransferContact::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TransferContact",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UntagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_239 = &_input.resource_arn;
                let input_239 = input_239.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let resource_arn = aws_smithy_http::label::fmt_string(
                    input_239,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if resource_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/tags/{resourceArn}", resourceArn = resource_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UntagResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_240 = &_input.tag_keys;
                let inner_240 = inner_240.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "tag_keys",
                        "cannot be empty or unset",
                    )
                })?;
                for inner_241 in inner_240 {
                    query.push_kv("tagKeys", &aws_smithy_http::query::fmt_string(&inner_241));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UntagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateAgentStatusInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAgentStatus`](crate::operation::UpdateAgentStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAgentStatus,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAgentStatusInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_242 = &_input.instance_id;
                let input_242 = input_242.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_242,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_243 = &_input.agent_status_id;
                let input_243 = input_243.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "agent_status_id",
                        "cannot be empty or unset",
                    )
                })?;
                let agent_status_id = aws_smithy_http::label::fmt_string(
                    input_243,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if agent_status_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "agent_status_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/agent-status/{InstanceId}/{AgentStatusId}",
                    InstanceId = instance_id,
                    AgentStatusId = agent_status_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAgentStatusInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_agent_status::ser_update_agent_status_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAgentStatus::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAgentStatus",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateContactInput {
    /// Consumes the builder and constructs an Operation<[`UpdateContact`](crate::operation::UpdateContact)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateContact,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateContactInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_244 = &_input.instance_id;
                let input_244 = input_244.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_244,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_245 = &_input.contact_id;
                let input_245 = input_245.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "contact_id",
                        "cannot be empty or unset",
                    )
                })?;
                let contact_id = aws_smithy_http::label::fmt_string(
                    input_245,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if contact_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "contact_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contacts/{InstanceId}/{ContactId}",
                    InstanceId = instance_id,
                    ContactId = contact_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateContactInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_contact::ser_update_contact_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateContact::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateContact",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateContactAttributesInput {
    /// Consumes the builder and constructs an Operation<[`UpdateContactAttributes`](crate::operation::UpdateContactAttributes)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateContactAttributes,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateContactAttributesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/attributes").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateContactAttributesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_contact_attributes::ser_update_contact_attributes_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateContactAttributes::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateContactAttributes",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateContactFlowContentInput {
    /// Consumes the builder and constructs an Operation<[`UpdateContactFlowContent`](crate::operation::UpdateContactFlowContent)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateContactFlowContent,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateContactFlowContentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_246 = &_input.instance_id;
                let input_246 = input_246.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_246,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_247 = &_input.contact_flow_id;
                let input_247 = input_247.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "contact_flow_id",
                        "cannot be empty or unset",
                    )
                })?;
                let contact_flow_id = aws_smithy_http::label::fmt_string(
                    input_247,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if contact_flow_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "contact_flow_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact-flows/{InstanceId}/{ContactFlowId}/content",
                    InstanceId = instance_id,
                    ContactFlowId = contact_flow_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateContactFlowContentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_contact_flow_content::ser_update_contact_flow_content_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateContactFlowContent::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateContactFlowContent",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateContactFlowMetadataInput {
    /// Consumes the builder and constructs an Operation<[`UpdateContactFlowMetadata`](crate::operation::UpdateContactFlowMetadata)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateContactFlowMetadata,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateContactFlowMetadataInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_248 = &_input.instance_id;
                let input_248 = input_248.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_248,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_249 = &_input.contact_flow_id;
                let input_249 = input_249.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "contact_flow_id",
                        "cannot be empty or unset",
                    )
                })?;
                let contact_flow_id = aws_smithy_http::label::fmt_string(
                    input_249,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if contact_flow_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "contact_flow_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact-flows/{InstanceId}/{ContactFlowId}/metadata",
                    InstanceId = instance_id,
                    ContactFlowId = contact_flow_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateContactFlowMetadataInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_contact_flow_metadata::ser_update_contact_flow_metadata_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateContactFlowMetadata::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateContactFlowMetadata",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateContactFlowModuleContentInput {
    /// Consumes the builder and constructs an Operation<[`UpdateContactFlowModuleContent`](crate::operation::UpdateContactFlowModuleContent)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateContactFlowModuleContent,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateContactFlowModuleContentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_250 = &_input.instance_id;
                let input_250 = input_250.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_250,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_251 = &_input.contact_flow_module_id;
                let input_251 = input_251.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "contact_flow_module_id",
                        "cannot be empty or unset",
                    )
                })?;
                let contact_flow_module_id = aws_smithy_http::label::fmt_string(
                    input_251,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if contact_flow_module_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "contact_flow_module_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/content",
                    InstanceId = instance_id,
                    ContactFlowModuleId = contact_flow_module_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateContactFlowModuleContentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_contact_flow_module_content::ser_update_contact_flow_module_content_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateContactFlowModuleContent::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateContactFlowModuleContent",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateContactFlowModuleMetadataInput {
    /// Consumes the builder and constructs an Operation<[`UpdateContactFlowModuleMetadata`](crate::operation::UpdateContactFlowModuleMetadata)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateContactFlowModuleMetadata,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateContactFlowModuleMetadataInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_252 = &_input.instance_id;
                let input_252 = input_252.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_252,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_253 = &_input.contact_flow_module_id;
                let input_253 = input_253.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "contact_flow_module_id",
                        "cannot be empty or unset",
                    )
                })?;
                let contact_flow_module_id = aws_smithy_http::label::fmt_string(
                    input_253,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if contact_flow_module_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "contact_flow_module_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/metadata",
                    InstanceId = instance_id,
                    ContactFlowModuleId = contact_flow_module_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateContactFlowModuleMetadataInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_contact_flow_module_metadata::ser_update_contact_flow_module_metadata_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateContactFlowModuleMetadata::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateContactFlowModuleMetadata",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateContactFlowNameInput {
    /// Consumes the builder and constructs an Operation<[`UpdateContactFlowName`](crate::operation::UpdateContactFlowName)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateContactFlowName,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateContactFlowNameInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_254 = &_input.instance_id;
                let input_254 = input_254.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_254,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_255 = &_input.contact_flow_id;
                let input_255 = input_255.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "contact_flow_id",
                        "cannot be empty or unset",
                    )
                })?;
                let contact_flow_id = aws_smithy_http::label::fmt_string(
                    input_255,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if contact_flow_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "contact_flow_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact-flows/{InstanceId}/{ContactFlowId}/name",
                    InstanceId = instance_id,
                    ContactFlowId = contact_flow_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateContactFlowNameInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_contact_flow_name::ser_update_contact_flow_name_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateContactFlowName::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateContactFlowName",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateContactScheduleInput {
    /// Consumes the builder and constructs an Operation<[`UpdateContactSchedule`](crate::operation::UpdateContactSchedule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateContactSchedule,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateContactScheduleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/contact/schedule").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateContactScheduleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_contact_schedule::ser_update_contact_schedule_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateContactSchedule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateContactSchedule",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateHoursOfOperationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateHoursOfOperation`](crate::operation::UpdateHoursOfOperation)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateHoursOfOperation,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateHoursOfOperationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_256 = &_input.instance_id;
                let input_256 = input_256.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_256,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_257 = &_input.hours_of_operation_id;
                let input_257 = input_257.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "hours_of_operation_id",
                        "cannot be empty or unset",
                    )
                })?;
                let hours_of_operation_id = aws_smithy_http::label::fmt_string(
                    input_257,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if hours_of_operation_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "hours_of_operation_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/hours-of-operations/{InstanceId}/{HoursOfOperationId}",
                    InstanceId = instance_id,
                    HoursOfOperationId = hours_of_operation_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateHoursOfOperationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_hours_of_operation::ser_update_hours_of_operation_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateHoursOfOperation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateHoursOfOperation",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateInstanceAttributeInput {
    /// Consumes the builder and constructs an Operation<[`UpdateInstanceAttribute`](crate::operation::UpdateInstanceAttribute)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateInstanceAttribute,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateInstanceAttributeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_258 = &_input.instance_id;
                let input_258 = input_258.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_258,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_259 = &_input.attribute_type;
                let input_259 = input_259.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "attribute_type",
                        "cannot be empty or unset",
                    )
                })?;
                let attribute_type = aws_smithy_http::label::fmt_string(
                    input_259,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if attribute_type.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "attribute_type",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/attribute/{AttributeType}",
                    InstanceId = instance_id,
                    AttributeType = attribute_type
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateInstanceAttributeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_instance_attribute::ser_update_instance_attribute_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateInstanceAttribute::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateInstanceAttribute",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateInstanceStorageConfigInput {
    /// Consumes the builder and constructs an Operation<[`UpdateInstanceStorageConfig`](crate::operation::UpdateInstanceStorageConfig)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateInstanceStorageConfig,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateInstanceStorageConfigInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_260 = &_input.instance_id;
                let input_260 = input_260.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_260,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_261 = &_input.association_id;
                let input_261 = input_261.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "association_id",
                        "cannot be empty or unset",
                    )
                })?;
                let association_id = aws_smithy_http::label::fmt_string(
                    input_261,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if association_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "association_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/storage-config/{AssociationId}",
                    InstanceId = instance_id,
                    AssociationId = association_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UpdateInstanceStorageConfigInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_262 = &_input.resource_type;
                let inner_262 = inner_262.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_type",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv(
                    "resourceType",
                    &aws_smithy_http::query::fmt_string(&inner_262),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateInstanceStorageConfigInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_instance_storage_config::ser_update_instance_storage_config_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateInstanceStorageConfig::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateInstanceStorageConfig",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateParticipantRoleConfigInput {
    /// Consumes the builder and constructs an Operation<[`UpdateParticipantRoleConfig`](crate::operation::UpdateParticipantRoleConfig)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateParticipantRoleConfig,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateParticipantRoleConfigInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_263 = &_input.instance_id;
                let input_263 = input_263.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_263,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_264 = &_input.contact_id;
                let input_264 = input_264.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "contact_id",
                        "cannot be empty or unset",
                    )
                })?;
                let contact_id = aws_smithy_http::label::fmt_string(
                    input_264,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if contact_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "contact_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/contact/participant-role-config/{InstanceId}/{ContactId}",
                    InstanceId = instance_id,
                    ContactId = contact_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateParticipantRoleConfigInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_participant_role_config::ser_update_participant_role_config_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateParticipantRoleConfig::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateParticipantRoleConfig",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdatePhoneNumberInput {
    /// Consumes the builder and constructs an Operation<[`UpdatePhoneNumber`](crate::operation::UpdatePhoneNumber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdatePhoneNumber,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdatePhoneNumberInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_265 = &_input.phone_number_id;
                let input_265 = input_265.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "phone_number_id",
                        "cannot be empty or unset",
                    )
                })?;
                let phone_number_id = aws_smithy_http::label::fmt_string(
                    input_265,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if phone_number_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "phone_number_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/phone-number/{PhoneNumberId}",
                    PhoneNumberId = phone_number_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdatePhoneNumberInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_phone_number::ser_update_phone_number_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdatePhoneNumber::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdatePhoneNumber",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateQueueHoursOfOperationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateQueueHoursOfOperation`](crate::operation::UpdateQueueHoursOfOperation)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateQueueHoursOfOperation,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateQueueHoursOfOperationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_266 = &_input.instance_id;
                let input_266 = input_266.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_266,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_267 = &_input.queue_id;
                let input_267 = input_267.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "queue_id",
                        "cannot be empty or unset",
                    )
                })?;
                let queue_id = aws_smithy_http::label::fmt_string(
                    input_267,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if queue_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "queue_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/queues/{InstanceId}/{QueueId}/hours-of-operation",
                    InstanceId = instance_id,
                    QueueId = queue_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateQueueHoursOfOperationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_queue_hours_of_operation::ser_update_queue_hours_of_operation_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateQueueHoursOfOperation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateQueueHoursOfOperation",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateQueueMaxContactsInput {
    /// Consumes the builder and constructs an Operation<[`UpdateQueueMaxContacts`](crate::operation::UpdateQueueMaxContacts)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateQueueMaxContacts,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateQueueMaxContactsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_268 = &_input.instance_id;
                let input_268 = input_268.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_268,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_269 = &_input.queue_id;
                let input_269 = input_269.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "queue_id",
                        "cannot be empty or unset",
                    )
                })?;
                let queue_id = aws_smithy_http::label::fmt_string(
                    input_269,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if queue_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "queue_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/queues/{InstanceId}/{QueueId}/max-contacts",
                    InstanceId = instance_id,
                    QueueId = queue_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateQueueMaxContactsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_queue_max_contacts::ser_update_queue_max_contacts_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateQueueMaxContacts::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateQueueMaxContacts",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateQueueNameInput {
    /// Consumes the builder and constructs an Operation<[`UpdateQueueName`](crate::operation::UpdateQueueName)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateQueueName,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateQueueNameInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_270 = &_input.instance_id;
                let input_270 = input_270.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_270,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_271 = &_input.queue_id;
                let input_271 = input_271.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "queue_id",
                        "cannot be empty or unset",
                    )
                })?;
                let queue_id = aws_smithy_http::label::fmt_string(
                    input_271,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if queue_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "queue_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/queues/{InstanceId}/{QueueId}/name",
                    InstanceId = instance_id,
                    QueueId = queue_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateQueueNameInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_queue_name::ser_update_queue_name_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateQueueName::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateQueueName",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateQueueOutboundCallerConfigInput {
    /// Consumes the builder and constructs an Operation<[`UpdateQueueOutboundCallerConfig`](crate::operation::UpdateQueueOutboundCallerConfig)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateQueueOutboundCallerConfig,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateQueueOutboundCallerConfigInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_272 = &_input.instance_id;
                let input_272 = input_272.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_272,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_273 = &_input.queue_id;
                let input_273 = input_273.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "queue_id",
                        "cannot be empty or unset",
                    )
                })?;
                let queue_id = aws_smithy_http::label::fmt_string(
                    input_273,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if queue_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "queue_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/queues/{InstanceId}/{QueueId}/outbound-caller-config",
                    InstanceId = instance_id,
                    QueueId = queue_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateQueueOutboundCallerConfigInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_queue_outbound_caller_config::ser_update_queue_outbound_caller_config_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateQueueOutboundCallerConfig::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateQueueOutboundCallerConfig",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateQueueStatusInput {
    /// Consumes the builder and constructs an Operation<[`UpdateQueueStatus`](crate::operation::UpdateQueueStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateQueueStatus,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateQueueStatusInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_274 = &_input.instance_id;
                let input_274 = input_274.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_274,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_275 = &_input.queue_id;
                let input_275 = input_275.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "queue_id",
                        "cannot be empty or unset",
                    )
                })?;
                let queue_id = aws_smithy_http::label::fmt_string(
                    input_275,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if queue_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "queue_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/queues/{InstanceId}/{QueueId}/status",
                    InstanceId = instance_id,
                    QueueId = queue_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateQueueStatusInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_queue_status::ser_update_queue_status_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateQueueStatus::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateQueueStatus",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateQuickConnectConfigInput {
    /// Consumes the builder and constructs an Operation<[`UpdateQuickConnectConfig`](crate::operation::UpdateQuickConnectConfig)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateQuickConnectConfig,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateQuickConnectConfigInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_276 = &_input.instance_id;
                let input_276 = input_276.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_276,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_277 = &_input.quick_connect_id;
                let input_277 = input_277.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "quick_connect_id",
                        "cannot be empty or unset",
                    )
                })?;
                let quick_connect_id = aws_smithy_http::label::fmt_string(
                    input_277,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if quick_connect_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "quick_connect_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/quick-connects/{InstanceId}/{QuickConnectId}/config",
                    InstanceId = instance_id,
                    QuickConnectId = quick_connect_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateQuickConnectConfigInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_quick_connect_config::ser_update_quick_connect_config_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateQuickConnectConfig::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateQuickConnectConfig",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateQuickConnectNameInput {
    /// Consumes the builder and constructs an Operation<[`UpdateQuickConnectName`](crate::operation::UpdateQuickConnectName)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateQuickConnectName,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateQuickConnectNameInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_278 = &_input.instance_id;
                let input_278 = input_278.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_278,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_279 = &_input.quick_connect_id;
                let input_279 = input_279.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "quick_connect_id",
                        "cannot be empty or unset",
                    )
                })?;
                let quick_connect_id = aws_smithy_http::label::fmt_string(
                    input_279,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if quick_connect_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "quick_connect_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/quick-connects/{InstanceId}/{QuickConnectId}/name",
                    InstanceId = instance_id,
                    QuickConnectId = quick_connect_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateQuickConnectNameInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_quick_connect_name::ser_update_quick_connect_name_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateQuickConnectName::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateQuickConnectName",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateRoutingProfileConcurrencyInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRoutingProfileConcurrency`](crate::operation::UpdateRoutingProfileConcurrency)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateRoutingProfileConcurrency,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateRoutingProfileConcurrencyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_280 = &_input.instance_id;
                let input_280 = input_280.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_280,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_281 = &_input.routing_profile_id;
                let input_281 = input_281.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "routing_profile_id",
                        "cannot be empty or unset",
                    )
                })?;
                let routing_profile_id = aws_smithy_http::label::fmt_string(
                    input_281,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if routing_profile_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "routing_profile_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/routing-profiles/{InstanceId}/{RoutingProfileId}/concurrency",
                    InstanceId = instance_id,
                    RoutingProfileId = routing_profile_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateRoutingProfileConcurrencyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_routing_profile_concurrency::ser_update_routing_profile_concurrency_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateRoutingProfileConcurrency::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateRoutingProfileConcurrency",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateRoutingProfileDefaultOutboundQueueInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRoutingProfileDefaultOutboundQueue`](crate::operation::UpdateRoutingProfileDefaultOutboundQueue)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateRoutingProfileDefaultOutboundQueue,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateRoutingProfileDefaultOutboundQueueInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_282 = &_input.instance_id;
                let input_282 = input_282.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_282,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_283 = &_input.routing_profile_id;
                let input_283 = input_283.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "routing_profile_id",
                        "cannot be empty or unset",
                    )
                })?;
                let routing_profile_id = aws_smithy_http::label::fmt_string(
                    input_283,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if routing_profile_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "routing_profile_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/routing-profiles/{InstanceId}/{RoutingProfileId}/default-outbound-queue",
                    InstanceId = instance_id,
                    RoutingProfileId = routing_profile_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateRoutingProfileDefaultOutboundQueueInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_routing_profile_default_outbound_queue::ser_update_routing_profile_default_outbound_queue_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateRoutingProfileDefaultOutboundQueue::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateRoutingProfileDefaultOutboundQueue",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateRoutingProfileNameInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRoutingProfileName`](crate::operation::UpdateRoutingProfileName)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateRoutingProfileName,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateRoutingProfileNameInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_284 = &_input.instance_id;
                let input_284 = input_284.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_284,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_285 = &_input.routing_profile_id;
                let input_285 = input_285.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "routing_profile_id",
                        "cannot be empty or unset",
                    )
                })?;
                let routing_profile_id = aws_smithy_http::label::fmt_string(
                    input_285,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if routing_profile_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "routing_profile_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/routing-profiles/{InstanceId}/{RoutingProfileId}/name",
                    InstanceId = instance_id,
                    RoutingProfileId = routing_profile_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateRoutingProfileNameInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_routing_profile_name::ser_update_routing_profile_name_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateRoutingProfileName::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateRoutingProfileName",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateRoutingProfileQueuesInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRoutingProfileQueues`](crate::operation::UpdateRoutingProfileQueues)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateRoutingProfileQueues,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateRoutingProfileQueuesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_286 = &_input.instance_id;
                let input_286 = input_286.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_286,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_287 = &_input.routing_profile_id;
                let input_287 = input_287.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "routing_profile_id",
                        "cannot be empty or unset",
                    )
                })?;
                let routing_profile_id = aws_smithy_http::label::fmt_string(
                    input_287,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if routing_profile_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "routing_profile_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/routing-profiles/{InstanceId}/{RoutingProfileId}/queues",
                    InstanceId = instance_id,
                    RoutingProfileId = routing_profile_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateRoutingProfileQueuesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_routing_profile_queues::ser_update_routing_profile_queues_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateRoutingProfileQueues::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateRoutingProfileQueues",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateRuleInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRule`](crate::operation::UpdateRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateRule,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_288 = &_input.instance_id;
                let input_288 = input_288.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_288,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_289 = &_input.rule_id;
                let input_289 = input_289.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "rule_id",
                        "cannot be empty or unset",
                    )
                })?;
                let rule_id = aws_smithy_http::label::fmt_string(
                    input_289,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if rule_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "rule_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/rules/{InstanceId}/{RuleId}",
                    InstanceId = instance_id,
                    RuleId = rule_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_rule::ser_update_rule_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateRule",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateSecurityProfileInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSecurityProfile`](crate::operation::UpdateSecurityProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateSecurityProfile,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateSecurityProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_290 = &_input.instance_id;
                let input_290 = input_290.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_290,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_291 = &_input.security_profile_id;
                let input_291 = input_291.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "security_profile_id",
                        "cannot be empty or unset",
                    )
                })?;
                let security_profile_id = aws_smithy_http::label::fmt_string(
                    input_291,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if security_profile_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "security_profile_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/security-profiles/{InstanceId}/{SecurityProfileId}",
                    InstanceId = instance_id,
                    SecurityProfileId = security_profile_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateSecurityProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_security_profile::ser_update_security_profile_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateSecurityProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateSecurityProfile",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateTaskTemplateInput {
    /// Consumes the builder and constructs an Operation<[`UpdateTaskTemplate`](crate::operation::UpdateTaskTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateTaskTemplate,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateTaskTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_292 = &_input.instance_id;
                let input_292 = input_292.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_292,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_293 = &_input.task_template_id;
                let input_293 = input_293.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "task_template_id",
                        "cannot be empty or unset",
                    )
                })?;
                let task_template_id = aws_smithy_http::label::fmt_string(
                    input_293,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if task_template_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "task_template_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/instance/{InstanceId}/task/template/{TaskTemplateId}",
                    InstanceId = instance_id,
                    TaskTemplateId = task_template_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateTaskTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_task_template::ser_update_task_template_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateTaskTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateTaskTemplate",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateTrafficDistributionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateTrafficDistribution`](crate::operation::UpdateTrafficDistribution)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateTrafficDistribution,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateTrafficDistributionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_294 = &_input.id;
                let input_294 = input_294.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "id",
                        "cannot be empty or unset",
                    )
                })?;
                let id = aws_smithy_http::label::fmt_string(
                    input_294,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/traffic-distribution/{Id}", Id = id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateTrafficDistributionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_traffic_distribution::ser_update_traffic_distribution_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateTrafficDistribution::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateTrafficDistribution",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateUserHierarchyInput {
    /// Consumes the builder and constructs an Operation<[`UpdateUserHierarchy`](crate::operation::UpdateUserHierarchy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateUserHierarchy,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateUserHierarchyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_295 = &_input.instance_id;
                let input_295 = input_295.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_295,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_296 = &_input.user_id;
                let input_296 = input_296.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "user_id",
                        "cannot be empty or unset",
                    )
                })?;
                let user_id = aws_smithy_http::label::fmt_string(
                    input_296,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if user_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "user_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/users/{InstanceId}/{UserId}/hierarchy",
                    InstanceId = instance_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateUserHierarchyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_user_hierarchy::ser_update_user_hierarchy_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateUserHierarchy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateUserHierarchy",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateUserHierarchyGroupNameInput {
    /// Consumes the builder and constructs an Operation<[`UpdateUserHierarchyGroupName`](crate::operation::UpdateUserHierarchyGroupName)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateUserHierarchyGroupName,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateUserHierarchyGroupNameInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_297 = &_input.instance_id;
                let input_297 = input_297.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_297,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_298 = &_input.hierarchy_group_id;
                let input_298 = input_298.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "hierarchy_group_id",
                        "cannot be empty or unset",
                    )
                })?;
                let hierarchy_group_id = aws_smithy_http::label::fmt_string(
                    input_298,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if hierarchy_group_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "hierarchy_group_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/user-hierarchy-groups/{InstanceId}/{HierarchyGroupId}/name",
                    InstanceId = instance_id,
                    HierarchyGroupId = hierarchy_group_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateUserHierarchyGroupNameInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_user_hierarchy_group_name::ser_update_user_hierarchy_group_name_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateUserHierarchyGroupName::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateUserHierarchyGroupName",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateUserHierarchyStructureInput {
    /// Consumes the builder and constructs an Operation<[`UpdateUserHierarchyStructure`](crate::operation::UpdateUserHierarchyStructure)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateUserHierarchyStructure,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateUserHierarchyStructureInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_299 = &_input.instance_id;
                let input_299 = input_299.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_299,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/user-hierarchy-structure/{InstanceId}",
                    InstanceId = instance_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateUserHierarchyStructureInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_user_hierarchy_structure::ser_update_user_hierarchy_structure_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateUserHierarchyStructure::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateUserHierarchyStructure",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateUserIdentityInfoInput {
    /// Consumes the builder and constructs an Operation<[`UpdateUserIdentityInfo`](crate::operation::UpdateUserIdentityInfo)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateUserIdentityInfo,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateUserIdentityInfoInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_300 = &_input.instance_id;
                let input_300 = input_300.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_300,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_301 = &_input.user_id;
                let input_301 = input_301.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "user_id",
                        "cannot be empty or unset",
                    )
                })?;
                let user_id = aws_smithy_http::label::fmt_string(
                    input_301,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if user_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "user_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/users/{InstanceId}/{UserId}/identity-info",
                    InstanceId = instance_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateUserIdentityInfoInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_user_identity_info::ser_update_user_identity_info_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateUserIdentityInfo::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateUserIdentityInfo",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateUserPhoneConfigInput {
    /// Consumes the builder and constructs an Operation<[`UpdateUserPhoneConfig`](crate::operation::UpdateUserPhoneConfig)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateUserPhoneConfig,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateUserPhoneConfigInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_302 = &_input.instance_id;
                let input_302 = input_302.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_302,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_303 = &_input.user_id;
                let input_303 = input_303.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "user_id",
                        "cannot be empty or unset",
                    )
                })?;
                let user_id = aws_smithy_http::label::fmt_string(
                    input_303,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if user_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "user_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/users/{InstanceId}/{UserId}/phone-config",
                    InstanceId = instance_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateUserPhoneConfigInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_user_phone_config::ser_update_user_phone_config_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateUserPhoneConfig::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateUserPhoneConfig",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateUserRoutingProfileInput {
    /// Consumes the builder and constructs an Operation<[`UpdateUserRoutingProfile`](crate::operation::UpdateUserRoutingProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateUserRoutingProfile,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateUserRoutingProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_304 = &_input.instance_id;
                let input_304 = input_304.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_304,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_305 = &_input.user_id;
                let input_305 = input_305.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "user_id",
                        "cannot be empty or unset",
                    )
                })?;
                let user_id = aws_smithy_http::label::fmt_string(
                    input_305,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if user_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "user_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/users/{InstanceId}/{UserId}/routing-profile",
                    InstanceId = instance_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateUserRoutingProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_user_routing_profile::ser_update_user_routing_profile_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateUserRoutingProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateUserRoutingProfile",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateUserSecurityProfilesInput {
    /// Consumes the builder and constructs an Operation<[`UpdateUserSecurityProfiles`](crate::operation::UpdateUserSecurityProfiles)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateUserSecurityProfiles,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateUserSecurityProfilesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_306 = &_input.instance_id;
                let input_306 = input_306.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "instance_id",
                        "cannot be empty or unset",
                    )
                })?;
                let instance_id = aws_smithy_http::label::fmt_string(
                    input_306,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if instance_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "instance_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_307 = &_input.user_id;
                let input_307 = input_307.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "user_id",
                        "cannot be empty or unset",
                    )
                })?;
                let user_id = aws_smithy_http::label::fmt_string(
                    input_307,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if user_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "user_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/users/{InstanceId}/{UserId}/security-profiles",
                    InstanceId = instance_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateUserSecurityProfilesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_user_security_profiles::ser_update_user_security_profiles_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateUserSecurityProfiles::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateUserSecurityProfiles",
            "connect",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateUserSecurityProfilesInput {
    /// <p>The identifiers of the security profiles for the user.</p>
    #[doc(hidden)]
    pub security_profile_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The identifier of the user account.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl UpdateUserSecurityProfilesInput {
    /// <p>The identifiers of the security profiles for the user.</p>
    pub fn security_profile_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_profile_ids.as_deref()
    }
    /// <p>The identifier of the user account.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl UpdateUserSecurityProfilesInput {
    /// Creates a new builder-style object to manufacture [`UpdateUserSecurityProfilesInput`](crate::input::UpdateUserSecurityProfilesInput).
    pub fn builder() -> crate::input::update_user_security_profiles_input::Builder {
        crate::input::update_user_security_profiles_input::Builder::default()
    }
}

/// See [`UpdateUserSecurityProfilesInput`](crate::input::UpdateUserSecurityProfilesInput).
pub mod update_user_security_profiles_input {

    /// A builder for [`UpdateUserSecurityProfilesInput`](crate::input::UpdateUserSecurityProfilesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_profile_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `security_profile_ids`.
        ///
        /// To override the contents of this collection use [`set_security_profile_ids`](Self::set_security_profile_ids).
        ///
        /// <p>The identifiers of the security profiles for the user.</p>
        pub fn security_profile_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_profile_ids.unwrap_or_default();
            v.push(input.into());
            self.security_profile_ids = Some(v);
            self
        }
        /// <p>The identifiers of the security profiles for the user.</p>
        pub fn set_security_profile_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_profile_ids = input;
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateUserSecurityProfilesInput`](crate::input::UpdateUserSecurityProfilesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateUserSecurityProfilesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateUserSecurityProfilesInput {
                security_profile_ids: self.security_profile_ids,
                user_id: self.user_id,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateUserRoutingProfileInput {
    /// <p>The identifier of the routing profile for the user.</p>
    #[doc(hidden)]
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the user account.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl UpdateUserRoutingProfileInput {
    /// <p>The identifier of the routing profile for the user.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The identifier of the user account.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl UpdateUserRoutingProfileInput {
    /// Creates a new builder-style object to manufacture [`UpdateUserRoutingProfileInput`](crate::input::UpdateUserRoutingProfileInput).
    pub fn builder() -> crate::input::update_user_routing_profile_input::Builder {
        crate::input::update_user_routing_profile_input::Builder::default()
    }
}

/// See [`UpdateUserRoutingProfileInput`](crate::input::UpdateUserRoutingProfileInput).
pub mod update_user_routing_profile_input {

    /// A builder for [`UpdateUserRoutingProfileInput`](crate::input::UpdateUserRoutingProfileInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the routing profile for the user.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile for the user.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateUserRoutingProfileInput`](crate::input::UpdateUserRoutingProfileInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateUserRoutingProfileInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateUserRoutingProfileInput {
                routing_profile_id: self.routing_profile_id,
                user_id: self.user_id,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateUserPhoneConfigInput {
    /// <p>Information about phone configuration settings for the user.</p>
    #[doc(hidden)]
    pub phone_config: std::option::Option<crate::model::UserPhoneConfig>,
    /// <p>The identifier of the user account.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl UpdateUserPhoneConfigInput {
    /// <p>Information about phone configuration settings for the user.</p>
    pub fn phone_config(&self) -> std::option::Option<&crate::model::UserPhoneConfig> {
        self.phone_config.as_ref()
    }
    /// <p>The identifier of the user account.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl UpdateUserPhoneConfigInput {
    /// Creates a new builder-style object to manufacture [`UpdateUserPhoneConfigInput`](crate::input::UpdateUserPhoneConfigInput).
    pub fn builder() -> crate::input::update_user_phone_config_input::Builder {
        crate::input::update_user_phone_config_input::Builder::default()
    }
}

/// See [`UpdateUserPhoneConfigInput`](crate::input::UpdateUserPhoneConfigInput).
pub mod update_user_phone_config_input {

    /// A builder for [`UpdateUserPhoneConfigInput`](crate::input::UpdateUserPhoneConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_config: std::option::Option<crate::model::UserPhoneConfig>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Information about phone configuration settings for the user.</p>
        pub fn phone_config(mut self, input: crate::model::UserPhoneConfig) -> Self {
            self.phone_config = Some(input);
            self
        }
        /// <p>Information about phone configuration settings for the user.</p>
        pub fn set_phone_config(
            mut self,
            input: std::option::Option<crate::model::UserPhoneConfig>,
        ) -> Self {
            self.phone_config = input;
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateUserPhoneConfigInput`](crate::input::UpdateUserPhoneConfigInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateUserPhoneConfigInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateUserPhoneConfigInput {
                phone_config: self.phone_config,
                user_id: self.user_id,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateUserIdentityInfoInput {
    /// <p>The identity information for the user.</p>
    #[doc(hidden)]
    pub identity_info: std::option::Option<crate::model::UserIdentityInfo>,
    /// <p>The identifier of the user account.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl UpdateUserIdentityInfoInput {
    /// <p>The identity information for the user.</p>
    pub fn identity_info(&self) -> std::option::Option<&crate::model::UserIdentityInfo> {
        self.identity_info.as_ref()
    }
    /// <p>The identifier of the user account.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl UpdateUserIdentityInfoInput {
    /// Creates a new builder-style object to manufacture [`UpdateUserIdentityInfoInput`](crate::input::UpdateUserIdentityInfoInput).
    pub fn builder() -> crate::input::update_user_identity_info_input::Builder {
        crate::input::update_user_identity_info_input::Builder::default()
    }
}

/// See [`UpdateUserIdentityInfoInput`](crate::input::UpdateUserIdentityInfoInput).
pub mod update_user_identity_info_input {

    /// A builder for [`UpdateUserIdentityInfoInput`](crate::input::UpdateUserIdentityInfoInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_info: std::option::Option<crate::model::UserIdentityInfo>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identity information for the user.</p>
        pub fn identity_info(mut self, input: crate::model::UserIdentityInfo) -> Self {
            self.identity_info = Some(input);
            self
        }
        /// <p>The identity information for the user.</p>
        pub fn set_identity_info(
            mut self,
            input: std::option::Option<crate::model::UserIdentityInfo>,
        ) -> Self {
            self.identity_info = input;
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateUserIdentityInfoInput`](crate::input::UpdateUserIdentityInfoInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateUserIdentityInfoInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateUserIdentityInfoInput {
                identity_info: self.identity_info,
                user_id: self.user_id,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateUserHierarchyStructureInput {
    /// <p>The hierarchy levels to update.</p>
    #[doc(hidden)]
    pub hierarchy_structure: std::option::Option<crate::model::HierarchyStructureUpdate>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl UpdateUserHierarchyStructureInput {
    /// <p>The hierarchy levels to update.</p>
    pub fn hierarchy_structure(
        &self,
    ) -> std::option::Option<&crate::model::HierarchyStructureUpdate> {
        self.hierarchy_structure.as_ref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl UpdateUserHierarchyStructureInput {
    /// Creates a new builder-style object to manufacture [`UpdateUserHierarchyStructureInput`](crate::input::UpdateUserHierarchyStructureInput).
    pub fn builder() -> crate::input::update_user_hierarchy_structure_input::Builder {
        crate::input::update_user_hierarchy_structure_input::Builder::default()
    }
}

/// See [`UpdateUserHierarchyStructureInput`](crate::input::UpdateUserHierarchyStructureInput).
pub mod update_user_hierarchy_structure_input {

    /// A builder for [`UpdateUserHierarchyStructureInput`](crate::input::UpdateUserHierarchyStructureInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hierarchy_structure: std::option::Option<crate::model::HierarchyStructureUpdate>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The hierarchy levels to update.</p>
        pub fn hierarchy_structure(
            mut self,
            input: crate::model::HierarchyStructureUpdate,
        ) -> Self {
            self.hierarchy_structure = Some(input);
            self
        }
        /// <p>The hierarchy levels to update.</p>
        pub fn set_hierarchy_structure(
            mut self,
            input: std::option::Option<crate::model::HierarchyStructureUpdate>,
        ) -> Self {
            self.hierarchy_structure = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateUserHierarchyStructureInput`](crate::input::UpdateUserHierarchyStructureInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateUserHierarchyStructureInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateUserHierarchyStructureInput {
                hierarchy_structure: self.hierarchy_structure,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateUserHierarchyGroupNameInput {
    /// <p>The name of the hierarchy group. Must not be more than 100 characters.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier of the hierarchy group.</p>
    #[doc(hidden)]
    pub hierarchy_group_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl UpdateUserHierarchyGroupNameInput {
    /// <p>The name of the hierarchy group. Must not be more than 100 characters.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier of the hierarchy group.</p>
    pub fn hierarchy_group_id(&self) -> std::option::Option<&str> {
        self.hierarchy_group_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl UpdateUserHierarchyGroupNameInput {
    /// Creates a new builder-style object to manufacture [`UpdateUserHierarchyGroupNameInput`](crate::input::UpdateUserHierarchyGroupNameInput).
    pub fn builder() -> crate::input::update_user_hierarchy_group_name_input::Builder {
        crate::input::update_user_hierarchy_group_name_input::Builder::default()
    }
}

/// See [`UpdateUserHierarchyGroupNameInput`](crate::input::UpdateUserHierarchyGroupNameInput).
pub mod update_user_hierarchy_group_name_input {

    /// A builder for [`UpdateUserHierarchyGroupNameInput`](crate::input::UpdateUserHierarchyGroupNameInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) hierarchy_group_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the hierarchy group. Must not be more than 100 characters.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hierarchy group. Must not be more than 100 characters.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The identifier of the hierarchy group.</p>
        pub fn hierarchy_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the hierarchy group.</p>
        pub fn set_hierarchy_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hierarchy_group_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateUserHierarchyGroupNameInput`](crate::input::UpdateUserHierarchyGroupNameInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateUserHierarchyGroupNameInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateUserHierarchyGroupNameInput {
                name: self.name,
                hierarchy_group_id: self.hierarchy_group_id,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateUserHierarchyInput {
    /// <p>The identifier of the hierarchy group.</p>
    #[doc(hidden)]
    pub hierarchy_group_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the user account.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl UpdateUserHierarchyInput {
    /// <p>The identifier of the hierarchy group.</p>
    pub fn hierarchy_group_id(&self) -> std::option::Option<&str> {
        self.hierarchy_group_id.as_deref()
    }
    /// <p>The identifier of the user account.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl UpdateUserHierarchyInput {
    /// Creates a new builder-style object to manufacture [`UpdateUserHierarchyInput`](crate::input::UpdateUserHierarchyInput).
    pub fn builder() -> crate::input::update_user_hierarchy_input::Builder {
        crate::input::update_user_hierarchy_input::Builder::default()
    }
}

/// See [`UpdateUserHierarchyInput`](crate::input::UpdateUserHierarchyInput).
pub mod update_user_hierarchy_input {

    /// A builder for [`UpdateUserHierarchyInput`](crate::input::UpdateUserHierarchyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hierarchy_group_id: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the hierarchy group.</p>
        pub fn hierarchy_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the hierarchy group.</p>
        pub fn set_hierarchy_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hierarchy_group_id = input;
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateUserHierarchyInput`](crate::input::UpdateUserHierarchyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateUserHierarchyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateUserHierarchyInput {
                hierarchy_group_id: self.hierarchy_group_id,
                user_id: self.user_id,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateTrafficDistributionInput {
    /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The distribution of traffic between the instance and its replica(s).</p>
    #[doc(hidden)]
    pub telephony_config: std::option::Option<crate::model::TelephonyConfig>,
}
impl UpdateTrafficDistributionInput {
    /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The distribution of traffic between the instance and its replica(s).</p>
    pub fn telephony_config(&self) -> std::option::Option<&crate::model::TelephonyConfig> {
        self.telephony_config.as_ref()
    }
}
impl UpdateTrafficDistributionInput {
    /// Creates a new builder-style object to manufacture [`UpdateTrafficDistributionInput`](crate::input::UpdateTrafficDistributionInput).
    pub fn builder() -> crate::input::update_traffic_distribution_input::Builder {
        crate::input::update_traffic_distribution_input::Builder::default()
    }
}

/// See [`UpdateTrafficDistributionInput`](crate::input::UpdateTrafficDistributionInput).
pub mod update_traffic_distribution_input {

    /// A builder for [`UpdateTrafficDistributionInput`](crate::input::UpdateTrafficDistributionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) telephony_config: std::option::Option<crate::model::TelephonyConfig>,
    }
    impl Builder {
        /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The distribution of traffic between the instance and its replica(s).</p>
        pub fn telephony_config(mut self, input: crate::model::TelephonyConfig) -> Self {
            self.telephony_config = Some(input);
            self
        }
        /// <p>The distribution of traffic between the instance and its replica(s).</p>
        pub fn set_telephony_config(
            mut self,
            input: std::option::Option<crate::model::TelephonyConfig>,
        ) -> Self {
            self.telephony_config = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateTrafficDistributionInput`](crate::input::UpdateTrafficDistributionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateTrafficDistributionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateTrafficDistributionInput {
                id: self.id,
                telephony_config: self.telephony_config,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateTaskTemplateInput {
    /// <p>A unique identifier for the task template.</p>
    #[doc(hidden)]
    pub task_template_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the task template.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the task template.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow that runs by default when a task is created by referencing this template.</p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
    /// <p>Constraints that are applicable to the fields listed.</p>
    #[doc(hidden)]
    pub constraints: std::option::Option<crate::model::TaskTemplateConstraints>,
    /// <p>The default values for fields when a task is created by referencing this template.</p>
    #[doc(hidden)]
    pub defaults: std::option::Option<crate::model::TaskTemplateDefaults>,
    /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TaskTemplateStatus>,
    /// <p>Fields that are part of the template.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::TaskTemplateField>>,
}
impl UpdateTaskTemplateInput {
    /// <p>A unique identifier for the task template.</p>
    pub fn task_template_id(&self) -> std::option::Option<&str> {
        self.task_template_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the task template.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the task template.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The identifier of the flow that runs by default when a task is created by referencing this template.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
    /// <p>Constraints that are applicable to the fields listed.</p>
    pub fn constraints(&self) -> std::option::Option<&crate::model::TaskTemplateConstraints> {
        self.constraints.as_ref()
    }
    /// <p>The default values for fields when a task is created by referencing this template.</p>
    pub fn defaults(&self) -> std::option::Option<&crate::model::TaskTemplateDefaults> {
        self.defaults.as_ref()
    }
    /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TaskTemplateStatus> {
        self.status.as_ref()
    }
    /// <p>Fields that are part of the template.</p>
    pub fn fields(&self) -> std::option::Option<&[crate::model::TaskTemplateField]> {
        self.fields.as_deref()
    }
}
impl UpdateTaskTemplateInput {
    /// Creates a new builder-style object to manufacture [`UpdateTaskTemplateInput`](crate::input::UpdateTaskTemplateInput).
    pub fn builder() -> crate::input::update_task_template_input::Builder {
        crate::input::update_task_template_input::Builder::default()
    }
}

/// See [`UpdateTaskTemplateInput`](crate::input::UpdateTaskTemplateInput).
pub mod update_task_template_input {

    /// A builder for [`UpdateTaskTemplateInput`](crate::input::UpdateTaskTemplateInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_template_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
        pub(crate) constraints: std::option::Option<crate::model::TaskTemplateConstraints>,
        pub(crate) defaults: std::option::Option<crate::model::TaskTemplateDefaults>,
        pub(crate) status: std::option::Option<crate::model::TaskTemplateStatus>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::TaskTemplateField>>,
    }
    impl Builder {
        /// <p>A unique identifier for the task template.</p>
        pub fn task_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_template_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the task template.</p>
        pub fn set_task_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_template_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the task template.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the task template.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the task template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the task template.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The identifier of the flow that runs by default when a task is created by referencing this template.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow that runs by default when a task is created by referencing this template.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// <p>Constraints that are applicable to the fields listed.</p>
        pub fn constraints(mut self, input: crate::model::TaskTemplateConstraints) -> Self {
            self.constraints = Some(input);
            self
        }
        /// <p>Constraints that are applicable to the fields listed.</p>
        pub fn set_constraints(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateConstraints>,
        ) -> Self {
            self.constraints = input;
            self
        }
        /// <p>The default values for fields when a task is created by referencing this template.</p>
        pub fn defaults(mut self, input: crate::model::TaskTemplateDefaults) -> Self {
            self.defaults = Some(input);
            self
        }
        /// <p>The default values for fields when a task is created by referencing this template.</p>
        pub fn set_defaults(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateDefaults>,
        ) -> Self {
            self.defaults = input;
            self
        }
        /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
        pub fn status(mut self, input: crate::model::TaskTemplateStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>Fields that are part of the template.</p>
        pub fn fields(mut self, input: crate::model::TaskTemplateField) -> Self {
            let mut v = self.fields.unwrap_or_default();
            v.push(input);
            self.fields = Some(v);
            self
        }
        /// <p>Fields that are part of the template.</p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TaskTemplateField>>,
        ) -> Self {
            self.fields = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateTaskTemplateInput`](crate::input::UpdateTaskTemplateInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateTaskTemplateInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateTaskTemplateInput {
                task_template_id: self.task_template_id,
                instance_id: self.instance_id,
                name: self.name,
                description: self.description,
                contact_flow_id: self.contact_flow_id,
                constraints: self.constraints,
                defaults: self.defaults,
                status: self.status,
                fields: self.fields,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateSecurityProfileInput {
    /// <p>The description of the security profile.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The permissions granted to a security profile. For a list of valid permissions, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html">List of security profile permissions</a>.</p>
    #[doc(hidden)]
    pub permissions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The identifier for the security profle.</p>
    #[doc(hidden)]
    pub security_profile_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The list of tags that a security profile uses to restrict access to resources in Amazon Connect.</p>
    #[doc(hidden)]
    pub allowed_access_control_tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The list of resources that a security profile applies tag restrictions to in Amazon Connect.</p>
    #[doc(hidden)]
    pub tag_restricted_resources: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UpdateSecurityProfileInput {
    /// <p>The description of the security profile.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The permissions granted to a security profile. For a list of valid permissions, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html">List of security profile permissions</a>.</p>
    pub fn permissions(&self) -> std::option::Option<&[std::string::String]> {
        self.permissions.as_deref()
    }
    /// <p>The identifier for the security profle.</p>
    pub fn security_profile_id(&self) -> std::option::Option<&str> {
        self.security_profile_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The list of tags that a security profile uses to restrict access to resources in Amazon Connect.</p>
    pub fn allowed_access_control_tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.allowed_access_control_tags.as_ref()
    }
    /// <p>The list of resources that a security profile applies tag restrictions to in Amazon Connect.</p>
    pub fn tag_restricted_resources(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_restricted_resources.as_deref()
    }
}
impl UpdateSecurityProfileInput {
    /// Creates a new builder-style object to manufacture [`UpdateSecurityProfileInput`](crate::input::UpdateSecurityProfileInput).
    pub fn builder() -> crate::input::update_security_profile_input::Builder {
        crate::input::update_security_profile_input::Builder::default()
    }
}

/// See [`UpdateSecurityProfileInput`](crate::input::UpdateSecurityProfileInput).
pub mod update_security_profile_input {

    /// A builder for [`UpdateSecurityProfileInput`](crate::input::UpdateSecurityProfileInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) permissions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_profile_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) allowed_access_control_tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) tag_restricted_resources:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The description of the security profile.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the security profile.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `permissions`.
        ///
        /// To override the contents of this collection use [`set_permissions`](Self::set_permissions).
        ///
        /// <p>The permissions granted to a security profile. For a list of valid permissions, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html">List of security profile permissions</a>.</p>
        pub fn permissions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.permissions.unwrap_or_default();
            v.push(input.into());
            self.permissions = Some(v);
            self
        }
        /// <p>The permissions granted to a security profile. For a list of valid permissions, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html">List of security profile permissions</a>.</p>
        pub fn set_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.permissions = input;
            self
        }
        /// <p>The identifier for the security profle.</p>
        pub fn security_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier for the security profle.</p>
        pub fn set_security_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Adds a key-value pair to `allowed_access_control_tags`.
        ///
        /// To override the contents of this collection use [`set_allowed_access_control_tags`](Self::set_allowed_access_control_tags).
        ///
        /// <p>The list of tags that a security profile uses to restrict access to resources in Amazon Connect.</p>
        pub fn allowed_access_control_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.allowed_access_control_tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.allowed_access_control_tags = Some(hash_map);
            self
        }
        /// <p>The list of tags that a security profile uses to restrict access to resources in Amazon Connect.</p>
        pub fn set_allowed_access_control_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.allowed_access_control_tags = input;
            self
        }
        /// Appends an item to `tag_restricted_resources`.
        ///
        /// To override the contents of this collection use [`set_tag_restricted_resources`](Self::set_tag_restricted_resources).
        ///
        /// <p>The list of resources that a security profile applies tag restrictions to in Amazon Connect.</p>
        pub fn tag_restricted_resources(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_restricted_resources.unwrap_or_default();
            v.push(input.into());
            self.tag_restricted_resources = Some(v);
            self
        }
        /// <p>The list of resources that a security profile applies tag restrictions to in Amazon Connect.</p>
        pub fn set_tag_restricted_resources(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_restricted_resources = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSecurityProfileInput`](crate::input::UpdateSecurityProfileInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateSecurityProfileInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateSecurityProfileInput {
                description: self.description,
                permissions: self.permissions,
                security_profile_id: self.security_profile_id,
                instance_id: self.instance_id,
                allowed_access_control_tags: self.allowed_access_control_tags,
                tag_restricted_resources: self.tag_restricted_resources,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateRuleInput {
    /// <p>A unique identifier for the rule.</p>
    #[doc(hidden)]
    pub rule_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the rule. You can change the name only if <code>TriggerEventSource</code> is one of the following values: <code>OnZendeskTicketCreate</code> | <code>OnZendeskTicketStatusUpdate</code> | <code>OnSalesforceCaseCreate</code> </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The conditions of the rule.</p>
    #[doc(hidden)]
    pub function: std::option::Option<std::string::String>,
    /// <p>A list of actions to be run when the rule is triggered.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::RuleAction>>,
    /// <p>The publish status of the rule.</p>
    #[doc(hidden)]
    pub publish_status: std::option::Option<crate::model::RulePublishStatus>,
}
impl UpdateRuleInput {
    /// <p>A unique identifier for the rule.</p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the rule. You can change the name only if <code>TriggerEventSource</code> is one of the following values: <code>OnZendeskTicketCreate</code> | <code>OnZendeskTicketStatusUpdate</code> | <code>OnSalesforceCaseCreate</code> </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The conditions of the rule.</p>
    pub fn function(&self) -> std::option::Option<&str> {
        self.function.as_deref()
    }
    /// <p>A list of actions to be run when the rule is triggered.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::RuleAction]> {
        self.actions.as_deref()
    }
    /// <p>The publish status of the rule.</p>
    pub fn publish_status(&self) -> std::option::Option<&crate::model::RulePublishStatus> {
        self.publish_status.as_ref()
    }
}
impl UpdateRuleInput {
    /// Creates a new builder-style object to manufacture [`UpdateRuleInput`](crate::input::UpdateRuleInput).
    pub fn builder() -> crate::input::update_rule_input::Builder {
        crate::input::update_rule_input::Builder::default()
    }
}

/// See [`UpdateRuleInput`](crate::input::UpdateRuleInput).
pub mod update_rule_input {

    /// A builder for [`UpdateRuleInput`](crate::input::UpdateRuleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) function: std::option::Option<std::string::String>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::RuleAction>>,
        pub(crate) publish_status: std::option::Option<crate::model::RulePublishStatus>,
    }
    impl Builder {
        /// <p>A unique identifier for the rule.</p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the rule.</p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the rule. You can change the name only if <code>TriggerEventSource</code> is one of the following values: <code>OnZendeskTicketCreate</code> | <code>OnZendeskTicketStatusUpdate</code> | <code>OnSalesforceCaseCreate</code> </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the rule. You can change the name only if <code>TriggerEventSource</code> is one of the following values: <code>OnZendeskTicketCreate</code> | <code>OnZendeskTicketStatusUpdate</code> | <code>OnSalesforceCaseCreate</code> </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The conditions of the rule.</p>
        pub fn function(mut self, input: impl Into<std::string::String>) -> Self {
            self.function = Some(input.into());
            self
        }
        /// <p>The conditions of the rule.</p>
        pub fn set_function(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>A list of actions to be run when the rule is triggered.</p>
        pub fn actions(mut self, input: crate::model::RuleAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>A list of actions to be run when the rule is triggered.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RuleAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// <p>The publish status of the rule.</p>
        pub fn publish_status(mut self, input: crate::model::RulePublishStatus) -> Self {
            self.publish_status = Some(input);
            self
        }
        /// <p>The publish status of the rule.</p>
        pub fn set_publish_status(
            mut self,
            input: std::option::Option<crate::model::RulePublishStatus>,
        ) -> Self {
            self.publish_status = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRuleInput`](crate::input::UpdateRuleInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateRuleInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateRuleInput {
                rule_id: self.rule_id,
                instance_id: self.instance_id,
                name: self.name,
                function: self.function,
                actions: self.actions,
                publish_status: self.publish_status,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateRoutingProfileQueuesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the routing profile.</p>
    #[doc(hidden)]
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The queues to be updated for this routing profile. Queues must first be associated to the routing profile. You can do this using AssociateRoutingProfileQueues.</p>
    #[doc(hidden)]
    pub queue_configs: std::option::Option<std::vec::Vec<crate::model::RoutingProfileQueueConfig>>,
}
impl UpdateRoutingProfileQueuesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the routing profile.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The queues to be updated for this routing profile. Queues must first be associated to the routing profile. You can do this using AssociateRoutingProfileQueues.</p>
    pub fn queue_configs(&self) -> std::option::Option<&[crate::model::RoutingProfileQueueConfig]> {
        self.queue_configs.as_deref()
    }
}
impl UpdateRoutingProfileQueuesInput {
    /// Creates a new builder-style object to manufacture [`UpdateRoutingProfileQueuesInput`](crate::input::UpdateRoutingProfileQueuesInput).
    pub fn builder() -> crate::input::update_routing_profile_queues_input::Builder {
        crate::input::update_routing_profile_queues_input::Builder::default()
    }
}

/// See [`UpdateRoutingProfileQueuesInput`](crate::input::UpdateRoutingProfileQueuesInput).
pub mod update_routing_profile_queues_input {

    /// A builder for [`UpdateRoutingProfileQueuesInput`](crate::input::UpdateRoutingProfileQueuesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) queue_configs:
            std::option::Option<std::vec::Vec<crate::model::RoutingProfileQueueConfig>>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// Appends an item to `queue_configs`.
        ///
        /// To override the contents of this collection use [`set_queue_configs`](Self::set_queue_configs).
        ///
        /// <p>The queues to be updated for this routing profile. Queues must first be associated to the routing profile. You can do this using AssociateRoutingProfileQueues.</p>
        pub fn queue_configs(mut self, input: crate::model::RoutingProfileQueueConfig) -> Self {
            let mut v = self.queue_configs.unwrap_or_default();
            v.push(input);
            self.queue_configs = Some(v);
            self
        }
        /// <p>The queues to be updated for this routing profile. Queues must first be associated to the routing profile. You can do this using AssociateRoutingProfileQueues.</p>
        pub fn set_queue_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RoutingProfileQueueConfig>>,
        ) -> Self {
            self.queue_configs = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRoutingProfileQueuesInput`](crate::input::UpdateRoutingProfileQueuesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateRoutingProfileQueuesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateRoutingProfileQueuesInput {
                instance_id: self.instance_id,
                routing_profile_id: self.routing_profile_id,
                queue_configs: self.queue_configs,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateRoutingProfileNameInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the routing profile.</p>
    #[doc(hidden)]
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The name of the routing profile. Must not be more than 127 characters.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the routing profile. Must not be more than 250 characters.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateRoutingProfileNameInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the routing profile.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The name of the routing profile. Must not be more than 127 characters.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the routing profile. Must not be more than 250 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl UpdateRoutingProfileNameInput {
    /// Creates a new builder-style object to manufacture [`UpdateRoutingProfileNameInput`](crate::input::UpdateRoutingProfileNameInput).
    pub fn builder() -> crate::input::update_routing_profile_name_input::Builder {
        crate::input::update_routing_profile_name_input::Builder::default()
    }
}

/// See [`UpdateRoutingProfileNameInput`](crate::input::UpdateRoutingProfileNameInput).
pub mod update_routing_profile_name_input {

    /// A builder for [`UpdateRoutingProfileNameInput`](crate::input::UpdateRoutingProfileNameInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// <p>The name of the routing profile. Must not be more than 127 characters.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the routing profile. Must not be more than 127 characters.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the routing profile. Must not be more than 250 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the routing profile. Must not be more than 250 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRoutingProfileNameInput`](crate::input::UpdateRoutingProfileNameInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateRoutingProfileNameInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateRoutingProfileNameInput {
                instance_id: self.instance_id,
                routing_profile_id: self.routing_profile_id,
                name: self.name,
                description: self.description,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateRoutingProfileDefaultOutboundQueueInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the routing profile.</p>
    #[doc(hidden)]
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the default outbound queue.</p>
    #[doc(hidden)]
    pub default_outbound_queue_id: std::option::Option<std::string::String>,
}
impl UpdateRoutingProfileDefaultOutboundQueueInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the routing profile.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The identifier for the default outbound queue.</p>
    pub fn default_outbound_queue_id(&self) -> std::option::Option<&str> {
        self.default_outbound_queue_id.as_deref()
    }
}
impl UpdateRoutingProfileDefaultOutboundQueueInput {
    /// Creates a new builder-style object to manufacture [`UpdateRoutingProfileDefaultOutboundQueueInput`](crate::input::UpdateRoutingProfileDefaultOutboundQueueInput).
    pub fn builder() -> crate::input::update_routing_profile_default_outbound_queue_input::Builder {
        crate::input::update_routing_profile_default_outbound_queue_input::Builder::default()
    }
}

/// See [`UpdateRoutingProfileDefaultOutboundQueueInput`](crate::input::UpdateRoutingProfileDefaultOutboundQueueInput).
pub mod update_routing_profile_default_outbound_queue_input {

    /// A builder for [`UpdateRoutingProfileDefaultOutboundQueueInput`](crate::input::UpdateRoutingProfileDefaultOutboundQueueInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) default_outbound_queue_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// <p>The identifier for the default outbound queue.</p>
        pub fn default_outbound_queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_outbound_queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the default outbound queue.</p>
        pub fn set_default_outbound_queue_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_outbound_queue_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRoutingProfileDefaultOutboundQueueInput`](crate::input::UpdateRoutingProfileDefaultOutboundQueueInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateRoutingProfileDefaultOutboundQueueInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(
                crate::input::UpdateRoutingProfileDefaultOutboundQueueInput {
                    instance_id: self.instance_id,
                    routing_profile_id: self.routing_profile_id,
                    default_outbound_queue_id: self.default_outbound_queue_id,
                },
            )
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateRoutingProfileConcurrencyInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the routing profile.</p>
    #[doc(hidden)]
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
    #[doc(hidden)]
    pub media_concurrencies: std::option::Option<std::vec::Vec<crate::model::MediaConcurrency>>,
}
impl UpdateRoutingProfileConcurrencyInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the routing profile.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
    pub fn media_concurrencies(&self) -> std::option::Option<&[crate::model::MediaConcurrency]> {
        self.media_concurrencies.as_deref()
    }
}
impl UpdateRoutingProfileConcurrencyInput {
    /// Creates a new builder-style object to manufacture [`UpdateRoutingProfileConcurrencyInput`](crate::input::UpdateRoutingProfileConcurrencyInput).
    pub fn builder() -> crate::input::update_routing_profile_concurrency_input::Builder {
        crate::input::update_routing_profile_concurrency_input::Builder::default()
    }
}

/// See [`UpdateRoutingProfileConcurrencyInput`](crate::input::UpdateRoutingProfileConcurrencyInput).
pub mod update_routing_profile_concurrency_input {

    /// A builder for [`UpdateRoutingProfileConcurrencyInput`](crate::input::UpdateRoutingProfileConcurrencyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) media_concurrencies:
            std::option::Option<std::vec::Vec<crate::model::MediaConcurrency>>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// Appends an item to `media_concurrencies`.
        ///
        /// To override the contents of this collection use [`set_media_concurrencies`](Self::set_media_concurrencies).
        ///
        /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
        pub fn media_concurrencies(mut self, input: crate::model::MediaConcurrency) -> Self {
            let mut v = self.media_concurrencies.unwrap_or_default();
            v.push(input);
            self.media_concurrencies = Some(v);
            self
        }
        /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
        pub fn set_media_concurrencies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MediaConcurrency>>,
        ) -> Self {
            self.media_concurrencies = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRoutingProfileConcurrencyInput`](crate::input::UpdateRoutingProfileConcurrencyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateRoutingProfileConcurrencyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateRoutingProfileConcurrencyInput {
                instance_id: self.instance_id,
                routing_profile_id: self.routing_profile_id,
                media_concurrencies: self.media_concurrencies,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateQuickConnectNameInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the quick connect.</p>
    #[doc(hidden)]
    pub quick_connect_id: std::option::Option<std::string::String>,
    /// <p>The name of the quick connect.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the quick connect.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateQuickConnectNameInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the quick connect.</p>
    pub fn quick_connect_id(&self) -> std::option::Option<&str> {
        self.quick_connect_id.as_deref()
    }
    /// <p>The name of the quick connect.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the quick connect.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl UpdateQuickConnectNameInput {
    /// Creates a new builder-style object to manufacture [`UpdateQuickConnectNameInput`](crate::input::UpdateQuickConnectNameInput).
    pub fn builder() -> crate::input::update_quick_connect_name_input::Builder {
        crate::input::update_quick_connect_name_input::Builder::default()
    }
}

/// See [`UpdateQuickConnectNameInput`](crate::input::UpdateQuickConnectNameInput).
pub mod update_quick_connect_name_input {

    /// A builder for [`UpdateQuickConnectNameInput`](crate::input::UpdateQuickConnectNameInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) quick_connect_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn quick_connect_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.quick_connect_id = Some(input.into());
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn set_quick_connect_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.quick_connect_id = input;
            self
        }
        /// <p>The name of the quick connect.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the quick connect.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the quick connect.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the quick connect.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateQuickConnectNameInput`](crate::input::UpdateQuickConnectNameInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateQuickConnectNameInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateQuickConnectNameInput {
                instance_id: self.instance_id,
                quick_connect_id: self.quick_connect_id,
                name: self.name,
                description: self.description,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateQuickConnectConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the quick connect.</p>
    #[doc(hidden)]
    pub quick_connect_id: std::option::Option<std::string::String>,
    /// <p>Information about the configuration settings for the quick connect.</p>
    #[doc(hidden)]
    pub quick_connect_config: std::option::Option<crate::model::QuickConnectConfig>,
}
impl UpdateQuickConnectConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the quick connect.</p>
    pub fn quick_connect_id(&self) -> std::option::Option<&str> {
        self.quick_connect_id.as_deref()
    }
    /// <p>Information about the configuration settings for the quick connect.</p>
    pub fn quick_connect_config(&self) -> std::option::Option<&crate::model::QuickConnectConfig> {
        self.quick_connect_config.as_ref()
    }
}
impl UpdateQuickConnectConfigInput {
    /// Creates a new builder-style object to manufacture [`UpdateQuickConnectConfigInput`](crate::input::UpdateQuickConnectConfigInput).
    pub fn builder() -> crate::input::update_quick_connect_config_input::Builder {
        crate::input::update_quick_connect_config_input::Builder::default()
    }
}

/// See [`UpdateQuickConnectConfigInput`](crate::input::UpdateQuickConnectConfigInput).
pub mod update_quick_connect_config_input {

    /// A builder for [`UpdateQuickConnectConfigInput`](crate::input::UpdateQuickConnectConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) quick_connect_id: std::option::Option<std::string::String>,
        pub(crate) quick_connect_config: std::option::Option<crate::model::QuickConnectConfig>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn quick_connect_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.quick_connect_id = Some(input.into());
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn set_quick_connect_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.quick_connect_id = input;
            self
        }
        /// <p>Information about the configuration settings for the quick connect.</p>
        pub fn quick_connect_config(mut self, input: crate::model::QuickConnectConfig) -> Self {
            self.quick_connect_config = Some(input);
            self
        }
        /// <p>Information about the configuration settings for the quick connect.</p>
        pub fn set_quick_connect_config(
            mut self,
            input: std::option::Option<crate::model::QuickConnectConfig>,
        ) -> Self {
            self.quick_connect_config = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateQuickConnectConfigInput`](crate::input::UpdateQuickConnectConfigInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateQuickConnectConfigInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateQuickConnectConfigInput {
                instance_id: self.instance_id,
                quick_connect_id: self.quick_connect_id,
                quick_connect_config: self.quick_connect_config,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateQueueStatusInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The status of the queue.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::QueueStatus>,
}
impl UpdateQueueStatusInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The status of the queue.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::QueueStatus> {
        self.status.as_ref()
    }
}
impl UpdateQueueStatusInput {
    /// Creates a new builder-style object to manufacture [`UpdateQueueStatusInput`](crate::input::UpdateQueueStatusInput).
    pub fn builder() -> crate::input::update_queue_status_input::Builder {
        crate::input::update_queue_status_input::Builder::default()
    }
}

/// See [`UpdateQueueStatusInput`](crate::input::UpdateQueueStatusInput).
pub mod update_queue_status_input {

    /// A builder for [`UpdateQueueStatusInput`](crate::input::UpdateQueueStatusInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::QueueStatus>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The status of the queue.</p>
        pub fn status(mut self, input: crate::model::QueueStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the queue.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::QueueStatus>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateQueueStatusInput`](crate::input::UpdateQueueStatusInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateQueueStatusInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateQueueStatusInput {
                instance_id: self.instance_id,
                queue_id: self.queue_id,
                status: self.status,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateQueueOutboundCallerConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
    #[doc(hidden)]
    pub outbound_caller_config: std::option::Option<crate::model::OutboundCallerConfig>,
}
impl UpdateQueueOutboundCallerConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
    pub fn outbound_caller_config(
        &self,
    ) -> std::option::Option<&crate::model::OutboundCallerConfig> {
        self.outbound_caller_config.as_ref()
    }
}
impl UpdateQueueOutboundCallerConfigInput {
    /// Creates a new builder-style object to manufacture [`UpdateQueueOutboundCallerConfigInput`](crate::input::UpdateQueueOutboundCallerConfigInput).
    pub fn builder() -> crate::input::update_queue_outbound_caller_config_input::Builder {
        crate::input::update_queue_outbound_caller_config_input::Builder::default()
    }
}

/// See [`UpdateQueueOutboundCallerConfigInput`](crate::input::UpdateQueueOutboundCallerConfigInput).
pub mod update_queue_outbound_caller_config_input {

    /// A builder for [`UpdateQueueOutboundCallerConfigInput`](crate::input::UpdateQueueOutboundCallerConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) outbound_caller_config: std::option::Option<crate::model::OutboundCallerConfig>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
        pub fn outbound_caller_config(mut self, input: crate::model::OutboundCallerConfig) -> Self {
            self.outbound_caller_config = Some(input);
            self
        }
        /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
        pub fn set_outbound_caller_config(
            mut self,
            input: std::option::Option<crate::model::OutboundCallerConfig>,
        ) -> Self {
            self.outbound_caller_config = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateQueueOutboundCallerConfigInput`](crate::input::UpdateQueueOutboundCallerConfigInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateQueueOutboundCallerConfigInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateQueueOutboundCallerConfigInput {
                instance_id: self.instance_id,
                queue_id: self.queue_id,
                outbound_caller_config: self.outbound_caller_config,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateQueueNameInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The name of the queue.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the queue.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateQueueNameInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The name of the queue.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the queue.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl UpdateQueueNameInput {
    /// Creates a new builder-style object to manufacture [`UpdateQueueNameInput`](crate::input::UpdateQueueNameInput).
    pub fn builder() -> crate::input::update_queue_name_input::Builder {
        crate::input::update_queue_name_input::Builder::default()
    }
}

/// See [`UpdateQueueNameInput`](crate::input::UpdateQueueNameInput).
pub mod update_queue_name_input {

    /// A builder for [`UpdateQueueNameInput`](crate::input::UpdateQueueNameInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The name of the queue.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the queue.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the queue.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the queue.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateQueueNameInput`](crate::input::UpdateQueueNameInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateQueueNameInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateQueueNameInput {
                instance_id: self.instance_id,
                queue_id: self.queue_id,
                name: self.name,
                description: self.description,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateQueueMaxContactsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
    #[doc(hidden)]
    pub max_contacts: std::option::Option<i32>,
}
impl UpdateQueueMaxContactsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
    pub fn max_contacts(&self) -> std::option::Option<i32> {
        self.max_contacts
    }
}
impl UpdateQueueMaxContactsInput {
    /// Creates a new builder-style object to manufacture [`UpdateQueueMaxContactsInput`](crate::input::UpdateQueueMaxContactsInput).
    pub fn builder() -> crate::input::update_queue_max_contacts_input::Builder {
        crate::input::update_queue_max_contacts_input::Builder::default()
    }
}

/// See [`UpdateQueueMaxContactsInput`](crate::input::UpdateQueueMaxContactsInput).
pub mod update_queue_max_contacts_input {

    /// A builder for [`UpdateQueueMaxContactsInput`](crate::input::UpdateQueueMaxContactsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) max_contacts: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
        pub fn max_contacts(mut self, input: i32) -> Self {
            self.max_contacts = Some(input);
            self
        }
        /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
        pub fn set_max_contacts(mut self, input: std::option::Option<i32>) -> Self {
            self.max_contacts = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateQueueMaxContactsInput`](crate::input::UpdateQueueMaxContactsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateQueueMaxContactsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateQueueMaxContactsInput {
                instance_id: self.instance_id,
                queue_id: self.queue_id,
                max_contacts: self.max_contacts,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateQueueHoursOfOperationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the hours of operation.</p>
    #[doc(hidden)]
    pub hours_of_operation_id: std::option::Option<std::string::String>,
}
impl UpdateQueueHoursOfOperationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The identifier for the hours of operation.</p>
    pub fn hours_of_operation_id(&self) -> std::option::Option<&str> {
        self.hours_of_operation_id.as_deref()
    }
}
impl UpdateQueueHoursOfOperationInput {
    /// Creates a new builder-style object to manufacture [`UpdateQueueHoursOfOperationInput`](crate::input::UpdateQueueHoursOfOperationInput).
    pub fn builder() -> crate::input::update_queue_hours_of_operation_input::Builder {
        crate::input::update_queue_hours_of_operation_input::Builder::default()
    }
}

/// See [`UpdateQueueHoursOfOperationInput`](crate::input::UpdateQueueHoursOfOperationInput).
pub mod update_queue_hours_of_operation_input {

    /// A builder for [`UpdateQueueHoursOfOperationInput`](crate::input::UpdateQueueHoursOfOperationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) hours_of_operation_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn hours_of_operation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hours_of_operation_id = Some(input.into());
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn set_hours_of_operation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hours_of_operation_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateQueueHoursOfOperationInput`](crate::input::UpdateQueueHoursOfOperationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateQueueHoursOfOperationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateQueueHoursOfOperationInput {
                instance_id: self.instance_id,
                queue_id: self.queue_id,
                hours_of_operation_id: self.hours_of_operation_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdatePhoneNumberInput {
    /// <p>A unique identifier for the phone number.</p>
    #[doc(hidden)]
    pub phone_number_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
    #[doc(hidden)]
    pub target_arn: std::option::Option<std::string::String>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl UpdatePhoneNumberInput {
    /// <p>A unique identifier for the phone number.</p>
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
    pub fn target_arn(&self) -> std::option::Option<&str> {
        self.target_arn.as_deref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl UpdatePhoneNumberInput {
    /// Creates a new builder-style object to manufacture [`UpdatePhoneNumberInput`](crate::input::UpdatePhoneNumberInput).
    pub fn builder() -> crate::input::update_phone_number_input::Builder {
        crate::input::update_phone_number_input::Builder::default()
    }
}

/// See [`UpdatePhoneNumberInput`](crate::input::UpdatePhoneNumberInput).
pub mod update_phone_number_input {

    /// A builder for [`UpdatePhoneNumberInput`](crate::input::UpdatePhoneNumberInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
        pub(crate) target_arn: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for the phone number.</p>
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the phone number.</p>
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdatePhoneNumberInput`](crate::input::UpdatePhoneNumberInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdatePhoneNumberInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdatePhoneNumberInput {
                phone_number_id: self.phone_number_id,
                target_arn: self.target_arn,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateParticipantRoleConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Connect channel you want to configure.</p>
    #[doc(hidden)]
    pub channel_configuration:
        std::option::Option<crate::model::UpdateParticipantRoleConfigChannelInfo>,
}
impl UpdateParticipantRoleConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The Amazon Connect channel you want to configure.</p>
    pub fn channel_configuration(
        &self,
    ) -> std::option::Option<&crate::model::UpdateParticipantRoleConfigChannelInfo> {
        self.channel_configuration.as_ref()
    }
}
impl UpdateParticipantRoleConfigInput {
    /// Creates a new builder-style object to manufacture [`UpdateParticipantRoleConfigInput`](crate::input::UpdateParticipantRoleConfigInput).
    pub fn builder() -> crate::input::update_participant_role_config_input::Builder {
        crate::input::update_participant_role_config_input::Builder::default()
    }
}

/// See [`UpdateParticipantRoleConfigInput`](crate::input::UpdateParticipantRoleConfigInput).
pub mod update_participant_role_config_input {

    /// A builder for [`UpdateParticipantRoleConfigInput`](crate::input::UpdateParticipantRoleConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) channel_configuration:
            std::option::Option<crate::model::UpdateParticipantRoleConfigChannelInfo>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The Amazon Connect channel you want to configure.</p>
        pub fn channel_configuration(
            mut self,
            input: crate::model::UpdateParticipantRoleConfigChannelInfo,
        ) -> Self {
            self.channel_configuration = Some(input);
            self
        }
        /// <p>The Amazon Connect channel you want to configure.</p>
        pub fn set_channel_configuration(
            mut self,
            input: std::option::Option<crate::model::UpdateParticipantRoleConfigChannelInfo>,
        ) -> Self {
            self.channel_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateParticipantRoleConfigInput`](crate::input::UpdateParticipantRoleConfigInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateParticipantRoleConfigInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateParticipantRoleConfigInput {
                instance_id: self.instance_id,
                contact_id: self.contact_id,
                channel_configuration: self.channel_configuration,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateInstanceStorageConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    #[doc(hidden)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>A valid resource type.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::InstanceStorageResourceType>,
    /// <p>The storage configuration for the instance.</p>
    #[doc(hidden)]
    pub storage_config: std::option::Option<crate::model::InstanceStorageConfig>,
}
impl UpdateInstanceStorageConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    pub fn association_id(&self) -> std::option::Option<&str> {
        self.association_id.as_deref()
    }
    /// <p>A valid resource type.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::InstanceStorageResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The storage configuration for the instance.</p>
    pub fn storage_config(&self) -> std::option::Option<&crate::model::InstanceStorageConfig> {
        self.storage_config.as_ref()
    }
}
impl UpdateInstanceStorageConfigInput {
    /// Creates a new builder-style object to manufacture [`UpdateInstanceStorageConfigInput`](crate::input::UpdateInstanceStorageConfigInput).
    pub fn builder() -> crate::input::update_instance_storage_config_input::Builder {
        crate::input::update_instance_storage_config_input::Builder::default()
    }
}

/// See [`UpdateInstanceStorageConfigInput`](crate::input::UpdateInstanceStorageConfigInput).
pub mod update_instance_storage_config_input {

    /// A builder for [`UpdateInstanceStorageConfigInput`](crate::input::UpdateInstanceStorageConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::InstanceStorageResourceType>,
        pub(crate) storage_config: std::option::Option<crate::model::InstanceStorageConfig>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>A valid resource type.</p>
        pub fn resource_type(mut self, input: crate::model::InstanceStorageResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>A valid resource type.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::InstanceStorageResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The storage configuration for the instance.</p>
        pub fn storage_config(mut self, input: crate::model::InstanceStorageConfig) -> Self {
            self.storage_config = Some(input);
            self
        }
        /// <p>The storage configuration for the instance.</p>
        pub fn set_storage_config(
            mut self,
            input: std::option::Option<crate::model::InstanceStorageConfig>,
        ) -> Self {
            self.storage_config = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateInstanceStorageConfigInput`](crate::input::UpdateInstanceStorageConfigInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateInstanceStorageConfigInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateInstanceStorageConfigInput {
                instance_id: self.instance_id,
                association_id: self.association_id,
                resource_type: self.resource_type,
                storage_config: self.storage_config,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateInstanceAttributeInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The type of attribute.</p> <note>
    /// <p>Only allowlisted customers can consume USE_CUSTOM_TTS_VOICES. To access this feature, contact Amazon Web Services Support for allowlisting.</p>
    /// </note>
    #[doc(hidden)]
    pub attribute_type: std::option::Option<crate::model::InstanceAttributeType>,
    /// <p>The value for the attribute. Maximum character limit is 100. </p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl UpdateInstanceAttributeInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The type of attribute.</p> <note>
    /// <p>Only allowlisted customers can consume USE_CUSTOM_TTS_VOICES. To access this feature, contact Amazon Web Services Support for allowlisting.</p>
    /// </note>
    pub fn attribute_type(&self) -> std::option::Option<&crate::model::InstanceAttributeType> {
        self.attribute_type.as_ref()
    }
    /// <p>The value for the attribute. Maximum character limit is 100. </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl UpdateInstanceAttributeInput {
    /// Creates a new builder-style object to manufacture [`UpdateInstanceAttributeInput`](crate::input::UpdateInstanceAttributeInput).
    pub fn builder() -> crate::input::update_instance_attribute_input::Builder {
        crate::input::update_instance_attribute_input::Builder::default()
    }
}

/// See [`UpdateInstanceAttributeInput`](crate::input::UpdateInstanceAttributeInput).
pub mod update_instance_attribute_input {

    /// A builder for [`UpdateInstanceAttributeInput`](crate::input::UpdateInstanceAttributeInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) attribute_type: std::option::Option<crate::model::InstanceAttributeType>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The type of attribute.</p> <note>
        /// <p>Only allowlisted customers can consume USE_CUSTOM_TTS_VOICES. To access this feature, contact Amazon Web Services Support for allowlisting.</p>
        /// </note>
        pub fn attribute_type(mut self, input: crate::model::InstanceAttributeType) -> Self {
            self.attribute_type = Some(input);
            self
        }
        /// <p>The type of attribute.</p> <note>
        /// <p>Only allowlisted customers can consume USE_CUSTOM_TTS_VOICES. To access this feature, contact Amazon Web Services Support for allowlisting.</p>
        /// </note>
        pub fn set_attribute_type(
            mut self,
            input: std::option::Option<crate::model::InstanceAttributeType>,
        ) -> Self {
            self.attribute_type = input;
            self
        }
        /// <p>The value for the attribute. Maximum character limit is 100. </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value for the attribute. Maximum character limit is 100. </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateInstanceAttributeInput`](crate::input::UpdateInstanceAttributeInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateInstanceAttributeInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateInstanceAttributeInput {
                instance_id: self.instance_id,
                attribute_type: self.attribute_type,
                value: self.value,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateHoursOfOperationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the hours of operation.</p>
    #[doc(hidden)]
    pub hours_of_operation_id: std::option::Option<std::string::String>,
    /// <p>The name of the hours of operation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the hours of operation.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The time zone of the hours of operation.</p>
    #[doc(hidden)]
    pub time_zone: std::option::Option<std::string::String>,
    /// <p>Configuration information of the hours of operation.</p>
    #[doc(hidden)]
    pub config: std::option::Option<std::vec::Vec<crate::model::HoursOfOperationConfig>>,
}
impl UpdateHoursOfOperationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the hours of operation.</p>
    pub fn hours_of_operation_id(&self) -> std::option::Option<&str> {
        self.hours_of_operation_id.as_deref()
    }
    /// <p>The name of the hours of operation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the hours of operation.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The time zone of the hours of operation.</p>
    pub fn time_zone(&self) -> std::option::Option<&str> {
        self.time_zone.as_deref()
    }
    /// <p>Configuration information of the hours of operation.</p>
    pub fn config(&self) -> std::option::Option<&[crate::model::HoursOfOperationConfig]> {
        self.config.as_deref()
    }
}
impl UpdateHoursOfOperationInput {
    /// Creates a new builder-style object to manufacture [`UpdateHoursOfOperationInput`](crate::input::UpdateHoursOfOperationInput).
    pub fn builder() -> crate::input::update_hours_of_operation_input::Builder {
        crate::input::update_hours_of_operation_input::Builder::default()
    }
}

/// See [`UpdateHoursOfOperationInput`](crate::input::UpdateHoursOfOperationInput).
pub mod update_hours_of_operation_input {

    /// A builder for [`UpdateHoursOfOperationInput`](crate::input::UpdateHoursOfOperationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) hours_of_operation_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) time_zone: std::option::Option<std::string::String>,
        pub(crate) config: std::option::Option<std::vec::Vec<crate::model::HoursOfOperationConfig>>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the hours of operation.</p>
        pub fn hours_of_operation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hours_of_operation_id = Some(input.into());
            self
        }
        /// <p>The identifier of the hours of operation.</p>
        pub fn set_hours_of_operation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hours_of_operation_id = input;
            self
        }
        /// <p>The name of the hours of operation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hours of operation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the hours of operation.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the hours of operation.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The time zone of the hours of operation.</p>
        pub fn time_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.time_zone = Some(input.into());
            self
        }
        /// <p>The time zone of the hours of operation.</p>
        pub fn set_time_zone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.time_zone = input;
            self
        }
        /// Appends an item to `config`.
        ///
        /// To override the contents of this collection use [`set_config`](Self::set_config).
        ///
        /// <p>Configuration information of the hours of operation.</p>
        pub fn config(mut self, input: crate::model::HoursOfOperationConfig) -> Self {
            let mut v = self.config.unwrap_or_default();
            v.push(input);
            self.config = Some(v);
            self
        }
        /// <p>Configuration information of the hours of operation.</p>
        pub fn set_config(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HoursOfOperationConfig>>,
        ) -> Self {
            self.config = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateHoursOfOperationInput`](crate::input::UpdateHoursOfOperationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateHoursOfOperationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateHoursOfOperationInput {
                instance_id: self.instance_id,
                hours_of_operation_id: self.hours_of_operation_id,
                name: self.name,
                description: self.description,
                time_zone: self.time_zone,
                config: self.config,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateContactScheduleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future. </p>
    #[doc(hidden)]
    pub scheduled_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl UpdateContactScheduleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the contact.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future. </p>
    pub fn scheduled_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.scheduled_time.as_ref()
    }
}
impl UpdateContactScheduleInput {
    /// Creates a new builder-style object to manufacture [`UpdateContactScheduleInput`](crate::input::UpdateContactScheduleInput).
    pub fn builder() -> crate::input::update_contact_schedule_input::Builder {
        crate::input::update_contact_schedule_input::Builder::default()
    }
}

/// See [`UpdateContactScheduleInput`](crate::input::UpdateContactScheduleInput).
pub mod update_contact_schedule_input {

    /// A builder for [`UpdateContactScheduleInput`](crate::input::UpdateContactScheduleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) scheduled_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future. </p>
        pub fn scheduled_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.scheduled_time = Some(input);
            self
        }
        /// <p>The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future. </p>
        pub fn set_scheduled_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.scheduled_time = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateContactScheduleInput`](crate::input::UpdateContactScheduleInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateContactScheduleInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateContactScheduleInput {
                instance_id: self.instance_id,
                contact_id: self.contact_id,
                scheduled_time: self.scheduled_time,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateContactFlowNameInput {
    /// <p>The identifier of the Amazon Connect instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow.</p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
    /// <p>The name of the flow.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the flow.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateContactFlowNameInput {
    /// <p>The identifier of the Amazon Connect instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the flow.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
    /// <p>The name of the flow.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the flow.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl UpdateContactFlowNameInput {
    /// Creates a new builder-style object to manufacture [`UpdateContactFlowNameInput`](crate::input::UpdateContactFlowNameInput).
    pub fn builder() -> crate::input::update_contact_flow_name_input::Builder {
        crate::input::update_contact_flow_name_input::Builder::default()
    }
}

/// See [`UpdateContactFlowNameInput`](crate::input::UpdateContactFlowNameInput).
pub mod update_contact_flow_name_input {

    /// A builder for [`UpdateContactFlowNameInput`](crate::input::UpdateContactFlowNameInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// <p>The name of the flow.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the flow.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the flow.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the flow.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateContactFlowNameInput`](crate::input::UpdateContactFlowNameInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateContactFlowNameInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateContactFlowNameInput {
                instance_id: self.instance_id,
                contact_flow_id: self.contact_flow_id,
                name: self.name,
                description: self.description,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateContactFlowModuleMetadataInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow module.</p>
    #[doc(hidden)]
    pub contact_flow_module_id: std::option::Option<std::string::String>,
    /// <p>The name of the flow module.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the flow module.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The state of flow module.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ContactFlowModuleState>,
}
impl UpdateContactFlowModuleMetadataInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the flow module.</p>
    pub fn contact_flow_module_id(&self) -> std::option::Option<&str> {
        self.contact_flow_module_id.as_deref()
    }
    /// <p>The name of the flow module.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the flow module.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The state of flow module.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ContactFlowModuleState> {
        self.state.as_ref()
    }
}
impl UpdateContactFlowModuleMetadataInput {
    /// Creates a new builder-style object to manufacture [`UpdateContactFlowModuleMetadataInput`](crate::input::UpdateContactFlowModuleMetadataInput).
    pub fn builder() -> crate::input::update_contact_flow_module_metadata_input::Builder {
        crate::input::update_contact_flow_module_metadata_input::Builder::default()
    }
}

/// See [`UpdateContactFlowModuleMetadataInput`](crate::input::UpdateContactFlowModuleMetadataInput).
pub mod update_contact_flow_module_metadata_input {

    /// A builder for [`UpdateContactFlowModuleMetadataInput`](crate::input::UpdateContactFlowModuleMetadataInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_module_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ContactFlowModuleState>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the flow module.</p>
        pub fn contact_flow_module_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_module_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow module.</p>
        pub fn set_contact_flow_module_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_module_id = input;
            self
        }
        /// <p>The name of the flow module.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the flow module.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the flow module.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the flow module.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The state of flow module.</p>
        pub fn state(mut self, input: crate::model::ContactFlowModuleState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of flow module.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ContactFlowModuleState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateContactFlowModuleMetadataInput`](crate::input::UpdateContactFlowModuleMetadataInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateContactFlowModuleMetadataInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateContactFlowModuleMetadataInput {
                instance_id: self.instance_id,
                contact_flow_module_id: self.contact_flow_module_id,
                name: self.name,
                description: self.description,
                state: self.state,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateContactFlowModuleContentInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow module.</p>
    #[doc(hidden)]
    pub contact_flow_module_id: std::option::Option<std::string::String>,
    /// <p>The content of the flow module.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
}
impl UpdateContactFlowModuleContentInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the flow module.</p>
    pub fn contact_flow_module_id(&self) -> std::option::Option<&str> {
        self.contact_flow_module_id.as_deref()
    }
    /// <p>The content of the flow module.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
}
impl UpdateContactFlowModuleContentInput {
    /// Creates a new builder-style object to manufacture [`UpdateContactFlowModuleContentInput`](crate::input::UpdateContactFlowModuleContentInput).
    pub fn builder() -> crate::input::update_contact_flow_module_content_input::Builder {
        crate::input::update_contact_flow_module_content_input::Builder::default()
    }
}

/// See [`UpdateContactFlowModuleContentInput`](crate::input::UpdateContactFlowModuleContentInput).
pub mod update_contact_flow_module_content_input {

    /// A builder for [`UpdateContactFlowModuleContentInput`](crate::input::UpdateContactFlowModuleContentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_module_id: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the flow module.</p>
        pub fn contact_flow_module_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_module_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow module.</p>
        pub fn set_contact_flow_module_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_module_id = input;
            self
        }
        /// <p>The content of the flow module.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the flow module.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateContactFlowModuleContentInput`](crate::input::UpdateContactFlowModuleContentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateContactFlowModuleContentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateContactFlowModuleContentInput {
                instance_id: self.instance_id,
                contact_flow_module_id: self.contact_flow_module_id,
                content: self.content,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateContactFlowMetadataInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow.</p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
    /// <p>The name of the flow.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the flow.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The state of flow.</p>
    #[doc(hidden)]
    pub contact_flow_state: std::option::Option<crate::model::ContactFlowState>,
}
impl UpdateContactFlowMetadataInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the flow.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
    /// <p>The name of the flow.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the flow.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The state of flow.</p>
    pub fn contact_flow_state(&self) -> std::option::Option<&crate::model::ContactFlowState> {
        self.contact_flow_state.as_ref()
    }
}
impl UpdateContactFlowMetadataInput {
    /// Creates a new builder-style object to manufacture [`UpdateContactFlowMetadataInput`](crate::input::UpdateContactFlowMetadataInput).
    pub fn builder() -> crate::input::update_contact_flow_metadata_input::Builder {
        crate::input::update_contact_flow_metadata_input::Builder::default()
    }
}

/// See [`UpdateContactFlowMetadataInput`](crate::input::UpdateContactFlowMetadataInput).
pub mod update_contact_flow_metadata_input {

    /// A builder for [`UpdateContactFlowMetadataInput`](crate::input::UpdateContactFlowMetadataInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) contact_flow_state: std::option::Option<crate::model::ContactFlowState>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// <p>The name of the flow.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the flow.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the flow.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the flow.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The state of flow.</p>
        pub fn contact_flow_state(mut self, input: crate::model::ContactFlowState) -> Self {
            self.contact_flow_state = Some(input);
            self
        }
        /// <p>The state of flow.</p>
        pub fn set_contact_flow_state(
            mut self,
            input: std::option::Option<crate::model::ContactFlowState>,
        ) -> Self {
            self.contact_flow_state = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateContactFlowMetadataInput`](crate::input::UpdateContactFlowMetadataInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateContactFlowMetadataInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateContactFlowMetadataInput {
                instance_id: self.instance_id,
                contact_flow_id: self.contact_flow_id,
                name: self.name,
                description: self.description,
                contact_flow_state: self.contact_flow_state,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateContactFlowContentInput {
    /// <p>The identifier of the Amazon Connect instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow.</p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
    /// <p>The JSON string that represents flow's content. For an example, see <a href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html">Example contact flow in Amazon Connect Flow language</a>. </p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
}
impl UpdateContactFlowContentInput {
    /// <p>The identifier of the Amazon Connect instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the flow.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
    /// <p>The JSON string that represents flow's content. For an example, see <a href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html">Example contact flow in Amazon Connect Flow language</a>. </p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
}
impl UpdateContactFlowContentInput {
    /// Creates a new builder-style object to manufacture [`UpdateContactFlowContentInput`](crate::input::UpdateContactFlowContentInput).
    pub fn builder() -> crate::input::update_contact_flow_content_input::Builder {
        crate::input::update_contact_flow_content_input::Builder::default()
    }
}

/// See [`UpdateContactFlowContentInput`](crate::input::UpdateContactFlowContentInput).
pub mod update_contact_flow_content_input {

    /// A builder for [`UpdateContactFlowContentInput`](crate::input::UpdateContactFlowContentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// <p>The JSON string that represents flow's content. For an example, see <a href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html">Example contact flow in Amazon Connect Flow language</a>. </p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The JSON string that represents flow's content. For an example, see <a href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html">Example contact flow in Amazon Connect Flow language</a>. </p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateContactFlowContentInput`](crate::input::UpdateContactFlowContentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateContactFlowContentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateContactFlowContentInput {
                instance_id: self.instance_id,
                contact_flow_id: self.contact_flow_id,
                content: self.content,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateContactAttributesInput {
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
    #[doc(hidden)]
    pub initial_contact_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Connect attributes. These attributes can be accessed in flows just like any other contact attributes.</p>
    /// <p>You can have up to 32,768 UTF-8 bytes across all attributes for a contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
    #[doc(hidden)]
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl UpdateContactAttributesInput {
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
    pub fn initial_contact_id(&self) -> std::option::Option<&str> {
        self.initial_contact_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The Amazon Connect attributes. These attributes can be accessed in flows just like any other contact attributes.</p>
    /// <p>You can have up to 32,768 UTF-8 bytes across all attributes for a contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
    pub fn attributes(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.attributes.as_ref()
    }
}
impl UpdateContactAttributesInput {
    /// Creates a new builder-style object to manufacture [`UpdateContactAttributesInput`](crate::input::UpdateContactAttributesInput).
    pub fn builder() -> crate::input::update_contact_attributes_input::Builder {
        crate::input::update_contact_attributes_input::Builder::default()
    }
}

/// See [`UpdateContactAttributesInput`](crate::input::UpdateContactAttributesInput).
pub mod update_contact_attributes_input {

    /// A builder for [`UpdateContactAttributesInput`](crate::input::UpdateContactAttributesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) initial_contact_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
        pub fn initial_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.initial_contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
        pub fn set_initial_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_contact_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>The Amazon Connect attributes. These attributes can be accessed in flows just like any other contact attributes.</p>
        /// <p>You can have up to 32,768 UTF-8 bytes across all attributes for a contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>The Amazon Connect attributes. These attributes can be accessed in flows just like any other contact attributes.</p>
        /// <p>You can have up to 32,768 UTF-8 bytes across all attributes for a contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateContactAttributesInput`](crate::input::UpdateContactAttributesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateContactAttributesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateContactAttributesInput {
                initial_contact_id: self.initial_contact_id,
                instance_id: self.instance_id,
                attributes: self.attributes,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateContactInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with your contact center.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The name of the contact.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the contact.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Well-formed data on contact, shown to agents on Contact Control Panel (CCP).</p>
    #[doc(hidden)]
    pub references: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::Reference>,
    >,
}
impl UpdateContactInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with your contact center.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The name of the contact.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the contact.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Well-formed data on contact, shown to agents on Contact Control Panel (CCP).</p>
    pub fn references(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, crate::model::Reference>>
    {
        self.references.as_ref()
    }
}
impl UpdateContactInput {
    /// Creates a new builder-style object to manufacture [`UpdateContactInput`](crate::input::UpdateContactInput).
    pub fn builder() -> crate::input::update_contact_input::Builder {
        crate::input::update_contact_input::Builder::default()
    }
}

/// See [`UpdateContactInput`](crate::input::UpdateContactInput).
pub mod update_contact_input {

    /// A builder for [`UpdateContactInput`](crate::input::UpdateContactInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) references: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::Reference>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with your contact center.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with your contact center.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The name of the contact.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the contact.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the contact.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the contact.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `references`.
        ///
        /// To override the contents of this collection use [`set_references`](Self::set_references).
        ///
        /// <p>Well-formed data on contact, shown to agents on Contact Control Panel (CCP).</p>
        pub fn references(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::Reference,
        ) -> Self {
            let mut hash_map = self.references.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.references = Some(hash_map);
            self
        }
        /// <p>Well-formed data on contact, shown to agents on Contact Control Panel (CCP).</p>
        pub fn set_references(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::Reference>,
            >,
        ) -> Self {
            self.references = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateContactInput`](crate::input::UpdateContactInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateContactInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateContactInput {
                instance_id: self.instance_id,
                contact_id: self.contact_id,
                name: self.name,
                description: self.description,
                references: self.references,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAgentStatusInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the agent status.</p>
    #[doc(hidden)]
    pub agent_status_id: std::option::Option<std::string::String>,
    /// <p>The name of the agent status.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the agent status.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The state of the agent status.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::AgentStatusState>,
    /// <p>The display order of the agent status.</p>
    #[doc(hidden)]
    pub display_order: std::option::Option<i32>,
    /// <p>A number indicating the reset order of the agent status.</p>
    #[doc(hidden)]
    pub reset_order_number: bool,
}
impl UpdateAgentStatusInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the agent status.</p>
    pub fn agent_status_id(&self) -> std::option::Option<&str> {
        self.agent_status_id.as_deref()
    }
    /// <p>The name of the agent status.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the agent status.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The state of the agent status.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::AgentStatusState> {
        self.state.as_ref()
    }
    /// <p>The display order of the agent status.</p>
    pub fn display_order(&self) -> std::option::Option<i32> {
        self.display_order
    }
    /// <p>A number indicating the reset order of the agent status.</p>
    pub fn reset_order_number(&self) -> bool {
        self.reset_order_number
    }
}
impl UpdateAgentStatusInput {
    /// Creates a new builder-style object to manufacture [`UpdateAgentStatusInput`](crate::input::UpdateAgentStatusInput).
    pub fn builder() -> crate::input::update_agent_status_input::Builder {
        crate::input::update_agent_status_input::Builder::default()
    }
}

/// See [`UpdateAgentStatusInput`](crate::input::UpdateAgentStatusInput).
pub mod update_agent_status_input {

    /// A builder for [`UpdateAgentStatusInput`](crate::input::UpdateAgentStatusInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) agent_status_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::AgentStatusState>,
        pub(crate) display_order: std::option::Option<i32>,
        pub(crate) reset_order_number: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the agent status.</p>
        pub fn agent_status_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_status_id = Some(input.into());
            self
        }
        /// <p>The identifier of the agent status.</p>
        pub fn set_agent_status_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.agent_status_id = input;
            self
        }
        /// <p>The name of the agent status.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the agent status.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the agent status.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the agent status.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The state of the agent status.</p>
        pub fn state(mut self, input: crate::model::AgentStatusState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the agent status.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AgentStatusState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The display order of the agent status.</p>
        pub fn display_order(mut self, input: i32) -> Self {
            self.display_order = Some(input);
            self
        }
        /// <p>The display order of the agent status.</p>
        pub fn set_display_order(mut self, input: std::option::Option<i32>) -> Self {
            self.display_order = input;
            self
        }
        /// <p>A number indicating the reset order of the agent status.</p>
        pub fn reset_order_number(mut self, input: bool) -> Self {
            self.reset_order_number = Some(input);
            self
        }
        /// <p>A number indicating the reset order of the agent status.</p>
        pub fn set_reset_order_number(mut self, input: std::option::Option<bool>) -> Self {
            self.reset_order_number = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAgentStatusInput`](crate::input::UpdateAgentStatusInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateAgentStatusInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateAgentStatusInput {
                instance_id: self.instance_id,
                agent_status_id: self.agent_status_id,
                name: self.name,
                description: self.description,
                state: self.state,
                display_order: self.display_order,
                reset_order_number: self.reset_order_number.unwrap_or_default(),
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tag keys.</p>
    #[doc(hidden)]
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The tag keys.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl UntagResourceInput {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput).
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput).
pub mod untag_resource_input {

    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>The tag keys.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>The tag keys.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UntagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransferContactInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the user.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow.</p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl TransferContactInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The identifier for the user.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The identifier of the flow.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl TransferContactInput {
    /// Creates a new builder-style object to manufacture [`TransferContactInput`](crate::input::TransferContactInput).
    pub fn builder() -> crate::input::transfer_contact_input::Builder {
        crate::input::transfer_contact_input::Builder::default()
    }
}

/// See [`TransferContactInput`](crate::input::TransferContactInput).
pub mod transfer_contact_input {

    /// A builder for [`TransferContactInput`](crate::input::TransferContactInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact in this instance of Amazon Connect. </p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The identifier for the user.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier for the user.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`TransferContactInput`](crate::input::TransferContactInput).
        pub fn build(
            self,
        ) -> Result<crate::input::TransferContactInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::TransferContactInput {
                instance_id: self.instance_id,
                contact_id: self.contact_id,
                queue_id: self.queue_id,
                user_id: self.user_id,
                contact_flow_id: self.contact_flow_id,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl TagResourceInput {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput).
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput).
pub mod tag_resource_input {

    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::TagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SuspendContactRecordingInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
    #[doc(hidden)]
    pub initial_contact_id: std::option::Option<std::string::String>,
}
impl SuspendContactRecordingInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the contact.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
    pub fn initial_contact_id(&self) -> std::option::Option<&str> {
        self.initial_contact_id.as_deref()
    }
}
impl SuspendContactRecordingInput {
    /// Creates a new builder-style object to manufacture [`SuspendContactRecordingInput`](crate::input::SuspendContactRecordingInput).
    pub fn builder() -> crate::input::suspend_contact_recording_input::Builder {
        crate::input::suspend_contact_recording_input::Builder::default()
    }
}

/// See [`SuspendContactRecordingInput`](crate::input::SuspendContactRecordingInput).
pub mod suspend_contact_recording_input {

    /// A builder for [`SuspendContactRecordingInput`](crate::input::SuspendContactRecordingInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) initial_contact_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
        pub fn initial_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.initial_contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
        pub fn set_initial_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_contact_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SuspendContactRecordingInput`](crate::input::SuspendContactRecordingInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::SuspendContactRecordingInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::SuspendContactRecordingInput {
                instance_id: self.instance_id,
                contact_id: self.contact_id,
                initial_contact_id: self.initial_contact_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StopContactStreamingInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact. This is the identifier of the contact that is associated with the first interaction with the contact center.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the streaming configuration enabled. </p>
    #[doc(hidden)]
    pub streaming_id: std::option::Option<std::string::String>,
}
impl StopContactStreamingInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the contact. This is the identifier of the contact that is associated with the first interaction with the contact center.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The identifier of the streaming configuration enabled. </p>
    pub fn streaming_id(&self) -> std::option::Option<&str> {
        self.streaming_id.as_deref()
    }
}
impl StopContactStreamingInput {
    /// Creates a new builder-style object to manufacture [`StopContactStreamingInput`](crate::input::StopContactStreamingInput).
    pub fn builder() -> crate::input::stop_contact_streaming_input::Builder {
        crate::input::stop_contact_streaming_input::Builder::default()
    }
}

/// See [`StopContactStreamingInput`](crate::input::StopContactStreamingInput).
pub mod stop_contact_streaming_input {

    /// A builder for [`StopContactStreamingInput`](crate::input::StopContactStreamingInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) streaming_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact that is associated with the first interaction with the contact center.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact that is associated with the first interaction with the contact center.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The identifier of the streaming configuration enabled. </p>
        pub fn streaming_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.streaming_id = Some(input.into());
            self
        }
        /// <p>The identifier of the streaming configuration enabled. </p>
        pub fn set_streaming_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.streaming_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopContactStreamingInput`](crate::input::StopContactStreamingInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StopContactStreamingInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StopContactStreamingInput {
                instance_id: self.instance_id,
                contact_id: self.contact_id,
                streaming_id: self.streaming_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StopContactRecordingInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
    #[doc(hidden)]
    pub initial_contact_id: std::option::Option<std::string::String>,
}
impl StopContactRecordingInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the contact.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
    pub fn initial_contact_id(&self) -> std::option::Option<&str> {
        self.initial_contact_id.as_deref()
    }
}
impl StopContactRecordingInput {
    /// Creates a new builder-style object to manufacture [`StopContactRecordingInput`](crate::input::StopContactRecordingInput).
    pub fn builder() -> crate::input::stop_contact_recording_input::Builder {
        crate::input::stop_contact_recording_input::Builder::default()
    }
}

/// See [`StopContactRecordingInput`](crate::input::StopContactRecordingInput).
pub mod stop_contact_recording_input {

    /// A builder for [`StopContactRecordingInput`](crate::input::StopContactRecordingInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) initial_contact_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
        pub fn initial_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.initial_contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
        pub fn set_initial_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_contact_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopContactRecordingInput`](crate::input::StopContactRecordingInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StopContactRecordingInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StopContactRecordingInput {
                instance_id: self.instance_id,
                contact_id: self.contact_id,
                initial_contact_id: self.initial_contact_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StopContactInput {
    /// <p>The ID of the contact.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl StopContactInput {
    /// <p>The ID of the contact.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl StopContactInput {
    /// Creates a new builder-style object to manufacture [`StopContactInput`](crate::input::StopContactInput).
    pub fn builder() -> crate::input::stop_contact_input::Builder {
        crate::input::stop_contact_input::Builder::default()
    }
}

/// See [`StopContactInput`](crate::input::StopContactInput).
pub mod stop_contact_input {

    /// A builder for [`StopContactInput`](crate::input::StopContactInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the contact.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The ID of the contact.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopContactInput`](crate::input::StopContactInput).
        pub fn build(
            self,
        ) -> Result<crate::input::StopContactInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::StopContactInput {
                contact_id: self.contact_id,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartTaskContactInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the previous chat, voice, or task contact. </p>
    #[doc(hidden)]
    pub previous_contact_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow for initiating the tasks. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p>
    /// <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
    /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes.</p>
    /// <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
    #[doc(hidden)]
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name of a task that is shown to an agent in the Contact Control Panel (CCP).</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A formatted URL that is shown to an agent in the Contact Control Panel (CCP).</p>
    #[doc(hidden)]
    pub references: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::Reference>,
    >,
    /// <p>A description of the task that is shown to an agent in the Contact Control Panel (CCP).</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future. </p>
    #[doc(hidden)]
    pub scheduled_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A unique identifier for the task template.</p>
    #[doc(hidden)]
    pub task_template_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the quick connect.</p>
    #[doc(hidden)]
    pub quick_connect_id: std::option::Option<std::string::String>,
}
impl StartTaskContactInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the previous chat, voice, or task contact. </p>
    pub fn previous_contact_id(&self) -> std::option::Option<&str> {
        self.previous_contact_id.as_deref()
    }
    /// <p>The identifier of the flow for initiating the tasks. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p>
    /// <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
    /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes.</p>
    /// <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
    pub fn attributes(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.attributes.as_ref()
    }
    /// <p>The name of a task that is shown to an agent in the Contact Control Panel (CCP).</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A formatted URL that is shown to an agent in the Contact Control Panel (CCP).</p>
    pub fn references(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, crate::model::Reference>>
    {
        self.references.as_ref()
    }
    /// <p>A description of the task that is shown to an agent in the Contact Control Panel (CCP).</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future. </p>
    pub fn scheduled_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.scheduled_time.as_ref()
    }
    /// <p>A unique identifier for the task template.</p>
    pub fn task_template_id(&self) -> std::option::Option<&str> {
        self.task_template_id.as_deref()
    }
    /// <p>The identifier for the quick connect.</p>
    pub fn quick_connect_id(&self) -> std::option::Option<&str> {
        self.quick_connect_id.as_deref()
    }
}
impl StartTaskContactInput {
    /// Creates a new builder-style object to manufacture [`StartTaskContactInput`](crate::input::StartTaskContactInput).
    pub fn builder() -> crate::input::start_task_contact_input::Builder {
        crate::input::start_task_contact_input::Builder::default()
    }
}

/// See [`StartTaskContactInput`](crate::input::StartTaskContactInput).
pub mod start_task_contact_input {

    /// A builder for [`StartTaskContactInput`](crate::input::StartTaskContactInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) previous_contact_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) references: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::Reference>,
        >,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) scheduled_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) task_template_id: std::option::Option<std::string::String>,
        pub(crate) quick_connect_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the previous chat, voice, or task contact. </p>
        pub fn previous_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.previous_contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the previous chat, voice, or task contact. </p>
        pub fn set_previous_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.previous_contact_id = input;
            self
        }
        /// <p>The identifier of the flow for initiating the tasks. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p>
        /// <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow for initiating the tasks. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p>
        /// <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes.</p>
        /// <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes.</p>
        /// <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The name of a task that is shown to an agent in the Contact Control Panel (CCP).</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a task that is shown to an agent in the Contact Control Panel (CCP).</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Adds a key-value pair to `references`.
        ///
        /// To override the contents of this collection use [`set_references`](Self::set_references).
        ///
        /// <p>A formatted URL that is shown to an agent in the Contact Control Panel (CCP).</p>
        pub fn references(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::Reference,
        ) -> Self {
            let mut hash_map = self.references.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.references = Some(hash_map);
            self
        }
        /// <p>A formatted URL that is shown to an agent in the Contact Control Panel (CCP).</p>
        pub fn set_references(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::Reference>,
            >,
        ) -> Self {
            self.references = input;
            self
        }
        /// <p>A description of the task that is shown to an agent in the Contact Control Panel (CCP).</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the task that is shown to an agent in the Contact Control Panel (CCP).</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future. </p>
        pub fn scheduled_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.scheduled_time = Some(input);
            self
        }
        /// <p>The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future. </p>
        pub fn set_scheduled_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.scheduled_time = input;
            self
        }
        /// <p>A unique identifier for the task template.</p>
        pub fn task_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_template_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the task template.</p>
        pub fn set_task_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_template_id = input;
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn quick_connect_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.quick_connect_id = Some(input.into());
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn set_quick_connect_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.quick_connect_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartTaskContactInput`](crate::input::StartTaskContactInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StartTaskContactInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StartTaskContactInput {
                instance_id: self.instance_id,
                previous_contact_id: self.previous_contact_id,
                contact_flow_id: self.contact_flow_id,
                attributes: self.attributes,
                name: self.name,
                references: self.references,
                description: self.description,
                client_token: self.client_token,
                scheduled_time: self.scheduled_time,
                task_template_id: self.task_template_id,
                quick_connect_id: self.quick_connect_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartOutboundVoiceContactInput {
    /// <p>The phone number of the customer, in E.164 format.</p>
    #[doc(hidden)]
    pub destination_phone_number: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow for the outbound call. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p>
    /// <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>. The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned. </p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.</p>
    #[doc(hidden)]
    pub source_phone_number: std::option::Option<std::string::String>,
    /// <p>The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the flow is used. If you do not specify a queue, you must specify a source phone number.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes.</p>
    /// <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
    #[doc(hidden)]
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Configuration of the answering machine detection for this outbound call. </p>
    #[doc(hidden)]
    pub answer_machine_detection_config:
        std::option::Option<crate::model::AnswerMachineDetectionConfig>,
    /// <p>The campaign identifier of the outbound communication.</p>
    #[doc(hidden)]
    pub campaign_id: std::option::Option<std::string::String>,
    /// <p>Denotes the class of traffic. Calls with different traffic types are handled differently by Amazon Connect. The default value is <code>GENERAL</code>. Use <code>CAMPAIGN</code> if <code>EnableAnswerMachineDetection</code> is set to <code>true</code>. For all other cases, use <code>GENERAL</code>. </p>
    #[doc(hidden)]
    pub traffic_type: std::option::Option<crate::model::TrafficType>,
}
impl StartOutboundVoiceContactInput {
    /// <p>The phone number of the customer, in E.164 format.</p>
    pub fn destination_phone_number(&self) -> std::option::Option<&str> {
        self.destination_phone_number.as_deref()
    }
    /// <p>The identifier of the flow for the outbound call. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p>
    /// <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>. The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned. </p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.</p>
    pub fn source_phone_number(&self) -> std::option::Option<&str> {
        self.source_phone_number.as_deref()
    }
    /// <p>The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the flow is used. If you do not specify a queue, you must specify a source phone number.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes.</p>
    /// <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
    pub fn attributes(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.attributes.as_ref()
    }
    /// <p>Configuration of the answering machine detection for this outbound call. </p>
    pub fn answer_machine_detection_config(
        &self,
    ) -> std::option::Option<&crate::model::AnswerMachineDetectionConfig> {
        self.answer_machine_detection_config.as_ref()
    }
    /// <p>The campaign identifier of the outbound communication.</p>
    pub fn campaign_id(&self) -> std::option::Option<&str> {
        self.campaign_id.as_deref()
    }
    /// <p>Denotes the class of traffic. Calls with different traffic types are handled differently by Amazon Connect. The default value is <code>GENERAL</code>. Use <code>CAMPAIGN</code> if <code>EnableAnswerMachineDetection</code> is set to <code>true</code>. For all other cases, use <code>GENERAL</code>. </p>
    pub fn traffic_type(&self) -> std::option::Option<&crate::model::TrafficType> {
        self.traffic_type.as_ref()
    }
}
impl StartOutboundVoiceContactInput {
    /// Creates a new builder-style object to manufacture [`StartOutboundVoiceContactInput`](crate::input::StartOutboundVoiceContactInput).
    pub fn builder() -> crate::input::start_outbound_voice_contact_input::Builder {
        crate::input::start_outbound_voice_contact_input::Builder::default()
    }
}

/// See [`StartOutboundVoiceContactInput`](crate::input::StartOutboundVoiceContactInput).
pub mod start_outbound_voice_contact_input {

    /// A builder for [`StartOutboundVoiceContactInput`](crate::input::StartOutboundVoiceContactInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_phone_number: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) source_phone_number: std::option::Option<std::string::String>,
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) answer_machine_detection_config:
            std::option::Option<crate::model::AnswerMachineDetectionConfig>,
        pub(crate) campaign_id: std::option::Option<std::string::String>,
        pub(crate) traffic_type: std::option::Option<crate::model::TrafficType>,
    }
    impl Builder {
        /// <p>The phone number of the customer, in E.164 format.</p>
        pub fn destination_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_phone_number = Some(input.into());
            self
        }
        /// <p>The phone number of the customer, in E.164 format.</p>
        pub fn set_destination_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_phone_number = input;
            self
        }
        /// <p>The identifier of the flow for the outbound call. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p>
        /// <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow for the outbound call. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p>
        /// <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>. The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned. </p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>. The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned. </p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.</p>
        pub fn source_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_phone_number = Some(input.into());
            self
        }
        /// <p>The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.</p>
        pub fn set_source_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_phone_number = input;
            self
        }
        /// <p>The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the flow is used. If you do not specify a queue, you must specify a source phone number.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the flow is used. If you do not specify a queue, you must specify a source phone number.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes.</p>
        /// <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes.</p>
        /// <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>Configuration of the answering machine detection for this outbound call. </p>
        pub fn answer_machine_detection_config(
            mut self,
            input: crate::model::AnswerMachineDetectionConfig,
        ) -> Self {
            self.answer_machine_detection_config = Some(input);
            self
        }
        /// <p>Configuration of the answering machine detection for this outbound call. </p>
        pub fn set_answer_machine_detection_config(
            mut self,
            input: std::option::Option<crate::model::AnswerMachineDetectionConfig>,
        ) -> Self {
            self.answer_machine_detection_config = input;
            self
        }
        /// <p>The campaign identifier of the outbound communication.</p>
        pub fn campaign_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.campaign_id = Some(input.into());
            self
        }
        /// <p>The campaign identifier of the outbound communication.</p>
        pub fn set_campaign_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.campaign_id = input;
            self
        }
        /// <p>Denotes the class of traffic. Calls with different traffic types are handled differently by Amazon Connect. The default value is <code>GENERAL</code>. Use <code>CAMPAIGN</code> if <code>EnableAnswerMachineDetection</code> is set to <code>true</code>. For all other cases, use <code>GENERAL</code>. </p>
        pub fn traffic_type(mut self, input: crate::model::TrafficType) -> Self {
            self.traffic_type = Some(input);
            self
        }
        /// <p>Denotes the class of traffic. Calls with different traffic types are handled differently by Amazon Connect. The default value is <code>GENERAL</code>. Use <code>CAMPAIGN</code> if <code>EnableAnswerMachineDetection</code> is set to <code>true</code>. For all other cases, use <code>GENERAL</code>. </p>
        pub fn set_traffic_type(
            mut self,
            input: std::option::Option<crate::model::TrafficType>,
        ) -> Self {
            self.traffic_type = input;
            self
        }
        /// Consumes the builder and constructs a [`StartOutboundVoiceContactInput`](crate::input::StartOutboundVoiceContactInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StartOutboundVoiceContactInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StartOutboundVoiceContactInput {
                destination_phone_number: self.destination_phone_number,
                contact_flow_id: self.contact_flow_id,
                instance_id: self.instance_id,
                client_token: self.client_token,
                source_phone_number: self.source_phone_number,
                queue_id: self.queue_id,
                attributes: self.attributes,
                answer_machine_detection_config: self.answer_machine_detection_config,
                campaign_id: self.campaign_id,
                traffic_type: self.traffic_type,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartContactStreamingInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The streaming configuration, such as the Amazon SNS streaming endpoint.</p>
    #[doc(hidden)]
    pub chat_streaming_configuration: std::option::Option<crate::model::ChatStreamingConfiguration>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl StartContactStreamingInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The streaming configuration, such as the Amazon SNS streaming endpoint.</p>
    pub fn chat_streaming_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ChatStreamingConfiguration> {
        self.chat_streaming_configuration.as_ref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl StartContactStreamingInput {
    /// Creates a new builder-style object to manufacture [`StartContactStreamingInput`](crate::input::StartContactStreamingInput).
    pub fn builder() -> crate::input::start_contact_streaming_input::Builder {
        crate::input::start_contact_streaming_input::Builder::default()
    }
}

/// See [`StartContactStreamingInput`](crate::input::StartContactStreamingInput).
pub mod start_contact_streaming_input {

    /// A builder for [`StartContactStreamingInput`](crate::input::StartContactStreamingInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) chat_streaming_configuration:
            std::option::Option<crate::model::ChatStreamingConfiguration>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The streaming configuration, such as the Amazon SNS streaming endpoint.</p>
        pub fn chat_streaming_configuration(
            mut self,
            input: crate::model::ChatStreamingConfiguration,
        ) -> Self {
            self.chat_streaming_configuration = Some(input);
            self
        }
        /// <p>The streaming configuration, such as the Amazon SNS streaming endpoint.</p>
        pub fn set_chat_streaming_configuration(
            mut self,
            input: std::option::Option<crate::model::ChatStreamingConfiguration>,
        ) -> Self {
            self.chat_streaming_configuration = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`StartContactStreamingInput`](crate::input::StartContactStreamingInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StartContactStreamingInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StartContactStreamingInput {
                instance_id: self.instance_id,
                contact_id: self.contact_id,
                chat_streaming_configuration: self.chat_streaming_configuration,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartContactRecordingInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
    #[doc(hidden)]
    pub initial_contact_id: std::option::Option<std::string::String>,
    /// <p>The person being recorded.</p>
    #[doc(hidden)]
    pub voice_recording_configuration:
        std::option::Option<crate::model::VoiceRecordingConfiguration>,
}
impl StartContactRecordingInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the contact.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
    pub fn initial_contact_id(&self) -> std::option::Option<&str> {
        self.initial_contact_id.as_deref()
    }
    /// <p>The person being recorded.</p>
    pub fn voice_recording_configuration(
        &self,
    ) -> std::option::Option<&crate::model::VoiceRecordingConfiguration> {
        self.voice_recording_configuration.as_ref()
    }
}
impl StartContactRecordingInput {
    /// Creates a new builder-style object to manufacture [`StartContactRecordingInput`](crate::input::StartContactRecordingInput).
    pub fn builder() -> crate::input::start_contact_recording_input::Builder {
        crate::input::start_contact_recording_input::Builder::default()
    }
}

/// See [`StartContactRecordingInput`](crate::input::StartContactRecordingInput).
pub mod start_contact_recording_input {

    /// A builder for [`StartContactRecordingInput`](crate::input::StartContactRecordingInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) initial_contact_id: std::option::Option<std::string::String>,
        pub(crate) voice_recording_configuration:
            std::option::Option<crate::model::VoiceRecordingConfiguration>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
        pub fn initial_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.initial_contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
        pub fn set_initial_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_contact_id = input;
            self
        }
        /// <p>The person being recorded.</p>
        pub fn voice_recording_configuration(
            mut self,
            input: crate::model::VoiceRecordingConfiguration,
        ) -> Self {
            self.voice_recording_configuration = Some(input);
            self
        }
        /// <p>The person being recorded.</p>
        pub fn set_voice_recording_configuration(
            mut self,
            input: std::option::Option<crate::model::VoiceRecordingConfiguration>,
        ) -> Self {
            self.voice_recording_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`StartContactRecordingInput`](crate::input::StartContactRecordingInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StartContactRecordingInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StartContactRecordingInput {
                instance_id: self.instance_id,
                contact_id: self.contact_id,
                initial_contact_id: self.initial_contact_id,
                voice_recording_configuration: self.voice_recording_configuration,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartChatContactInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow for initiating the chat. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p>
    /// <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
    /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows just like any other contact attributes. </p>
    /// <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
    #[doc(hidden)]
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Information identifying the participant.</p>
    #[doc(hidden)]
    pub participant_details: std::option::Option<crate::model::ParticipantDetails>,
    /// <p>The initial message to be sent to the newly created chat.</p>
    #[doc(hidden)]
    pub initial_message: std::option::Option<crate::model::ChatMessage>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The total duration of the newly started chat session. If not specified, the chat session duration defaults to 25 hour. The minumum configurable time is 60 minutes. The maximum configurable time is 10,080 minutes (7 days).</p>
    #[doc(hidden)]
    pub chat_duration_in_minutes: std::option::Option<i32>,
    /// <p>The supported chat message content types. Content types must always contain <code>text/plain</code>. You can then put any other supported type in the list. For example, all the following lists are valid because they contain <code>text/plain</code>: <code>[text/plain, text/markdown, application/json]</code>, <code>[text/markdown, text/plain]</code>, <code>[text/plain, application/json]</code>.</p>
    #[doc(hidden)]
    pub supported_messaging_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Enable persistent chats. For more information about enabling persistent chat, and for example use cases and how to configure for them, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html">Enable persistent chat</a>.</p>
    #[doc(hidden)]
    pub persistent_chat: std::option::Option<crate::model::PersistentChat>,
}
impl StartChatContactInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the flow for initiating the chat. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p>
    /// <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
    /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows just like any other contact attributes. </p>
    /// <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
    pub fn attributes(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.attributes.as_ref()
    }
    /// <p>Information identifying the participant.</p>
    pub fn participant_details(&self) -> std::option::Option<&crate::model::ParticipantDetails> {
        self.participant_details.as_ref()
    }
    /// <p>The initial message to be sent to the newly created chat.</p>
    pub fn initial_message(&self) -> std::option::Option<&crate::model::ChatMessage> {
        self.initial_message.as_ref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The total duration of the newly started chat session. If not specified, the chat session duration defaults to 25 hour. The minumum configurable time is 60 minutes. The maximum configurable time is 10,080 minutes (7 days).</p>
    pub fn chat_duration_in_minutes(&self) -> std::option::Option<i32> {
        self.chat_duration_in_minutes
    }
    /// <p>The supported chat message content types. Content types must always contain <code>text/plain</code>. You can then put any other supported type in the list. For example, all the following lists are valid because they contain <code>text/plain</code>: <code>[text/plain, text/markdown, application/json]</code>, <code>[text/markdown, text/plain]</code>, <code>[text/plain, application/json]</code>.</p>
    pub fn supported_messaging_content_types(&self) -> std::option::Option<&[std::string::String]> {
        self.supported_messaging_content_types.as_deref()
    }
    /// <p>Enable persistent chats. For more information about enabling persistent chat, and for example use cases and how to configure for them, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html">Enable persistent chat</a>.</p>
    pub fn persistent_chat(&self) -> std::option::Option<&crate::model::PersistentChat> {
        self.persistent_chat.as_ref()
    }
}
impl StartChatContactInput {
    /// Creates a new builder-style object to manufacture [`StartChatContactInput`](crate::input::StartChatContactInput).
    pub fn builder() -> crate::input::start_chat_contact_input::Builder {
        crate::input::start_chat_contact_input::Builder::default()
    }
}

/// See [`StartChatContactInput`](crate::input::StartChatContactInput).
pub mod start_chat_contact_input {

    /// A builder for [`StartChatContactInput`](crate::input::StartChatContactInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) participant_details: std::option::Option<crate::model::ParticipantDetails>,
        pub(crate) initial_message: std::option::Option<crate::model::ChatMessage>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) chat_duration_in_minutes: std::option::Option<i32>,
        pub(crate) supported_messaging_content_types:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) persistent_chat: std::option::Option<crate::model::PersistentChat>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the flow for initiating the chat. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p>
        /// <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow for initiating the chat. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p>
        /// <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows just like any other contact attributes. </p>
        /// <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows just like any other contact attributes. </p>
        /// <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>Information identifying the participant.</p>
        pub fn participant_details(mut self, input: crate::model::ParticipantDetails) -> Self {
            self.participant_details = Some(input);
            self
        }
        /// <p>Information identifying the participant.</p>
        pub fn set_participant_details(
            mut self,
            input: std::option::Option<crate::model::ParticipantDetails>,
        ) -> Self {
            self.participant_details = input;
            self
        }
        /// <p>The initial message to be sent to the newly created chat.</p>
        pub fn initial_message(mut self, input: crate::model::ChatMessage) -> Self {
            self.initial_message = Some(input);
            self
        }
        /// <p>The initial message to be sent to the newly created chat.</p>
        pub fn set_initial_message(
            mut self,
            input: std::option::Option<crate::model::ChatMessage>,
        ) -> Self {
            self.initial_message = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>The total duration of the newly started chat session. If not specified, the chat session duration defaults to 25 hour. The minumum configurable time is 60 minutes. The maximum configurable time is 10,080 minutes (7 days).</p>
        pub fn chat_duration_in_minutes(mut self, input: i32) -> Self {
            self.chat_duration_in_minutes = Some(input);
            self
        }
        /// <p>The total duration of the newly started chat session. If not specified, the chat session duration defaults to 25 hour. The minumum configurable time is 60 minutes. The maximum configurable time is 10,080 minutes (7 days).</p>
        pub fn set_chat_duration_in_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.chat_duration_in_minutes = input;
            self
        }
        /// Appends an item to `supported_messaging_content_types`.
        ///
        /// To override the contents of this collection use [`set_supported_messaging_content_types`](Self::set_supported_messaging_content_types).
        ///
        /// <p>The supported chat message content types. Content types must always contain <code>text/plain</code>. You can then put any other supported type in the list. For example, all the following lists are valid because they contain <code>text/plain</code>: <code>[text/plain, text/markdown, application/json]</code>, <code>[text/markdown, text/plain]</code>, <code>[text/plain, application/json]</code>.</p>
        pub fn supported_messaging_content_types(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.supported_messaging_content_types.unwrap_or_default();
            v.push(input.into());
            self.supported_messaging_content_types = Some(v);
            self
        }
        /// <p>The supported chat message content types. Content types must always contain <code>text/plain</code>. You can then put any other supported type in the list. For example, all the following lists are valid because they contain <code>text/plain</code>: <code>[text/plain, text/markdown, application/json]</code>, <code>[text/markdown, text/plain]</code>, <code>[text/plain, application/json]</code>.</p>
        pub fn set_supported_messaging_content_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.supported_messaging_content_types = input;
            self
        }
        /// <p>Enable persistent chats. For more information about enabling persistent chat, and for example use cases and how to configure for them, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html">Enable persistent chat</a>.</p>
        pub fn persistent_chat(mut self, input: crate::model::PersistentChat) -> Self {
            self.persistent_chat = Some(input);
            self
        }
        /// <p>Enable persistent chats. For more information about enabling persistent chat, and for example use cases and how to configure for them, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html">Enable persistent chat</a>.</p>
        pub fn set_persistent_chat(
            mut self,
            input: std::option::Option<crate::model::PersistentChat>,
        ) -> Self {
            self.persistent_chat = input;
            self
        }
        /// Consumes the builder and constructs a [`StartChatContactInput`](crate::input::StartChatContactInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StartChatContactInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StartChatContactInput {
                instance_id: self.instance_id,
                contact_flow_id: self.contact_flow_id,
                attributes: self.attributes,
                participant_details: self.participant_details,
                initial_message: self.initial_message,
                client_token: self.client_token,
                chat_duration_in_minutes: self.chat_duration_in_minutes,
                supported_messaging_content_types: self.supported_messaging_content_types,
                persistent_chat: self.persistent_chat,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SearchVocabulariesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: i32,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The current state of the custom vocabulary.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::VocabularyState>,
    /// <p>The starting pattern of the name of the vocabulary.</p>
    #[doc(hidden)]
    pub name_starts_with: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
}
impl SearchVocabulariesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The current state of the custom vocabulary.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::VocabularyState> {
        self.state.as_ref()
    }
    /// <p>The starting pattern of the name of the vocabulary.</p>
    pub fn name_starts_with(&self) -> std::option::Option<&str> {
        self.name_starts_with.as_deref()
    }
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::VocabularyLanguageCode> {
        self.language_code.as_ref()
    }
}
impl SearchVocabulariesInput {
    /// Creates a new builder-style object to manufacture [`SearchVocabulariesInput`](crate::input::SearchVocabulariesInput).
    pub fn builder() -> crate::input::search_vocabularies_input::Builder {
        crate::input::search_vocabularies_input::Builder::default()
    }
}

/// See [`SearchVocabulariesInput`](crate::input::SearchVocabulariesInput).
pub mod search_vocabularies_input {

    /// A builder for [`SearchVocabulariesInput`](crate::input::SearchVocabulariesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::VocabularyState>,
        pub(crate) name_starts_with: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The current state of the custom vocabulary.</p>
        pub fn state(mut self, input: crate::model::VocabularyState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the custom vocabulary.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The starting pattern of the name of the vocabulary.</p>
        pub fn name_starts_with(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_starts_with = Some(input.into());
            self
        }
        /// <p>The starting pattern of the name of the vocabulary.</p>
        pub fn set_name_starts_with(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.name_starts_with = input;
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn language_code(mut self, input: crate::model::VocabularyLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::VocabularyLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchVocabulariesInput`](crate::input::SearchVocabulariesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::SearchVocabulariesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::SearchVocabulariesInput {
                instance_id: self.instance_id,
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
                state: self.state,
                name_starts_with: self.name_starts_with,
                language_code: self.language_code,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SearchUsersInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Filters to be applied to search results.</p>
    #[doc(hidden)]
    pub search_filter: std::option::Option<crate::model::UserSearchFilter>,
    /// <p>The search criteria to be used to return users.</p> <note>
    /// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
    /// </note>
    #[doc(hidden)]
    pub search_criteria: std::option::Option<crate::model::UserSearchCriteria>,
}
impl SearchUsersInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Filters to be applied to search results.</p>
    pub fn search_filter(&self) -> std::option::Option<&crate::model::UserSearchFilter> {
        self.search_filter.as_ref()
    }
    /// <p>The search criteria to be used to return users.</p> <note>
    /// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
    /// </note>
    pub fn search_criteria(&self) -> std::option::Option<&crate::model::UserSearchCriteria> {
        self.search_criteria.as_ref()
    }
}
impl SearchUsersInput {
    /// Creates a new builder-style object to manufacture [`SearchUsersInput`](crate::input::SearchUsersInput).
    pub fn builder() -> crate::input::search_users_input::Builder {
        crate::input::search_users_input::Builder::default()
    }
}

/// See [`SearchUsersInput`](crate::input::SearchUsersInput).
pub mod search_users_input {

    /// A builder for [`SearchUsersInput`](crate::input::SearchUsersInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) search_filter: std::option::Option<crate::model::UserSearchFilter>,
        pub(crate) search_criteria: std::option::Option<crate::model::UserSearchCriteria>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Filters to be applied to search results.</p>
        pub fn search_filter(mut self, input: crate::model::UserSearchFilter) -> Self {
            self.search_filter = Some(input);
            self
        }
        /// <p>Filters to be applied to search results.</p>
        pub fn set_search_filter(
            mut self,
            input: std::option::Option<crate::model::UserSearchFilter>,
        ) -> Self {
            self.search_filter = input;
            self
        }
        /// <p>The search criteria to be used to return users.</p> <note>
        /// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
        /// </note>
        pub fn search_criteria(mut self, input: crate::model::UserSearchCriteria) -> Self {
            self.search_criteria = Some(input);
            self
        }
        /// <p>The search criteria to be used to return users.</p> <note>
        /// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
        /// </note>
        pub fn set_search_criteria(
            mut self,
            input: std::option::Option<crate::model::UserSearchCriteria>,
        ) -> Self {
            self.search_criteria = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchUsersInput`](crate::input::SearchUsersInput).
        pub fn build(
            self,
        ) -> Result<crate::input::SearchUsersInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::SearchUsersInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
                search_filter: self.search_filter,
                search_criteria: self.search_criteria,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SearchSecurityProfilesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The search criteria to be used to return security profiles. </p> <note>
    /// <p>The <code>name</code> field support "contains" queries with a minimum of 2 characters and maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.</p>
    /// </note> <note>
    /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
    /// </note>
    #[doc(hidden)]
    pub search_criteria: std::option::Option<crate::model::SecurityProfileSearchCriteria>,
    /// <p>Filters to be applied to search results.</p>
    #[doc(hidden)]
    pub search_filter: std::option::Option<crate::model::SecurityProfilesSearchFilter>,
}
impl SearchSecurityProfilesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The search criteria to be used to return security profiles. </p> <note>
    /// <p>The <code>name</code> field support "contains" queries with a minimum of 2 characters and maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.</p>
    /// </note> <note>
    /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
    /// </note>
    pub fn search_criteria(
        &self,
    ) -> std::option::Option<&crate::model::SecurityProfileSearchCriteria> {
        self.search_criteria.as_ref()
    }
    /// <p>Filters to be applied to search results.</p>
    pub fn search_filter(
        &self,
    ) -> std::option::Option<&crate::model::SecurityProfilesSearchFilter> {
        self.search_filter.as_ref()
    }
}
impl SearchSecurityProfilesInput {
    /// Creates a new builder-style object to manufacture [`SearchSecurityProfilesInput`](crate::input::SearchSecurityProfilesInput).
    pub fn builder() -> crate::input::search_security_profiles_input::Builder {
        crate::input::search_security_profiles_input::Builder::default()
    }
}

/// See [`SearchSecurityProfilesInput`](crate::input::SearchSecurityProfilesInput).
pub mod search_security_profiles_input {

    /// A builder for [`SearchSecurityProfilesInput`](crate::input::SearchSecurityProfilesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) search_criteria:
            std::option::Option<crate::model::SecurityProfileSearchCriteria>,
        pub(crate) search_filter: std::option::Option<crate::model::SecurityProfilesSearchFilter>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The search criteria to be used to return security profiles. </p> <note>
        /// <p>The <code>name</code> field support "contains" queries with a minimum of 2 characters and maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.</p>
        /// </note> <note>
        /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
        /// </note>
        pub fn search_criteria(
            mut self,
            input: crate::model::SecurityProfileSearchCriteria,
        ) -> Self {
            self.search_criteria = Some(input);
            self
        }
        /// <p>The search criteria to be used to return security profiles. </p> <note>
        /// <p>The <code>name</code> field support "contains" queries with a minimum of 2 characters and maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.</p>
        /// </note> <note>
        /// <p>The currently supported value for <code>FieldName</code>: <code>name</code> </p>
        /// </note>
        pub fn set_search_criteria(
            mut self,
            input: std::option::Option<crate::model::SecurityProfileSearchCriteria>,
        ) -> Self {
            self.search_criteria = input;
            self
        }
        /// <p>Filters to be applied to search results.</p>
        pub fn search_filter(mut self, input: crate::model::SecurityProfilesSearchFilter) -> Self {
            self.search_filter = Some(input);
            self
        }
        /// <p>Filters to be applied to search results.</p>
        pub fn set_search_filter(
            mut self,
            input: std::option::Option<crate::model::SecurityProfilesSearchFilter>,
        ) -> Self {
            self.search_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchSecurityProfilesInput`](crate::input::SearchSecurityProfilesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::SearchSecurityProfilesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::SearchSecurityProfilesInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
                search_criteria: self.search_criteria,
                search_filter: self.search_filter,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SearchRoutingProfilesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Filters to be applied to search results.</p>
    #[doc(hidden)]
    pub search_filter: std::option::Option<crate::model::RoutingProfileSearchFilter>,
    /// <p>The search criteria to be used to return routing profiles.</p> <note>
    /// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
    /// </note>
    #[doc(hidden)]
    pub search_criteria: std::option::Option<crate::model::RoutingProfileSearchCriteria>,
}
impl SearchRoutingProfilesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Filters to be applied to search results.</p>
    pub fn search_filter(&self) -> std::option::Option<&crate::model::RoutingProfileSearchFilter> {
        self.search_filter.as_ref()
    }
    /// <p>The search criteria to be used to return routing profiles.</p> <note>
    /// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
    /// </note>
    pub fn search_criteria(
        &self,
    ) -> std::option::Option<&crate::model::RoutingProfileSearchCriteria> {
        self.search_criteria.as_ref()
    }
}
impl SearchRoutingProfilesInput {
    /// Creates a new builder-style object to manufacture [`SearchRoutingProfilesInput`](crate::input::SearchRoutingProfilesInput).
    pub fn builder() -> crate::input::search_routing_profiles_input::Builder {
        crate::input::search_routing_profiles_input::Builder::default()
    }
}

/// See [`SearchRoutingProfilesInput`](crate::input::SearchRoutingProfilesInput).
pub mod search_routing_profiles_input {

    /// A builder for [`SearchRoutingProfilesInput`](crate::input::SearchRoutingProfilesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) search_filter: std::option::Option<crate::model::RoutingProfileSearchFilter>,
        pub(crate) search_criteria: std::option::Option<crate::model::RoutingProfileSearchCriteria>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Filters to be applied to search results.</p>
        pub fn search_filter(mut self, input: crate::model::RoutingProfileSearchFilter) -> Self {
            self.search_filter = Some(input);
            self
        }
        /// <p>Filters to be applied to search results.</p>
        pub fn set_search_filter(
            mut self,
            input: std::option::Option<crate::model::RoutingProfileSearchFilter>,
        ) -> Self {
            self.search_filter = input;
            self
        }
        /// <p>The search criteria to be used to return routing profiles.</p> <note>
        /// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
        /// </note>
        pub fn search_criteria(
            mut self,
            input: crate::model::RoutingProfileSearchCriteria,
        ) -> Self {
            self.search_criteria = Some(input);
            self
        }
        /// <p>The search criteria to be used to return routing profiles.</p> <note>
        /// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
        /// </note>
        pub fn set_search_criteria(
            mut self,
            input: std::option::Option<crate::model::RoutingProfileSearchCriteria>,
        ) -> Self {
            self.search_criteria = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchRoutingProfilesInput`](crate::input::SearchRoutingProfilesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::SearchRoutingProfilesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::SearchRoutingProfilesInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
                search_filter: self.search_filter,
                search_criteria: self.search_criteria,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SearchQueuesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Filters to be applied to search results.</p>
    #[doc(hidden)]
    pub search_filter: std::option::Option<crate::model::QueueSearchFilter>,
    /// <p>The search criteria to be used to return queues.</p> <note>
    /// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
    /// </note>
    #[doc(hidden)]
    pub search_criteria: std::option::Option<crate::model::QueueSearchCriteria>,
}
impl SearchQueuesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Filters to be applied to search results.</p>
    pub fn search_filter(&self) -> std::option::Option<&crate::model::QueueSearchFilter> {
        self.search_filter.as_ref()
    }
    /// <p>The search criteria to be used to return queues.</p> <note>
    /// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
    /// </note>
    pub fn search_criteria(&self) -> std::option::Option<&crate::model::QueueSearchCriteria> {
        self.search_criteria.as_ref()
    }
}
impl SearchQueuesInput {
    /// Creates a new builder-style object to manufacture [`SearchQueuesInput`](crate::input::SearchQueuesInput).
    pub fn builder() -> crate::input::search_queues_input::Builder {
        crate::input::search_queues_input::Builder::default()
    }
}

/// See [`SearchQueuesInput`](crate::input::SearchQueuesInput).
pub mod search_queues_input {

    /// A builder for [`SearchQueuesInput`](crate::input::SearchQueuesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) search_filter: std::option::Option<crate::model::QueueSearchFilter>,
        pub(crate) search_criteria: std::option::Option<crate::model::QueueSearchCriteria>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Filters to be applied to search results.</p>
        pub fn search_filter(mut self, input: crate::model::QueueSearchFilter) -> Self {
            self.search_filter = Some(input);
            self
        }
        /// <p>Filters to be applied to search results.</p>
        pub fn set_search_filter(
            mut self,
            input: std::option::Option<crate::model::QueueSearchFilter>,
        ) -> Self {
            self.search_filter = input;
            self
        }
        /// <p>The search criteria to be used to return queues.</p> <note>
        /// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
        /// </note>
        pub fn search_criteria(mut self, input: crate::model::QueueSearchCriteria) -> Self {
            self.search_criteria = Some(input);
            self
        }
        /// <p>The search criteria to be used to return queues.</p> <note>
        /// <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p>
        /// </note>
        pub fn set_search_criteria(
            mut self,
            input: std::option::Option<crate::model::QueueSearchCriteria>,
        ) -> Self {
            self.search_criteria = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchQueuesInput`](crate::input::SearchQueuesInput).
        pub fn build(
            self,
        ) -> Result<crate::input::SearchQueuesInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::SearchQueuesInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
                search_filter: self.search_filter,
                search_criteria: self.search_criteria,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SearchAvailablePhoneNumbersInput {
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
    #[doc(hidden)]
    pub target_arn: std::option::Option<std::string::String>,
    /// <p>The ISO country code.</p>
    #[doc(hidden)]
    pub phone_number_country_code: std::option::Option<crate::model::PhoneNumberCountryCode>,
    /// <p>The type of phone number.</p>
    #[doc(hidden)]
    pub phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
    /// <p>The prefix of the phone number. If provided, it must contain <code>+</code> as part of the country code.</p>
    #[doc(hidden)]
    pub phone_number_prefix: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl SearchAvailablePhoneNumbersInput {
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
    pub fn target_arn(&self) -> std::option::Option<&str> {
        self.target_arn.as_deref()
    }
    /// <p>The ISO country code.</p>
    pub fn phone_number_country_code(
        &self,
    ) -> std::option::Option<&crate::model::PhoneNumberCountryCode> {
        self.phone_number_country_code.as_ref()
    }
    /// <p>The type of phone number.</p>
    pub fn phone_number_type(&self) -> std::option::Option<&crate::model::PhoneNumberType> {
        self.phone_number_type.as_ref()
    }
    /// <p>The prefix of the phone number. If provided, it must contain <code>+</code> as part of the country code.</p>
    pub fn phone_number_prefix(&self) -> std::option::Option<&str> {
        self.phone_number_prefix.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl SearchAvailablePhoneNumbersInput {
    /// Creates a new builder-style object to manufacture [`SearchAvailablePhoneNumbersInput`](crate::input::SearchAvailablePhoneNumbersInput).
    pub fn builder() -> crate::input::search_available_phone_numbers_input::Builder {
        crate::input::search_available_phone_numbers_input::Builder::default()
    }
}

/// See [`SearchAvailablePhoneNumbersInput`](crate::input::SearchAvailablePhoneNumbersInput).
pub mod search_available_phone_numbers_input {

    /// A builder for [`SearchAvailablePhoneNumbersInput`](crate::input::SearchAvailablePhoneNumbersInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_arn: std::option::Option<std::string::String>,
        pub(crate) phone_number_country_code:
            std::option::Option<crate::model::PhoneNumberCountryCode>,
        pub(crate) phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
        pub(crate) phone_number_prefix: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// <p>The ISO country code.</p>
        pub fn phone_number_country_code(
            mut self,
            input: crate::model::PhoneNumberCountryCode,
        ) -> Self {
            self.phone_number_country_code = Some(input);
            self
        }
        /// <p>The ISO country code.</p>
        pub fn set_phone_number_country_code(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberCountryCode>,
        ) -> Self {
            self.phone_number_country_code = input;
            self
        }
        /// <p>The type of phone number.</p>
        pub fn phone_number_type(mut self, input: crate::model::PhoneNumberType) -> Self {
            self.phone_number_type = Some(input);
            self
        }
        /// <p>The type of phone number.</p>
        pub fn set_phone_number_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberType>,
        ) -> Self {
            self.phone_number_type = input;
            self
        }
        /// <p>The prefix of the phone number. If provided, it must contain <code>+</code> as part of the country code.</p>
        pub fn phone_number_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_prefix = Some(input.into());
            self
        }
        /// <p>The prefix of the phone number. If provided, it must contain <code>+</code> as part of the country code.</p>
        pub fn set_phone_number_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_prefix = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchAvailablePhoneNumbersInput`](crate::input::SearchAvailablePhoneNumbersInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::SearchAvailablePhoneNumbersInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::SearchAvailablePhoneNumbersInput {
                target_arn: self.target_arn,
                phone_number_country_code: self.phone_number_country_code,
                phone_number_type: self.phone_number_type,
                phone_number_prefix: self.phone_number_prefix,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResumeContactRecordingInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
    #[doc(hidden)]
    pub initial_contact_id: std::option::Option<std::string::String>,
}
impl ResumeContactRecordingInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the contact.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
    pub fn initial_contact_id(&self) -> std::option::Option<&str> {
        self.initial_contact_id.as_deref()
    }
}
impl ResumeContactRecordingInput {
    /// Creates a new builder-style object to manufacture [`ResumeContactRecordingInput`](crate::input::ResumeContactRecordingInput).
    pub fn builder() -> crate::input::resume_contact_recording_input::Builder {
        crate::input::resume_contact_recording_input::Builder::default()
    }
}

/// See [`ResumeContactRecordingInput`](crate::input::ResumeContactRecordingInput).
pub mod resume_contact_recording_input {

    /// A builder for [`ResumeContactRecordingInput`](crate::input::ResumeContactRecordingInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) initial_contact_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
        pub fn initial_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.initial_contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.</p>
        pub fn set_initial_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_contact_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ResumeContactRecordingInput`](crate::input::ResumeContactRecordingInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ResumeContactRecordingInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ResumeContactRecordingInput {
                instance_id: self.instance_id,
                contact_id: self.contact_id,
                initial_contact_id: self.initial_contact_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicateInstanceInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance. You can provide the <code>InstanceId</code>, or the entire ARN.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region where to replicate the Amazon Connect instance.</p>
    #[doc(hidden)]
    pub replica_region: std::option::Option<std::string::String>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The alias for the replicated instance. The <code>ReplicaAlias</code> must be unique.</p>
    #[doc(hidden)]
    pub replica_alias: std::option::Option<std::string::String>,
}
impl ReplicateInstanceInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance. You can provide the <code>InstanceId</code>, or the entire ARN.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The Amazon Web Services Region where to replicate the Amazon Connect instance.</p>
    pub fn replica_region(&self) -> std::option::Option<&str> {
        self.replica_region.as_deref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The alias for the replicated instance. The <code>ReplicaAlias</code> must be unique.</p>
    pub fn replica_alias(&self) -> std::option::Option<&str> {
        self.replica_alias.as_deref()
    }
}
impl std::fmt::Debug for ReplicateInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicateInstanceInput");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("replica_region", &self.replica_region);
        formatter.field("client_token", &self.client_token);
        formatter.field("replica_alias", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl ReplicateInstanceInput {
    /// Creates a new builder-style object to manufacture [`ReplicateInstanceInput`](crate::input::ReplicateInstanceInput).
    pub fn builder() -> crate::input::replicate_instance_input::Builder {
        crate::input::replicate_instance_input::Builder::default()
    }
}

/// See [`ReplicateInstanceInput`](crate::input::ReplicateInstanceInput).
pub mod replicate_instance_input {

    /// A builder for [`ReplicateInstanceInput`](crate::input::ReplicateInstanceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) replica_region: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) replica_alias: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance. You can provide the <code>InstanceId</code>, or the entire ARN.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance. You can provide the <code>InstanceId</code>, or the entire ARN.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The Amazon Web Services Region where to replicate the Amazon Connect instance.</p>
        pub fn replica_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.replica_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region where to replicate the Amazon Connect instance.</p>
        pub fn set_replica_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.replica_region = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>The alias for the replicated instance. The <code>ReplicaAlias</code> must be unique.</p>
        pub fn replica_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.replica_alias = Some(input.into());
            self
        }
        /// <p>The alias for the replicated instance. The <code>ReplicaAlias</code> must be unique.</p>
        pub fn set_replica_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.replica_alias = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplicateInstanceInput`](crate::input::ReplicateInstanceInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ReplicateInstanceInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ReplicateInstanceInput {
                instance_id: self.instance_id,
                replica_region: self.replica_region,
                client_token: self.client_token,
                replica_alias: self.replica_alias,
            })
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("instance_id", &self.instance_id);
            formatter.field("replica_region", &self.replica_region);
            formatter.field("client_token", &self.client_token);
            formatter.field("replica_alias", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReleasePhoneNumberInput {
    /// <p>A unique identifier for the phone number.</p>
    #[doc(hidden)]
    pub phone_number_id: std::option::Option<std::string::String>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl ReleasePhoneNumberInput {
    /// <p>A unique identifier for the phone number.</p>
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl ReleasePhoneNumberInput {
    /// Creates a new builder-style object to manufacture [`ReleasePhoneNumberInput`](crate::input::ReleasePhoneNumberInput).
    pub fn builder() -> crate::input::release_phone_number_input::Builder {
        crate::input::release_phone_number_input::Builder::default()
    }
}

/// See [`ReleasePhoneNumberInput`](crate::input::ReleasePhoneNumberInput).
pub mod release_phone_number_input {

    /// A builder for [`ReleasePhoneNumberInput`](crate::input::ReleasePhoneNumberInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for the phone number.</p>
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the phone number.</p>
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ReleasePhoneNumberInput`](crate::input::ReleasePhoneNumberInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ReleasePhoneNumberInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ReleasePhoneNumberInput {
                phone_number_id: self.phone_number_id,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutUserStatusInput {
    /// <p>The identifier of the user.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the agent status.</p>
    #[doc(hidden)]
    pub agent_status_id: std::option::Option<std::string::String>,
}
impl PutUserStatusInput {
    /// <p>The identifier of the user.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the agent status.</p>
    pub fn agent_status_id(&self) -> std::option::Option<&str> {
        self.agent_status_id.as_deref()
    }
}
impl PutUserStatusInput {
    /// Creates a new builder-style object to manufacture [`PutUserStatusInput`](crate::input::PutUserStatusInput).
    pub fn builder() -> crate::input::put_user_status_input::Builder {
        crate::input::put_user_status_input::Builder::default()
    }
}

/// See [`PutUserStatusInput`](crate::input::PutUserStatusInput).
pub mod put_user_status_input {

    /// A builder for [`PutUserStatusInput`](crate::input::PutUserStatusInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) agent_status_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the user.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the agent status.</p>
        pub fn agent_status_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_status_id = Some(input.into());
            self
        }
        /// <p>The identifier of the agent status.</p>
        pub fn set_agent_status_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.agent_status_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PutUserStatusInput`](crate::input::PutUserStatusInput).
        pub fn build(
            self,
        ) -> Result<crate::input::PutUserStatusInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::PutUserStatusInput {
                user_id: self.user_id,
                instance_id: self.instance_id,
                agent_status_id: self.agent_status_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MonitorContactInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the user account.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>Specify which monitoring actions the user is allowed to take. For example, whether the user is allowed to escalate from silent monitoring to barge.</p>
    #[doc(hidden)]
    pub allowed_monitor_capabilities:
        std::option::Option<std::vec::Vec<crate::model::MonitorCapability>>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl MonitorContactInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the contact.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The identifier of the user account.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>Specify which monitoring actions the user is allowed to take. For example, whether the user is allowed to escalate from silent monitoring to barge.</p>
    pub fn allowed_monitor_capabilities(
        &self,
    ) -> std::option::Option<&[crate::model::MonitorCapability]> {
        self.allowed_monitor_capabilities.as_deref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl MonitorContactInput {
    /// Creates a new builder-style object to manufacture [`MonitorContactInput`](crate::input::MonitorContactInput).
    pub fn builder() -> crate::input::monitor_contact_input::Builder {
        crate::input::monitor_contact_input::Builder::default()
    }
}

/// See [`MonitorContactInput`](crate::input::MonitorContactInput).
pub mod monitor_contact_input {

    /// A builder for [`MonitorContactInput`](crate::input::MonitorContactInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) allowed_monitor_capabilities:
            std::option::Option<std::vec::Vec<crate::model::MonitorCapability>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Appends an item to `allowed_monitor_capabilities`.
        ///
        /// To override the contents of this collection use [`set_allowed_monitor_capabilities`](Self::set_allowed_monitor_capabilities).
        ///
        /// <p>Specify which monitoring actions the user is allowed to take. For example, whether the user is allowed to escalate from silent monitoring to barge.</p>
        pub fn allowed_monitor_capabilities(
            mut self,
            input: crate::model::MonitorCapability,
        ) -> Self {
            let mut v = self.allowed_monitor_capabilities.unwrap_or_default();
            v.push(input);
            self.allowed_monitor_capabilities = Some(v);
            self
        }
        /// <p>Specify which monitoring actions the user is allowed to take. For example, whether the user is allowed to escalate from silent monitoring to barge.</p>
        pub fn set_allowed_monitor_capabilities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MonitorCapability>>,
        ) -> Self {
            self.allowed_monitor_capabilities = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitorContactInput`](crate::input::MonitorContactInput).
        pub fn build(
            self,
        ) -> Result<crate::input::MonitorContactInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::MonitorContactInput {
                instance_id: self.instance_id,
                contact_id: self.contact_id,
                user_id: self.user_id,
                allowed_monitor_capabilities: self.allowed_monitor_capabilities,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListUsersInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListUsersInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListUsersInput {
    /// Creates a new builder-style object to manufacture [`ListUsersInput`](crate::input::ListUsersInput).
    pub fn builder() -> crate::input::list_users_input::Builder {
        crate::input::list_users_input::Builder::default()
    }
}

/// See [`ListUsersInput`](crate::input::ListUsersInput).
pub mod list_users_input {

    /// A builder for [`ListUsersInput`](crate::input::ListUsersInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListUsersInput`](crate::input::ListUsersInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListUsersInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListUsersInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListUserHierarchyGroupsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListUserHierarchyGroupsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListUserHierarchyGroupsInput {
    /// Creates a new builder-style object to manufacture [`ListUserHierarchyGroupsInput`](crate::input::ListUserHierarchyGroupsInput).
    pub fn builder() -> crate::input::list_user_hierarchy_groups_input::Builder {
        crate::input::list_user_hierarchy_groups_input::Builder::default()
    }
}

/// See [`ListUserHierarchyGroupsInput`](crate::input::ListUserHierarchyGroupsInput).
pub mod list_user_hierarchy_groups_input {

    /// A builder for [`ListUserHierarchyGroupsInput`](crate::input::ListUserHierarchyGroupsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListUserHierarchyGroupsInput`](crate::input::ListUserHierarchyGroupsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListUserHierarchyGroupsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListUserHierarchyGroupsInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

/// <p>Provides summary information about the use cases for the specified integration association.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListUseCasesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the integration association.</p>
    #[doc(hidden)]
    pub integration_association_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListUseCasesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the integration association.</p>
    pub fn integration_association_id(&self) -> std::option::Option<&str> {
        self.integration_association_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListUseCasesInput {
    /// Creates a new builder-style object to manufacture [`ListUseCasesInput`](crate::input::ListUseCasesInput).
    pub fn builder() -> crate::input::list_use_cases_input::Builder {
        crate::input::list_use_cases_input::Builder::default()
    }
}

/// See [`ListUseCasesInput`](crate::input::ListUseCasesInput).
pub mod list_use_cases_input {

    /// A builder for [`ListUseCasesInput`](crate::input::ListUseCasesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) integration_association_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the integration association.</p>
        pub fn integration_association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.integration_association_id = Some(input.into());
            self
        }
        /// <p>The identifier for the integration association.</p>
        pub fn set_integration_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.integration_association_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListUseCasesInput`](crate::input::ListUseCasesInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListUseCasesInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListUseCasesInput {
                instance_id: self.instance_id,
                integration_association_id: self.integration_association_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTrafficDistributionGroupsInput {
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: i32,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl ListTrafficDistributionGroupsInput {
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl ListTrafficDistributionGroupsInput {
    /// Creates a new builder-style object to manufacture [`ListTrafficDistributionGroupsInput`](crate::input::ListTrafficDistributionGroupsInput).
    pub fn builder() -> crate::input::list_traffic_distribution_groups_input::Builder {
        crate::input::list_traffic_distribution_groups_input::Builder::default()
    }
}

/// See [`ListTrafficDistributionGroupsInput`](crate::input::ListTrafficDistributionGroupsInput).
pub mod list_traffic_distribution_groups_input {

    /// A builder for [`ListTrafficDistributionGroupsInput`](crate::input::ListTrafficDistributionGroupsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTrafficDistributionGroupsInput`](crate::input::ListTrafficDistributionGroupsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListTrafficDistributionGroupsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListTrafficDistributionGroupsInput {
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTaskTemplatesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p> <important>
    /// <p>It is not expected that you set this because the value returned in the previous response is always null.</p>
    /// </important>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p> <important>
    /// <p>It is not expected that you set this.</p>
    /// </important>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TaskTemplateStatus>,
    /// <p>The name of the task template.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl ListTaskTemplatesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p> <important>
    /// <p>It is not expected that you set this because the value returned in the previous response is always null.</p>
    /// </important>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p> <important>
    /// <p>It is not expected that you set this.</p>
    /// </important>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TaskTemplateStatus> {
        self.status.as_ref()
    }
    /// <p>The name of the task template.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl ListTaskTemplatesInput {
    /// Creates a new builder-style object to manufacture [`ListTaskTemplatesInput`](crate::input::ListTaskTemplatesInput).
    pub fn builder() -> crate::input::list_task_templates_input::Builder {
        crate::input::list_task_templates_input::Builder::default()
    }
}

/// See [`ListTaskTemplatesInput`](crate::input::ListTaskTemplatesInput).
pub mod list_task_templates_input {

    /// A builder for [`ListTaskTemplatesInput`](crate::input::ListTaskTemplatesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::TaskTemplateStatus>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p> <important>
        /// <p>It is not expected that you set this because the value returned in the previous response is always null.</p>
        /// </important>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p> <important>
        /// <p>It is not expected that you set this because the value returned in the previous response is always null.</p>
        /// </important>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p> <important>
        /// <p>It is not expected that you set this.</p>
        /// </important>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p> <important>
        /// <p>It is not expected that you set this.</p>
        /// </important>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
        pub fn status(mut self, input: crate::model::TaskTemplateStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The name of the task template.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the task template.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTaskTemplatesInput`](crate::input::ListTaskTemplatesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListTaskTemplatesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListTaskTemplatesInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
                status: self.status,
                name: self.name,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl ListTagsForResourceInput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
pub mod list_tags_for_resource_input {

    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSecurityProfilesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListSecurityProfilesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListSecurityProfilesInput {
    /// Creates a new builder-style object to manufacture [`ListSecurityProfilesInput`](crate::input::ListSecurityProfilesInput).
    pub fn builder() -> crate::input::list_security_profiles_input::Builder {
        crate::input::list_security_profiles_input::Builder::default()
    }
}

/// See [`ListSecurityProfilesInput`](crate::input::ListSecurityProfilesInput).
pub mod list_security_profiles_input {

    /// A builder for [`ListSecurityProfilesInput`](crate::input::ListSecurityProfilesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSecurityProfilesInput`](crate::input::ListSecurityProfilesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListSecurityProfilesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListSecurityProfilesInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSecurityProfilePermissionsInput {
    /// <p>The identifier for the security profle.</p>
    #[doc(hidden)]
    pub security_profile_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListSecurityProfilePermissionsInput {
    /// <p>The identifier for the security profle.</p>
    pub fn security_profile_id(&self) -> std::option::Option<&str> {
        self.security_profile_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListSecurityProfilePermissionsInput {
    /// Creates a new builder-style object to manufacture [`ListSecurityProfilePermissionsInput`](crate::input::ListSecurityProfilePermissionsInput).
    pub fn builder() -> crate::input::list_security_profile_permissions_input::Builder {
        crate::input::list_security_profile_permissions_input::Builder::default()
    }
}

/// See [`ListSecurityProfilePermissionsInput`](crate::input::ListSecurityProfilePermissionsInput).
pub mod list_security_profile_permissions_input {

    /// A builder for [`ListSecurityProfilePermissionsInput`](crate::input::ListSecurityProfilePermissionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_profile_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier for the security profle.</p>
        pub fn security_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier for the security profle.</p>
        pub fn set_security_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSecurityProfilePermissionsInput`](crate::input::ListSecurityProfilePermissionsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListSecurityProfilePermissionsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListSecurityProfilePermissionsInput {
                security_profile_id: self.security_profile_id,
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSecurityKeysInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListSecurityKeysInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListSecurityKeysInput {
    /// Creates a new builder-style object to manufacture [`ListSecurityKeysInput`](crate::input::ListSecurityKeysInput).
    pub fn builder() -> crate::input::list_security_keys_input::Builder {
        crate::input::list_security_keys_input::Builder::default()
    }
}

/// See [`ListSecurityKeysInput`](crate::input::ListSecurityKeysInput).
pub mod list_security_keys_input {

    /// A builder for [`ListSecurityKeysInput`](crate::input::ListSecurityKeysInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSecurityKeysInput`](crate::input::ListSecurityKeysInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListSecurityKeysInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListSecurityKeysInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListRulesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The publish status of the rule.</p>
    #[doc(hidden)]
    pub publish_status: std::option::Option<crate::model::RulePublishStatus>,
    /// <p>The name of the event source.</p>
    #[doc(hidden)]
    pub event_source_name: std::option::Option<crate::model::EventSourceName>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListRulesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The publish status of the rule.</p>
    pub fn publish_status(&self) -> std::option::Option<&crate::model::RulePublishStatus> {
        self.publish_status.as_ref()
    }
    /// <p>The name of the event source.</p>
    pub fn event_source_name(&self) -> std::option::Option<&crate::model::EventSourceName> {
        self.event_source_name.as_ref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListRulesInput {
    /// Creates a new builder-style object to manufacture [`ListRulesInput`](crate::input::ListRulesInput).
    pub fn builder() -> crate::input::list_rules_input::Builder {
        crate::input::list_rules_input::Builder::default()
    }
}

/// See [`ListRulesInput`](crate::input::ListRulesInput).
pub mod list_rules_input {

    /// A builder for [`ListRulesInput`](crate::input::ListRulesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) publish_status: std::option::Option<crate::model::RulePublishStatus>,
        pub(crate) event_source_name: std::option::Option<crate::model::EventSourceName>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The publish status of the rule.</p>
        pub fn publish_status(mut self, input: crate::model::RulePublishStatus) -> Self {
            self.publish_status = Some(input);
            self
        }
        /// <p>The publish status of the rule.</p>
        pub fn set_publish_status(
            mut self,
            input: std::option::Option<crate::model::RulePublishStatus>,
        ) -> Self {
            self.publish_status = input;
            self
        }
        /// <p>The name of the event source.</p>
        pub fn event_source_name(mut self, input: crate::model::EventSourceName) -> Self {
            self.event_source_name = Some(input);
            self
        }
        /// <p>The name of the event source.</p>
        pub fn set_event_source_name(
            mut self,
            input: std::option::Option<crate::model::EventSourceName>,
        ) -> Self {
            self.event_source_name = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRulesInput`](crate::input::ListRulesInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListRulesInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListRulesInput {
                instance_id: self.instance_id,
                publish_status: self.publish_status,
                event_source_name: self.event_source_name,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListRoutingProfilesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListRoutingProfilesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListRoutingProfilesInput {
    /// Creates a new builder-style object to manufacture [`ListRoutingProfilesInput`](crate::input::ListRoutingProfilesInput).
    pub fn builder() -> crate::input::list_routing_profiles_input::Builder {
        crate::input::list_routing_profiles_input::Builder::default()
    }
}

/// See [`ListRoutingProfilesInput`](crate::input::ListRoutingProfilesInput).
pub mod list_routing_profiles_input {

    /// A builder for [`ListRoutingProfilesInput`](crate::input::ListRoutingProfilesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRoutingProfilesInput`](crate::input::ListRoutingProfilesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListRoutingProfilesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListRoutingProfilesInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListRoutingProfileQueuesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the routing profile.</p>
    #[doc(hidden)]
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListRoutingProfileQueuesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the routing profile.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListRoutingProfileQueuesInput {
    /// Creates a new builder-style object to manufacture [`ListRoutingProfileQueuesInput`](crate::input::ListRoutingProfileQueuesInput).
    pub fn builder() -> crate::input::list_routing_profile_queues_input::Builder {
        crate::input::list_routing_profile_queues_input::Builder::default()
    }
}

/// See [`ListRoutingProfileQueuesInput`](crate::input::ListRoutingProfileQueuesInput).
pub mod list_routing_profile_queues_input {

    /// A builder for [`ListRoutingProfileQueuesInput`](crate::input::ListRoutingProfileQueuesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRoutingProfileQueuesInput`](crate::input::ListRoutingProfileQueuesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListRoutingProfileQueuesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListRoutingProfileQueuesInput {
                instance_id: self.instance_id,
                routing_profile_id: self.routing_profile_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListQuickConnectsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
    #[doc(hidden)]
    pub quick_connect_types: std::option::Option<std::vec::Vec<crate::model::QuickConnectType>>,
}
impl ListQuickConnectsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
    pub fn quick_connect_types(&self) -> std::option::Option<&[crate::model::QuickConnectType]> {
        self.quick_connect_types.as_deref()
    }
}
impl ListQuickConnectsInput {
    /// Creates a new builder-style object to manufacture [`ListQuickConnectsInput`](crate::input::ListQuickConnectsInput).
    pub fn builder() -> crate::input::list_quick_connects_input::Builder {
        crate::input::list_quick_connects_input::Builder::default()
    }
}

/// See [`ListQuickConnectsInput`](crate::input::ListQuickConnectsInput).
pub mod list_quick_connects_input {

    /// A builder for [`ListQuickConnectsInput`](crate::input::ListQuickConnectsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) quick_connect_types:
            std::option::Option<std::vec::Vec<crate::model::QuickConnectType>>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Appends an item to `quick_connect_types`.
        ///
        /// To override the contents of this collection use [`set_quick_connect_types`](Self::set_quick_connect_types).
        ///
        /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
        pub fn quick_connect_types(mut self, input: crate::model::QuickConnectType) -> Self {
            let mut v = self.quick_connect_types.unwrap_or_default();
            v.push(input);
            self.quick_connect_types = Some(v);
            self
        }
        /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
        pub fn set_quick_connect_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::QuickConnectType>>,
        ) -> Self {
            self.quick_connect_types = input;
            self
        }
        /// Consumes the builder and constructs a [`ListQuickConnectsInput`](crate::input::ListQuickConnectsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListQuickConnectsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListQuickConnectsInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
                quick_connect_types: self.quick_connect_types,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListQueuesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The type of queue.</p>
    #[doc(hidden)]
    pub queue_types: std::option::Option<std::vec::Vec<crate::model::QueueType>>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    #[doc(hidden)]
    pub max_results: i32,
}
impl ListQueuesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The type of queue.</p>
    pub fn queue_types(&self) -> std::option::Option<&[crate::model::QueueType]> {
        self.queue_types.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
impl ListQueuesInput {
    /// Creates a new builder-style object to manufacture [`ListQueuesInput`](crate::input::ListQueuesInput).
    pub fn builder() -> crate::input::list_queues_input::Builder {
        crate::input::list_queues_input::Builder::default()
    }
}

/// See [`ListQueuesInput`](crate::input::ListQueuesInput).
pub mod list_queues_input {

    /// A builder for [`ListQueuesInput`](crate::input::ListQueuesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) queue_types: std::option::Option<std::vec::Vec<crate::model::QueueType>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Appends an item to `queue_types`.
        ///
        /// To override the contents of this collection use [`set_queue_types`](Self::set_queue_types).
        ///
        /// <p>The type of queue.</p>
        pub fn queue_types(mut self, input: crate::model::QueueType) -> Self {
            let mut v = self.queue_types.unwrap_or_default();
            v.push(input);
            self.queue_types = Some(v);
            self
        }
        /// <p>The type of queue.</p>
        pub fn set_queue_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::QueueType>>,
        ) -> Self {
            self.queue_types = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListQueuesInput`](crate::input::ListQueuesInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListQueuesInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListQueuesInput {
                instance_id: self.instance_id,
                queue_types: self.queue_types,
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListQueueQuickConnectsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListQueueQuickConnectsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListQueueQuickConnectsInput {
    /// Creates a new builder-style object to manufacture [`ListQueueQuickConnectsInput`](crate::input::ListQueueQuickConnectsInput).
    pub fn builder() -> crate::input::list_queue_quick_connects_input::Builder {
        crate::input::list_queue_quick_connects_input::Builder::default()
    }
}

/// See [`ListQueueQuickConnectsInput`](crate::input::ListQueueQuickConnectsInput).
pub mod list_queue_quick_connects_input {

    /// A builder for [`ListQueueQuickConnectsInput`](crate::input::ListQueueQuickConnectsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListQueueQuickConnectsInput`](crate::input::ListQueueQuickConnectsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListQueueQuickConnectsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListQueueQuickConnectsInput {
                instance_id: self.instance_id,
                queue_id: self.queue_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListPromptsInput {
    /// <p>The identifier of the Amazon Connect instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListPromptsInput {
    /// <p>The identifier of the Amazon Connect instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListPromptsInput {
    /// Creates a new builder-style object to manufacture [`ListPromptsInput`](crate::input::ListPromptsInput).
    pub fn builder() -> crate::input::list_prompts_input::Builder {
        crate::input::list_prompts_input::Builder::default()
    }
}

/// See [`ListPromptsInput`](crate::input::ListPromptsInput).
pub mod list_prompts_input {

    /// A builder for [`ListPromptsInput`](crate::input::ListPromptsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPromptsInput`](crate::input::ListPromptsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListPromptsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListPromptsInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListPhoneNumbersV2Input {
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to. If <code>TargetArn</code> input is not provided, this API lists numbers claimed to all the Amazon Connect instances belonging to your account in the same Amazon Web Services Region as the request.</p>
    #[doc(hidden)]
    pub target_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The ISO country code.</p>
    #[doc(hidden)]
    pub phone_number_country_codes:
        std::option::Option<std::vec::Vec<crate::model::PhoneNumberCountryCode>>,
    /// <p>The type of phone number.</p>
    #[doc(hidden)]
    pub phone_number_types: std::option::Option<std::vec::Vec<crate::model::PhoneNumberType>>,
    /// <p>The prefix of the phone number. If provided, it must contain <code>+</code> as part of the country code.</p>
    #[doc(hidden)]
    pub phone_number_prefix: std::option::Option<std::string::String>,
}
impl ListPhoneNumbersV2Input {
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to. If <code>TargetArn</code> input is not provided, this API lists numbers claimed to all the Amazon Connect instances belonging to your account in the same Amazon Web Services Region as the request.</p>
    pub fn target_arn(&self) -> std::option::Option<&str> {
        self.target_arn.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The ISO country code.</p>
    pub fn phone_number_country_codes(
        &self,
    ) -> std::option::Option<&[crate::model::PhoneNumberCountryCode]> {
        self.phone_number_country_codes.as_deref()
    }
    /// <p>The type of phone number.</p>
    pub fn phone_number_types(&self) -> std::option::Option<&[crate::model::PhoneNumberType]> {
        self.phone_number_types.as_deref()
    }
    /// <p>The prefix of the phone number. If provided, it must contain <code>+</code> as part of the country code.</p>
    pub fn phone_number_prefix(&self) -> std::option::Option<&str> {
        self.phone_number_prefix.as_deref()
    }
}
impl ListPhoneNumbersV2Input {
    /// Creates a new builder-style object to manufacture [`ListPhoneNumbersV2Input`](crate::input::ListPhoneNumbersV2Input).
    pub fn builder() -> crate::input::list_phone_numbers_v2_input::Builder {
        crate::input::list_phone_numbers_v2_input::Builder::default()
    }
}

/// See [`ListPhoneNumbersV2Input`](crate::input::ListPhoneNumbersV2Input).
pub mod list_phone_numbers_v2_input {

    /// A builder for [`ListPhoneNumbersV2Input`](crate::input::ListPhoneNumbersV2Input).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) phone_number_country_codes:
            std::option::Option<std::vec::Vec<crate::model::PhoneNumberCountryCode>>,
        pub(crate) phone_number_types:
            std::option::Option<std::vec::Vec<crate::model::PhoneNumberType>>,
        pub(crate) phone_number_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to. If <code>TargetArn</code> input is not provided, this API lists numbers claimed to all the Amazon Connect instances belonging to your account in the same Amazon Web Services Region as the request.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to. If <code>TargetArn</code> input is not provided, this API lists numbers claimed to all the Amazon Connect instances belonging to your account in the same Amazon Web Services Region as the request.</p>
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `phone_number_country_codes`.
        ///
        /// To override the contents of this collection use [`set_phone_number_country_codes`](Self::set_phone_number_country_codes).
        ///
        /// <p>The ISO country code.</p>
        pub fn phone_number_country_codes(
            mut self,
            input: crate::model::PhoneNumberCountryCode,
        ) -> Self {
            let mut v = self.phone_number_country_codes.unwrap_or_default();
            v.push(input);
            self.phone_number_country_codes = Some(v);
            self
        }
        /// <p>The ISO country code.</p>
        pub fn set_phone_number_country_codes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PhoneNumberCountryCode>>,
        ) -> Self {
            self.phone_number_country_codes = input;
            self
        }
        /// Appends an item to `phone_number_types`.
        ///
        /// To override the contents of this collection use [`set_phone_number_types`](Self::set_phone_number_types).
        ///
        /// <p>The type of phone number.</p>
        pub fn phone_number_types(mut self, input: crate::model::PhoneNumberType) -> Self {
            let mut v = self.phone_number_types.unwrap_or_default();
            v.push(input);
            self.phone_number_types = Some(v);
            self
        }
        /// <p>The type of phone number.</p>
        pub fn set_phone_number_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PhoneNumberType>>,
        ) -> Self {
            self.phone_number_types = input;
            self
        }
        /// <p>The prefix of the phone number. If provided, it must contain <code>+</code> as part of the country code.</p>
        pub fn phone_number_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_prefix = Some(input.into());
            self
        }
        /// <p>The prefix of the phone number. If provided, it must contain <code>+</code> as part of the country code.</p>
        pub fn set_phone_number_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPhoneNumbersV2Input`](crate::input::ListPhoneNumbersV2Input).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListPhoneNumbersV2Input,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListPhoneNumbersV2Input {
                target_arn: self.target_arn,
                max_results: self.max_results,
                next_token: self.next_token,
                phone_number_country_codes: self.phone_number_country_codes,
                phone_number_types: self.phone_number_types,
                phone_number_prefix: self.phone_number_prefix,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListPhoneNumbersInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The type of phone number.</p>
    #[doc(hidden)]
    pub phone_number_types: std::option::Option<std::vec::Vec<crate::model::PhoneNumberType>>,
    /// <p>The ISO country code.</p>
    #[doc(hidden)]
    pub phone_number_country_codes:
        std::option::Option<std::vec::Vec<crate::model::PhoneNumberCountryCode>>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    #[doc(hidden)]
    pub max_results: i32,
}
impl ListPhoneNumbersInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The type of phone number.</p>
    pub fn phone_number_types(&self) -> std::option::Option<&[crate::model::PhoneNumberType]> {
        self.phone_number_types.as_deref()
    }
    /// <p>The ISO country code.</p>
    pub fn phone_number_country_codes(
        &self,
    ) -> std::option::Option<&[crate::model::PhoneNumberCountryCode]> {
        self.phone_number_country_codes.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
impl ListPhoneNumbersInput {
    /// Creates a new builder-style object to manufacture [`ListPhoneNumbersInput`](crate::input::ListPhoneNumbersInput).
    pub fn builder() -> crate::input::list_phone_numbers_input::Builder {
        crate::input::list_phone_numbers_input::Builder::default()
    }
}

/// See [`ListPhoneNumbersInput`](crate::input::ListPhoneNumbersInput).
pub mod list_phone_numbers_input {

    /// A builder for [`ListPhoneNumbersInput`](crate::input::ListPhoneNumbersInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) phone_number_types:
            std::option::Option<std::vec::Vec<crate::model::PhoneNumberType>>,
        pub(crate) phone_number_country_codes:
            std::option::Option<std::vec::Vec<crate::model::PhoneNumberCountryCode>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Appends an item to `phone_number_types`.
        ///
        /// To override the contents of this collection use [`set_phone_number_types`](Self::set_phone_number_types).
        ///
        /// <p>The type of phone number.</p>
        pub fn phone_number_types(mut self, input: crate::model::PhoneNumberType) -> Self {
            let mut v = self.phone_number_types.unwrap_or_default();
            v.push(input);
            self.phone_number_types = Some(v);
            self
        }
        /// <p>The type of phone number.</p>
        pub fn set_phone_number_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PhoneNumberType>>,
        ) -> Self {
            self.phone_number_types = input;
            self
        }
        /// Appends an item to `phone_number_country_codes`.
        ///
        /// To override the contents of this collection use [`set_phone_number_country_codes`](Self::set_phone_number_country_codes).
        ///
        /// <p>The ISO country code.</p>
        pub fn phone_number_country_codes(
            mut self,
            input: crate::model::PhoneNumberCountryCode,
        ) -> Self {
            let mut v = self.phone_number_country_codes.unwrap_or_default();
            v.push(input);
            self.phone_number_country_codes = Some(v);
            self
        }
        /// <p>The ISO country code.</p>
        pub fn set_phone_number_country_codes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PhoneNumberCountryCode>>,
        ) -> Self {
            self.phone_number_country_codes = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPhoneNumbersInput`](crate::input::ListPhoneNumbersInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListPhoneNumbersInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListPhoneNumbersInput {
                instance_id: self.instance_id,
                phone_number_types: self.phone_number_types,
                phone_number_country_codes: self.phone_number_country_codes,
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListLexBotsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page. If no value is specified, the default is 10. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListLexBotsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page. If no value is specified, the default is 10. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListLexBotsInput {
    /// Creates a new builder-style object to manufacture [`ListLexBotsInput`](crate::input::ListLexBotsInput).
    pub fn builder() -> crate::input::list_lex_bots_input::Builder {
        crate::input::list_lex_bots_input::Builder::default()
    }
}

/// See [`ListLexBotsInput`](crate::input::ListLexBotsInput).
pub mod list_lex_bots_input {

    /// A builder for [`ListLexBotsInput`](crate::input::ListLexBotsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page. If no value is specified, the default is 10. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page. If no value is specified, the default is 10. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListLexBotsInput`](crate::input::ListLexBotsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListLexBotsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListLexBotsInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListLambdaFunctionsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListLambdaFunctionsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListLambdaFunctionsInput {
    /// Creates a new builder-style object to manufacture [`ListLambdaFunctionsInput`](crate::input::ListLambdaFunctionsInput).
    pub fn builder() -> crate::input::list_lambda_functions_input::Builder {
        crate::input::list_lambda_functions_input::Builder::default()
    }
}

/// See [`ListLambdaFunctionsInput`](crate::input::ListLambdaFunctionsInput).
pub mod list_lambda_functions_input {

    /// A builder for [`ListLambdaFunctionsInput`](crate::input::ListLambdaFunctionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListLambdaFunctionsInput`](crate::input::ListLambdaFunctionsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListLambdaFunctionsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListLambdaFunctionsInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListIntegrationAssociationsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The integration type.</p>
    #[doc(hidden)]
    pub integration_type: std::option::Option<crate::model::IntegrationType>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListIntegrationAssociationsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The integration type.</p>
    pub fn integration_type(&self) -> std::option::Option<&crate::model::IntegrationType> {
        self.integration_type.as_ref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListIntegrationAssociationsInput {
    /// Creates a new builder-style object to manufacture [`ListIntegrationAssociationsInput`](crate::input::ListIntegrationAssociationsInput).
    pub fn builder() -> crate::input::list_integration_associations_input::Builder {
        crate::input::list_integration_associations_input::Builder::default()
    }
}

/// See [`ListIntegrationAssociationsInput`](crate::input::ListIntegrationAssociationsInput).
pub mod list_integration_associations_input {

    /// A builder for [`ListIntegrationAssociationsInput`](crate::input::ListIntegrationAssociationsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) integration_type: std::option::Option<crate::model::IntegrationType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The integration type.</p>
        pub fn integration_type(mut self, input: crate::model::IntegrationType) -> Self {
            self.integration_type = Some(input);
            self
        }
        /// <p>The integration type.</p>
        pub fn set_integration_type(
            mut self,
            input: std::option::Option<crate::model::IntegrationType>,
        ) -> Self {
            self.integration_type = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListIntegrationAssociationsInput`](crate::input::ListIntegrationAssociationsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListIntegrationAssociationsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListIntegrationAssociationsInput {
                instance_id: self.instance_id,
                integration_type: self.integration_type,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListInstanceStorageConfigsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A valid resource type.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::InstanceStorageResourceType>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListInstanceStorageConfigsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>A valid resource type.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::InstanceStorageResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListInstanceStorageConfigsInput {
    /// Creates a new builder-style object to manufacture [`ListInstanceStorageConfigsInput`](crate::input::ListInstanceStorageConfigsInput).
    pub fn builder() -> crate::input::list_instance_storage_configs_input::Builder {
        crate::input::list_instance_storage_configs_input::Builder::default()
    }
}

/// See [`ListInstanceStorageConfigsInput`](crate::input::ListInstanceStorageConfigsInput).
pub mod list_instance_storage_configs_input {

    /// A builder for [`ListInstanceStorageConfigsInput`](crate::input::ListInstanceStorageConfigsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::InstanceStorageResourceType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>A valid resource type.</p>
        pub fn resource_type(mut self, input: crate::model::InstanceStorageResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>A valid resource type.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::InstanceStorageResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListInstanceStorageConfigsInput`](crate::input::ListInstanceStorageConfigsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListInstanceStorageConfigsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListInstanceStorageConfigsInput {
                instance_id: self.instance_id,
                resource_type: self.resource_type,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListInstancesInput {
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListInstancesInput {
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListInstancesInput {
    /// Creates a new builder-style object to manufacture [`ListInstancesInput`](crate::input::ListInstancesInput).
    pub fn builder() -> crate::input::list_instances_input::Builder {
        crate::input::list_instances_input::Builder::default()
    }
}

/// See [`ListInstancesInput`](crate::input::ListInstancesInput).
pub mod list_instances_input {

    /// A builder for [`ListInstancesInput`](crate::input::ListInstancesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListInstancesInput`](crate::input::ListInstancesInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListInstancesInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListInstancesInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListInstanceAttributesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListInstanceAttributesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListInstanceAttributesInput {
    /// Creates a new builder-style object to manufacture [`ListInstanceAttributesInput`](crate::input::ListInstanceAttributesInput).
    pub fn builder() -> crate::input::list_instance_attributes_input::Builder {
        crate::input::list_instance_attributes_input::Builder::default()
    }
}

/// See [`ListInstanceAttributesInput`](crate::input::ListInstanceAttributesInput).
pub mod list_instance_attributes_input {

    /// A builder for [`ListInstanceAttributesInput`](crate::input::ListInstanceAttributesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListInstanceAttributesInput`](crate::input::ListInstanceAttributesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListInstanceAttributesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListInstanceAttributesInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListHoursOfOperationsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    #[doc(hidden)]
    pub max_results: i32,
}
impl ListHoursOfOperationsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
impl ListHoursOfOperationsInput {
    /// Creates a new builder-style object to manufacture [`ListHoursOfOperationsInput`](crate::input::ListHoursOfOperationsInput).
    pub fn builder() -> crate::input::list_hours_of_operations_input::Builder {
        crate::input::list_hours_of_operations_input::Builder::default()
    }
}

/// See [`ListHoursOfOperationsInput`](crate::input::ListHoursOfOperationsInput).
pub mod list_hours_of_operations_input {

    /// A builder for [`ListHoursOfOperationsInput`](crate::input::ListHoursOfOperationsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListHoursOfOperationsInput`](crate::input::ListHoursOfOperationsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListHoursOfOperationsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListHoursOfOperationsInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDefaultVocabulariesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: i32,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListDefaultVocabulariesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::VocabularyLanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListDefaultVocabulariesInput {
    /// Creates a new builder-style object to manufacture [`ListDefaultVocabulariesInput`](crate::input::ListDefaultVocabulariesInput).
    pub fn builder() -> crate::input::list_default_vocabularies_input::Builder {
        crate::input::list_default_vocabularies_input::Builder::default()
    }
}

/// See [`ListDefaultVocabulariesInput`](crate::input::ListDefaultVocabulariesInput).
pub mod list_default_vocabularies_input {

    /// A builder for [`ListDefaultVocabulariesInput`](crate::input::ListDefaultVocabulariesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn language_code(mut self, input: crate::model::VocabularyLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::VocabularyLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDefaultVocabulariesInput`](crate::input::ListDefaultVocabulariesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListDefaultVocabulariesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListDefaultVocabulariesInput {
                instance_id: self.instance_id,
                language_code: self.language_code,
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListContactReferencesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the initial contact.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>The type of reference.</p>
    #[doc(hidden)]
    pub reference_types: std::option::Option<std::vec::Vec<crate::model::ReferenceType>>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p> <important>
    /// <p>This is not expected to be set, because the value returned in the previous response is always null.</p>
    /// </important>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListContactReferencesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the initial contact.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>The type of reference.</p>
    pub fn reference_types(&self) -> std::option::Option<&[crate::model::ReferenceType]> {
        self.reference_types.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p> <important>
    /// <p>This is not expected to be set, because the value returned in the previous response is always null.</p>
    /// </important>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListContactReferencesInput {
    /// Creates a new builder-style object to manufacture [`ListContactReferencesInput`](crate::input::ListContactReferencesInput).
    pub fn builder() -> crate::input::list_contact_references_input::Builder {
        crate::input::list_contact_references_input::Builder::default()
    }
}

/// See [`ListContactReferencesInput`](crate::input::ListContactReferencesInput).
pub mod list_contact_references_input {

    /// A builder for [`ListContactReferencesInput`](crate::input::ListContactReferencesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) reference_types: std::option::Option<std::vec::Vec<crate::model::ReferenceType>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the initial contact.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the initial contact.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// Appends an item to `reference_types`.
        ///
        /// To override the contents of this collection use [`set_reference_types`](Self::set_reference_types).
        ///
        /// <p>The type of reference.</p>
        pub fn reference_types(mut self, input: crate::model::ReferenceType) -> Self {
            let mut v = self.reference_types.unwrap_or_default();
            v.push(input);
            self.reference_types = Some(v);
            self
        }
        /// <p>The type of reference.</p>
        pub fn set_reference_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReferenceType>>,
        ) -> Self {
            self.reference_types = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p> <important>
        /// <p>This is not expected to be set, because the value returned in the previous response is always null.</p>
        /// </important>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p> <important>
        /// <p>This is not expected to be set, because the value returned in the previous response is always null.</p>
        /// </important>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListContactReferencesInput`](crate::input::ListContactReferencesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListContactReferencesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListContactReferencesInput {
                instance_id: self.instance_id,
                contact_id: self.contact_id,
                reference_types: self.reference_types,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListContactFlowsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The type of flow.</p>
    #[doc(hidden)]
    pub contact_flow_types: std::option::Option<std::vec::Vec<crate::model::ContactFlowType>>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    #[doc(hidden)]
    pub max_results: i32,
}
impl ListContactFlowsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The type of flow.</p>
    pub fn contact_flow_types(&self) -> std::option::Option<&[crate::model::ContactFlowType]> {
        self.contact_flow_types.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
impl ListContactFlowsInput {
    /// Creates a new builder-style object to manufacture [`ListContactFlowsInput`](crate::input::ListContactFlowsInput).
    pub fn builder() -> crate::input::list_contact_flows_input::Builder {
        crate::input::list_contact_flows_input::Builder::default()
    }
}

/// See [`ListContactFlowsInput`](crate::input::ListContactFlowsInput).
pub mod list_contact_flows_input {

    /// A builder for [`ListContactFlowsInput`](crate::input::ListContactFlowsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_types:
            std::option::Option<std::vec::Vec<crate::model::ContactFlowType>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Appends an item to `contact_flow_types`.
        ///
        /// To override the contents of this collection use [`set_contact_flow_types`](Self::set_contact_flow_types).
        ///
        /// <p>The type of flow.</p>
        pub fn contact_flow_types(mut self, input: crate::model::ContactFlowType) -> Self {
            let mut v = self.contact_flow_types.unwrap_or_default();
            v.push(input);
            self.contact_flow_types = Some(v);
            self
        }
        /// <p>The type of flow.</p>
        pub fn set_contact_flow_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContactFlowType>>,
        ) -> Self {
            self.contact_flow_types = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page. The default MaxResult size is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListContactFlowsInput`](crate::input::ListContactFlowsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListContactFlowsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListContactFlowsInput {
                instance_id: self.instance_id,
                contact_flow_types: self.contact_flow_types,
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListContactFlowModulesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The state of the flow module.</p>
    #[doc(hidden)]
    pub contact_flow_module_state: std::option::Option<crate::model::ContactFlowModuleState>,
}
impl ListContactFlowModulesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The state of the flow module.</p>
    pub fn contact_flow_module_state(
        &self,
    ) -> std::option::Option<&crate::model::ContactFlowModuleState> {
        self.contact_flow_module_state.as_ref()
    }
}
impl ListContactFlowModulesInput {
    /// Creates a new builder-style object to manufacture [`ListContactFlowModulesInput`](crate::input::ListContactFlowModulesInput).
    pub fn builder() -> crate::input::list_contact_flow_modules_input::Builder {
        crate::input::list_contact_flow_modules_input::Builder::default()
    }
}

/// See [`ListContactFlowModulesInput`](crate::input::ListContactFlowModulesInput).
pub mod list_contact_flow_modules_input {

    /// A builder for [`ListContactFlowModulesInput`](crate::input::ListContactFlowModulesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) contact_flow_module_state:
            std::option::Option<crate::model::ContactFlowModuleState>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The state of the flow module.</p>
        pub fn contact_flow_module_state(
            mut self,
            input: crate::model::ContactFlowModuleState,
        ) -> Self {
            self.contact_flow_module_state = Some(input);
            self
        }
        /// <p>The state of the flow module.</p>
        pub fn set_contact_flow_module_state(
            mut self,
            input: std::option::Option<crate::model::ContactFlowModuleState>,
        ) -> Self {
            self.contact_flow_module_state = input;
            self
        }
        /// Consumes the builder and constructs a [`ListContactFlowModulesInput`](crate::input::ListContactFlowModulesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListContactFlowModulesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListContactFlowModulesInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
                contact_flow_module_state: self.contact_flow_module_state,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListBotsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The version of Amazon Lex or Amazon Lex V2.</p>
    #[doc(hidden)]
    pub lex_version: std::option::Option<crate::model::LexVersion>,
}
impl ListBotsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The version of Amazon Lex or Amazon Lex V2.</p>
    pub fn lex_version(&self) -> std::option::Option<&crate::model::LexVersion> {
        self.lex_version.as_ref()
    }
}
impl ListBotsInput {
    /// Creates a new builder-style object to manufacture [`ListBotsInput`](crate::input::ListBotsInput).
    pub fn builder() -> crate::input::list_bots_input::Builder {
        crate::input::list_bots_input::Builder::default()
    }
}

/// See [`ListBotsInput`](crate::input::ListBotsInput).
pub mod list_bots_input {

    /// A builder for [`ListBotsInput`](crate::input::ListBotsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) lex_version: std::option::Option<crate::model::LexVersion>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The version of Amazon Lex or Amazon Lex V2.</p>
        pub fn lex_version(mut self, input: crate::model::LexVersion) -> Self {
            self.lex_version = Some(input);
            self
        }
        /// <p>The version of Amazon Lex or Amazon Lex V2.</p>
        pub fn set_lex_version(
            mut self,
            input: std::option::Option<crate::model::LexVersion>,
        ) -> Self {
            self.lex_version = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBotsInput`](crate::input::ListBotsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListBotsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListBotsInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
                lex_version: self.lex_version,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListApprovedOriginsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListApprovedOriginsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListApprovedOriginsInput {
    /// Creates a new builder-style object to manufacture [`ListApprovedOriginsInput`](crate::input::ListApprovedOriginsInput).
    pub fn builder() -> crate::input::list_approved_origins_input::Builder {
        crate::input::list_approved_origins_input::Builder::default()
    }
}

/// See [`ListApprovedOriginsInput`](crate::input::ListApprovedOriginsInput).
pub mod list_approved_origins_input {

    /// A builder for [`ListApprovedOriginsInput`](crate::input::ListApprovedOriginsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListApprovedOriginsInput`](crate::input::ListApprovedOriginsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListApprovedOriginsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListApprovedOriginsInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAgentStatusesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Available agent status types.</p>
    #[doc(hidden)]
    pub agent_status_types: std::option::Option<std::vec::Vec<crate::model::AgentStatusType>>,
}
impl ListAgentStatusesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Available agent status types.</p>
    pub fn agent_status_types(&self) -> std::option::Option<&[crate::model::AgentStatusType]> {
        self.agent_status_types.as_deref()
    }
}
impl ListAgentStatusesInput {
    /// Creates a new builder-style object to manufacture [`ListAgentStatusesInput`](crate::input::ListAgentStatusesInput).
    pub fn builder() -> crate::input::list_agent_statuses_input::Builder {
        crate::input::list_agent_statuses_input::Builder::default()
    }
}

/// See [`ListAgentStatusesInput`](crate::input::ListAgentStatusesInput).
pub mod list_agent_statuses_input {

    /// A builder for [`ListAgentStatusesInput`](crate::input::ListAgentStatusesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) agent_status_types:
            std::option::Option<std::vec::Vec<crate::model::AgentStatusType>>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Appends an item to `agent_status_types`.
        ///
        /// To override the contents of this collection use [`set_agent_status_types`](Self::set_agent_status_types).
        ///
        /// <p>Available agent status types.</p>
        pub fn agent_status_types(mut self, input: crate::model::AgentStatusType) -> Self {
            let mut v = self.agent_status_types.unwrap_or_default();
            v.push(input);
            self.agent_status_types = Some(v);
            self
        }
        /// <p>Available agent status types.</p>
        pub fn set_agent_status_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AgentStatusType>>,
        ) -> Self {
            self.agent_status_types = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAgentStatusesInput`](crate::input::ListAgentStatusesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListAgentStatusesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListAgentStatusesInput {
                instance_id: self.instance_id,
                next_token: self.next_token,
                max_results: self.max_results,
                agent_status_types: self.agent_status_types,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetTrafficDistributionInput {
    /// <p>The identifier of the traffic distribution group.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl GetTrafficDistributionInput {
    /// <p>The identifier of the traffic distribution group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
impl GetTrafficDistributionInput {
    /// Creates a new builder-style object to manufacture [`GetTrafficDistributionInput`](crate::input::GetTrafficDistributionInput).
    pub fn builder() -> crate::input::get_traffic_distribution_input::Builder {
        crate::input::get_traffic_distribution_input::Builder::default()
    }
}

/// See [`GetTrafficDistributionInput`](crate::input::GetTrafficDistributionInput).
pub mod get_traffic_distribution_input {

    /// A builder for [`GetTrafficDistributionInput`](crate::input::GetTrafficDistributionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the traffic distribution group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the traffic distribution group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTrafficDistributionInput`](crate::input::GetTrafficDistributionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetTrafficDistributionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetTrafficDistributionInput { id: self.id })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetTaskTemplateInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the task template.</p>
    #[doc(hidden)]
    pub task_template_id: std::option::Option<std::string::String>,
    /// <p>The system generated version of a task template that is associated with a task, when the task is created.</p>
    #[doc(hidden)]
    pub snapshot_version: std::option::Option<std::string::String>,
}
impl GetTaskTemplateInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>A unique identifier for the task template.</p>
    pub fn task_template_id(&self) -> std::option::Option<&str> {
        self.task_template_id.as_deref()
    }
    /// <p>The system generated version of a task template that is associated with a task, when the task is created.</p>
    pub fn snapshot_version(&self) -> std::option::Option<&str> {
        self.snapshot_version.as_deref()
    }
}
impl GetTaskTemplateInput {
    /// Creates a new builder-style object to manufacture [`GetTaskTemplateInput`](crate::input::GetTaskTemplateInput).
    pub fn builder() -> crate::input::get_task_template_input::Builder {
        crate::input::get_task_template_input::Builder::default()
    }
}

/// See [`GetTaskTemplateInput`](crate::input::GetTaskTemplateInput).
pub mod get_task_template_input {

    /// A builder for [`GetTaskTemplateInput`](crate::input::GetTaskTemplateInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) task_template_id: std::option::Option<std::string::String>,
        pub(crate) snapshot_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>A unique identifier for the task template.</p>
        pub fn task_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_template_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the task template.</p>
        pub fn set_task_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_template_id = input;
            self
        }
        /// <p>The system generated version of a task template that is associated with a task, when the task is created.</p>
        pub fn snapshot_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_version = Some(input.into());
            self
        }
        /// <p>The system generated version of a task template that is associated with a task, when the task is created.</p>
        pub fn set_snapshot_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_version = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTaskTemplateInput`](crate::input::GetTaskTemplateInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetTaskTemplateInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetTaskTemplateInput {
                instance_id: self.instance_id,
                task_template_id: self.task_template_id,
                snapshot_version: self.snapshot_version,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetMetricDataInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be specified using a multiple of 5 minutes, such as 10:05, 10:10, 10:15.</p>
    /// <p>The start time cannot be earlier than 24 hours before the time of the request. Historical metrics are available only for 24 hours.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be specified using an interval of 5 minutes, such as 11:00, 11:05, 11:10, and must be later than the start time timestamp.</p>
    /// <p>The time range between the start and end time must be less than 24 hours.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is retrieved only for the resources associated with the queues or channels included in the filter. You can include both queue IDs and queue ARNs in the same request. VOICE, CHAT, and TASK channels are supported.</p> <note>
    /// <p>To filter by <code>Queues</code>, enter the queue ID/ARN, not the name of the queue.</p>
    /// </note>
    #[doc(hidden)]
    pub filters: std::option::Option<crate::model::Filters>,
    /// <p>The grouping applied to the metrics returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values returned apply to the metrics for each queue rather than aggregated for all queues.</p>
    /// <p>If no grouping is specified, a summary of metrics for all queues is returned.</p>
    #[doc(hidden)]
    pub groupings: std::option::Option<std::vec::Vec<crate::model::Grouping>>,
    /// <p>The metrics to retrieve. Specify the name, unit, and statistic for each metric. The following historical metrics are available. For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p> <note>
    /// <p>This API does not support a contacts incoming metric (there's no CONTACTS_INCOMING metric missing from the documented list). </p>
    /// </note>
    /// <dl>
    /// <dt>
    /// ABANDON_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// AFTER_CONTACT_WORK_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// API_CONTACTS_HANDLED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CALLBACK_CONTACTS_HANDLED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_ABANDONED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_AGENT_HUNG_UP_FIRST
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_CONSULTED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_HANDLED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_HANDLED_INCOMING
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_HANDLED_OUTBOUND
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_HOLD_ABANDONS
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_MISSED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_QUEUED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_TRANSFERRED_IN
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_TRANSFERRED_IN_FROM_QUEUE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_TRANSFERRED_OUT
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_TRANSFERRED_OUT_FROM_QUEUE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// HANDLE_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// HOLD_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// INTERACTION_AND_HOLD_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// INTERACTION_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// OCCUPANCY
    /// </dt>
    /// <dd>
    /// <p>Unit: PERCENT</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// QUEUE_ANSWER_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// QUEUED_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: MAX</p>
    /// </dd>
    /// <dt>
    /// SERVICE_LEVEL
    /// </dt>
    /// <dd>
    /// <p>You can include up to 20 SERVICE_LEVEL metrics in a request.</p>
    /// <p>Unit: PERCENT</p>
    /// <p>Statistic: AVG</p>
    /// <p>Threshold: For <code>ThresholdValue</code>, enter any whole number from 1 to 604800 (inclusive), in seconds. For <code>Comparison</code>, you must enter <code>LT</code> (for "Less than"). </p>
    /// </dd>
    /// </dl>
    #[doc(hidden)]
    pub historical_metrics: std::option::Option<std::vec::Vec<crate::model::HistoricalMetric>>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetMetricDataInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be specified using a multiple of 5 minutes, such as 10:05, 10:10, 10:15.</p>
    /// <p>The start time cannot be earlier than 24 hours before the time of the request. Historical metrics are available only for 24 hours.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be specified using an interval of 5 minutes, such as 11:00, 11:05, 11:10, and must be later than the start time timestamp.</p>
    /// <p>The time range between the start and end time must be less than 24 hours.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is retrieved only for the resources associated with the queues or channels included in the filter. You can include both queue IDs and queue ARNs in the same request. VOICE, CHAT, and TASK channels are supported.</p> <note>
    /// <p>To filter by <code>Queues</code>, enter the queue ID/ARN, not the name of the queue.</p>
    /// </note>
    pub fn filters(&self) -> std::option::Option<&crate::model::Filters> {
        self.filters.as_ref()
    }
    /// <p>The grouping applied to the metrics returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values returned apply to the metrics for each queue rather than aggregated for all queues.</p>
    /// <p>If no grouping is specified, a summary of metrics for all queues is returned.</p>
    pub fn groupings(&self) -> std::option::Option<&[crate::model::Grouping]> {
        self.groupings.as_deref()
    }
    /// <p>The metrics to retrieve. Specify the name, unit, and statistic for each metric. The following historical metrics are available. For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p> <note>
    /// <p>This API does not support a contacts incoming metric (there's no CONTACTS_INCOMING metric missing from the documented list). </p>
    /// </note>
    /// <dl>
    /// <dt>
    /// ABANDON_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// AFTER_CONTACT_WORK_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// API_CONTACTS_HANDLED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CALLBACK_CONTACTS_HANDLED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_ABANDONED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_AGENT_HUNG_UP_FIRST
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_CONSULTED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_HANDLED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_HANDLED_INCOMING
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_HANDLED_OUTBOUND
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_HOLD_ABANDONS
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_MISSED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_QUEUED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_TRANSFERRED_IN
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_TRANSFERRED_IN_FROM_QUEUE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_TRANSFERRED_OUT
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// CONTACTS_TRANSFERRED_OUT_FROM_QUEUE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Statistic: SUM</p>
    /// </dd>
    /// <dt>
    /// HANDLE_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// HOLD_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// INTERACTION_AND_HOLD_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// INTERACTION_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// OCCUPANCY
    /// </dt>
    /// <dd>
    /// <p>Unit: PERCENT</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// QUEUE_ANSWER_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: AVG</p>
    /// </dd>
    /// <dt>
    /// QUEUED_TIME
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>Statistic: MAX</p>
    /// </dd>
    /// <dt>
    /// SERVICE_LEVEL
    /// </dt>
    /// <dd>
    /// <p>You can include up to 20 SERVICE_LEVEL metrics in a request.</p>
    /// <p>Unit: PERCENT</p>
    /// <p>Statistic: AVG</p>
    /// <p>Threshold: For <code>ThresholdValue</code>, enter any whole number from 1 to 604800 (inclusive), in seconds. For <code>Comparison</code>, you must enter <code>LT</code> (for "Less than"). </p>
    /// </dd>
    /// </dl>
    pub fn historical_metrics(&self) -> std::option::Option<&[crate::model::HistoricalMetric]> {
        self.historical_metrics.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl GetMetricDataInput {
    /// Creates a new builder-style object to manufacture [`GetMetricDataInput`](crate::input::GetMetricDataInput).
    pub fn builder() -> crate::input::get_metric_data_input::Builder {
        crate::input::get_metric_data_input::Builder::default()
    }
}

/// See [`GetMetricDataInput`](crate::input::GetMetricDataInput).
pub mod get_metric_data_input {

    /// A builder for [`GetMetricDataInput`](crate::input::GetMetricDataInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) filters: std::option::Option<crate::model::Filters>,
        pub(crate) groupings: std::option::Option<std::vec::Vec<crate::model::Grouping>>,
        pub(crate) historical_metrics:
            std::option::Option<std::vec::Vec<crate::model::HistoricalMetric>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be specified using a multiple of 5 minutes, such as 10:05, 10:10, 10:15.</p>
        /// <p>The start time cannot be earlier than 24 hours before the time of the request. Historical metrics are available only for 24 hours.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be specified using a multiple of 5 minutes, such as 10:05, 10:10, 10:15.</p>
        /// <p>The start time cannot be earlier than 24 hours before the time of the request. Historical metrics are available only for 24 hours.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be specified using an interval of 5 minutes, such as 11:00, 11:05, 11:10, and must be later than the start time timestamp.</p>
        /// <p>The time range between the start and end time must be less than 24 hours.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be specified using an interval of 5 minutes, such as 11:00, 11:05, 11:10, and must be later than the start time timestamp.</p>
        /// <p>The time range between the start and end time must be less than 24 hours.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is retrieved only for the resources associated with the queues or channels included in the filter. You can include both queue IDs and queue ARNs in the same request. VOICE, CHAT, and TASK channels are supported.</p> <note>
        /// <p>To filter by <code>Queues</code>, enter the queue ID/ARN, not the name of the queue.</p>
        /// </note>
        pub fn filters(mut self, input: crate::model::Filters) -> Self {
            self.filters = Some(input);
            self
        }
        /// <p>The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is retrieved only for the resources associated with the queues or channels included in the filter. You can include both queue IDs and queue ARNs in the same request. VOICE, CHAT, and TASK channels are supported.</p> <note>
        /// <p>To filter by <code>Queues</code>, enter the queue ID/ARN, not the name of the queue.</p>
        /// </note>
        pub fn set_filters(mut self, input: std::option::Option<crate::model::Filters>) -> Self {
            self.filters = input;
            self
        }
        /// Appends an item to `groupings`.
        ///
        /// To override the contents of this collection use [`set_groupings`](Self::set_groupings).
        ///
        /// <p>The grouping applied to the metrics returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values returned apply to the metrics for each queue rather than aggregated for all queues.</p>
        /// <p>If no grouping is specified, a summary of metrics for all queues is returned.</p>
        pub fn groupings(mut self, input: crate::model::Grouping) -> Self {
            let mut v = self.groupings.unwrap_or_default();
            v.push(input);
            self.groupings = Some(v);
            self
        }
        /// <p>The grouping applied to the metrics returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values returned apply to the metrics for each queue rather than aggregated for all queues.</p>
        /// <p>If no grouping is specified, a summary of metrics for all queues is returned.</p>
        pub fn set_groupings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Grouping>>,
        ) -> Self {
            self.groupings = input;
            self
        }
        /// Appends an item to `historical_metrics`.
        ///
        /// To override the contents of this collection use [`set_historical_metrics`](Self::set_historical_metrics).
        ///
        /// <p>The metrics to retrieve. Specify the name, unit, and statistic for each metric. The following historical metrics are available. For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p> <note>
        /// <p>This API does not support a contacts incoming metric (there's no CONTACTS_INCOMING metric missing from the documented list). </p>
        /// </note>
        /// <dl>
        /// <dt>
        /// ABANDON_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// AFTER_CONTACT_WORK_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// API_CONTACTS_HANDLED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CALLBACK_CONTACTS_HANDLED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_ABANDONED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_AGENT_HUNG_UP_FIRST
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_CONSULTED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_HANDLED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_HANDLED_INCOMING
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_HANDLED_OUTBOUND
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_HOLD_ABANDONS
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_MISSED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_QUEUED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_TRANSFERRED_IN
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_TRANSFERRED_IN_FROM_QUEUE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_TRANSFERRED_OUT
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_TRANSFERRED_OUT_FROM_QUEUE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// HANDLE_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// HOLD_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// INTERACTION_AND_HOLD_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// INTERACTION_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// OCCUPANCY
        /// </dt>
        /// <dd>
        /// <p>Unit: PERCENT</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// QUEUE_ANSWER_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// QUEUED_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: MAX</p>
        /// </dd>
        /// <dt>
        /// SERVICE_LEVEL
        /// </dt>
        /// <dd>
        /// <p>You can include up to 20 SERVICE_LEVEL metrics in a request.</p>
        /// <p>Unit: PERCENT</p>
        /// <p>Statistic: AVG</p>
        /// <p>Threshold: For <code>ThresholdValue</code>, enter any whole number from 1 to 604800 (inclusive), in seconds. For <code>Comparison</code>, you must enter <code>LT</code> (for "Less than"). </p>
        /// </dd>
        /// </dl>
        pub fn historical_metrics(mut self, input: crate::model::HistoricalMetric) -> Self {
            let mut v = self.historical_metrics.unwrap_or_default();
            v.push(input);
            self.historical_metrics = Some(v);
            self
        }
        /// <p>The metrics to retrieve. Specify the name, unit, and statistic for each metric. The following historical metrics are available. For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p> <note>
        /// <p>This API does not support a contacts incoming metric (there's no CONTACTS_INCOMING metric missing from the documented list). </p>
        /// </note>
        /// <dl>
        /// <dt>
        /// ABANDON_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// AFTER_CONTACT_WORK_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// API_CONTACTS_HANDLED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CALLBACK_CONTACTS_HANDLED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_ABANDONED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_AGENT_HUNG_UP_FIRST
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_CONSULTED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_HANDLED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_HANDLED_INCOMING
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_HANDLED_OUTBOUND
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_HOLD_ABANDONS
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_MISSED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_QUEUED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_TRANSFERRED_IN
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_TRANSFERRED_IN_FROM_QUEUE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_TRANSFERRED_OUT
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// CONTACTS_TRANSFERRED_OUT_FROM_QUEUE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Statistic: SUM</p>
        /// </dd>
        /// <dt>
        /// HANDLE_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// HOLD_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// INTERACTION_AND_HOLD_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// INTERACTION_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// OCCUPANCY
        /// </dt>
        /// <dd>
        /// <p>Unit: PERCENT</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// QUEUE_ANSWER_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: AVG</p>
        /// </dd>
        /// <dt>
        /// QUEUED_TIME
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>Statistic: MAX</p>
        /// </dd>
        /// <dt>
        /// SERVICE_LEVEL
        /// </dt>
        /// <dd>
        /// <p>You can include up to 20 SERVICE_LEVEL metrics in a request.</p>
        /// <p>Unit: PERCENT</p>
        /// <p>Statistic: AVG</p>
        /// <p>Threshold: For <code>ThresholdValue</code>, enter any whole number from 1 to 604800 (inclusive), in seconds. For <code>Comparison</code>, you must enter <code>LT</code> (for "Less than"). </p>
        /// </dd>
        /// </dl>
        pub fn set_historical_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HistoricalMetric>>,
        ) -> Self {
            self.historical_metrics = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMetricDataInput`](crate::input::GetMetricDataInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetMetricDataInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetMetricDataInput {
                instance_id: self.instance_id,
                start_time: self.start_time,
                end_time: self.end_time,
                filters: self.filters,
                groupings: self.groupings,
                historical_metrics: self.historical_metrics,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetFederationTokenInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl GetFederationTokenInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl GetFederationTokenInput {
    /// Creates a new builder-style object to manufacture [`GetFederationTokenInput`](crate::input::GetFederationTokenInput).
    pub fn builder() -> crate::input::get_federation_token_input::Builder {
        crate::input::get_federation_token_input::Builder::default()
    }
}

/// See [`GetFederationTokenInput`](crate::input::GetFederationTokenInput).
pub mod get_federation_token_input {

    /// A builder for [`GetFederationTokenInput`](crate::input::GetFederationTokenInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetFederationTokenInput`](crate::input::GetFederationTokenInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetFederationTokenInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetFederationTokenInput {
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCurrentUserDataInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The filters to apply to returned user data. You can filter up to the following limits:</p>
    /// <ul>
    /// <li> <p>Queues: 100</p> </li>
    /// <li> <p>Routing profiles: 100</p> </li>
    /// <li> <p>Agents: 100</p> </li>
    /// <li> <p>Contact states: 9</p> </li>
    /// <li> <p>User hierarchy groups: 1</p> </li>
    /// </ul>
    /// <p> The user data is retrieved for only the specified values/resources in the filter. A maximum of one filter can be passed from queues, routing profiles, agents, and user hierarchy groups. </p>
    /// <p>Currently tagging is only supported on the resources that are passed in the filter.</p>
    #[doc(hidden)]
    pub filters: std::option::Option<crate::model::UserDataFilters>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetCurrentUserDataInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The filters to apply to returned user data. You can filter up to the following limits:</p>
    /// <ul>
    /// <li> <p>Queues: 100</p> </li>
    /// <li> <p>Routing profiles: 100</p> </li>
    /// <li> <p>Agents: 100</p> </li>
    /// <li> <p>Contact states: 9</p> </li>
    /// <li> <p>User hierarchy groups: 1</p> </li>
    /// </ul>
    /// <p> The user data is retrieved for only the specified values/resources in the filter. A maximum of one filter can be passed from queues, routing profiles, agents, and user hierarchy groups. </p>
    /// <p>Currently tagging is only supported on the resources that are passed in the filter.</p>
    pub fn filters(&self) -> std::option::Option<&crate::model::UserDataFilters> {
        self.filters.as_ref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl GetCurrentUserDataInput {
    /// Creates a new builder-style object to manufacture [`GetCurrentUserDataInput`](crate::input::GetCurrentUserDataInput).
    pub fn builder() -> crate::input::get_current_user_data_input::Builder {
        crate::input::get_current_user_data_input::Builder::default()
    }
}

/// See [`GetCurrentUserDataInput`](crate::input::GetCurrentUserDataInput).
pub mod get_current_user_data_input {

    /// A builder for [`GetCurrentUserDataInput`](crate::input::GetCurrentUserDataInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) filters: std::option::Option<crate::model::UserDataFilters>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The filters to apply to returned user data. You can filter up to the following limits:</p>
        /// <ul>
        /// <li> <p>Queues: 100</p> </li>
        /// <li> <p>Routing profiles: 100</p> </li>
        /// <li> <p>Agents: 100</p> </li>
        /// <li> <p>Contact states: 9</p> </li>
        /// <li> <p>User hierarchy groups: 1</p> </li>
        /// </ul>
        /// <p> The user data is retrieved for only the specified values/resources in the filter. A maximum of one filter can be passed from queues, routing profiles, agents, and user hierarchy groups. </p>
        /// <p>Currently tagging is only supported on the resources that are passed in the filter.</p>
        pub fn filters(mut self, input: crate::model::UserDataFilters) -> Self {
            self.filters = Some(input);
            self
        }
        /// <p>The filters to apply to returned user data. You can filter up to the following limits:</p>
        /// <ul>
        /// <li> <p>Queues: 100</p> </li>
        /// <li> <p>Routing profiles: 100</p> </li>
        /// <li> <p>Agents: 100</p> </li>
        /// <li> <p>Contact states: 9</p> </li>
        /// <li> <p>User hierarchy groups: 1</p> </li>
        /// </ul>
        /// <p> The user data is retrieved for only the specified values/resources in the filter. A maximum of one filter can be passed from queues, routing profiles, agents, and user hierarchy groups. </p>
        /// <p>Currently tagging is only supported on the resources that are passed in the filter.</p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<crate::model::UserDataFilters>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCurrentUserDataInput`](crate::input::GetCurrentUserDataInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetCurrentUserDataInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetCurrentUserDataInput {
                instance_id: self.instance_id,
                filters: self.filters,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCurrentMetricDataInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The filters to apply to returned metrics. You can filter up to the following limits:</p>
    /// <ul>
    /// <li> <p>Queues: 100</p> </li>
    /// <li> <p>Routing profiles: 100</p> </li>
    /// <li> <p>Channels: 3 (VOICE, CHAT, and TASK channels are supported.)</p> </li>
    /// </ul>
    /// <p>Metric data is retrieved only for the resources associated with the queues or routing profiles, and by any channels included in the filter. (You cannot filter by both queue AND routing profile.) You can include both resource IDs and resource ARNs in the same request. </p>
    /// <p>Currently tagging is only supported on the resources that are passed in the filter.</p>
    #[doc(hidden)]
    pub filters: std::option::Option<crate::model::Filters>,
    /// <p>The grouping applied to the metrics returned. For example, when grouped by <code>QUEUE</code>, the metrics returned apply to each queue rather than aggregated for all queues. </p>
    /// <ul>
    /// <li> <p>If you group by <code>CHANNEL</code>, you should include a Channels filter. VOICE, CHAT, and TASK channels are supported.</p> </li>
    /// <li> <p>If you group by <code>ROUTING_PROFILE</code>, you must include either a queue or routing profile filter. In addition, a routing profile filter is required for metrics <code>CONTACTS_SCHEDULED</code>, <code>CONTACTS_IN_QUEUE</code>, and <code> OLDEST_CONTACT_AGE</code>.</p> </li>
    /// <li> <p>If no <code>Grouping</code> is included in the request, a summary of metrics is returned.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub groupings: std::option::Option<std::vec::Vec<crate::model::Grouping>>,
    /// <p>The metrics to retrieve. Specify the name and unit for each metric. The following metrics are available. For a description of all the metrics, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    /// <dl>
    /// <dt>
    /// AGENTS_AFTER_CONTACT_WORK
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#aftercallwork-real-time">ACW</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_AVAILABLE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#available-real-time">Available</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_ERROR
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#error-real-time">Error</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_NON_PRODUCTIVE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#non-productive-time-real-time">NPT (Non-Productive Time)</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_ON_CALL
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On contact</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_ON_CONTACT
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On contact</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_ONLINE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#online-real-time">Online</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_STAFFED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#staffed-real-time">Staffed</a> </p>
    /// </dd>
    /// <dt>
    /// CONTACTS_IN_QUEUE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#in-queue-real-time">In queue</a> </p>
    /// </dd>
    /// <dt>
    /// CONTACTS_SCHEDULED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#scheduled-real-time">Scheduled</a> </p>
    /// </dd>
    /// <dt>
    /// OLDEST_CONTACT_AGE
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>When you use groupings, Unit says SECONDS and the Value is returned in SECONDS. </p>
    /// <p>When you do not use groupings, Unit says SECONDS but the Value is returned in MILLISECONDS. For example, if you get a response like this:</p>
    /// <p> <code>{ "Metric": { "Name": "OLDEST_CONTACT_AGE", "Unit": "SECONDS" }, "Value": 24113.0 </code>}</p>
    /// <p>The actual OLDEST_CONTACT_AGE is 24 seconds.</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#oldest-real-time">Oldest</a> </p>
    /// </dd>
    /// <dt>
    /// SLOTS_ACTIVE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#active-real-time">Active</a> </p>
    /// </dd>
    /// <dt>
    /// SLOTS_AVAILABLE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#availability-real-time">Availability</a> </p>
    /// </dd>
    /// </dl>
    #[doc(hidden)]
    pub current_metrics: std::option::Option<std::vec::Vec<crate::model::CurrentMetric>>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    /// <p>The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The way to sort the resulting response based on metrics. You can enter one sort criteria. By default resources are sorted based on <code>AGENTS_ONLINE</code>, <code>DESCENDING</code>. The metric collection is sorted based on the input metrics.</p>
    /// <p>Note the following:</p>
    /// <ul>
    /// <li> <p>Sorting on <code>SLOTS_ACTIVE</code> and <code>SLOTS_AVAILABLE</code> is not supported.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub sort_criteria: std::option::Option<std::vec::Vec<crate::model::CurrentMetricSortCriteria>>,
}
impl GetCurrentMetricDataInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The filters to apply to returned metrics. You can filter up to the following limits:</p>
    /// <ul>
    /// <li> <p>Queues: 100</p> </li>
    /// <li> <p>Routing profiles: 100</p> </li>
    /// <li> <p>Channels: 3 (VOICE, CHAT, and TASK channels are supported.)</p> </li>
    /// </ul>
    /// <p>Metric data is retrieved only for the resources associated with the queues or routing profiles, and by any channels included in the filter. (You cannot filter by both queue AND routing profile.) You can include both resource IDs and resource ARNs in the same request. </p>
    /// <p>Currently tagging is only supported on the resources that are passed in the filter.</p>
    pub fn filters(&self) -> std::option::Option<&crate::model::Filters> {
        self.filters.as_ref()
    }
    /// <p>The grouping applied to the metrics returned. For example, when grouped by <code>QUEUE</code>, the metrics returned apply to each queue rather than aggregated for all queues. </p>
    /// <ul>
    /// <li> <p>If you group by <code>CHANNEL</code>, you should include a Channels filter. VOICE, CHAT, and TASK channels are supported.</p> </li>
    /// <li> <p>If you group by <code>ROUTING_PROFILE</code>, you must include either a queue or routing profile filter. In addition, a routing profile filter is required for metrics <code>CONTACTS_SCHEDULED</code>, <code>CONTACTS_IN_QUEUE</code>, and <code> OLDEST_CONTACT_AGE</code>.</p> </li>
    /// <li> <p>If no <code>Grouping</code> is included in the request, a summary of metrics is returned.</p> </li>
    /// </ul>
    pub fn groupings(&self) -> std::option::Option<&[crate::model::Grouping]> {
        self.groupings.as_deref()
    }
    /// <p>The metrics to retrieve. Specify the name and unit for each metric. The following metrics are available. For a description of all the metrics, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    /// <dl>
    /// <dt>
    /// AGENTS_AFTER_CONTACT_WORK
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#aftercallwork-real-time">ACW</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_AVAILABLE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#available-real-time">Available</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_ERROR
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#error-real-time">Error</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_NON_PRODUCTIVE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#non-productive-time-real-time">NPT (Non-Productive Time)</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_ON_CALL
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On contact</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_ON_CONTACT
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On contact</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_ONLINE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#online-real-time">Online</a> </p>
    /// </dd>
    /// <dt>
    /// AGENTS_STAFFED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#staffed-real-time">Staffed</a> </p>
    /// </dd>
    /// <dt>
    /// CONTACTS_IN_QUEUE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#in-queue-real-time">In queue</a> </p>
    /// </dd>
    /// <dt>
    /// CONTACTS_SCHEDULED
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#scheduled-real-time">Scheduled</a> </p>
    /// </dd>
    /// <dt>
    /// OLDEST_CONTACT_AGE
    /// </dt>
    /// <dd>
    /// <p>Unit: SECONDS</p>
    /// <p>When you use groupings, Unit says SECONDS and the Value is returned in SECONDS. </p>
    /// <p>When you do not use groupings, Unit says SECONDS but the Value is returned in MILLISECONDS. For example, if you get a response like this:</p>
    /// <p> <code>{ "Metric": { "Name": "OLDEST_CONTACT_AGE", "Unit": "SECONDS" }, "Value": 24113.0 </code>}</p>
    /// <p>The actual OLDEST_CONTACT_AGE is 24 seconds.</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#oldest-real-time">Oldest</a> </p>
    /// </dd>
    /// <dt>
    /// SLOTS_ACTIVE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#active-real-time">Active</a> </p>
    /// </dd>
    /// <dt>
    /// SLOTS_AVAILABLE
    /// </dt>
    /// <dd>
    /// <p>Unit: COUNT</p>
    /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#availability-real-time">Availability</a> </p>
    /// </dd>
    /// </dl>
    pub fn current_metrics(&self) -> std::option::Option<&[crate::model::CurrentMetric]> {
        self.current_metrics.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    /// <p>The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The way to sort the resulting response based on metrics. You can enter one sort criteria. By default resources are sorted based on <code>AGENTS_ONLINE</code>, <code>DESCENDING</code>. The metric collection is sorted based on the input metrics.</p>
    /// <p>Note the following:</p>
    /// <ul>
    /// <li> <p>Sorting on <code>SLOTS_ACTIVE</code> and <code>SLOTS_AVAILABLE</code> is not supported.</p> </li>
    /// </ul>
    pub fn sort_criteria(&self) -> std::option::Option<&[crate::model::CurrentMetricSortCriteria]> {
        self.sort_criteria.as_deref()
    }
}
impl GetCurrentMetricDataInput {
    /// Creates a new builder-style object to manufacture [`GetCurrentMetricDataInput`](crate::input::GetCurrentMetricDataInput).
    pub fn builder() -> crate::input::get_current_metric_data_input::Builder {
        crate::input::get_current_metric_data_input::Builder::default()
    }
}

/// See [`GetCurrentMetricDataInput`](crate::input::GetCurrentMetricDataInput).
pub mod get_current_metric_data_input {

    /// A builder for [`GetCurrentMetricDataInput`](crate::input::GetCurrentMetricDataInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) filters: std::option::Option<crate::model::Filters>,
        pub(crate) groupings: std::option::Option<std::vec::Vec<crate::model::Grouping>>,
        pub(crate) current_metrics: std::option::Option<std::vec::Vec<crate::model::CurrentMetric>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) sort_criteria:
            std::option::Option<std::vec::Vec<crate::model::CurrentMetricSortCriteria>>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The filters to apply to returned metrics. You can filter up to the following limits:</p>
        /// <ul>
        /// <li> <p>Queues: 100</p> </li>
        /// <li> <p>Routing profiles: 100</p> </li>
        /// <li> <p>Channels: 3 (VOICE, CHAT, and TASK channels are supported.)</p> </li>
        /// </ul>
        /// <p>Metric data is retrieved only for the resources associated with the queues or routing profiles, and by any channels included in the filter. (You cannot filter by both queue AND routing profile.) You can include both resource IDs and resource ARNs in the same request. </p>
        /// <p>Currently tagging is only supported on the resources that are passed in the filter.</p>
        pub fn filters(mut self, input: crate::model::Filters) -> Self {
            self.filters = Some(input);
            self
        }
        /// <p>The filters to apply to returned metrics. You can filter up to the following limits:</p>
        /// <ul>
        /// <li> <p>Queues: 100</p> </li>
        /// <li> <p>Routing profiles: 100</p> </li>
        /// <li> <p>Channels: 3 (VOICE, CHAT, and TASK channels are supported.)</p> </li>
        /// </ul>
        /// <p>Metric data is retrieved only for the resources associated with the queues or routing profiles, and by any channels included in the filter. (You cannot filter by both queue AND routing profile.) You can include both resource IDs and resource ARNs in the same request. </p>
        /// <p>Currently tagging is only supported on the resources that are passed in the filter.</p>
        pub fn set_filters(mut self, input: std::option::Option<crate::model::Filters>) -> Self {
            self.filters = input;
            self
        }
        /// Appends an item to `groupings`.
        ///
        /// To override the contents of this collection use [`set_groupings`](Self::set_groupings).
        ///
        /// <p>The grouping applied to the metrics returned. For example, when grouped by <code>QUEUE</code>, the metrics returned apply to each queue rather than aggregated for all queues. </p>
        /// <ul>
        /// <li> <p>If you group by <code>CHANNEL</code>, you should include a Channels filter. VOICE, CHAT, and TASK channels are supported.</p> </li>
        /// <li> <p>If you group by <code>ROUTING_PROFILE</code>, you must include either a queue or routing profile filter. In addition, a routing profile filter is required for metrics <code>CONTACTS_SCHEDULED</code>, <code>CONTACTS_IN_QUEUE</code>, and <code> OLDEST_CONTACT_AGE</code>.</p> </li>
        /// <li> <p>If no <code>Grouping</code> is included in the request, a summary of metrics is returned.</p> </li>
        /// </ul>
        pub fn groupings(mut self, input: crate::model::Grouping) -> Self {
            let mut v = self.groupings.unwrap_or_default();
            v.push(input);
            self.groupings = Some(v);
            self
        }
        /// <p>The grouping applied to the metrics returned. For example, when grouped by <code>QUEUE</code>, the metrics returned apply to each queue rather than aggregated for all queues. </p>
        /// <ul>
        /// <li> <p>If you group by <code>CHANNEL</code>, you should include a Channels filter. VOICE, CHAT, and TASK channels are supported.</p> </li>
        /// <li> <p>If you group by <code>ROUTING_PROFILE</code>, you must include either a queue or routing profile filter. In addition, a routing profile filter is required for metrics <code>CONTACTS_SCHEDULED</code>, <code>CONTACTS_IN_QUEUE</code>, and <code> OLDEST_CONTACT_AGE</code>.</p> </li>
        /// <li> <p>If no <code>Grouping</code> is included in the request, a summary of metrics is returned.</p> </li>
        /// </ul>
        pub fn set_groupings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Grouping>>,
        ) -> Self {
            self.groupings = input;
            self
        }
        /// Appends an item to `current_metrics`.
        ///
        /// To override the contents of this collection use [`set_current_metrics`](Self::set_current_metrics).
        ///
        /// <p>The metrics to retrieve. Specify the name and unit for each metric. The following metrics are available. For a description of all the metrics, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        /// <dl>
        /// <dt>
        /// AGENTS_AFTER_CONTACT_WORK
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#aftercallwork-real-time">ACW</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_AVAILABLE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#available-real-time">Available</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_ERROR
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#error-real-time">Error</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_NON_PRODUCTIVE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#non-productive-time-real-time">NPT (Non-Productive Time)</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_ON_CALL
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On contact</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_ON_CONTACT
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On contact</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_ONLINE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#online-real-time">Online</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_STAFFED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#staffed-real-time">Staffed</a> </p>
        /// </dd>
        /// <dt>
        /// CONTACTS_IN_QUEUE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#in-queue-real-time">In queue</a> </p>
        /// </dd>
        /// <dt>
        /// CONTACTS_SCHEDULED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#scheduled-real-time">Scheduled</a> </p>
        /// </dd>
        /// <dt>
        /// OLDEST_CONTACT_AGE
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>When you use groupings, Unit says SECONDS and the Value is returned in SECONDS. </p>
        /// <p>When you do not use groupings, Unit says SECONDS but the Value is returned in MILLISECONDS. For example, if you get a response like this:</p>
        /// <p> <code>{ "Metric": { "Name": "OLDEST_CONTACT_AGE", "Unit": "SECONDS" }, "Value": 24113.0 </code>}</p>
        /// <p>The actual OLDEST_CONTACT_AGE is 24 seconds.</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#oldest-real-time">Oldest</a> </p>
        /// </dd>
        /// <dt>
        /// SLOTS_ACTIVE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#active-real-time">Active</a> </p>
        /// </dd>
        /// <dt>
        /// SLOTS_AVAILABLE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#availability-real-time">Availability</a> </p>
        /// </dd>
        /// </dl>
        pub fn current_metrics(mut self, input: crate::model::CurrentMetric) -> Self {
            let mut v = self.current_metrics.unwrap_or_default();
            v.push(input);
            self.current_metrics = Some(v);
            self
        }
        /// <p>The metrics to retrieve. Specify the name and unit for each metric. The following metrics are available. For a description of all the metrics, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        /// <dl>
        /// <dt>
        /// AGENTS_AFTER_CONTACT_WORK
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#aftercallwork-real-time">ACW</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_AVAILABLE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#available-real-time">Available</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_ERROR
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#error-real-time">Error</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_NON_PRODUCTIVE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#non-productive-time-real-time">NPT (Non-Productive Time)</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_ON_CALL
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On contact</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_ON_CONTACT
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On contact</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_ONLINE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#online-real-time">Online</a> </p>
        /// </dd>
        /// <dt>
        /// AGENTS_STAFFED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#staffed-real-time">Staffed</a> </p>
        /// </dd>
        /// <dt>
        /// CONTACTS_IN_QUEUE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#in-queue-real-time">In queue</a> </p>
        /// </dd>
        /// <dt>
        /// CONTACTS_SCHEDULED
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#scheduled-real-time">Scheduled</a> </p>
        /// </dd>
        /// <dt>
        /// OLDEST_CONTACT_AGE
        /// </dt>
        /// <dd>
        /// <p>Unit: SECONDS</p>
        /// <p>When you use groupings, Unit says SECONDS and the Value is returned in SECONDS. </p>
        /// <p>When you do not use groupings, Unit says SECONDS but the Value is returned in MILLISECONDS. For example, if you get a response like this:</p>
        /// <p> <code>{ "Metric": { "Name": "OLDEST_CONTACT_AGE", "Unit": "SECONDS" }, "Value": 24113.0 </code>}</p>
        /// <p>The actual OLDEST_CONTACT_AGE is 24 seconds.</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#oldest-real-time">Oldest</a> </p>
        /// </dd>
        /// <dt>
        /// SLOTS_ACTIVE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#active-real-time">Active</a> </p>
        /// </dd>
        /// <dt>
        /// SLOTS_AVAILABLE
        /// </dt>
        /// <dd>
        /// <p>Unit: COUNT</p>
        /// <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#availability-real-time">Availability</a> </p>
        /// </dd>
        /// </dl>
        pub fn set_current_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CurrentMetric>>,
        ) -> Self {
            self.current_metrics = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        /// <p>The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        /// <p>The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Appends an item to `sort_criteria`.
        ///
        /// To override the contents of this collection use [`set_sort_criteria`](Self::set_sort_criteria).
        ///
        /// <p>The way to sort the resulting response based on metrics. You can enter one sort criteria. By default resources are sorted based on <code>AGENTS_ONLINE</code>, <code>DESCENDING</code>. The metric collection is sorted based on the input metrics.</p>
        /// <p>Note the following:</p>
        /// <ul>
        /// <li> <p>Sorting on <code>SLOTS_ACTIVE</code> and <code>SLOTS_AVAILABLE</code> is not supported.</p> </li>
        /// </ul>
        pub fn sort_criteria(mut self, input: crate::model::CurrentMetricSortCriteria) -> Self {
            let mut v = self.sort_criteria.unwrap_or_default();
            v.push(input);
            self.sort_criteria = Some(v);
            self
        }
        /// <p>The way to sort the resulting response based on metrics. You can enter one sort criteria. By default resources are sorted based on <code>AGENTS_ONLINE</code>, <code>DESCENDING</code>. The metric collection is sorted based on the input metrics.</p>
        /// <p>Note the following:</p>
        /// <ul>
        /// <li> <p>Sorting on <code>SLOTS_ACTIVE</code> and <code>SLOTS_AVAILABLE</code> is not supported.</p> </li>
        /// </ul>
        pub fn set_sort_criteria(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CurrentMetricSortCriteria>>,
        ) -> Self {
            self.sort_criteria = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCurrentMetricDataInput`](crate::input::GetCurrentMetricDataInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetCurrentMetricDataInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetCurrentMetricDataInput {
                instance_id: self.instance_id,
                filters: self.filters,
                groupings: self.groupings,
                current_metrics: self.current_metrics,
                next_token: self.next_token,
                max_results: self.max_results,
                sort_criteria: self.sort_criteria,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetContactAttributesInput {
    /// <p>The identifier of the Amazon Connect instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the initial contact.</p>
    #[doc(hidden)]
    pub initial_contact_id: std::option::Option<std::string::String>,
}
impl GetContactAttributesInput {
    /// <p>The identifier of the Amazon Connect instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the initial contact.</p>
    pub fn initial_contact_id(&self) -> std::option::Option<&str> {
        self.initial_contact_id.as_deref()
    }
}
impl GetContactAttributesInput {
    /// Creates a new builder-style object to manufacture [`GetContactAttributesInput`](crate::input::GetContactAttributesInput).
    pub fn builder() -> crate::input::get_contact_attributes_input::Builder {
        crate::input::get_contact_attributes_input::Builder::default()
    }
}

/// See [`GetContactAttributesInput`](crate::input::GetContactAttributesInput).
pub mod get_contact_attributes_input {

    /// A builder for [`GetContactAttributesInput`](crate::input::GetContactAttributesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) initial_contact_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the initial contact.</p>
        pub fn initial_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.initial_contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the initial contact.</p>
        pub fn set_initial_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_contact_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetContactAttributesInput`](crate::input::GetContactAttributesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetContactAttributesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetContactAttributesInput {
                instance_id: self.instance_id,
                initial_contact_id: self.initial_contact_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DismissUserContactInput {
    /// <p>The identifier of the user account.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
}
impl DismissUserContactInput {
    /// <p>The identifier of the user account.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the contact.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
}
impl DismissUserContactInput {
    /// Creates a new builder-style object to manufacture [`DismissUserContactInput`](crate::input::DismissUserContactInput).
    pub fn builder() -> crate::input::dismiss_user_contact_input::Builder {
        crate::input::dismiss_user_contact_input::Builder::default()
    }
}

/// See [`DismissUserContactInput`](crate::input::DismissUserContactInput).
pub mod dismiss_user_contact_input {

    /// A builder for [`DismissUserContactInput`](crate::input::DismissUserContactInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the user account.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DismissUserContactInput`](crate::input::DismissUserContactInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DismissUserContactInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DismissUserContactInput {
                user_id: self.user_id,
                instance_id: self.instance_id,
                contact_id: self.contact_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateSecurityKeyInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    #[doc(hidden)]
    pub association_id: std::option::Option<std::string::String>,
}
impl DisassociateSecurityKeyInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    pub fn association_id(&self) -> std::option::Option<&str> {
        self.association_id.as_deref()
    }
}
impl DisassociateSecurityKeyInput {
    /// Creates a new builder-style object to manufacture [`DisassociateSecurityKeyInput`](crate::input::DisassociateSecurityKeyInput).
    pub fn builder() -> crate::input::disassociate_security_key_input::Builder {
        crate::input::disassociate_security_key_input::Builder::default()
    }
}

/// See [`DisassociateSecurityKeyInput`](crate::input::DisassociateSecurityKeyInput).
pub mod disassociate_security_key_input {

    /// A builder for [`DisassociateSecurityKeyInput`](crate::input::DisassociateSecurityKeyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) association_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateSecurityKeyInput`](crate::input::DisassociateSecurityKeyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateSecurityKeyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociateSecurityKeyInput {
                instance_id: self.instance_id,
                association_id: self.association_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateRoutingProfileQueuesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the routing profile.</p>
    #[doc(hidden)]
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The queues to disassociate from this routing profile.</p>
    #[doc(hidden)]
    pub queue_references:
        std::option::Option<std::vec::Vec<crate::model::RoutingProfileQueueReference>>,
}
impl DisassociateRoutingProfileQueuesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the routing profile.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The queues to disassociate from this routing profile.</p>
    pub fn queue_references(
        &self,
    ) -> std::option::Option<&[crate::model::RoutingProfileQueueReference]> {
        self.queue_references.as_deref()
    }
}
impl DisassociateRoutingProfileQueuesInput {
    /// Creates a new builder-style object to manufacture [`DisassociateRoutingProfileQueuesInput`](crate::input::DisassociateRoutingProfileQueuesInput).
    pub fn builder() -> crate::input::disassociate_routing_profile_queues_input::Builder {
        crate::input::disassociate_routing_profile_queues_input::Builder::default()
    }
}

/// See [`DisassociateRoutingProfileQueuesInput`](crate::input::DisassociateRoutingProfileQueuesInput).
pub mod disassociate_routing_profile_queues_input {

    /// A builder for [`DisassociateRoutingProfileQueuesInput`](crate::input::DisassociateRoutingProfileQueuesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) queue_references:
            std::option::Option<std::vec::Vec<crate::model::RoutingProfileQueueReference>>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// Appends an item to `queue_references`.
        ///
        /// To override the contents of this collection use [`set_queue_references`](Self::set_queue_references).
        ///
        /// <p>The queues to disassociate from this routing profile.</p>
        pub fn queue_references(
            mut self,
            input: crate::model::RoutingProfileQueueReference,
        ) -> Self {
            let mut v = self.queue_references.unwrap_or_default();
            v.push(input);
            self.queue_references = Some(v);
            self
        }
        /// <p>The queues to disassociate from this routing profile.</p>
        pub fn set_queue_references(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RoutingProfileQueueReference>>,
        ) -> Self {
            self.queue_references = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateRoutingProfileQueuesInput`](crate::input::DisassociateRoutingProfileQueuesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateRoutingProfileQueuesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociateRoutingProfileQueuesInput {
                instance_id: self.instance_id,
                routing_profile_id: self.routing_profile_id,
                queue_references: self.queue_references,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateQueueQuickConnectsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The quick connects to disassociate from the queue.</p>
    #[doc(hidden)]
    pub quick_connect_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DisassociateQueueQuickConnectsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The quick connects to disassociate from the queue.</p>
    pub fn quick_connect_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.quick_connect_ids.as_deref()
    }
}
impl DisassociateQueueQuickConnectsInput {
    /// Creates a new builder-style object to manufacture [`DisassociateQueueQuickConnectsInput`](crate::input::DisassociateQueueQuickConnectsInput).
    pub fn builder() -> crate::input::disassociate_queue_quick_connects_input::Builder {
        crate::input::disassociate_queue_quick_connects_input::Builder::default()
    }
}

/// See [`DisassociateQueueQuickConnectsInput`](crate::input::DisassociateQueueQuickConnectsInput).
pub mod disassociate_queue_quick_connects_input {

    /// A builder for [`DisassociateQueueQuickConnectsInput`](crate::input::DisassociateQueueQuickConnectsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) quick_connect_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// Appends an item to `quick_connect_ids`.
        ///
        /// To override the contents of this collection use [`set_quick_connect_ids`](Self::set_quick_connect_ids).
        ///
        /// <p>The quick connects to disassociate from the queue.</p>
        pub fn quick_connect_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.quick_connect_ids.unwrap_or_default();
            v.push(input.into());
            self.quick_connect_ids = Some(v);
            self
        }
        /// <p>The quick connects to disassociate from the queue.</p>
        pub fn set_quick_connect_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.quick_connect_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateQueueQuickConnectsInput`](crate::input::DisassociateQueueQuickConnectsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateQueueQuickConnectsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociateQueueQuickConnectsInput {
                instance_id: self.instance_id,
                queue_id: self.queue_id,
                quick_connect_ids: self.quick_connect_ids,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociatePhoneNumberContactFlowInput {
    /// <p>A unique identifier for the phone number.</p>
    #[doc(hidden)]
    pub phone_number_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl DisassociatePhoneNumberContactFlowInput {
    /// <p>A unique identifier for the phone number.</p>
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl DisassociatePhoneNumberContactFlowInput {
    /// Creates a new builder-style object to manufacture [`DisassociatePhoneNumberContactFlowInput`](crate::input::DisassociatePhoneNumberContactFlowInput).
    pub fn builder() -> crate::input::disassociate_phone_number_contact_flow_input::Builder {
        crate::input::disassociate_phone_number_contact_flow_input::Builder::default()
    }
}

/// See [`DisassociatePhoneNumberContactFlowInput`](crate::input::DisassociatePhoneNumberContactFlowInput).
pub mod disassociate_phone_number_contact_flow_input {

    /// A builder for [`DisassociatePhoneNumberContactFlowInput`](crate::input::DisassociatePhoneNumberContactFlowInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for the phone number.</p>
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the phone number.</p>
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociatePhoneNumberContactFlowInput`](crate::input::DisassociatePhoneNumberContactFlowInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociatePhoneNumberContactFlowInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociatePhoneNumberContactFlowInput {
                phone_number_id: self.phone_number_id,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateLexBotInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon Lex bot. Maximum character limit of 50.</p>
    #[doc(hidden)]
    pub bot_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region in which the Amazon Lex bot has been created.</p>
    #[doc(hidden)]
    pub lex_region: std::option::Option<std::string::String>,
}
impl DisassociateLexBotInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the Amazon Lex bot. Maximum character limit of 50.</p>
    pub fn bot_name(&self) -> std::option::Option<&str> {
        self.bot_name.as_deref()
    }
    /// <p>The Amazon Web Services Region in which the Amazon Lex bot has been created.</p>
    pub fn lex_region(&self) -> std::option::Option<&str> {
        self.lex_region.as_deref()
    }
}
impl DisassociateLexBotInput {
    /// Creates a new builder-style object to manufacture [`DisassociateLexBotInput`](crate::input::DisassociateLexBotInput).
    pub fn builder() -> crate::input::disassociate_lex_bot_input::Builder {
        crate::input::disassociate_lex_bot_input::Builder::default()
    }
}

/// See [`DisassociateLexBotInput`](crate::input::DisassociateLexBotInput).
pub mod disassociate_lex_bot_input {

    /// A builder for [`DisassociateLexBotInput`](crate::input::DisassociateLexBotInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) bot_name: std::option::Option<std::string::String>,
        pub(crate) lex_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the Amazon Lex bot. Maximum character limit of 50.</p>
        pub fn bot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bot_name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Lex bot. Maximum character limit of 50.</p>
        pub fn set_bot_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bot_name = input;
            self
        }
        /// <p>The Amazon Web Services Region in which the Amazon Lex bot has been created.</p>
        pub fn lex_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.lex_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region in which the Amazon Lex bot has been created.</p>
        pub fn set_lex_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lex_region = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateLexBotInput`](crate::input::DisassociateLexBotInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateLexBotInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociateLexBotInput {
                instance_id: self.instance_id,
                bot_name: self.bot_name,
                lex_region: self.lex_region,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateLambdaFunctionInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance..</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Lambda function being disassociated.</p>
    #[doc(hidden)]
    pub function_arn: std::option::Option<std::string::String>,
}
impl DisassociateLambdaFunctionInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance..</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Lambda function being disassociated.</p>
    pub fn function_arn(&self) -> std::option::Option<&str> {
        self.function_arn.as_deref()
    }
}
impl DisassociateLambdaFunctionInput {
    /// Creates a new builder-style object to manufacture [`DisassociateLambdaFunctionInput`](crate::input::DisassociateLambdaFunctionInput).
    pub fn builder() -> crate::input::disassociate_lambda_function_input::Builder {
        crate::input::disassociate_lambda_function_input::Builder::default()
    }
}

/// See [`DisassociateLambdaFunctionInput`](crate::input::DisassociateLambdaFunctionInput).
pub mod disassociate_lambda_function_input {

    /// A builder for [`DisassociateLambdaFunctionInput`](crate::input::DisassociateLambdaFunctionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) function_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance..</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance..</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Lambda function being disassociated.</p>
        pub fn function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Lambda function being disassociated.</p>
        pub fn set_function_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateLambdaFunctionInput`](crate::input::DisassociateLambdaFunctionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateLambdaFunctionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociateLambdaFunctionInput {
                instance_id: self.instance_id,
                function_arn: self.function_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateInstanceStorageConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    #[doc(hidden)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>A valid resource type.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::InstanceStorageResourceType>,
}
impl DisassociateInstanceStorageConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    pub fn association_id(&self) -> std::option::Option<&str> {
        self.association_id.as_deref()
    }
    /// <p>A valid resource type.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::InstanceStorageResourceType> {
        self.resource_type.as_ref()
    }
}
impl DisassociateInstanceStorageConfigInput {
    /// Creates a new builder-style object to manufacture [`DisassociateInstanceStorageConfigInput`](crate::input::DisassociateInstanceStorageConfigInput).
    pub fn builder() -> crate::input::disassociate_instance_storage_config_input::Builder {
        crate::input::disassociate_instance_storage_config_input::Builder::default()
    }
}

/// See [`DisassociateInstanceStorageConfigInput`](crate::input::DisassociateInstanceStorageConfigInput).
pub mod disassociate_instance_storage_config_input {

    /// A builder for [`DisassociateInstanceStorageConfigInput`](crate::input::DisassociateInstanceStorageConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::InstanceStorageResourceType>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>A valid resource type.</p>
        pub fn resource_type(mut self, input: crate::model::InstanceStorageResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>A valid resource type.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::InstanceStorageResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateInstanceStorageConfigInput`](crate::input::DisassociateInstanceStorageConfigInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateInstanceStorageConfigInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociateInstanceStorageConfigInput {
                instance_id: self.instance_id,
                association_id: self.association_id,
                resource_type: self.resource_type,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateBotInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>Configuration information of an Amazon Lex bot.</p>
    #[doc(hidden)]
    pub lex_bot: std::option::Option<crate::model::LexBot>,
    /// <p>The Amazon Lex V2 bot to disassociate from the instance.</p>
    #[doc(hidden)]
    pub lex_v2_bot: std::option::Option<crate::model::LexV2Bot>,
}
impl DisassociateBotInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>Configuration information of an Amazon Lex bot.</p>
    pub fn lex_bot(&self) -> std::option::Option<&crate::model::LexBot> {
        self.lex_bot.as_ref()
    }
    /// <p>The Amazon Lex V2 bot to disassociate from the instance.</p>
    pub fn lex_v2_bot(&self) -> std::option::Option<&crate::model::LexV2Bot> {
        self.lex_v2_bot.as_ref()
    }
}
impl DisassociateBotInput {
    /// Creates a new builder-style object to manufacture [`DisassociateBotInput`](crate::input::DisassociateBotInput).
    pub fn builder() -> crate::input::disassociate_bot_input::Builder {
        crate::input::disassociate_bot_input::Builder::default()
    }
}

/// See [`DisassociateBotInput`](crate::input::DisassociateBotInput).
pub mod disassociate_bot_input {

    /// A builder for [`DisassociateBotInput`](crate::input::DisassociateBotInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) lex_bot: std::option::Option<crate::model::LexBot>,
        pub(crate) lex_v2_bot: std::option::Option<crate::model::LexV2Bot>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>Configuration information of an Amazon Lex bot.</p>
        pub fn lex_bot(mut self, input: crate::model::LexBot) -> Self {
            self.lex_bot = Some(input);
            self
        }
        /// <p>Configuration information of an Amazon Lex bot.</p>
        pub fn set_lex_bot(mut self, input: std::option::Option<crate::model::LexBot>) -> Self {
            self.lex_bot = input;
            self
        }
        /// <p>The Amazon Lex V2 bot to disassociate from the instance.</p>
        pub fn lex_v2_bot(mut self, input: crate::model::LexV2Bot) -> Self {
            self.lex_v2_bot = Some(input);
            self
        }
        /// <p>The Amazon Lex V2 bot to disassociate from the instance.</p>
        pub fn set_lex_v2_bot(
            mut self,
            input: std::option::Option<crate::model::LexV2Bot>,
        ) -> Self {
            self.lex_v2_bot = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateBotInput`](crate::input::DisassociateBotInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DisassociateBotInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DisassociateBotInput {
                instance_id: self.instance_id,
                lex_bot: self.lex_bot,
                lex_v2_bot: self.lex_v2_bot,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateApprovedOriginInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The domain URL of the integrated application.</p>
    #[doc(hidden)]
    pub origin: std::option::Option<std::string::String>,
}
impl DisassociateApprovedOriginInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The domain URL of the integrated application.</p>
    pub fn origin(&self) -> std::option::Option<&str> {
        self.origin.as_deref()
    }
}
impl DisassociateApprovedOriginInput {
    /// Creates a new builder-style object to manufacture [`DisassociateApprovedOriginInput`](crate::input::DisassociateApprovedOriginInput).
    pub fn builder() -> crate::input::disassociate_approved_origin_input::Builder {
        crate::input::disassociate_approved_origin_input::Builder::default()
    }
}

/// See [`DisassociateApprovedOriginInput`](crate::input::DisassociateApprovedOriginInput).
pub mod disassociate_approved_origin_input {

    /// A builder for [`DisassociateApprovedOriginInput`](crate::input::DisassociateApprovedOriginInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) origin: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The domain URL of the integrated application.</p>
        pub fn origin(mut self, input: impl Into<std::string::String>) -> Self {
            self.origin = Some(input.into());
            self
        }
        /// <p>The domain URL of the integrated application.</p>
        pub fn set_origin(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.origin = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateApprovedOriginInput`](crate::input::DisassociateApprovedOriginInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateApprovedOriginInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociateApprovedOriginInput {
                instance_id: self.instance_id,
                origin: self.origin,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeVocabularyInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the custom vocabulary.</p>
    #[doc(hidden)]
    pub vocabulary_id: std::option::Option<std::string::String>,
}
impl DescribeVocabularyInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the custom vocabulary.</p>
    pub fn vocabulary_id(&self) -> std::option::Option<&str> {
        self.vocabulary_id.as_deref()
    }
}
impl DescribeVocabularyInput {
    /// Creates a new builder-style object to manufacture [`DescribeVocabularyInput`](crate::input::DescribeVocabularyInput).
    pub fn builder() -> crate::input::describe_vocabulary_input::Builder {
        crate::input::describe_vocabulary_input::Builder::default()
    }
}

/// See [`DescribeVocabularyInput`](crate::input::DescribeVocabularyInput).
pub mod describe_vocabulary_input {

    /// A builder for [`DescribeVocabularyInput`](crate::input::DescribeVocabularyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) vocabulary_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn vocabulary_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_id = Some(input.into());
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn set_vocabulary_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeVocabularyInput`](crate::input::DescribeVocabularyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeVocabularyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeVocabularyInput {
                instance_id: self.instance_id,
                vocabulary_id: self.vocabulary_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeUserHierarchyStructureInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl DescribeUserHierarchyStructureInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl DescribeUserHierarchyStructureInput {
    /// Creates a new builder-style object to manufacture [`DescribeUserHierarchyStructureInput`](crate::input::DescribeUserHierarchyStructureInput).
    pub fn builder() -> crate::input::describe_user_hierarchy_structure_input::Builder {
        crate::input::describe_user_hierarchy_structure_input::Builder::default()
    }
}

/// See [`DescribeUserHierarchyStructureInput`](crate::input::DescribeUserHierarchyStructureInput).
pub mod describe_user_hierarchy_structure_input {

    /// A builder for [`DescribeUserHierarchyStructureInput`](crate::input::DescribeUserHierarchyStructureInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeUserHierarchyStructureInput`](crate::input::DescribeUserHierarchyStructureInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeUserHierarchyStructureInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeUserHierarchyStructureInput {
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeUserHierarchyGroupInput {
    /// <p>The identifier of the hierarchy group.</p>
    #[doc(hidden)]
    pub hierarchy_group_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl DescribeUserHierarchyGroupInput {
    /// <p>The identifier of the hierarchy group.</p>
    pub fn hierarchy_group_id(&self) -> std::option::Option<&str> {
        self.hierarchy_group_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl DescribeUserHierarchyGroupInput {
    /// Creates a new builder-style object to manufacture [`DescribeUserHierarchyGroupInput`](crate::input::DescribeUserHierarchyGroupInput).
    pub fn builder() -> crate::input::describe_user_hierarchy_group_input::Builder {
        crate::input::describe_user_hierarchy_group_input::Builder::default()
    }
}

/// See [`DescribeUserHierarchyGroupInput`](crate::input::DescribeUserHierarchyGroupInput).
pub mod describe_user_hierarchy_group_input {

    /// A builder for [`DescribeUserHierarchyGroupInput`](crate::input::DescribeUserHierarchyGroupInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hierarchy_group_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the hierarchy group.</p>
        pub fn hierarchy_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the hierarchy group.</p>
        pub fn set_hierarchy_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hierarchy_group_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeUserHierarchyGroupInput`](crate::input::DescribeUserHierarchyGroupInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeUserHierarchyGroupInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeUserHierarchyGroupInput {
                hierarchy_group_id: self.hierarchy_group_id,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeUserInput {
    /// <p>The identifier of the user account.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl DescribeUserInput {
    /// <p>The identifier of the user account.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl DescribeUserInput {
    /// Creates a new builder-style object to manufacture [`DescribeUserInput`](crate::input::DescribeUserInput).
    pub fn builder() -> crate::input::describe_user_input::Builder {
        crate::input::describe_user_input::Builder::default()
    }
}

/// See [`DescribeUserInput`](crate::input::DescribeUserInput).
pub mod describe_user_input {

    /// A builder for [`DescribeUserInput`](crate::input::DescribeUserInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the user account.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeUserInput`](crate::input::DescribeUserInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DescribeUserInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DescribeUserInput {
                user_id: self.user_id,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeTrafficDistributionGroupInput {
    /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
    #[doc(hidden)]
    pub traffic_distribution_group_id: std::option::Option<std::string::String>,
}
impl DescribeTrafficDistributionGroupInput {
    /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
    pub fn traffic_distribution_group_id(&self) -> std::option::Option<&str> {
        self.traffic_distribution_group_id.as_deref()
    }
}
impl DescribeTrafficDistributionGroupInput {
    /// Creates a new builder-style object to manufacture [`DescribeTrafficDistributionGroupInput`](crate::input::DescribeTrafficDistributionGroupInput).
    pub fn builder() -> crate::input::describe_traffic_distribution_group_input::Builder {
        crate::input::describe_traffic_distribution_group_input::Builder::default()
    }
}

/// See [`DescribeTrafficDistributionGroupInput`](crate::input::DescribeTrafficDistributionGroupInput).
pub mod describe_traffic_distribution_group_input {

    /// A builder for [`DescribeTrafficDistributionGroupInput`](crate::input::DescribeTrafficDistributionGroupInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) traffic_distribution_group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
        pub fn traffic_distribution_group_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.traffic_distribution_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
        pub fn set_traffic_distribution_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.traffic_distribution_group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeTrafficDistributionGroupInput`](crate::input::DescribeTrafficDistributionGroupInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeTrafficDistributionGroupInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeTrafficDistributionGroupInput {
                traffic_distribution_group_id: self.traffic_distribution_group_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeSecurityProfileInput {
    /// <p>The identifier for the security profle.</p>
    #[doc(hidden)]
    pub security_profile_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl DescribeSecurityProfileInput {
    /// <p>The identifier for the security profle.</p>
    pub fn security_profile_id(&self) -> std::option::Option<&str> {
        self.security_profile_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl DescribeSecurityProfileInput {
    /// Creates a new builder-style object to manufacture [`DescribeSecurityProfileInput`](crate::input::DescribeSecurityProfileInput).
    pub fn builder() -> crate::input::describe_security_profile_input::Builder {
        crate::input::describe_security_profile_input::Builder::default()
    }
}

/// See [`DescribeSecurityProfileInput`](crate::input::DescribeSecurityProfileInput).
pub mod describe_security_profile_input {

    /// A builder for [`DescribeSecurityProfileInput`](crate::input::DescribeSecurityProfileInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_profile_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the security profle.</p>
        pub fn security_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier for the security profle.</p>
        pub fn set_security_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeSecurityProfileInput`](crate::input::DescribeSecurityProfileInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeSecurityProfileInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeSecurityProfileInput {
                security_profile_id: self.security_profile_id,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeRuleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the rule.</p>
    #[doc(hidden)]
    pub rule_id: std::option::Option<std::string::String>,
}
impl DescribeRuleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>A unique identifier for the rule.</p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
}
impl DescribeRuleInput {
    /// Creates a new builder-style object to manufacture [`DescribeRuleInput`](crate::input::DescribeRuleInput).
    pub fn builder() -> crate::input::describe_rule_input::Builder {
        crate::input::describe_rule_input::Builder::default()
    }
}

/// See [`DescribeRuleInput`](crate::input::DescribeRuleInput).
pub mod describe_rule_input {

    /// A builder for [`DescribeRuleInput`](crate::input::DescribeRuleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) rule_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>A unique identifier for the rule.</p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the rule.</p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeRuleInput`](crate::input::DescribeRuleInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DescribeRuleInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DescribeRuleInput {
                instance_id: self.instance_id,
                rule_id: self.rule_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeRoutingProfileInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the routing profile.</p>
    #[doc(hidden)]
    pub routing_profile_id: std::option::Option<std::string::String>,
}
impl DescribeRoutingProfileInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the routing profile.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
}
impl DescribeRoutingProfileInput {
    /// Creates a new builder-style object to manufacture [`DescribeRoutingProfileInput`](crate::input::DescribeRoutingProfileInput).
    pub fn builder() -> crate::input::describe_routing_profile_input::Builder {
        crate::input::describe_routing_profile_input::Builder::default()
    }
}

/// See [`DescribeRoutingProfileInput`](crate::input::DescribeRoutingProfileInput).
pub mod describe_routing_profile_input {

    /// A builder for [`DescribeRoutingProfileInput`](crate::input::DescribeRoutingProfileInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeRoutingProfileInput`](crate::input::DescribeRoutingProfileInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeRoutingProfileInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeRoutingProfileInput {
                instance_id: self.instance_id,
                routing_profile_id: self.routing_profile_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeQuickConnectInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the quick connect.</p>
    #[doc(hidden)]
    pub quick_connect_id: std::option::Option<std::string::String>,
}
impl DescribeQuickConnectInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the quick connect.</p>
    pub fn quick_connect_id(&self) -> std::option::Option<&str> {
        self.quick_connect_id.as_deref()
    }
}
impl DescribeQuickConnectInput {
    /// Creates a new builder-style object to manufacture [`DescribeQuickConnectInput`](crate::input::DescribeQuickConnectInput).
    pub fn builder() -> crate::input::describe_quick_connect_input::Builder {
        crate::input::describe_quick_connect_input::Builder::default()
    }
}

/// See [`DescribeQuickConnectInput`](crate::input::DescribeQuickConnectInput).
pub mod describe_quick_connect_input {

    /// A builder for [`DescribeQuickConnectInput`](crate::input::DescribeQuickConnectInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) quick_connect_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn quick_connect_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.quick_connect_id = Some(input.into());
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn set_quick_connect_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.quick_connect_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeQuickConnectInput`](crate::input::DescribeQuickConnectInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeQuickConnectInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeQuickConnectInput {
                instance_id: self.instance_id,
                quick_connect_id: self.quick_connect_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeQueueInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
}
impl DescribeQueueInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
}
impl DescribeQueueInput {
    /// Creates a new builder-style object to manufacture [`DescribeQueueInput`](crate::input::DescribeQueueInput).
    pub fn builder() -> crate::input::describe_queue_input::Builder {
        crate::input::describe_queue_input::Builder::default()
    }
}

/// See [`DescribeQueueInput`](crate::input::DescribeQueueInput).
pub mod describe_queue_input {

    /// A builder for [`DescribeQueueInput`](crate::input::DescribeQueueInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) queue_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeQueueInput`](crate::input::DescribeQueueInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DescribeQueueInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DescribeQueueInput {
                instance_id: self.instance_id,
                queue_id: self.queue_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribePhoneNumberInput {
    /// <p>A unique identifier for the phone number.</p>
    #[doc(hidden)]
    pub phone_number_id: std::option::Option<std::string::String>,
}
impl DescribePhoneNumberInput {
    /// <p>A unique identifier for the phone number.</p>
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
}
impl DescribePhoneNumberInput {
    /// Creates a new builder-style object to manufacture [`DescribePhoneNumberInput`](crate::input::DescribePhoneNumberInput).
    pub fn builder() -> crate::input::describe_phone_number_input::Builder {
        crate::input::describe_phone_number_input::Builder::default()
    }
}

/// See [`DescribePhoneNumberInput`](crate::input::DescribePhoneNumberInput).
pub mod describe_phone_number_input {

    /// A builder for [`DescribePhoneNumberInput`](crate::input::DescribePhoneNumberInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for the phone number.</p>
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the phone number.</p>
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribePhoneNumberInput`](crate::input::DescribePhoneNumberInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribePhoneNumberInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribePhoneNumberInput {
                phone_number_id: self.phone_number_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeInstanceStorageConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    #[doc(hidden)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>A valid resource type.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::InstanceStorageResourceType>,
}
impl DescribeInstanceStorageConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    pub fn association_id(&self) -> std::option::Option<&str> {
        self.association_id.as_deref()
    }
    /// <p>A valid resource type.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::InstanceStorageResourceType> {
        self.resource_type.as_ref()
    }
}
impl DescribeInstanceStorageConfigInput {
    /// Creates a new builder-style object to manufacture [`DescribeInstanceStorageConfigInput`](crate::input::DescribeInstanceStorageConfigInput).
    pub fn builder() -> crate::input::describe_instance_storage_config_input::Builder {
        crate::input::describe_instance_storage_config_input::Builder::default()
    }
}

/// See [`DescribeInstanceStorageConfigInput`](crate::input::DescribeInstanceStorageConfigInput).
pub mod describe_instance_storage_config_input {

    /// A builder for [`DescribeInstanceStorageConfigInput`](crate::input::DescribeInstanceStorageConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::InstanceStorageResourceType>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>A valid resource type.</p>
        pub fn resource_type(mut self, input: crate::model::InstanceStorageResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>A valid resource type.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::InstanceStorageResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeInstanceStorageConfigInput`](crate::input::DescribeInstanceStorageConfigInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeInstanceStorageConfigInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeInstanceStorageConfigInput {
                instance_id: self.instance_id,
                association_id: self.association_id,
                resource_type: self.resource_type,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeInstanceAttributeInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The type of attribute.</p>
    #[doc(hidden)]
    pub attribute_type: std::option::Option<crate::model::InstanceAttributeType>,
}
impl DescribeInstanceAttributeInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The type of attribute.</p>
    pub fn attribute_type(&self) -> std::option::Option<&crate::model::InstanceAttributeType> {
        self.attribute_type.as_ref()
    }
}
impl DescribeInstanceAttributeInput {
    /// Creates a new builder-style object to manufacture [`DescribeInstanceAttributeInput`](crate::input::DescribeInstanceAttributeInput).
    pub fn builder() -> crate::input::describe_instance_attribute_input::Builder {
        crate::input::describe_instance_attribute_input::Builder::default()
    }
}

/// See [`DescribeInstanceAttributeInput`](crate::input::DescribeInstanceAttributeInput).
pub mod describe_instance_attribute_input {

    /// A builder for [`DescribeInstanceAttributeInput`](crate::input::DescribeInstanceAttributeInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) attribute_type: std::option::Option<crate::model::InstanceAttributeType>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The type of attribute.</p>
        pub fn attribute_type(mut self, input: crate::model::InstanceAttributeType) -> Self {
            self.attribute_type = Some(input);
            self
        }
        /// <p>The type of attribute.</p>
        pub fn set_attribute_type(
            mut self,
            input: std::option::Option<crate::model::InstanceAttributeType>,
        ) -> Self {
            self.attribute_type = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeInstanceAttributeInput`](crate::input::DescribeInstanceAttributeInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeInstanceAttributeInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeInstanceAttributeInput {
                instance_id: self.instance_id,
                attribute_type: self.attribute_type,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeInstanceInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl DescribeInstanceInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl DescribeInstanceInput {
    /// Creates a new builder-style object to manufacture [`DescribeInstanceInput`](crate::input::DescribeInstanceInput).
    pub fn builder() -> crate::input::describe_instance_input::Builder {
        crate::input::describe_instance_input::Builder::default()
    }
}

/// See [`DescribeInstanceInput`](crate::input::DescribeInstanceInput).
pub mod describe_instance_input {

    /// A builder for [`DescribeInstanceInput`](crate::input::DescribeInstanceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeInstanceInput`](crate::input::DescribeInstanceInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeInstanceInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeInstanceInput {
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeHoursOfOperationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the hours of operation.</p>
    #[doc(hidden)]
    pub hours_of_operation_id: std::option::Option<std::string::String>,
}
impl DescribeHoursOfOperationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the hours of operation.</p>
    pub fn hours_of_operation_id(&self) -> std::option::Option<&str> {
        self.hours_of_operation_id.as_deref()
    }
}
impl DescribeHoursOfOperationInput {
    /// Creates a new builder-style object to manufacture [`DescribeHoursOfOperationInput`](crate::input::DescribeHoursOfOperationInput).
    pub fn builder() -> crate::input::describe_hours_of_operation_input::Builder {
        crate::input::describe_hours_of_operation_input::Builder::default()
    }
}

/// See [`DescribeHoursOfOperationInput`](crate::input::DescribeHoursOfOperationInput).
pub mod describe_hours_of_operation_input {

    /// A builder for [`DescribeHoursOfOperationInput`](crate::input::DescribeHoursOfOperationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) hours_of_operation_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn hours_of_operation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hours_of_operation_id = Some(input.into());
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn set_hours_of_operation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hours_of_operation_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeHoursOfOperationInput`](crate::input::DescribeHoursOfOperationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeHoursOfOperationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeHoursOfOperationInput {
                instance_id: self.instance_id,
                hours_of_operation_id: self.hours_of_operation_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeContactFlowModuleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow module.</p>
    #[doc(hidden)]
    pub contact_flow_module_id: std::option::Option<std::string::String>,
}
impl DescribeContactFlowModuleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the flow module.</p>
    pub fn contact_flow_module_id(&self) -> std::option::Option<&str> {
        self.contact_flow_module_id.as_deref()
    }
}
impl DescribeContactFlowModuleInput {
    /// Creates a new builder-style object to manufacture [`DescribeContactFlowModuleInput`](crate::input::DescribeContactFlowModuleInput).
    pub fn builder() -> crate::input::describe_contact_flow_module_input::Builder {
        crate::input::describe_contact_flow_module_input::Builder::default()
    }
}

/// See [`DescribeContactFlowModuleInput`](crate::input::DescribeContactFlowModuleInput).
pub mod describe_contact_flow_module_input {

    /// A builder for [`DescribeContactFlowModuleInput`](crate::input::DescribeContactFlowModuleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_module_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the flow module.</p>
        pub fn contact_flow_module_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_module_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow module.</p>
        pub fn set_contact_flow_module_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_module_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeContactFlowModuleInput`](crate::input::DescribeContactFlowModuleInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeContactFlowModuleInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeContactFlowModuleInput {
                instance_id: self.instance_id,
                contact_flow_module_id: self.contact_flow_module_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeContactFlowInput {
    /// <p>The identifier of the Amazon Connect instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow.</p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
}
impl DescribeContactFlowInput {
    /// <p>The identifier of the Amazon Connect instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the flow.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
}
impl DescribeContactFlowInput {
    /// Creates a new builder-style object to manufacture [`DescribeContactFlowInput`](crate::input::DescribeContactFlowInput).
    pub fn builder() -> crate::input::describe_contact_flow_input::Builder {
        crate::input::describe_contact_flow_input::Builder::default()
    }
}

/// See [`DescribeContactFlowInput`](crate::input::DescribeContactFlowInput).
pub mod describe_contact_flow_input {

    /// A builder for [`DescribeContactFlowInput`](crate::input::DescribeContactFlowInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeContactFlowInput`](crate::input::DescribeContactFlowInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeContactFlowInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeContactFlowInput {
                instance_id: self.instance_id,
                contact_flow_id: self.contact_flow_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeContactInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the contact.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
}
impl DescribeContactInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the contact.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
}
impl DescribeContactInput {
    /// Creates a new builder-style object to manufacture [`DescribeContactInput`](crate::input::DescribeContactInput).
    pub fn builder() -> crate::input::describe_contact_input::Builder {
        crate::input::describe_contact_input::Builder::default()
    }
}

/// See [`DescribeContactInput`](crate::input::DescribeContactInput).
pub mod describe_contact_input {

    /// A builder for [`DescribeContactInput`](crate::input::DescribeContactInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the contact.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeContactInput`](crate::input::DescribeContactInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DescribeContactInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DescribeContactInput {
                instance_id: self.instance_id,
                contact_id: self.contact_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeAgentStatusInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the agent status.</p>
    #[doc(hidden)]
    pub agent_status_id: std::option::Option<std::string::String>,
}
impl DescribeAgentStatusInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the agent status.</p>
    pub fn agent_status_id(&self) -> std::option::Option<&str> {
        self.agent_status_id.as_deref()
    }
}
impl DescribeAgentStatusInput {
    /// Creates a new builder-style object to manufacture [`DescribeAgentStatusInput`](crate::input::DescribeAgentStatusInput).
    pub fn builder() -> crate::input::describe_agent_status_input::Builder {
        crate::input::describe_agent_status_input::Builder::default()
    }
}

/// See [`DescribeAgentStatusInput`](crate::input::DescribeAgentStatusInput).
pub mod describe_agent_status_input {

    /// A builder for [`DescribeAgentStatusInput`](crate::input::DescribeAgentStatusInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) agent_status_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the agent status.</p>
        pub fn agent_status_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_status_id = Some(input.into());
            self
        }
        /// <p>The identifier for the agent status.</p>
        pub fn set_agent_status_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.agent_status_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAgentStatusInput`](crate::input::DescribeAgentStatusInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeAgentStatusInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeAgentStatusInput {
                instance_id: self.instance_id,
                agent_status_id: self.agent_status_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteVocabularyInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the custom vocabulary.</p>
    #[doc(hidden)]
    pub vocabulary_id: std::option::Option<std::string::String>,
}
impl DeleteVocabularyInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the custom vocabulary.</p>
    pub fn vocabulary_id(&self) -> std::option::Option<&str> {
        self.vocabulary_id.as_deref()
    }
}
impl DeleteVocabularyInput {
    /// Creates a new builder-style object to manufacture [`DeleteVocabularyInput`](crate::input::DeleteVocabularyInput).
    pub fn builder() -> crate::input::delete_vocabulary_input::Builder {
        crate::input::delete_vocabulary_input::Builder::default()
    }
}

/// See [`DeleteVocabularyInput`](crate::input::DeleteVocabularyInput).
pub mod delete_vocabulary_input {

    /// A builder for [`DeleteVocabularyInput`](crate::input::DeleteVocabularyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) vocabulary_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn vocabulary_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_id = Some(input.into());
            self
        }
        /// <p>The identifier of the custom vocabulary.</p>
        pub fn set_vocabulary_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVocabularyInput`](crate::input::DeleteVocabularyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteVocabularyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteVocabularyInput {
                instance_id: self.instance_id,
                vocabulary_id: self.vocabulary_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteUserHierarchyGroupInput {
    /// <p>The identifier of the hierarchy group.</p>
    #[doc(hidden)]
    pub hierarchy_group_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl DeleteUserHierarchyGroupInput {
    /// <p>The identifier of the hierarchy group.</p>
    pub fn hierarchy_group_id(&self) -> std::option::Option<&str> {
        self.hierarchy_group_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl DeleteUserHierarchyGroupInput {
    /// Creates a new builder-style object to manufacture [`DeleteUserHierarchyGroupInput`](crate::input::DeleteUserHierarchyGroupInput).
    pub fn builder() -> crate::input::delete_user_hierarchy_group_input::Builder {
        crate::input::delete_user_hierarchy_group_input::Builder::default()
    }
}

/// See [`DeleteUserHierarchyGroupInput`](crate::input::DeleteUserHierarchyGroupInput).
pub mod delete_user_hierarchy_group_input {

    /// A builder for [`DeleteUserHierarchyGroupInput`](crate::input::DeleteUserHierarchyGroupInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hierarchy_group_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the hierarchy group.</p>
        pub fn hierarchy_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the hierarchy group.</p>
        pub fn set_hierarchy_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hierarchy_group_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteUserHierarchyGroupInput`](crate::input::DeleteUserHierarchyGroupInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteUserHierarchyGroupInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteUserHierarchyGroupInput {
                hierarchy_group_id: self.hierarchy_group_id,
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteUserInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the user.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
}
impl DeleteUserInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the user.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
}
impl DeleteUserInput {
    /// Creates a new builder-style object to manufacture [`DeleteUserInput`](crate::input::DeleteUserInput).
    pub fn builder() -> crate::input::delete_user_input::Builder {
        crate::input::delete_user_input::Builder::default()
    }
}

/// See [`DeleteUserInput`](crate::input::DeleteUserInput).
pub mod delete_user_input {

    /// A builder for [`DeleteUserInput`](crate::input::DeleteUserInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the user.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteUserInput`](crate::input::DeleteUserInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteUserInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DeleteUserInput {
                instance_id: self.instance_id,
                user_id: self.user_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteUseCaseInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the integration association.</p>
    #[doc(hidden)]
    pub integration_association_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the use case.</p>
    #[doc(hidden)]
    pub use_case_id: std::option::Option<std::string::String>,
}
impl DeleteUseCaseInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the integration association.</p>
    pub fn integration_association_id(&self) -> std::option::Option<&str> {
        self.integration_association_id.as_deref()
    }
    /// <p>The identifier for the use case.</p>
    pub fn use_case_id(&self) -> std::option::Option<&str> {
        self.use_case_id.as_deref()
    }
}
impl DeleteUseCaseInput {
    /// Creates a new builder-style object to manufacture [`DeleteUseCaseInput`](crate::input::DeleteUseCaseInput).
    pub fn builder() -> crate::input::delete_use_case_input::Builder {
        crate::input::delete_use_case_input::Builder::default()
    }
}

/// See [`DeleteUseCaseInput`](crate::input::DeleteUseCaseInput).
pub mod delete_use_case_input {

    /// A builder for [`DeleteUseCaseInput`](crate::input::DeleteUseCaseInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) integration_association_id: std::option::Option<std::string::String>,
        pub(crate) use_case_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the integration association.</p>
        pub fn integration_association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.integration_association_id = Some(input.into());
            self
        }
        /// <p>The identifier for the integration association.</p>
        pub fn set_integration_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.integration_association_id = input;
            self
        }
        /// <p>The identifier for the use case.</p>
        pub fn use_case_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.use_case_id = Some(input.into());
            self
        }
        /// <p>The identifier for the use case.</p>
        pub fn set_use_case_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.use_case_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteUseCaseInput`](crate::input::DeleteUseCaseInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteUseCaseInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DeleteUseCaseInput {
                instance_id: self.instance_id,
                integration_association_id: self.integration_association_id,
                use_case_id: self.use_case_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteTrafficDistributionGroupInput {
    /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
    #[doc(hidden)]
    pub traffic_distribution_group_id: std::option::Option<std::string::String>,
}
impl DeleteTrafficDistributionGroupInput {
    /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
    pub fn traffic_distribution_group_id(&self) -> std::option::Option<&str> {
        self.traffic_distribution_group_id.as_deref()
    }
}
impl DeleteTrafficDistributionGroupInput {
    /// Creates a new builder-style object to manufacture [`DeleteTrafficDistributionGroupInput`](crate::input::DeleteTrafficDistributionGroupInput).
    pub fn builder() -> crate::input::delete_traffic_distribution_group_input::Builder {
        crate::input::delete_traffic_distribution_group_input::Builder::default()
    }
}

/// See [`DeleteTrafficDistributionGroupInput`](crate::input::DeleteTrafficDistributionGroupInput).
pub mod delete_traffic_distribution_group_input {

    /// A builder for [`DeleteTrafficDistributionGroupInput`](crate::input::DeleteTrafficDistributionGroupInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) traffic_distribution_group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
        pub fn traffic_distribution_group_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.traffic_distribution_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the traffic distribution group. This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created. The ARN must be provided if the call is from the replicated Region.</p>
        pub fn set_traffic_distribution_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.traffic_distribution_group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteTrafficDistributionGroupInput`](crate::input::DeleteTrafficDistributionGroupInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteTrafficDistributionGroupInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteTrafficDistributionGroupInput {
                traffic_distribution_group_id: self.traffic_distribution_group_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteTaskTemplateInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the task template.</p>
    #[doc(hidden)]
    pub task_template_id: std::option::Option<std::string::String>,
}
impl DeleteTaskTemplateInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>A unique identifier for the task template.</p>
    pub fn task_template_id(&self) -> std::option::Option<&str> {
        self.task_template_id.as_deref()
    }
}
impl DeleteTaskTemplateInput {
    /// Creates a new builder-style object to manufacture [`DeleteTaskTemplateInput`](crate::input::DeleteTaskTemplateInput).
    pub fn builder() -> crate::input::delete_task_template_input::Builder {
        crate::input::delete_task_template_input::Builder::default()
    }
}

/// See [`DeleteTaskTemplateInput`](crate::input::DeleteTaskTemplateInput).
pub mod delete_task_template_input {

    /// A builder for [`DeleteTaskTemplateInput`](crate::input::DeleteTaskTemplateInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) task_template_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>A unique identifier for the task template.</p>
        pub fn task_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_template_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the task template.</p>
        pub fn set_task_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_template_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteTaskTemplateInput`](crate::input::DeleteTaskTemplateInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteTaskTemplateInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteTaskTemplateInput {
                instance_id: self.instance_id,
                task_template_id: self.task_template_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteSecurityProfileInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the security profle.</p>
    #[doc(hidden)]
    pub security_profile_id: std::option::Option<std::string::String>,
}
impl DeleteSecurityProfileInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the security profle.</p>
    pub fn security_profile_id(&self) -> std::option::Option<&str> {
        self.security_profile_id.as_deref()
    }
}
impl DeleteSecurityProfileInput {
    /// Creates a new builder-style object to manufacture [`DeleteSecurityProfileInput`](crate::input::DeleteSecurityProfileInput).
    pub fn builder() -> crate::input::delete_security_profile_input::Builder {
        crate::input::delete_security_profile_input::Builder::default()
    }
}

/// See [`DeleteSecurityProfileInput`](crate::input::DeleteSecurityProfileInput).
pub mod delete_security_profile_input {

    /// A builder for [`DeleteSecurityProfileInput`](crate::input::DeleteSecurityProfileInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) security_profile_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the security profle.</p>
        pub fn security_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier for the security profle.</p>
        pub fn set_security_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSecurityProfileInput`](crate::input::DeleteSecurityProfileInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteSecurityProfileInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteSecurityProfileInput {
                instance_id: self.instance_id,
                security_profile_id: self.security_profile_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteRuleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the rule.</p>
    #[doc(hidden)]
    pub rule_id: std::option::Option<std::string::String>,
}
impl DeleteRuleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>A unique identifier for the rule.</p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
}
impl DeleteRuleInput {
    /// Creates a new builder-style object to manufacture [`DeleteRuleInput`](crate::input::DeleteRuleInput).
    pub fn builder() -> crate::input::delete_rule_input::Builder {
        crate::input::delete_rule_input::Builder::default()
    }
}

/// See [`DeleteRuleInput`](crate::input::DeleteRuleInput).
pub mod delete_rule_input {

    /// A builder for [`DeleteRuleInput`](crate::input::DeleteRuleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) rule_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>A unique identifier for the rule.</p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the rule.</p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRuleInput`](crate::input::DeleteRuleInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteRuleInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DeleteRuleInput {
                instance_id: self.instance_id,
                rule_id: self.rule_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteQuickConnectInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the quick connect.</p>
    #[doc(hidden)]
    pub quick_connect_id: std::option::Option<std::string::String>,
}
impl DeleteQuickConnectInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the quick connect.</p>
    pub fn quick_connect_id(&self) -> std::option::Option<&str> {
        self.quick_connect_id.as_deref()
    }
}
impl DeleteQuickConnectInput {
    /// Creates a new builder-style object to manufacture [`DeleteQuickConnectInput`](crate::input::DeleteQuickConnectInput).
    pub fn builder() -> crate::input::delete_quick_connect_input::Builder {
        crate::input::delete_quick_connect_input::Builder::default()
    }
}

/// See [`DeleteQuickConnectInput`](crate::input::DeleteQuickConnectInput).
pub mod delete_quick_connect_input {

    /// A builder for [`DeleteQuickConnectInput`](crate::input::DeleteQuickConnectInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) quick_connect_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn quick_connect_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.quick_connect_id = Some(input.into());
            self
        }
        /// <p>The identifier for the quick connect.</p>
        pub fn set_quick_connect_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.quick_connect_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteQuickConnectInput`](crate::input::DeleteQuickConnectInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteQuickConnectInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteQuickConnectInput {
                instance_id: self.instance_id,
                quick_connect_id: self.quick_connect_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteIntegrationAssociationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the integration association.</p>
    #[doc(hidden)]
    pub integration_association_id: std::option::Option<std::string::String>,
}
impl DeleteIntegrationAssociationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the integration association.</p>
    pub fn integration_association_id(&self) -> std::option::Option<&str> {
        self.integration_association_id.as_deref()
    }
}
impl DeleteIntegrationAssociationInput {
    /// Creates a new builder-style object to manufacture [`DeleteIntegrationAssociationInput`](crate::input::DeleteIntegrationAssociationInput).
    pub fn builder() -> crate::input::delete_integration_association_input::Builder {
        crate::input::delete_integration_association_input::Builder::default()
    }
}

/// See [`DeleteIntegrationAssociationInput`](crate::input::DeleteIntegrationAssociationInput).
pub mod delete_integration_association_input {

    /// A builder for [`DeleteIntegrationAssociationInput`](crate::input::DeleteIntegrationAssociationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) integration_association_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the integration association.</p>
        pub fn integration_association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.integration_association_id = Some(input.into());
            self
        }
        /// <p>The identifier for the integration association.</p>
        pub fn set_integration_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.integration_association_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteIntegrationAssociationInput`](crate::input::DeleteIntegrationAssociationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteIntegrationAssociationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteIntegrationAssociationInput {
                instance_id: self.instance_id,
                integration_association_id: self.integration_association_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteInstanceInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
}
impl DeleteInstanceInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl DeleteInstanceInput {
    /// Creates a new builder-style object to manufacture [`DeleteInstanceInput`](crate::input::DeleteInstanceInput).
    pub fn builder() -> crate::input::delete_instance_input::Builder {
        crate::input::delete_instance_input::Builder::default()
    }
}

/// See [`DeleteInstanceInput`](crate::input::DeleteInstanceInput).
pub mod delete_instance_input {

    /// A builder for [`DeleteInstanceInput`](crate::input::DeleteInstanceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteInstanceInput`](crate::input::DeleteInstanceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteInstanceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DeleteInstanceInput {
                instance_id: self.instance_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteHoursOfOperationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the hours of operation.</p>
    #[doc(hidden)]
    pub hours_of_operation_id: std::option::Option<std::string::String>,
}
impl DeleteHoursOfOperationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the hours of operation.</p>
    pub fn hours_of_operation_id(&self) -> std::option::Option<&str> {
        self.hours_of_operation_id.as_deref()
    }
}
impl DeleteHoursOfOperationInput {
    /// Creates a new builder-style object to manufacture [`DeleteHoursOfOperationInput`](crate::input::DeleteHoursOfOperationInput).
    pub fn builder() -> crate::input::delete_hours_of_operation_input::Builder {
        crate::input::delete_hours_of_operation_input::Builder::default()
    }
}

/// See [`DeleteHoursOfOperationInput`](crate::input::DeleteHoursOfOperationInput).
pub mod delete_hours_of_operation_input {

    /// A builder for [`DeleteHoursOfOperationInput`](crate::input::DeleteHoursOfOperationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) hours_of_operation_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn hours_of_operation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hours_of_operation_id = Some(input.into());
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn set_hours_of_operation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hours_of_operation_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteHoursOfOperationInput`](crate::input::DeleteHoursOfOperationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteHoursOfOperationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteHoursOfOperationInput {
                instance_id: self.instance_id,
                hours_of_operation_id: self.hours_of_operation_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteContactFlowModuleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow module.</p>
    #[doc(hidden)]
    pub contact_flow_module_id: std::option::Option<std::string::String>,
}
impl DeleteContactFlowModuleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the flow module.</p>
    pub fn contact_flow_module_id(&self) -> std::option::Option<&str> {
        self.contact_flow_module_id.as_deref()
    }
}
impl DeleteContactFlowModuleInput {
    /// Creates a new builder-style object to manufacture [`DeleteContactFlowModuleInput`](crate::input::DeleteContactFlowModuleInput).
    pub fn builder() -> crate::input::delete_contact_flow_module_input::Builder {
        crate::input::delete_contact_flow_module_input::Builder::default()
    }
}

/// See [`DeleteContactFlowModuleInput`](crate::input::DeleteContactFlowModuleInput).
pub mod delete_contact_flow_module_input {

    /// A builder for [`DeleteContactFlowModuleInput`](crate::input::DeleteContactFlowModuleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_module_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the flow module.</p>
        pub fn contact_flow_module_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_module_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow module.</p>
        pub fn set_contact_flow_module_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_module_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteContactFlowModuleInput`](crate::input::DeleteContactFlowModuleInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteContactFlowModuleInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteContactFlowModuleInput {
                instance_id: self.instance_id,
                contact_flow_module_id: self.contact_flow_module_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteContactFlowInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow.</p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
}
impl DeleteContactFlowInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the flow.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
}
impl DeleteContactFlowInput {
    /// Creates a new builder-style object to manufacture [`DeleteContactFlowInput`](crate::input::DeleteContactFlowInput).
    pub fn builder() -> crate::input::delete_contact_flow_input::Builder {
        crate::input::delete_contact_flow_input::Builder::default()
    }
}

/// See [`DeleteContactFlowInput`](crate::input::DeleteContactFlowInput).
pub mod delete_contact_flow_input {

    /// A builder for [`DeleteContactFlowInput`](crate::input::DeleteContactFlowInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteContactFlowInput`](crate::input::DeleteContactFlowInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteContactFlowInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteContactFlowInput {
                instance_id: self.instance_id,
                contact_flow_id: self.contact_flow_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateVocabularyInput {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>. If a create request is received more than once with same client token, subsequent requests return the previous response without creating a vocabulary again.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A unique name of the custom vocabulary.</p>
    #[doc(hidden)]
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
    /// <p>The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and <code>DisplayAs</code> fields. Separate the fields with TAB characters. The size limit is 50KB. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create a custom vocabulary using a table</a>.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateVocabularyInput {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>. If a create request is received more than once with same client token, subsequent requests return the previous response without creating a vocabulary again.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>A unique name of the custom vocabulary.</p>
    pub fn vocabulary_name(&self) -> std::option::Option<&str> {
        self.vocabulary_name.as_deref()
    }
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::VocabularyLanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and <code>DisplayAs</code> fields. Separate the fields with TAB characters. The size limit is 50KB. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create a custom vocabulary using a table</a>.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateVocabularyInput {
    /// Creates a new builder-style object to manufacture [`CreateVocabularyInput`](crate::input::CreateVocabularyInput).
    pub fn builder() -> crate::input::create_vocabulary_input::Builder {
        crate::input::create_vocabulary_input::Builder::default()
    }
}

/// See [`CreateVocabularyInput`](crate::input::CreateVocabularyInput).
pub mod create_vocabulary_input {

    /// A builder for [`CreateVocabularyInput`](crate::input::CreateVocabularyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>. If a create request is received more than once with same client token, subsequent requests return the previous response without creating a vocabulary again.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>. If a create request is received more than once with same client token, subsequent requests return the previous response without creating a vocabulary again.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>A unique name of the custom vocabulary.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn language_code(mut self, input: crate::model::VocabularyLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::VocabularyLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and <code>DisplayAs</code> fields. Separate the fields with TAB characters. The size limit is 50KB. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create a custom vocabulary using a table</a>.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and <code>DisplayAs</code> fields. Separate the fields with TAB characters. The size limit is 50KB. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create a custom vocabulary using a table</a>.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVocabularyInput`](crate::input::CreateVocabularyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateVocabularyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateVocabularyInput {
                client_token: self.client_token,
                instance_id: self.instance_id,
                vocabulary_name: self.vocabulary_name,
                language_code: self.language_code,
                content: self.content,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateUserHierarchyGroupInput {
    /// <p>The name of the user hierarchy group. Must not be more than 100 characters.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier for the parent hierarchy group. The user hierarchy is created at level one if the parent group ID is null.</p>
    #[doc(hidden)]
    pub parent_group_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateUserHierarchyGroupInput {
    /// <p>The name of the user hierarchy group. Must not be more than 100 characters.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier for the parent hierarchy group. The user hierarchy is created at level one if the parent group ID is null.</p>
    pub fn parent_group_id(&self) -> std::option::Option<&str> {
        self.parent_group_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateUserHierarchyGroupInput {
    /// Creates a new builder-style object to manufacture [`CreateUserHierarchyGroupInput`](crate::input::CreateUserHierarchyGroupInput).
    pub fn builder() -> crate::input::create_user_hierarchy_group_input::Builder {
        crate::input::create_user_hierarchy_group_input::Builder::default()
    }
}

/// See [`CreateUserHierarchyGroupInput`](crate::input::CreateUserHierarchyGroupInput).
pub mod create_user_hierarchy_group_input {

    /// A builder for [`CreateUserHierarchyGroupInput`](crate::input::CreateUserHierarchyGroupInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) parent_group_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the user hierarchy group. Must not be more than 100 characters.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the user hierarchy group. Must not be more than 100 characters.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The identifier for the parent hierarchy group. The user hierarchy is created at level one if the parent group ID is null.</p>
        pub fn parent_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.parent_group_id = Some(input.into());
            self
        }
        /// <p>The identifier for the parent hierarchy group. The user hierarchy is created at level one if the parent group ID is null.</p>
        pub fn set_parent_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parent_group_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateUserHierarchyGroupInput`](crate::input::CreateUserHierarchyGroupInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateUserHierarchyGroupInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateUserHierarchyGroupInput {
                name: self.name,
                parent_group_id: self.parent_group_id,
                instance_id: self.instance_id,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateUserInput {
    /// <p>The user name for the account. For instances not using SAML for identity management, the user name can include up to 20 characters. If you are using SAML for identity management, the user name can include up to 64 characters from [a-zA-Z0-9_-.\@]+.</p>
    #[doc(hidden)]
    pub username: std::option::Option<std::string::String>,
    /// <p>The password for the user account. A password is required if you are using Amazon Connect for identity management. Otherwise, it is an error to include a password.</p>
    #[doc(hidden)]
    pub password: std::option::Option<std::string::String>,
    /// <p>The information about the identity of the user.</p>
    #[doc(hidden)]
    pub identity_info: std::option::Option<crate::model::UserIdentityInfo>,
    /// <p>The phone settings for the user.</p>
    #[doc(hidden)]
    pub phone_config: std::option::Option<crate::model::UserPhoneConfig>,
    /// <p>The identifier of the user account in the directory used for identity management. If Amazon Connect cannot access the directory, you can specify this identifier to authenticate users. If you include the identifier, we assume that Amazon Connect cannot access the directory. Otherwise, the identity information is used to authenticate users from your directory.</p>
    /// <p>This parameter is required if you are using an existing directory for identity management in Amazon Connect when Amazon Connect cannot access your directory to authenticate users. If you are using SAML for identity management and include this parameter, an error is returned.</p>
    #[doc(hidden)]
    pub directory_user_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the security profile for the user.</p>
    #[doc(hidden)]
    pub security_profile_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The identifier of the routing profile for the user.</p>
    #[doc(hidden)]
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the hierarchy group for the user.</p>
    #[doc(hidden)]
    pub hierarchy_group_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateUserInput {
    /// <p>The user name for the account. For instances not using SAML for identity management, the user name can include up to 20 characters. If you are using SAML for identity management, the user name can include up to 64 characters from [a-zA-Z0-9_-.\@]+.</p>
    pub fn username(&self) -> std::option::Option<&str> {
        self.username.as_deref()
    }
    /// <p>The password for the user account. A password is required if you are using Amazon Connect for identity management. Otherwise, it is an error to include a password.</p>
    pub fn password(&self) -> std::option::Option<&str> {
        self.password.as_deref()
    }
    /// <p>The information about the identity of the user.</p>
    pub fn identity_info(&self) -> std::option::Option<&crate::model::UserIdentityInfo> {
        self.identity_info.as_ref()
    }
    /// <p>The phone settings for the user.</p>
    pub fn phone_config(&self) -> std::option::Option<&crate::model::UserPhoneConfig> {
        self.phone_config.as_ref()
    }
    /// <p>The identifier of the user account in the directory used for identity management. If Amazon Connect cannot access the directory, you can specify this identifier to authenticate users. If you include the identifier, we assume that Amazon Connect cannot access the directory. Otherwise, the identity information is used to authenticate users from your directory.</p>
    /// <p>This parameter is required if you are using an existing directory for identity management in Amazon Connect when Amazon Connect cannot access your directory to authenticate users. If you are using SAML for identity management and include this parameter, an error is returned.</p>
    pub fn directory_user_id(&self) -> std::option::Option<&str> {
        self.directory_user_id.as_deref()
    }
    /// <p>The identifier of the security profile for the user.</p>
    pub fn security_profile_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_profile_ids.as_deref()
    }
    /// <p>The identifier of the routing profile for the user.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The identifier of the hierarchy group for the user.</p>
    pub fn hierarchy_group_id(&self) -> std::option::Option<&str> {
        self.hierarchy_group_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateUserInput {
    /// Creates a new builder-style object to manufacture [`CreateUserInput`](crate::input::CreateUserInput).
    pub fn builder() -> crate::input::create_user_input::Builder {
        crate::input::create_user_input::Builder::default()
    }
}

/// See [`CreateUserInput`](crate::input::CreateUserInput).
pub mod create_user_input {

    /// A builder for [`CreateUserInput`](crate::input::CreateUserInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) username: std::option::Option<std::string::String>,
        pub(crate) password: std::option::Option<std::string::String>,
        pub(crate) identity_info: std::option::Option<crate::model::UserIdentityInfo>,
        pub(crate) phone_config: std::option::Option<crate::model::UserPhoneConfig>,
        pub(crate) directory_user_id: std::option::Option<std::string::String>,
        pub(crate) security_profile_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) hierarchy_group_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The user name for the account. For instances not using SAML for identity management, the user name can include up to 20 characters. If you are using SAML for identity management, the user name can include up to 64 characters from [a-zA-Z0-9_-.\@]+.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        /// <p>The user name for the account. For instances not using SAML for identity management, the user name can include up to 20 characters. If you are using SAML for identity management, the user name can include up to 64 characters from [a-zA-Z0-9_-.\@]+.</p>
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input;
            self
        }
        /// <p>The password for the user account. A password is required if you are using Amazon Connect for identity management. Otherwise, it is an error to include a password.</p>
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.password = Some(input.into());
            self
        }
        /// <p>The password for the user account. A password is required if you are using Amazon Connect for identity management. Otherwise, it is an error to include a password.</p>
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.password = input;
            self
        }
        /// <p>The information about the identity of the user.</p>
        pub fn identity_info(mut self, input: crate::model::UserIdentityInfo) -> Self {
            self.identity_info = Some(input);
            self
        }
        /// <p>The information about the identity of the user.</p>
        pub fn set_identity_info(
            mut self,
            input: std::option::Option<crate::model::UserIdentityInfo>,
        ) -> Self {
            self.identity_info = input;
            self
        }
        /// <p>The phone settings for the user.</p>
        pub fn phone_config(mut self, input: crate::model::UserPhoneConfig) -> Self {
            self.phone_config = Some(input);
            self
        }
        /// <p>The phone settings for the user.</p>
        pub fn set_phone_config(
            mut self,
            input: std::option::Option<crate::model::UserPhoneConfig>,
        ) -> Self {
            self.phone_config = input;
            self
        }
        /// <p>The identifier of the user account in the directory used for identity management. If Amazon Connect cannot access the directory, you can specify this identifier to authenticate users. If you include the identifier, we assume that Amazon Connect cannot access the directory. Otherwise, the identity information is used to authenticate users from your directory.</p>
        /// <p>This parameter is required if you are using an existing directory for identity management in Amazon Connect when Amazon Connect cannot access your directory to authenticate users. If you are using SAML for identity management and include this parameter, an error is returned.</p>
        pub fn directory_user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user account in the directory used for identity management. If Amazon Connect cannot access the directory, you can specify this identifier to authenticate users. If you include the identifier, we assume that Amazon Connect cannot access the directory. Otherwise, the identity information is used to authenticate users from your directory.</p>
        /// <p>This parameter is required if you are using an existing directory for identity management in Amazon Connect when Amazon Connect cannot access your directory to authenticate users. If you are using SAML for identity management and include this parameter, an error is returned.</p>
        pub fn set_directory_user_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.directory_user_id = input;
            self
        }
        /// Appends an item to `security_profile_ids`.
        ///
        /// To override the contents of this collection use [`set_security_profile_ids`](Self::set_security_profile_ids).
        ///
        /// <p>The identifier of the security profile for the user.</p>
        pub fn security_profile_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_profile_ids.unwrap_or_default();
            v.push(input.into());
            self.security_profile_ids = Some(v);
            self
        }
        /// <p>The identifier of the security profile for the user.</p>
        pub fn set_security_profile_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_profile_ids = input;
            self
        }
        /// <p>The identifier of the routing profile for the user.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile for the user.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// <p>The identifier of the hierarchy group for the user.</p>
        pub fn hierarchy_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the hierarchy group for the user.</p>
        pub fn set_hierarchy_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hierarchy_group_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateUserInput`](crate::input::CreateUserInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateUserInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateUserInput {
                username: self.username,
                password: self.password,
                identity_info: self.identity_info,
                phone_config: self.phone_config,
                directory_user_id: self.directory_user_id,
                security_profile_ids: self.security_profile_ids,
                routing_profile_id: self.routing_profile_id,
                hierarchy_group_id: self.hierarchy_group_id,
                instance_id: self.instance_id,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateUseCaseInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the integration association.</p>
    #[doc(hidden)]
    pub integration_association_id: std::option::Option<std::string::String>,
    /// <p>The type of use case to associate to the integration association. Each integration association can have only one of each use case type.</p>
    #[doc(hidden)]
    pub use_case_type: std::option::Option<crate::model::UseCaseType>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateUseCaseInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the integration association.</p>
    pub fn integration_association_id(&self) -> std::option::Option<&str> {
        self.integration_association_id.as_deref()
    }
    /// <p>The type of use case to associate to the integration association. Each integration association can have only one of each use case type.</p>
    pub fn use_case_type(&self) -> std::option::Option<&crate::model::UseCaseType> {
        self.use_case_type.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateUseCaseInput {
    /// Creates a new builder-style object to manufacture [`CreateUseCaseInput`](crate::input::CreateUseCaseInput).
    pub fn builder() -> crate::input::create_use_case_input::Builder {
        crate::input::create_use_case_input::Builder::default()
    }
}

/// See [`CreateUseCaseInput`](crate::input::CreateUseCaseInput).
pub mod create_use_case_input {

    /// A builder for [`CreateUseCaseInput`](crate::input::CreateUseCaseInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) integration_association_id: std::option::Option<std::string::String>,
        pub(crate) use_case_type: std::option::Option<crate::model::UseCaseType>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the integration association.</p>
        pub fn integration_association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.integration_association_id = Some(input.into());
            self
        }
        /// <p>The identifier for the integration association.</p>
        pub fn set_integration_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.integration_association_id = input;
            self
        }
        /// <p>The type of use case to associate to the integration association. Each integration association can have only one of each use case type.</p>
        pub fn use_case_type(mut self, input: crate::model::UseCaseType) -> Self {
            self.use_case_type = Some(input);
            self
        }
        /// <p>The type of use case to associate to the integration association. Each integration association can have only one of each use case type.</p>
        pub fn set_use_case_type(
            mut self,
            input: std::option::Option<crate::model::UseCaseType>,
        ) -> Self {
            self.use_case_type = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateUseCaseInput`](crate::input::CreateUseCaseInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateUseCaseInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateUseCaseInput {
                instance_id: self.instance_id,
                integration_association_id: self.integration_association_id,
                use_case_type: self.use_case_type,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateTrafficDistributionGroupInput {
    /// <p>The name for the traffic distribution group. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description for the traffic distribution group.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance that has been replicated. You can find the <code>instanceId</code> in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateTrafficDistributionGroupInput {
    /// <p>The name for the traffic distribution group. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description for the traffic distribution group.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance that has been replicated. You can find the <code>instanceId</code> in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateTrafficDistributionGroupInput {
    /// Creates a new builder-style object to manufacture [`CreateTrafficDistributionGroupInput`](crate::input::CreateTrafficDistributionGroupInput).
    pub fn builder() -> crate::input::create_traffic_distribution_group_input::Builder {
        crate::input::create_traffic_distribution_group_input::Builder::default()
    }
}

/// See [`CreateTrafficDistributionGroupInput`](crate::input::CreateTrafficDistributionGroupInput).
pub mod create_traffic_distribution_group_input {

    /// A builder for [`CreateTrafficDistributionGroupInput`](crate::input::CreateTrafficDistributionGroupInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name for the traffic distribution group. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the traffic distribution group. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description for the traffic distribution group.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the traffic distribution group.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance that has been replicated. You can find the <code>instanceId</code> in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance that has been replicated. You can find the <code>instanceId</code> in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateTrafficDistributionGroupInput`](crate::input::CreateTrafficDistributionGroupInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateTrafficDistributionGroupInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateTrafficDistributionGroupInput {
                name: self.name,
                description: self.description,
                instance_id: self.instance_id,
                client_token: self.client_token,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateTaskTemplateInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the task template.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the task template.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow that runs by default when a task is created by referencing this template.</p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
    /// <p>Constraints that are applicable to the fields listed.</p>
    #[doc(hidden)]
    pub constraints: std::option::Option<crate::model::TaskTemplateConstraints>,
    /// <p>The default values for fields when a task is created by referencing this template.</p>
    #[doc(hidden)]
    pub defaults: std::option::Option<crate::model::TaskTemplateDefaults>,
    /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TaskTemplateStatus>,
    /// <p>Fields that are part of the template.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::TaskTemplateField>>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateTaskTemplateInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the task template.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the task template.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The identifier of the flow that runs by default when a task is created by referencing this template.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
    /// <p>Constraints that are applicable to the fields listed.</p>
    pub fn constraints(&self) -> std::option::Option<&crate::model::TaskTemplateConstraints> {
        self.constraints.as_ref()
    }
    /// <p>The default values for fields when a task is created by referencing this template.</p>
    pub fn defaults(&self) -> std::option::Option<&crate::model::TaskTemplateDefaults> {
        self.defaults.as_ref()
    }
    /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::TaskTemplateStatus> {
        self.status.as_ref()
    }
    /// <p>Fields that are part of the template.</p>
    pub fn fields(&self) -> std::option::Option<&[crate::model::TaskTemplateField]> {
        self.fields.as_deref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl CreateTaskTemplateInput {
    /// Creates a new builder-style object to manufacture [`CreateTaskTemplateInput`](crate::input::CreateTaskTemplateInput).
    pub fn builder() -> crate::input::create_task_template_input::Builder {
        crate::input::create_task_template_input::Builder::default()
    }
}

/// See [`CreateTaskTemplateInput`](crate::input::CreateTaskTemplateInput).
pub mod create_task_template_input {

    /// A builder for [`CreateTaskTemplateInput`](crate::input::CreateTaskTemplateInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
        pub(crate) constraints: std::option::Option<crate::model::TaskTemplateConstraints>,
        pub(crate) defaults: std::option::Option<crate::model::TaskTemplateDefaults>,
        pub(crate) status: std::option::Option<crate::model::TaskTemplateStatus>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::TaskTemplateField>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the task template.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the task template.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the task template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the task template.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The identifier of the flow that runs by default when a task is created by referencing this template.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow that runs by default when a task is created by referencing this template.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// <p>Constraints that are applicable to the fields listed.</p>
        pub fn constraints(mut self, input: crate::model::TaskTemplateConstraints) -> Self {
            self.constraints = Some(input);
            self
        }
        /// <p>Constraints that are applicable to the fields listed.</p>
        pub fn set_constraints(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateConstraints>,
        ) -> Self {
            self.constraints = input;
            self
        }
        /// <p>The default values for fields when a task is created by referencing this template.</p>
        pub fn defaults(mut self, input: crate::model::TaskTemplateDefaults) -> Self {
            self.defaults = Some(input);
            self
        }
        /// <p>The default values for fields when a task is created by referencing this template.</p>
        pub fn set_defaults(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateDefaults>,
        ) -> Self {
            self.defaults = input;
            self
        }
        /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created. </p>
        pub fn status(mut self, input: crate::model::TaskTemplateStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TaskTemplateStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>Fields that are part of the template.</p>
        pub fn fields(mut self, input: crate::model::TaskTemplateField) -> Self {
            let mut v = self.fields.unwrap_or_default();
            v.push(input);
            self.fields = Some(v);
            self
        }
        /// <p>Fields that are part of the template.</p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TaskTemplateField>>,
        ) -> Self {
            self.fields = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateTaskTemplateInput`](crate::input::CreateTaskTemplateInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateTaskTemplateInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateTaskTemplateInput {
                instance_id: self.instance_id,
                name: self.name,
                description: self.description,
                contact_flow_id: self.contact_flow_id,
                constraints: self.constraints,
                defaults: self.defaults,
                status: self.status,
                fields: self.fields,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateSecurityProfileInput {
    /// <p>The name of the security profile.</p>
    #[doc(hidden)]
    pub security_profile_name: std::option::Option<std::string::String>,
    /// <p>The description of the security profile.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Permissions assigned to the security profile. For a list of valid permissions, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html">List of security profile permissions</a>. </p>
    #[doc(hidden)]
    pub permissions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The list of tags that a security profile uses to restrict access to resources in Amazon Connect.</p>
    #[doc(hidden)]
    pub allowed_access_control_tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The list of resources that a security profile applies tag restrictions to in Amazon Connect. Following are acceptable ResourceNames: <code>User</code> | <code>SecurityProfile</code> | <code>Queue</code> | <code>RoutingProfile</code> </p>
    #[doc(hidden)]
    pub tag_restricted_resources: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CreateSecurityProfileInput {
    /// <p>The name of the security profile.</p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
    /// <p>The description of the security profile.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Permissions assigned to the security profile. For a list of valid permissions, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html">List of security profile permissions</a>. </p>
    pub fn permissions(&self) -> std::option::Option<&[std::string::String]> {
        self.permissions.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The list of tags that a security profile uses to restrict access to resources in Amazon Connect.</p>
    pub fn allowed_access_control_tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.allowed_access_control_tags.as_ref()
    }
    /// <p>The list of resources that a security profile applies tag restrictions to in Amazon Connect. Following are acceptable ResourceNames: <code>User</code> | <code>SecurityProfile</code> | <code>Queue</code> | <code>RoutingProfile</code> </p>
    pub fn tag_restricted_resources(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_restricted_resources.as_deref()
    }
}
impl CreateSecurityProfileInput {
    /// Creates a new builder-style object to manufacture [`CreateSecurityProfileInput`](crate::input::CreateSecurityProfileInput).
    pub fn builder() -> crate::input::create_security_profile_input::Builder {
        crate::input::create_security_profile_input::Builder::default()
    }
}

/// See [`CreateSecurityProfileInput`](crate::input::CreateSecurityProfileInput).
pub mod create_security_profile_input {

    /// A builder for [`CreateSecurityProfileInput`](crate::input::CreateSecurityProfileInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) permissions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) allowed_access_control_tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) tag_restricted_resources:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the security profile.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p>The name of the security profile.</p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// <p>The description of the security profile.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the security profile.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `permissions`.
        ///
        /// To override the contents of this collection use [`set_permissions`](Self::set_permissions).
        ///
        /// <p>Permissions assigned to the security profile. For a list of valid permissions, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html">List of security profile permissions</a>. </p>
        pub fn permissions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.permissions.unwrap_or_default();
            v.push(input.into());
            self.permissions = Some(v);
            self
        }
        /// <p>Permissions assigned to the security profile. For a list of valid permissions, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html">List of security profile permissions</a>. </p>
        pub fn set_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.permissions = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Adds a key-value pair to `allowed_access_control_tags`.
        ///
        /// To override the contents of this collection use [`set_allowed_access_control_tags`](Self::set_allowed_access_control_tags).
        ///
        /// <p>The list of tags that a security profile uses to restrict access to resources in Amazon Connect.</p>
        pub fn allowed_access_control_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.allowed_access_control_tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.allowed_access_control_tags = Some(hash_map);
            self
        }
        /// <p>The list of tags that a security profile uses to restrict access to resources in Amazon Connect.</p>
        pub fn set_allowed_access_control_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.allowed_access_control_tags = input;
            self
        }
        /// Appends an item to `tag_restricted_resources`.
        ///
        /// To override the contents of this collection use [`set_tag_restricted_resources`](Self::set_tag_restricted_resources).
        ///
        /// <p>The list of resources that a security profile applies tag restrictions to in Amazon Connect. Following are acceptable ResourceNames: <code>User</code> | <code>SecurityProfile</code> | <code>Queue</code> | <code>RoutingProfile</code> </p>
        pub fn tag_restricted_resources(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_restricted_resources.unwrap_or_default();
            v.push(input.into());
            self.tag_restricted_resources = Some(v);
            self
        }
        /// <p>The list of resources that a security profile applies tag restrictions to in Amazon Connect. Following are acceptable ResourceNames: <code>User</code> | <code>SecurityProfile</code> | <code>Queue</code> | <code>RoutingProfile</code> </p>
        pub fn set_tag_restricted_resources(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_restricted_resources = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSecurityProfileInput`](crate::input::CreateSecurityProfileInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateSecurityProfileInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateSecurityProfileInput {
                security_profile_name: self.security_profile_name,
                description: self.description,
                permissions: self.permissions,
                instance_id: self.instance_id,
                tags: self.tags,
                allowed_access_control_tags: self.allowed_access_control_tags,
                tag_restricted_resources: self.tag_restricted_resources,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateRuleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A unique name for the rule.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The event source to trigger the rule.</p>
    #[doc(hidden)]
    pub trigger_event_source: std::option::Option<crate::model::RuleTriggerEventSource>,
    /// <p>The conditions of the rule.</p>
    #[doc(hidden)]
    pub function: std::option::Option<std::string::String>,
    /// <p>A list of actions to be run when the rule is triggered.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::RuleAction>>,
    /// <p>The publish status of the rule.</p>
    #[doc(hidden)]
    pub publish_status: std::option::Option<crate::model::RulePublishStatus>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateRuleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>A unique name for the rule.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The event source to trigger the rule.</p>
    pub fn trigger_event_source(
        &self,
    ) -> std::option::Option<&crate::model::RuleTriggerEventSource> {
        self.trigger_event_source.as_ref()
    }
    /// <p>The conditions of the rule.</p>
    pub fn function(&self) -> std::option::Option<&str> {
        self.function.as_deref()
    }
    /// <p>A list of actions to be run when the rule is triggered.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::RuleAction]> {
        self.actions.as_deref()
    }
    /// <p>The publish status of the rule.</p>
    pub fn publish_status(&self) -> std::option::Option<&crate::model::RulePublishStatus> {
        self.publish_status.as_ref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl CreateRuleInput {
    /// Creates a new builder-style object to manufacture [`CreateRuleInput`](crate::input::CreateRuleInput).
    pub fn builder() -> crate::input::create_rule_input::Builder {
        crate::input::create_rule_input::Builder::default()
    }
}

/// See [`CreateRuleInput`](crate::input::CreateRuleInput).
pub mod create_rule_input {

    /// A builder for [`CreateRuleInput`](crate::input::CreateRuleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) trigger_event_source: std::option::Option<crate::model::RuleTriggerEventSource>,
        pub(crate) function: std::option::Option<std::string::String>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::RuleAction>>,
        pub(crate) publish_status: std::option::Option<crate::model::RulePublishStatus>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>A unique name for the rule.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A unique name for the rule.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The event source to trigger the rule.</p>
        pub fn trigger_event_source(mut self, input: crate::model::RuleTriggerEventSource) -> Self {
            self.trigger_event_source = Some(input);
            self
        }
        /// <p>The event source to trigger the rule.</p>
        pub fn set_trigger_event_source(
            mut self,
            input: std::option::Option<crate::model::RuleTriggerEventSource>,
        ) -> Self {
            self.trigger_event_source = input;
            self
        }
        /// <p>The conditions of the rule.</p>
        pub fn function(mut self, input: impl Into<std::string::String>) -> Self {
            self.function = Some(input.into());
            self
        }
        /// <p>The conditions of the rule.</p>
        pub fn set_function(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>A list of actions to be run when the rule is triggered.</p>
        pub fn actions(mut self, input: crate::model::RuleAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>A list of actions to be run when the rule is triggered.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RuleAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// <p>The publish status of the rule.</p>
        pub fn publish_status(mut self, input: crate::model::RulePublishStatus) -> Self {
            self.publish_status = Some(input);
            self
        }
        /// <p>The publish status of the rule.</p>
        pub fn set_publish_status(
            mut self,
            input: std::option::Option<crate::model::RulePublishStatus>,
        ) -> Self {
            self.publish_status = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRuleInput`](crate::input::CreateRuleInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateRuleInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateRuleInput {
                instance_id: self.instance_id,
                name: self.name,
                trigger_event_source: self.trigger_event_source,
                function: self.function,
                actions: self.actions,
                publish_status: self.publish_status,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateRoutingProfileInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the routing profile. Must not be more than 127 characters.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Description of the routing profile. Must not be more than 250 characters.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The default outbound queue for the routing profile.</p>
    #[doc(hidden)]
    pub default_outbound_queue_id: std::option::Option<std::string::String>,
    /// <p>The inbound queues associated with the routing profile. If no queue is added, the agent can make only outbound calls.</p>
    #[doc(hidden)]
    pub queue_configs: std::option::Option<std::vec::Vec<crate::model::RoutingProfileQueueConfig>>,
    /// <p>The channels that agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
    #[doc(hidden)]
    pub media_concurrencies: std::option::Option<std::vec::Vec<crate::model::MediaConcurrency>>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateRoutingProfileInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the routing profile. Must not be more than 127 characters.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Description of the routing profile. Must not be more than 250 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The default outbound queue for the routing profile.</p>
    pub fn default_outbound_queue_id(&self) -> std::option::Option<&str> {
        self.default_outbound_queue_id.as_deref()
    }
    /// <p>The inbound queues associated with the routing profile. If no queue is added, the agent can make only outbound calls.</p>
    pub fn queue_configs(&self) -> std::option::Option<&[crate::model::RoutingProfileQueueConfig]> {
        self.queue_configs.as_deref()
    }
    /// <p>The channels that agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
    pub fn media_concurrencies(&self) -> std::option::Option<&[crate::model::MediaConcurrency]> {
        self.media_concurrencies.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateRoutingProfileInput {
    /// Creates a new builder-style object to manufacture [`CreateRoutingProfileInput`](crate::input::CreateRoutingProfileInput).
    pub fn builder() -> crate::input::create_routing_profile_input::Builder {
        crate::input::create_routing_profile_input::Builder::default()
    }
}

/// See [`CreateRoutingProfileInput`](crate::input::CreateRoutingProfileInput).
pub mod create_routing_profile_input {

    /// A builder for [`CreateRoutingProfileInput`](crate::input::CreateRoutingProfileInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) default_outbound_queue_id: std::option::Option<std::string::String>,
        pub(crate) queue_configs:
            std::option::Option<std::vec::Vec<crate::model::RoutingProfileQueueConfig>>,
        pub(crate) media_concurrencies:
            std::option::Option<std::vec::Vec<crate::model::MediaConcurrency>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the routing profile. Must not be more than 127 characters.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the routing profile. Must not be more than 127 characters.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Description of the routing profile. Must not be more than 250 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Description of the routing profile. Must not be more than 250 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The default outbound queue for the routing profile.</p>
        pub fn default_outbound_queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_outbound_queue_id = Some(input.into());
            self
        }
        /// <p>The default outbound queue for the routing profile.</p>
        pub fn set_default_outbound_queue_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_outbound_queue_id = input;
            self
        }
        /// Appends an item to `queue_configs`.
        ///
        /// To override the contents of this collection use [`set_queue_configs`](Self::set_queue_configs).
        ///
        /// <p>The inbound queues associated with the routing profile. If no queue is added, the agent can make only outbound calls.</p>
        pub fn queue_configs(mut self, input: crate::model::RoutingProfileQueueConfig) -> Self {
            let mut v = self.queue_configs.unwrap_or_default();
            v.push(input);
            self.queue_configs = Some(v);
            self
        }
        /// <p>The inbound queues associated with the routing profile. If no queue is added, the agent can make only outbound calls.</p>
        pub fn set_queue_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RoutingProfileQueueConfig>>,
        ) -> Self {
            self.queue_configs = input;
            self
        }
        /// Appends an item to `media_concurrencies`.
        ///
        /// To override the contents of this collection use [`set_media_concurrencies`](Self::set_media_concurrencies).
        ///
        /// <p>The channels that agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
        pub fn media_concurrencies(mut self, input: crate::model::MediaConcurrency) -> Self {
            let mut v = self.media_concurrencies.unwrap_or_default();
            v.push(input);
            self.media_concurrencies = Some(v);
            self
        }
        /// <p>The channels that agents can handle in the Contact Control Panel (CCP) for this routing profile.</p>
        pub fn set_media_concurrencies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MediaConcurrency>>,
        ) -> Self {
            self.media_concurrencies = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRoutingProfileInput`](crate::input::CreateRoutingProfileInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateRoutingProfileInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateRoutingProfileInput {
                instance_id: self.instance_id,
                name: self.name,
                description: self.description,
                default_outbound_queue_id: self.default_outbound_queue_id,
                queue_configs: self.queue_configs,
                media_concurrencies: self.media_concurrencies,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateQuickConnectInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the quick connect.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the quick connect.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Configuration settings for the quick connect.</p>
    #[doc(hidden)]
    pub quick_connect_config: std::option::Option<crate::model::QuickConnectConfig>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateQuickConnectInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the quick connect.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the quick connect.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Configuration settings for the quick connect.</p>
    pub fn quick_connect_config(&self) -> std::option::Option<&crate::model::QuickConnectConfig> {
        self.quick_connect_config.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateQuickConnectInput {
    /// Creates a new builder-style object to manufacture [`CreateQuickConnectInput`](crate::input::CreateQuickConnectInput).
    pub fn builder() -> crate::input::create_quick_connect_input::Builder {
        crate::input::create_quick_connect_input::Builder::default()
    }
}

/// See [`CreateQuickConnectInput`](crate::input::CreateQuickConnectInput).
pub mod create_quick_connect_input {

    /// A builder for [`CreateQuickConnectInput`](crate::input::CreateQuickConnectInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) quick_connect_config: std::option::Option<crate::model::QuickConnectConfig>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the quick connect.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the quick connect.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the quick connect.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the quick connect.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Configuration settings for the quick connect.</p>
        pub fn quick_connect_config(mut self, input: crate::model::QuickConnectConfig) -> Self {
            self.quick_connect_config = Some(input);
            self
        }
        /// <p>Configuration settings for the quick connect.</p>
        pub fn set_quick_connect_config(
            mut self,
            input: std::option::Option<crate::model::QuickConnectConfig>,
        ) -> Self {
            self.quick_connect_config = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateQuickConnectInput`](crate::input::CreateQuickConnectInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateQuickConnectInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateQuickConnectInput {
                instance_id: self.instance_id,
                name: self.name,
                description: self.description,
                quick_connect_config: self.quick_connect_config,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateQueueInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the queue.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the queue.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
    #[doc(hidden)]
    pub outbound_caller_config: std::option::Option<crate::model::OutboundCallerConfig>,
    /// <p>The identifier for the hours of operation.</p>
    #[doc(hidden)]
    pub hours_of_operation_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
    #[doc(hidden)]
    pub max_contacts: std::option::Option<i32>,
    /// <p>The quick connects available to agents who are working the queue.</p>
    #[doc(hidden)]
    pub quick_connect_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateQueueInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the queue.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the queue.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
    pub fn outbound_caller_config(
        &self,
    ) -> std::option::Option<&crate::model::OutboundCallerConfig> {
        self.outbound_caller_config.as_ref()
    }
    /// <p>The identifier for the hours of operation.</p>
    pub fn hours_of_operation_id(&self) -> std::option::Option<&str> {
        self.hours_of_operation_id.as_deref()
    }
    /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
    pub fn max_contacts(&self) -> std::option::Option<i32> {
        self.max_contacts
    }
    /// <p>The quick connects available to agents who are working the queue.</p>
    pub fn quick_connect_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.quick_connect_ids.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateQueueInput {
    /// Creates a new builder-style object to manufacture [`CreateQueueInput`](crate::input::CreateQueueInput).
    pub fn builder() -> crate::input::create_queue_input::Builder {
        crate::input::create_queue_input::Builder::default()
    }
}

/// See [`CreateQueueInput`](crate::input::CreateQueueInput).
pub mod create_queue_input {

    /// A builder for [`CreateQueueInput`](crate::input::CreateQueueInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) outbound_caller_config: std::option::Option<crate::model::OutboundCallerConfig>,
        pub(crate) hours_of_operation_id: std::option::Option<std::string::String>,
        pub(crate) max_contacts: std::option::Option<i32>,
        pub(crate) quick_connect_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the queue.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the queue.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the queue.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the queue.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
        pub fn outbound_caller_config(mut self, input: crate::model::OutboundCallerConfig) -> Self {
            self.outbound_caller_config = Some(input);
            self
        }
        /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
        pub fn set_outbound_caller_config(
            mut self,
            input: std::option::Option<crate::model::OutboundCallerConfig>,
        ) -> Self {
            self.outbound_caller_config = input;
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn hours_of_operation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hours_of_operation_id = Some(input.into());
            self
        }
        /// <p>The identifier for the hours of operation.</p>
        pub fn set_hours_of_operation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hours_of_operation_id = input;
            self
        }
        /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
        pub fn max_contacts(mut self, input: i32) -> Self {
            self.max_contacts = Some(input);
            self
        }
        /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
        pub fn set_max_contacts(mut self, input: std::option::Option<i32>) -> Self {
            self.max_contacts = input;
            self
        }
        /// Appends an item to `quick_connect_ids`.
        ///
        /// To override the contents of this collection use [`set_quick_connect_ids`](Self::set_quick_connect_ids).
        ///
        /// <p>The quick connects available to agents who are working the queue.</p>
        pub fn quick_connect_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.quick_connect_ids.unwrap_or_default();
            v.push(input.into());
            self.quick_connect_ids = Some(v);
            self
        }
        /// <p>The quick connects available to agents who are working the queue.</p>
        pub fn set_quick_connect_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.quick_connect_ids = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateQueueInput`](crate::input::CreateQueueInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateQueueInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateQueueInput {
                instance_id: self.instance_id,
                name: self.name,
                description: self.description,
                outbound_caller_config: self.outbound_caller_config,
                hours_of_operation_id: self.hours_of_operation_id,
                max_contacts: self.max_contacts,
                quick_connect_ids: self.quick_connect_ids,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateIntegrationAssociationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The type of information to be ingested.</p>
    #[doc(hidden)]
    pub integration_type: std::option::Option<crate::model::IntegrationType>,
    /// <p>The Amazon Resource Name (ARN) of the integration.</p> <note>
    /// <p>When integrating with Amazon Pinpoint, the Amazon Connect and Amazon Pinpoint instances must be in the same account.</p>
    /// </note>
    #[doc(hidden)]
    pub integration_arn: std::option::Option<std::string::String>,
    /// <p>The URL for the external application. This field is only required for the EVENT integration type.</p>
    #[doc(hidden)]
    pub source_application_url: std::option::Option<std::string::String>,
    /// <p>The name of the external application. This field is only required for the EVENT integration type.</p>
    #[doc(hidden)]
    pub source_application_name: std::option::Option<std::string::String>,
    /// <p>The type of the data source. This field is only required for the EVENT integration type.</p>
    #[doc(hidden)]
    pub source_type: std::option::Option<crate::model::SourceType>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateIntegrationAssociationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The type of information to be ingested.</p>
    pub fn integration_type(&self) -> std::option::Option<&crate::model::IntegrationType> {
        self.integration_type.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the integration.</p> <note>
    /// <p>When integrating with Amazon Pinpoint, the Amazon Connect and Amazon Pinpoint instances must be in the same account.</p>
    /// </note>
    pub fn integration_arn(&self) -> std::option::Option<&str> {
        self.integration_arn.as_deref()
    }
    /// <p>The URL for the external application. This field is only required for the EVENT integration type.</p>
    pub fn source_application_url(&self) -> std::option::Option<&str> {
        self.source_application_url.as_deref()
    }
    /// <p>The name of the external application. This field is only required for the EVENT integration type.</p>
    pub fn source_application_name(&self) -> std::option::Option<&str> {
        self.source_application_name.as_deref()
    }
    /// <p>The type of the data source. This field is only required for the EVENT integration type.</p>
    pub fn source_type(&self) -> std::option::Option<&crate::model::SourceType> {
        self.source_type.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateIntegrationAssociationInput {
    /// Creates a new builder-style object to manufacture [`CreateIntegrationAssociationInput`](crate::input::CreateIntegrationAssociationInput).
    pub fn builder() -> crate::input::create_integration_association_input::Builder {
        crate::input::create_integration_association_input::Builder::default()
    }
}

/// See [`CreateIntegrationAssociationInput`](crate::input::CreateIntegrationAssociationInput).
pub mod create_integration_association_input {

    /// A builder for [`CreateIntegrationAssociationInput`](crate::input::CreateIntegrationAssociationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) integration_type: std::option::Option<crate::model::IntegrationType>,
        pub(crate) integration_arn: std::option::Option<std::string::String>,
        pub(crate) source_application_url: std::option::Option<std::string::String>,
        pub(crate) source_application_name: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<crate::model::SourceType>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The type of information to be ingested.</p>
        pub fn integration_type(mut self, input: crate::model::IntegrationType) -> Self {
            self.integration_type = Some(input);
            self
        }
        /// <p>The type of information to be ingested.</p>
        pub fn set_integration_type(
            mut self,
            input: std::option::Option<crate::model::IntegrationType>,
        ) -> Self {
            self.integration_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the integration.</p> <note>
        /// <p>When integrating with Amazon Pinpoint, the Amazon Connect and Amazon Pinpoint instances must be in the same account.</p>
        /// </note>
        pub fn integration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.integration_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the integration.</p> <note>
        /// <p>When integrating with Amazon Pinpoint, the Amazon Connect and Amazon Pinpoint instances must be in the same account.</p>
        /// </note>
        pub fn set_integration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.integration_arn = input;
            self
        }
        /// <p>The URL for the external application. This field is only required for the EVENT integration type.</p>
        pub fn source_application_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_application_url = Some(input.into());
            self
        }
        /// <p>The URL for the external application. This field is only required for the EVENT integration type.</p>
        pub fn set_source_application_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_application_url = input;
            self
        }
        /// <p>The name of the external application. This field is only required for the EVENT integration type.</p>
        pub fn source_application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_application_name = Some(input.into());
            self
        }
        /// <p>The name of the external application. This field is only required for the EVENT integration type.</p>
        pub fn set_source_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_application_name = input;
            self
        }
        /// <p>The type of the data source. This field is only required for the EVENT integration type.</p>
        pub fn source_type(mut self, input: crate::model::SourceType) -> Self {
            self.source_type = Some(input);
            self
        }
        /// <p>The type of the data source. This field is only required for the EVENT integration type.</p>
        pub fn set_source_type(
            mut self,
            input: std::option::Option<crate::model::SourceType>,
        ) -> Self {
            self.source_type = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateIntegrationAssociationInput`](crate::input::CreateIntegrationAssociationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateIntegrationAssociationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateIntegrationAssociationInput {
                instance_id: self.instance_id,
                integration_type: self.integration_type,
                integration_arn: self.integration_arn,
                source_application_url: self.source_application_url,
                source_application_name: self.source_application_name,
                source_type: self.source_type,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateInstanceInput {
    /// <p>The idempotency token.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The type of identity management for your Amazon Connect users.</p>
    #[doc(hidden)]
    pub identity_management_type: std::option::Option<crate::model::DirectoryType>,
    /// <p>The name for your instance.</p>
    #[doc(hidden)]
    pub instance_alias: std::option::Option<std::string::String>,
    /// <p>The identifier for the directory.</p>
    #[doc(hidden)]
    pub directory_id: std::option::Option<std::string::String>,
    /// <p>Your contact center handles incoming contacts.</p>
    #[doc(hidden)]
    pub inbound_calls_enabled: std::option::Option<bool>,
    /// <p>Your contact center allows outbound calls.</p>
    #[doc(hidden)]
    pub outbound_calls_enabled: std::option::Option<bool>,
}
impl CreateInstanceInput {
    /// <p>The idempotency token.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The type of identity management for your Amazon Connect users.</p>
    pub fn identity_management_type(&self) -> std::option::Option<&crate::model::DirectoryType> {
        self.identity_management_type.as_ref()
    }
    /// <p>The name for your instance.</p>
    pub fn instance_alias(&self) -> std::option::Option<&str> {
        self.instance_alias.as_deref()
    }
    /// <p>The identifier for the directory.</p>
    pub fn directory_id(&self) -> std::option::Option<&str> {
        self.directory_id.as_deref()
    }
    /// <p>Your contact center handles incoming contacts.</p>
    pub fn inbound_calls_enabled(&self) -> std::option::Option<bool> {
        self.inbound_calls_enabled
    }
    /// <p>Your contact center allows outbound calls.</p>
    pub fn outbound_calls_enabled(&self) -> std::option::Option<bool> {
        self.outbound_calls_enabled
    }
}
impl std::fmt::Debug for CreateInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateInstanceInput");
        formatter.field("client_token", &self.client_token);
        formatter.field("identity_management_type", &self.identity_management_type);
        formatter.field("instance_alias", &"*** Sensitive Data Redacted ***");
        formatter.field("directory_id", &self.directory_id);
        formatter.field("inbound_calls_enabled", &self.inbound_calls_enabled);
        formatter.field("outbound_calls_enabled", &self.outbound_calls_enabled);
        formatter.finish()
    }
}
impl CreateInstanceInput {
    /// Creates a new builder-style object to manufacture [`CreateInstanceInput`](crate::input::CreateInstanceInput).
    pub fn builder() -> crate::input::create_instance_input::Builder {
        crate::input::create_instance_input::Builder::default()
    }
}

/// See [`CreateInstanceInput`](crate::input::CreateInstanceInput).
pub mod create_instance_input {

    /// A builder for [`CreateInstanceInput`](crate::input::CreateInstanceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) identity_management_type: std::option::Option<crate::model::DirectoryType>,
        pub(crate) instance_alias: std::option::Option<std::string::String>,
        pub(crate) directory_id: std::option::Option<std::string::String>,
        pub(crate) inbound_calls_enabled: std::option::Option<bool>,
        pub(crate) outbound_calls_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The idempotency token.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The idempotency token.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>The type of identity management for your Amazon Connect users.</p>
        pub fn identity_management_type(mut self, input: crate::model::DirectoryType) -> Self {
            self.identity_management_type = Some(input);
            self
        }
        /// <p>The type of identity management for your Amazon Connect users.</p>
        pub fn set_identity_management_type(
            mut self,
            input: std::option::Option<crate::model::DirectoryType>,
        ) -> Self {
            self.identity_management_type = input;
            self
        }
        /// <p>The name for your instance.</p>
        pub fn instance_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_alias = Some(input.into());
            self
        }
        /// <p>The name for your instance.</p>
        pub fn set_instance_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_alias = input;
            self
        }
        /// <p>The identifier for the directory.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        /// <p>The identifier for the directory.</p>
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// <p>Your contact center handles incoming contacts.</p>
        pub fn inbound_calls_enabled(mut self, input: bool) -> Self {
            self.inbound_calls_enabled = Some(input);
            self
        }
        /// <p>Your contact center handles incoming contacts.</p>
        pub fn set_inbound_calls_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inbound_calls_enabled = input;
            self
        }
        /// <p>Your contact center allows outbound calls.</p>
        pub fn outbound_calls_enabled(mut self, input: bool) -> Self {
            self.outbound_calls_enabled = Some(input);
            self
        }
        /// <p>Your contact center allows outbound calls.</p>
        pub fn set_outbound_calls_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.outbound_calls_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateInstanceInput`](crate::input::CreateInstanceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateInstanceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateInstanceInput {
                client_token: self.client_token,
                identity_management_type: self.identity_management_type,
                instance_alias: self.instance_alias,
                directory_id: self.directory_id,
                inbound_calls_enabled: self.inbound_calls_enabled,
                outbound_calls_enabled: self.outbound_calls_enabled,
            })
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("client_token", &self.client_token);
            formatter.field("identity_management_type", &self.identity_management_type);
            formatter.field("instance_alias", &"*** Sensitive Data Redacted ***");
            formatter.field("directory_id", &self.directory_id);
            formatter.field("inbound_calls_enabled", &self.inbound_calls_enabled);
            formatter.field("outbound_calls_enabled", &self.outbound_calls_enabled);
            formatter.finish()
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateHoursOfOperationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the hours of operation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the hours of operation.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The time zone of the hours of operation.</p>
    #[doc(hidden)]
    pub time_zone: std::option::Option<std::string::String>,
    /// <p>Configuration information for the hours of operation: day, start time, and end time.</p>
    #[doc(hidden)]
    pub config: std::option::Option<std::vec::Vec<crate::model::HoursOfOperationConfig>>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateHoursOfOperationInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the hours of operation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the hours of operation.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The time zone of the hours of operation.</p>
    pub fn time_zone(&self) -> std::option::Option<&str> {
        self.time_zone.as_deref()
    }
    /// <p>Configuration information for the hours of operation: day, start time, and end time.</p>
    pub fn config(&self) -> std::option::Option<&[crate::model::HoursOfOperationConfig]> {
        self.config.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateHoursOfOperationInput {
    /// Creates a new builder-style object to manufacture [`CreateHoursOfOperationInput`](crate::input::CreateHoursOfOperationInput).
    pub fn builder() -> crate::input::create_hours_of_operation_input::Builder {
        crate::input::create_hours_of_operation_input::Builder::default()
    }
}

/// See [`CreateHoursOfOperationInput`](crate::input::CreateHoursOfOperationInput).
pub mod create_hours_of_operation_input {

    /// A builder for [`CreateHoursOfOperationInput`](crate::input::CreateHoursOfOperationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) time_zone: std::option::Option<std::string::String>,
        pub(crate) config: std::option::Option<std::vec::Vec<crate::model::HoursOfOperationConfig>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the hours of operation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hours of operation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the hours of operation.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the hours of operation.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The time zone of the hours of operation.</p>
        pub fn time_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.time_zone = Some(input.into());
            self
        }
        /// <p>The time zone of the hours of operation.</p>
        pub fn set_time_zone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.time_zone = input;
            self
        }
        /// Appends an item to `config`.
        ///
        /// To override the contents of this collection use [`set_config`](Self::set_config).
        ///
        /// <p>Configuration information for the hours of operation: day, start time, and end time.</p>
        pub fn config(mut self, input: crate::model::HoursOfOperationConfig) -> Self {
            let mut v = self.config.unwrap_or_default();
            v.push(input);
            self.config = Some(v);
            self
        }
        /// <p>Configuration information for the hours of operation: day, start time, and end time.</p>
        pub fn set_config(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HoursOfOperationConfig>>,
        ) -> Self {
            self.config = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateHoursOfOperationInput`](crate::input::CreateHoursOfOperationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateHoursOfOperationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateHoursOfOperationInput {
                instance_id: self.instance_id,
                name: self.name,
                description: self.description,
                time_zone: self.time_zone,
                config: self.config,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateContactFlowModuleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the flow module.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the flow module. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The content of the flow module.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateContactFlowModuleInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the flow module.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the flow module. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The content of the flow module.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl CreateContactFlowModuleInput {
    /// Creates a new builder-style object to manufacture [`CreateContactFlowModuleInput`](crate::input::CreateContactFlowModuleInput).
    pub fn builder() -> crate::input::create_contact_flow_module_input::Builder {
        crate::input::create_contact_flow_module_input::Builder::default()
    }
}

/// See [`CreateContactFlowModuleInput`](crate::input::CreateContactFlowModuleInput).
pub mod create_contact_flow_module_input {

    /// A builder for [`CreateContactFlowModuleInput`](crate::input::CreateContactFlowModuleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the flow module.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the flow module.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the flow module. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the flow module. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The content of the flow module.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the flow module.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateContactFlowModuleInput`](crate::input::CreateContactFlowModuleInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateContactFlowModuleInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateContactFlowModuleInput {
                instance_id: self.instance_id,
                name: self.name,
                description: self.description,
                content: self.content,
                tags: self.tags,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateContactFlowInput {
    /// <p>The identifier of the Amazon Connect instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the flow.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a flow type</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ContactFlowType>,
    /// <p>The description of the flow. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The content of the flow. </p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateContactFlowInput {
    /// <p>The identifier of the Amazon Connect instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the flow.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a flow type</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ContactFlowType> {
        self.r#type.as_ref()
    }
    /// <p>The description of the flow. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The content of the flow. </p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateContactFlowInput {
    /// Creates a new builder-style object to manufacture [`CreateContactFlowInput`](crate::input::CreateContactFlowInput).
    pub fn builder() -> crate::input::create_contact_flow_input::Builder {
        crate::input::create_contact_flow_input::Builder::default()
    }
}

/// See [`CreateContactFlowInput`](crate::input::CreateContactFlowInput).
pub mod create_contact_flow_input {

    /// A builder for [`CreateContactFlowInput`](crate::input::CreateContactFlowInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ContactFlowType>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the flow.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the flow.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a flow type</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn r#type(mut self, input: crate::model::ContactFlowType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a flow type</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ContactFlowType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The description of the flow. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the flow. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The content of the flow. </p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the flow. </p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateContactFlowInput`](crate::input::CreateContactFlowInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateContactFlowInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateContactFlowInput {
                instance_id: self.instance_id,
                name: self.name,
                r#type: self.r#type,
                description: self.description,
                content: self.content,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAgentStatusInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the status.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the status.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The state of the status.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::AgentStatusState>,
    /// <p>The display order of the status.</p>
    #[doc(hidden)]
    pub display_order: std::option::Option<i32>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateAgentStatusInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the status.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the status.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The state of the status.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::AgentStatusState> {
        self.state.as_ref()
    }
    /// <p>The display order of the status.</p>
    pub fn display_order(&self) -> std::option::Option<i32> {
        self.display_order
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateAgentStatusInput {
    /// Creates a new builder-style object to manufacture [`CreateAgentStatusInput`](crate::input::CreateAgentStatusInput).
    pub fn builder() -> crate::input::create_agent_status_input::Builder {
        crate::input::create_agent_status_input::Builder::default()
    }
}

/// See [`CreateAgentStatusInput`](crate::input::CreateAgentStatusInput).
pub mod create_agent_status_input {

    /// A builder for [`CreateAgentStatusInput`](crate::input::CreateAgentStatusInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::AgentStatusState>,
        pub(crate) display_order: std::option::Option<i32>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the status.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the status.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the status.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the status.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The state of the status.</p>
        pub fn state(mut self, input: crate::model::AgentStatusState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the status.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AgentStatusState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The display order of the status.</p>
        pub fn display_order(mut self, input: i32) -> Self {
            self.display_order = Some(input);
            self
        }
        /// <p>The display order of the status.</p>
        pub fn set_display_order(mut self, input: std::option::Option<i32>) -> Self {
            self.display_order = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAgentStatusInput`](crate::input::CreateAgentStatusInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateAgentStatusInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateAgentStatusInput {
                instance_id: self.instance_id,
                name: self.name,
                description: self.description,
                state: self.state,
                display_order: self.display_order,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClaimPhoneNumberInput {
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
    #[doc(hidden)]
    pub target_arn: std::option::Option<std::string::String>,
    /// <p>The phone number you want to claim. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    #[doc(hidden)]
    pub phone_number: std::option::Option<std::string::String>,
    /// <p>The description of the phone number.</p>
    #[doc(hidden)]
    pub phone_number_description: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    /// <p>Pattern: <code>^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$</code> </p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl ClaimPhoneNumberInput {
    /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
    pub fn target_arn(&self) -> std::option::Option<&str> {
        self.target_arn.as_deref()
    }
    /// <p>The phone number you want to claim. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
    /// <p>The description of the phone number.</p>
    pub fn phone_number_description(&self) -> std::option::Option<&str> {
        self.phone_number_description.as_deref()
    }
    /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    /// <p>Pattern: <code>^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$</code> </p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl ClaimPhoneNumberInput {
    /// Creates a new builder-style object to manufacture [`ClaimPhoneNumberInput`](crate::input::ClaimPhoneNumberInput).
    pub fn builder() -> crate::input::claim_phone_number_input::Builder {
        crate::input::claim_phone_number_input::Builder::default()
    }
}

/// See [`ClaimPhoneNumberInput`](crate::input::ClaimPhoneNumberInput).
pub mod claim_phone_number_input {

    /// A builder for [`ClaimPhoneNumberInput`](crate::input::ClaimPhoneNumberInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_arn: std::option::Option<std::string::String>,
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) phone_number_description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.</p>
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// <p>The phone number you want to claim. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>The phone number you want to claim. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// <p>The description of the phone number.</p>
        pub fn phone_number_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_description = Some(input.into());
            self
        }
        /// <p>The description of the phone number.</p>
        pub fn set_phone_number_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_description = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        /// <p>Pattern: <code>^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$</code> </p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        /// <p>Pattern: <code>^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$</code> </p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ClaimPhoneNumberInput`](crate::input::ClaimPhoneNumberInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ClaimPhoneNumberInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ClaimPhoneNumberInput {
                target_arn: self.target_arn,
                phone_number: self.phone_number,
                phone_number_description: self.phone_number_description,
                tags: self.tags,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateSecurityKeyInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A valid security key in PEM format.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
}
impl AssociateSecurityKeyInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>A valid security key in PEM format.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
}
impl AssociateSecurityKeyInput {
    /// Creates a new builder-style object to manufacture [`AssociateSecurityKeyInput`](crate::input::AssociateSecurityKeyInput).
    pub fn builder() -> crate::input::associate_security_key_input::Builder {
        crate::input::associate_security_key_input::Builder::default()
    }
}

/// See [`AssociateSecurityKeyInput`](crate::input::AssociateSecurityKeyInput).
pub mod associate_security_key_input {

    /// A builder for [`AssociateSecurityKeyInput`](crate::input::AssociateSecurityKeyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>A valid security key in PEM format.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>A valid security key in PEM format.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateSecurityKeyInput`](crate::input::AssociateSecurityKeyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociateSecurityKeyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociateSecurityKeyInput {
                instance_id: self.instance_id,
                key: self.key,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateRoutingProfileQueuesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the routing profile.</p>
    #[doc(hidden)]
    pub routing_profile_id: std::option::Option<std::string::String>,
    /// <p>The queues to associate with this routing profile.</p>
    #[doc(hidden)]
    pub queue_configs: std::option::Option<std::vec::Vec<crate::model::RoutingProfileQueueConfig>>,
}
impl AssociateRoutingProfileQueuesInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the routing profile.</p>
    pub fn routing_profile_id(&self) -> std::option::Option<&str> {
        self.routing_profile_id.as_deref()
    }
    /// <p>The queues to associate with this routing profile.</p>
    pub fn queue_configs(&self) -> std::option::Option<&[crate::model::RoutingProfileQueueConfig]> {
        self.queue_configs.as_deref()
    }
}
impl AssociateRoutingProfileQueuesInput {
    /// Creates a new builder-style object to manufacture [`AssociateRoutingProfileQueuesInput`](crate::input::AssociateRoutingProfileQueuesInput).
    pub fn builder() -> crate::input::associate_routing_profile_queues_input::Builder {
        crate::input::associate_routing_profile_queues_input::Builder::default()
    }
}

/// See [`AssociateRoutingProfileQueuesInput`](crate::input::AssociateRoutingProfileQueuesInput).
pub mod associate_routing_profile_queues_input {

    /// A builder for [`AssociateRoutingProfileQueuesInput`](crate::input::AssociateRoutingProfileQueuesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) routing_profile_id: std::option::Option<std::string::String>,
        pub(crate) queue_configs:
            std::option::Option<std::vec::Vec<crate::model::RoutingProfileQueueConfig>>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn routing_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.routing_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the routing profile.</p>
        pub fn set_routing_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.routing_profile_id = input;
            self
        }
        /// Appends an item to `queue_configs`.
        ///
        /// To override the contents of this collection use [`set_queue_configs`](Self::set_queue_configs).
        ///
        /// <p>The queues to associate with this routing profile.</p>
        pub fn queue_configs(mut self, input: crate::model::RoutingProfileQueueConfig) -> Self {
            let mut v = self.queue_configs.unwrap_or_default();
            v.push(input);
            self.queue_configs = Some(v);
            self
        }
        /// <p>The queues to associate with this routing profile.</p>
        pub fn set_queue_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RoutingProfileQueueConfig>>,
        ) -> Self {
            self.queue_configs = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateRoutingProfileQueuesInput`](crate::input::AssociateRoutingProfileQueuesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociateRoutingProfileQueuesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociateRoutingProfileQueuesInput {
                instance_id: self.instance_id,
                routing_profile_id: self.routing_profile_id,
                queue_configs: self.queue_configs,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateQueueQuickConnectsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the queue.</p>
    #[doc(hidden)]
    pub queue_id: std::option::Option<std::string::String>,
    /// <p>The quick connects to associate with this queue.</p>
    #[doc(hidden)]
    pub quick_connect_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AssociateQueueQuickConnectsInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier for the queue.</p>
    pub fn queue_id(&self) -> std::option::Option<&str> {
        self.queue_id.as_deref()
    }
    /// <p>The quick connects to associate with this queue.</p>
    pub fn quick_connect_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.quick_connect_ids.as_deref()
    }
}
impl AssociateQueueQuickConnectsInput {
    /// Creates a new builder-style object to manufacture [`AssociateQueueQuickConnectsInput`](crate::input::AssociateQueueQuickConnectsInput).
    pub fn builder() -> crate::input::associate_queue_quick_connects_input::Builder {
        crate::input::associate_queue_quick_connects_input::Builder::default()
    }
}

/// See [`AssociateQueueQuickConnectsInput`](crate::input::AssociateQueueQuickConnectsInput).
pub mod associate_queue_quick_connects_input {

    /// A builder for [`AssociateQueueQuickConnectsInput`](crate::input::AssociateQueueQuickConnectsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) queue_id: std::option::Option<std::string::String>,
        pub(crate) quick_connect_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_id = Some(input.into());
            self
        }
        /// <p>The identifier for the queue.</p>
        pub fn set_queue_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_id = input;
            self
        }
        /// Appends an item to `quick_connect_ids`.
        ///
        /// To override the contents of this collection use [`set_quick_connect_ids`](Self::set_quick_connect_ids).
        ///
        /// <p>The quick connects to associate with this queue.</p>
        pub fn quick_connect_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.quick_connect_ids.unwrap_or_default();
            v.push(input.into());
            self.quick_connect_ids = Some(v);
            self
        }
        /// <p>The quick connects to associate with this queue.</p>
        pub fn set_quick_connect_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.quick_connect_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateQueueQuickConnectsInput`](crate::input::AssociateQueueQuickConnectsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociateQueueQuickConnectsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociateQueueQuickConnectsInput {
                instance_id: self.instance_id,
                queue_id: self.queue_id,
                quick_connect_ids: self.quick_connect_ids,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociatePhoneNumberContactFlowInput {
    /// <p>A unique identifier for the phone number.</p>
    #[doc(hidden)]
    pub phone_number_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the flow.</p>
    #[doc(hidden)]
    pub contact_flow_id: std::option::Option<std::string::String>,
}
impl AssociatePhoneNumberContactFlowInput {
    /// <p>A unique identifier for the phone number.</p>
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The identifier of the flow.</p>
    pub fn contact_flow_id(&self) -> std::option::Option<&str> {
        self.contact_flow_id.as_deref()
    }
}
impl AssociatePhoneNumberContactFlowInput {
    /// Creates a new builder-style object to manufacture [`AssociatePhoneNumberContactFlowInput`](crate::input::AssociatePhoneNumberContactFlowInput).
    pub fn builder() -> crate::input::associate_phone_number_contact_flow_input::Builder {
        crate::input::associate_phone_number_contact_flow_input::Builder::default()
    }
}

/// See [`AssociatePhoneNumberContactFlowInput`](crate::input::AssociatePhoneNumberContactFlowInput).
pub mod associate_phone_number_contact_flow_input {

    /// A builder for [`AssociatePhoneNumberContactFlowInput`](crate::input::AssociatePhoneNumberContactFlowInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) contact_flow_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for the phone number.</p>
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the phone number.</p>
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_flow_id = Some(input.into());
            self
        }
        /// <p>The identifier of the flow.</p>
        pub fn set_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_flow_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociatePhoneNumberContactFlowInput`](crate::input::AssociatePhoneNumberContactFlowInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociatePhoneNumberContactFlowInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociatePhoneNumberContactFlowInput {
                phone_number_id: self.phone_number_id,
                instance_id: self.instance_id,
                contact_flow_id: self.contact_flow_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateLexBotInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Lex bot to associate with the instance.</p>
    #[doc(hidden)]
    pub lex_bot: std::option::Option<crate::model::LexBot>,
}
impl AssociateLexBotInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The Amazon Lex bot to associate with the instance.</p>
    pub fn lex_bot(&self) -> std::option::Option<&crate::model::LexBot> {
        self.lex_bot.as_ref()
    }
}
impl AssociateLexBotInput {
    /// Creates a new builder-style object to manufacture [`AssociateLexBotInput`](crate::input::AssociateLexBotInput).
    pub fn builder() -> crate::input::associate_lex_bot_input::Builder {
        crate::input::associate_lex_bot_input::Builder::default()
    }
}

/// See [`AssociateLexBotInput`](crate::input::AssociateLexBotInput).
pub mod associate_lex_bot_input {

    /// A builder for [`AssociateLexBotInput`](crate::input::AssociateLexBotInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) lex_bot: std::option::Option<crate::model::LexBot>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The Amazon Lex bot to associate with the instance.</p>
        pub fn lex_bot(mut self, input: crate::model::LexBot) -> Self {
            self.lex_bot = Some(input);
            self
        }
        /// <p>The Amazon Lex bot to associate with the instance.</p>
        pub fn set_lex_bot(mut self, input: std::option::Option<crate::model::LexBot>) -> Self {
            self.lex_bot = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateLexBotInput`](crate::input::AssociateLexBotInput).
        pub fn build(
            self,
        ) -> Result<crate::input::AssociateLexBotInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::AssociateLexBotInput {
                instance_id: self.instance_id,
                lex_bot: self.lex_bot,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateLambdaFunctionInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the Lambda function being associated. Maximum number of characters allowed is 140.</p>
    #[doc(hidden)]
    pub function_arn: std::option::Option<std::string::String>,
}
impl AssociateLambdaFunctionInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the Lambda function being associated. Maximum number of characters allowed is 140.</p>
    pub fn function_arn(&self) -> std::option::Option<&str> {
        self.function_arn.as_deref()
    }
}
impl AssociateLambdaFunctionInput {
    /// Creates a new builder-style object to manufacture [`AssociateLambdaFunctionInput`](crate::input::AssociateLambdaFunctionInput).
    pub fn builder() -> crate::input::associate_lambda_function_input::Builder {
        crate::input::associate_lambda_function_input::Builder::default()
    }
}

/// See [`AssociateLambdaFunctionInput`](crate::input::AssociateLambdaFunctionInput).
pub mod associate_lambda_function_input {

    /// A builder for [`AssociateLambdaFunctionInput`](crate::input::AssociateLambdaFunctionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) function_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the Lambda function being associated. Maximum number of characters allowed is 140.</p>
        pub fn function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the Lambda function being associated. Maximum number of characters allowed is 140.</p>
        pub fn set_function_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateLambdaFunctionInput`](crate::input::AssociateLambdaFunctionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociateLambdaFunctionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociateLambdaFunctionInput {
                instance_id: self.instance_id,
                function_arn: self.function_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateInstanceStorageConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A valid resource type.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::InstanceStorageResourceType>,
    /// <p>A valid storage type.</p>
    #[doc(hidden)]
    pub storage_config: std::option::Option<crate::model::InstanceStorageConfig>,
}
impl AssociateInstanceStorageConfigInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>A valid resource type.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::InstanceStorageResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>A valid storage type.</p>
    pub fn storage_config(&self) -> std::option::Option<&crate::model::InstanceStorageConfig> {
        self.storage_config.as_ref()
    }
}
impl AssociateInstanceStorageConfigInput {
    /// Creates a new builder-style object to manufacture [`AssociateInstanceStorageConfigInput`](crate::input::AssociateInstanceStorageConfigInput).
    pub fn builder() -> crate::input::associate_instance_storage_config_input::Builder {
        crate::input::associate_instance_storage_config_input::Builder::default()
    }
}

/// See [`AssociateInstanceStorageConfigInput`](crate::input::AssociateInstanceStorageConfigInput).
pub mod associate_instance_storage_config_input {

    /// A builder for [`AssociateInstanceStorageConfigInput`](crate::input::AssociateInstanceStorageConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::InstanceStorageResourceType>,
        pub(crate) storage_config: std::option::Option<crate::model::InstanceStorageConfig>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>A valid resource type.</p>
        pub fn resource_type(mut self, input: crate::model::InstanceStorageResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>A valid resource type.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::InstanceStorageResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>A valid storage type.</p>
        pub fn storage_config(mut self, input: crate::model::InstanceStorageConfig) -> Self {
            self.storage_config = Some(input);
            self
        }
        /// <p>A valid storage type.</p>
        pub fn set_storage_config(
            mut self,
            input: std::option::Option<crate::model::InstanceStorageConfig>,
        ) -> Self {
            self.storage_config = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateInstanceStorageConfigInput`](crate::input::AssociateInstanceStorageConfigInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociateInstanceStorageConfigInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociateInstanceStorageConfigInput {
                instance_id: self.instance_id,
                resource_type: self.resource_type,
                storage_config: self.storage_config,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateDefaultVocabularyInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
    /// <p>The identifier of the custom vocabulary. If this is empty, the default is set to none.</p>
    #[doc(hidden)]
    pub vocabulary_id: std::option::Option<std::string::String>,
}
impl AssociateDefaultVocabularyInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::VocabularyLanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The identifier of the custom vocabulary. If this is empty, the default is set to none.</p>
    pub fn vocabulary_id(&self) -> std::option::Option<&str> {
        self.vocabulary_id.as_deref()
    }
}
impl AssociateDefaultVocabularyInput {
    /// Creates a new builder-style object to manufacture [`AssociateDefaultVocabularyInput`](crate::input::AssociateDefaultVocabularyInput).
    pub fn builder() -> crate::input::associate_default_vocabulary_input::Builder {
        crate::input::associate_default_vocabulary_input::Builder::default()
    }
}

/// See [`AssociateDefaultVocabularyInput`](crate::input::AssociateDefaultVocabularyInput).
pub mod associate_default_vocabulary_input {

    /// A builder for [`AssociateDefaultVocabularyInput`](crate::input::AssociateDefaultVocabularyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::VocabularyLanguageCode>,
        pub(crate) vocabulary_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn language_code(mut self, input: crate::model::VocabularyLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> </p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::VocabularyLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The identifier of the custom vocabulary. If this is empty, the default is set to none.</p>
        pub fn vocabulary_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_id = Some(input.into());
            self
        }
        /// <p>The identifier of the custom vocabulary. If this is empty, the default is set to none.</p>
        pub fn set_vocabulary_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateDefaultVocabularyInput`](crate::input::AssociateDefaultVocabularyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociateDefaultVocabularyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociateDefaultVocabularyInput {
                instance_id: self.instance_id,
                language_code: self.language_code,
                vocabulary_id: self.vocabulary_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateBotInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>Configuration information of an Amazon Lex bot.</p>
    #[doc(hidden)]
    pub lex_bot: std::option::Option<crate::model::LexBot>,
    /// <p>The Amazon Lex V2 bot to associate with the instance.</p>
    #[doc(hidden)]
    pub lex_v2_bot: std::option::Option<crate::model::LexV2Bot>,
}
impl AssociateBotInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>Configuration information of an Amazon Lex bot.</p>
    pub fn lex_bot(&self) -> std::option::Option<&crate::model::LexBot> {
        self.lex_bot.as_ref()
    }
    /// <p>The Amazon Lex V2 bot to associate with the instance.</p>
    pub fn lex_v2_bot(&self) -> std::option::Option<&crate::model::LexV2Bot> {
        self.lex_v2_bot.as_ref()
    }
}
impl AssociateBotInput {
    /// Creates a new builder-style object to manufacture [`AssociateBotInput`](crate::input::AssociateBotInput).
    pub fn builder() -> crate::input::associate_bot_input::Builder {
        crate::input::associate_bot_input::Builder::default()
    }
}

/// See [`AssociateBotInput`](crate::input::AssociateBotInput).
pub mod associate_bot_input {

    /// A builder for [`AssociateBotInput`](crate::input::AssociateBotInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) lex_bot: std::option::Option<crate::model::LexBot>,
        pub(crate) lex_v2_bot: std::option::Option<crate::model::LexV2Bot>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>Configuration information of an Amazon Lex bot.</p>
        pub fn lex_bot(mut self, input: crate::model::LexBot) -> Self {
            self.lex_bot = Some(input);
            self
        }
        /// <p>Configuration information of an Amazon Lex bot.</p>
        pub fn set_lex_bot(mut self, input: std::option::Option<crate::model::LexBot>) -> Self {
            self.lex_bot = input;
            self
        }
        /// <p>The Amazon Lex V2 bot to associate with the instance.</p>
        pub fn lex_v2_bot(mut self, input: crate::model::LexV2Bot) -> Self {
            self.lex_v2_bot = Some(input);
            self
        }
        /// <p>The Amazon Lex V2 bot to associate with the instance.</p>
        pub fn set_lex_v2_bot(
            mut self,
            input: std::option::Option<crate::model::LexV2Bot>,
        ) -> Self {
            self.lex_v2_bot = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateBotInput`](crate::input::AssociateBotInput).
        pub fn build(
            self,
        ) -> Result<crate::input::AssociateBotInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::AssociateBotInput {
                instance_id: self.instance_id,
                lex_bot: self.lex_bot,
                lex_v2_bot: self.lex_v2_bot,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateApprovedOriginInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The domain to add to your allow list.</p>
    #[doc(hidden)]
    pub origin: std::option::Option<std::string::String>,
}
impl AssociateApprovedOriginInput {
    /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The domain to add to your allow list.</p>
    pub fn origin(&self) -> std::option::Option<&str> {
        self.origin.as_deref()
    }
}
impl AssociateApprovedOriginInput {
    /// Creates a new builder-style object to manufacture [`AssociateApprovedOriginInput`](crate::input::AssociateApprovedOriginInput).
    pub fn builder() -> crate::input::associate_approved_origin_input::Builder {
        crate::input::associate_approved_origin_input::Builder::default()
    }
}

/// See [`AssociateApprovedOriginInput`](crate::input::AssociateApprovedOriginInput).
pub mod associate_approved_origin_input {

    /// A builder for [`AssociateApprovedOriginInput`](crate::input::AssociateApprovedOriginInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) origin: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The domain to add to your allow list.</p>
        pub fn origin(mut self, input: impl Into<std::string::String>) -> Self {
            self.origin = Some(input.into());
            self
        }
        /// <p>The domain to add to your allow list.</p>
        pub fn set_origin(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.origin = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateApprovedOriginInput`](crate::input::AssociateApprovedOriginInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociateApprovedOriginInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociateApprovedOriginInput {
                instance_id: self.instance_id,
                origin: self.origin,
            })
        }
    }
}
