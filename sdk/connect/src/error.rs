// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateApprovedOriginError {
    pub kind: AssociateApprovedOriginErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateApprovedOriginErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateApprovedOriginError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateApprovedOriginErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            AssociateApprovedOriginErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AssociateApprovedOriginErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AssociateApprovedOriginErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            AssociateApprovedOriginErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateApprovedOriginErrorKind::ServiceQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            AssociateApprovedOriginErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateApprovedOriginErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateApprovedOriginError {
    fn code(&self) -> Option<&str> {
        AssociateApprovedOriginError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateApprovedOriginError {
    pub fn new(kind: AssociateApprovedOriginErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateApprovedOriginErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateApprovedOriginErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovedOriginErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovedOriginErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovedOriginErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovedOriginErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovedOriginErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovedOriginErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovedOriginErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AssociateApprovedOriginError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateApprovedOriginErrorKind::InternalServiceException(_inner) => Some(_inner),
            AssociateApprovedOriginErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AssociateApprovedOriginErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AssociateApprovedOriginErrorKind::ResourceConflictException(_inner) => Some(_inner),
            AssociateApprovedOriginErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateApprovedOriginErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            AssociateApprovedOriginErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateApprovedOriginErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateBotError {
    pub kind: AssociateBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateBotErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateBotErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            AssociateBotErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AssociateBotErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AssociateBotErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            AssociateBotErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateBotErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            AssociateBotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateBotError {
    fn code(&self) -> Option<&str> {
        AssociateBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateBotError {
    pub fn new(kind: AssociateBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateBotErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateBotErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, AssociateBotErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateBotErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateBotErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateBotErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, AssociateBotErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for AssociateBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateBotErrorKind::InternalServiceException(_inner) => Some(_inner),
            AssociateBotErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AssociateBotErrorKind::LimitExceededException(_inner) => Some(_inner),
            AssociateBotErrorKind::ResourceConflictException(_inner) => Some(_inner),
            AssociateBotErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateBotErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            AssociateBotErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateInstanceStorageConfigError {
    pub kind: AssociateInstanceStorageConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateInstanceStorageConfigErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateInstanceStorageConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateInstanceStorageConfigErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            AssociateInstanceStorageConfigErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            AssociateInstanceStorageConfigErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            AssociateInstanceStorageConfigErrorKind::ResourceConflictException(_inner) => {
                _inner.fmt(f)
            }
            AssociateInstanceStorageConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateInstanceStorageConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateInstanceStorageConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateInstanceStorageConfigError {
    fn code(&self) -> Option<&str> {
        AssociateInstanceStorageConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateInstanceStorageConfigError {
    pub fn new(kind: AssociateInstanceStorageConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateInstanceStorageConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateInstanceStorageConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateInstanceStorageConfigErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateInstanceStorageConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateInstanceStorageConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateInstanceStorageConfigErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateInstanceStorageConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateInstanceStorageConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AssociateInstanceStorageConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateInstanceStorageConfigErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            AssociateInstanceStorageConfigErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            AssociateInstanceStorageConfigErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            AssociateInstanceStorageConfigErrorKind::ResourceConflictException(_inner) => {
                Some(_inner)
            }
            AssociateInstanceStorageConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AssociateInstanceStorageConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateInstanceStorageConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateLambdaFunctionError {
    pub kind: AssociateLambdaFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateLambdaFunctionErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateLambdaFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateLambdaFunctionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            AssociateLambdaFunctionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AssociateLambdaFunctionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AssociateLambdaFunctionErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            AssociateLambdaFunctionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateLambdaFunctionErrorKind::ServiceQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            AssociateLambdaFunctionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateLambdaFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateLambdaFunctionError {
    fn code(&self) -> Option<&str> {
        AssociateLambdaFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateLambdaFunctionError {
    pub fn new(kind: AssociateLambdaFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateLambdaFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateLambdaFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateLambdaFunctionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateLambdaFunctionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateLambdaFunctionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateLambdaFunctionErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateLambdaFunctionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateLambdaFunctionErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateLambdaFunctionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AssociateLambdaFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateLambdaFunctionErrorKind::InternalServiceException(_inner) => Some(_inner),
            AssociateLambdaFunctionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AssociateLambdaFunctionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AssociateLambdaFunctionErrorKind::ResourceConflictException(_inner) => Some(_inner),
            AssociateLambdaFunctionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateLambdaFunctionErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            AssociateLambdaFunctionErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateLambdaFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateLexBotError {
    pub kind: AssociateLexBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateLexBotErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateLexBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateLexBotErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            AssociateLexBotErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AssociateLexBotErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AssociateLexBotErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            AssociateLexBotErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateLexBotErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            AssociateLexBotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateLexBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateLexBotError {
    fn code(&self) -> Option<&str> {
        AssociateLexBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateLexBotError {
    pub fn new(kind: AssociateLexBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateLexBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateLexBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateLexBotErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateLexBotErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateLexBotErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateLexBotErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateLexBotErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateLexBotErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, AssociateLexBotErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for AssociateLexBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateLexBotErrorKind::InternalServiceException(_inner) => Some(_inner),
            AssociateLexBotErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AssociateLexBotErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AssociateLexBotErrorKind::ResourceConflictException(_inner) => Some(_inner),
            AssociateLexBotErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateLexBotErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            AssociateLexBotErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateLexBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateQueueQuickConnectsError {
    pub kind: AssociateQueueQuickConnectsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateQueueQuickConnectsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateQueueQuickConnectsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateQueueQuickConnectsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            AssociateQueueQuickConnectsErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            AssociateQueueQuickConnectsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AssociateQueueQuickConnectsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AssociateQueueQuickConnectsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateQueueQuickConnectsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateQueueQuickConnectsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateQueueQuickConnectsError {
    fn code(&self) -> Option<&str> {
        AssociateQueueQuickConnectsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateQueueQuickConnectsError {
    pub fn new(kind: AssociateQueueQuickConnectsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateQueueQuickConnectsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateQueueQuickConnectsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateQueueQuickConnectsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateQueueQuickConnectsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateQueueQuickConnectsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateQueueQuickConnectsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateQueueQuickConnectsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateQueueQuickConnectsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AssociateQueueQuickConnectsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateQueueQuickConnectsErrorKind::InternalServiceException(_inner) => Some(_inner),
            AssociateQueueQuickConnectsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AssociateQueueQuickConnectsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AssociateQueueQuickConnectsErrorKind::LimitExceededException(_inner) => Some(_inner),
            AssociateQueueQuickConnectsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateQueueQuickConnectsErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateQueueQuickConnectsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateRoutingProfileQueuesError {
    pub kind: AssociateRoutingProfileQueuesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateRoutingProfileQueuesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateRoutingProfileQueuesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateRoutingProfileQueuesErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            AssociateRoutingProfileQueuesErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            AssociateRoutingProfileQueuesErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            AssociateRoutingProfileQueuesErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateRoutingProfileQueuesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateRoutingProfileQueuesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateRoutingProfileQueuesError {
    fn code(&self) -> Option<&str> {
        AssociateRoutingProfileQueuesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateRoutingProfileQueuesError {
    pub fn new(kind: AssociateRoutingProfileQueuesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateRoutingProfileQueuesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateRoutingProfileQueuesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateRoutingProfileQueuesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateRoutingProfileQueuesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateRoutingProfileQueuesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateRoutingProfileQueuesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateRoutingProfileQueuesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AssociateRoutingProfileQueuesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateRoutingProfileQueuesErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            AssociateRoutingProfileQueuesErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            AssociateRoutingProfileQueuesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AssociateRoutingProfileQueuesErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AssociateRoutingProfileQueuesErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateRoutingProfileQueuesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateSecurityKeyError {
    pub kind: AssociateSecurityKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateSecurityKeyErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateSecurityKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateSecurityKeyErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            AssociateSecurityKeyErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AssociateSecurityKeyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AssociateSecurityKeyErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            AssociateSecurityKeyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateSecurityKeyErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            AssociateSecurityKeyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateSecurityKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateSecurityKeyError {
    fn code(&self) -> Option<&str> {
        AssociateSecurityKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateSecurityKeyError {
    pub fn new(kind: AssociateSecurityKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateSecurityKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateSecurityKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSecurityKeyErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSecurityKeyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSecurityKeyErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSecurityKeyErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSecurityKeyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSecurityKeyErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSecurityKeyErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AssociateSecurityKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateSecurityKeyErrorKind::InternalServiceException(_inner) => Some(_inner),
            AssociateSecurityKeyErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AssociateSecurityKeyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AssociateSecurityKeyErrorKind::ResourceConflictException(_inner) => Some(_inner),
            AssociateSecurityKeyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateSecurityKeyErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            AssociateSecurityKeyErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateSecurityKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAgentStatusError {
    pub kind: CreateAgentStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAgentStatusErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAgentStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAgentStatusErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            CreateAgentStatusErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateAgentStatusErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateAgentStatusErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateAgentStatusErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateAgentStatusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateAgentStatusErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateAgentStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAgentStatusError {
    fn code(&self) -> Option<&str> {
        CreateAgentStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAgentStatusError {
    pub fn new(kind: CreateAgentStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAgentStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAgentStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAgentStatusErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAgentStatusErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAgentStatusErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAgentStatusErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAgentStatusErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAgentStatusErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAgentStatusErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateAgentStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAgentStatusErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            CreateAgentStatusErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateAgentStatusErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateAgentStatusErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateAgentStatusErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateAgentStatusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateAgentStatusErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateAgentStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateContactFlowError {
    pub kind: CreateContactFlowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateContactFlowErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidContactFlowException(crate::error::InvalidContactFlowException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateContactFlowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateContactFlowErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            CreateContactFlowErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateContactFlowErrorKind::InvalidContactFlowException(_inner) => _inner.fmt(f),
            CreateContactFlowErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateContactFlowErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateContactFlowErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateContactFlowErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateContactFlowErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateContactFlowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateContactFlowError {
    fn code(&self) -> Option<&str> {
        CreateContactFlowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateContactFlowError {
    pub fn new(kind: CreateContactFlowErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateContactFlowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateContactFlowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactFlowErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactFlowErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_contact_flow_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactFlowErrorKind::InvalidContactFlowException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactFlowErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactFlowErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactFlowErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactFlowErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactFlowErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateContactFlowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateContactFlowErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            CreateContactFlowErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateContactFlowErrorKind::InvalidContactFlowException(_inner) => Some(_inner),
            CreateContactFlowErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateContactFlowErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateContactFlowErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateContactFlowErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateContactFlowErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateContactFlowErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateHoursOfOperationError {
    pub kind: CreateHoursOfOperationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateHoursOfOperationErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateHoursOfOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateHoursOfOperationErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            CreateHoursOfOperationErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateHoursOfOperationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateHoursOfOperationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateHoursOfOperationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateHoursOfOperationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateHoursOfOperationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateHoursOfOperationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateHoursOfOperationError {
    fn code(&self) -> Option<&str> {
        CreateHoursOfOperationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateHoursOfOperationError {
    pub fn new(kind: CreateHoursOfOperationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateHoursOfOperationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateHoursOfOperationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateHoursOfOperationErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateHoursOfOperationErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateHoursOfOperationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateHoursOfOperationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateHoursOfOperationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateHoursOfOperationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateHoursOfOperationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateHoursOfOperationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateHoursOfOperationErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            CreateHoursOfOperationErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateHoursOfOperationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateHoursOfOperationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateHoursOfOperationErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateHoursOfOperationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateHoursOfOperationErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateHoursOfOperationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInstanceError {
    pub kind: CreateInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInstanceErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInstanceErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateInstanceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateInstanceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateInstanceErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateInstanceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInstanceError {
    fn code(&self) -> Option<&str> {
        CreateInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInstanceError {
    pub fn new(kind: CreateInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateInstanceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInstanceErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateInstanceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateInstanceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateInstanceErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateInstanceErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateIntegrationAssociationError {
    pub kind: CreateIntegrationAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateIntegrationAssociationErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateIntegrationAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateIntegrationAssociationErrorKind::DuplicateResourceException(_inner) => {
                _inner.fmt(f)
            }
            CreateIntegrationAssociationErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            CreateIntegrationAssociationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateIntegrationAssociationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateIntegrationAssociationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateIntegrationAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateIntegrationAssociationError {
    fn code(&self) -> Option<&str> {
        CreateIntegrationAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateIntegrationAssociationError {
    pub fn new(kind: CreateIntegrationAssociationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateIntegrationAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateIntegrationAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntegrationAssociationErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntegrationAssociationErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntegrationAssociationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntegrationAssociationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntegrationAssociationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateIntegrationAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateIntegrationAssociationErrorKind::DuplicateResourceException(_inner) => {
                Some(_inner)
            }
            CreateIntegrationAssociationErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateIntegrationAssociationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateIntegrationAssociationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CreateIntegrationAssociationErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateIntegrationAssociationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateQueueError {
    pub kind: CreateQueueErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateQueueErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateQueueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateQueueErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            CreateQueueErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateQueueErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateQueueErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateQueueErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateQueueErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateQueueErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateQueueErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateQueueError {
    fn code(&self) -> Option<&str> {
        CreateQueueError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateQueueError {
    pub fn new(kind: CreateQueueErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateQueueErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateQueueErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQueueErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQueueErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQueueErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, CreateQueueErrorKind::InvalidRequestException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateQueueErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQueueErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateQueueErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateQueueError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateQueueErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            CreateQueueErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateQueueErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateQueueErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateQueueErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateQueueErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateQueueErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateQueueErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateQuickConnectError {
    pub kind: CreateQuickConnectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateQuickConnectErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateQuickConnectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateQuickConnectErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            CreateQuickConnectErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateQuickConnectErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateQuickConnectErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateQuickConnectErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateQuickConnectErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateQuickConnectErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateQuickConnectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateQuickConnectError {
    fn code(&self) -> Option<&str> {
        CreateQuickConnectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateQuickConnectError {
    pub fn new(kind: CreateQuickConnectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateQuickConnectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateQuickConnectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuickConnectErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuickConnectErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuickConnectErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuickConnectErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuickConnectErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuickConnectErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuickConnectErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateQuickConnectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateQuickConnectErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            CreateQuickConnectErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateQuickConnectErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateQuickConnectErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateQuickConnectErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateQuickConnectErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateQuickConnectErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateQuickConnectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRoutingProfileError {
    pub kind: CreateRoutingProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRoutingProfileErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRoutingProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRoutingProfileErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            CreateRoutingProfileErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateRoutingProfileErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateRoutingProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateRoutingProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateRoutingProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateRoutingProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateRoutingProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRoutingProfileError {
    fn code(&self) -> Option<&str> {
        CreateRoutingProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRoutingProfileError {
    pub fn new(kind: CreateRoutingProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRoutingProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRoutingProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoutingProfileErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoutingProfileErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoutingProfileErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoutingProfileErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoutingProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoutingProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoutingProfileErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateRoutingProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRoutingProfileErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            CreateRoutingProfileErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateRoutingProfileErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateRoutingProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateRoutingProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateRoutingProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateRoutingProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateRoutingProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUseCaseError {
    pub kind: CreateUseCaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUseCaseErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUseCaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUseCaseErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            CreateUseCaseErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateUseCaseErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateUseCaseErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateUseCaseErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateUseCaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUseCaseError {
    fn code(&self) -> Option<&str> {
        CreateUseCaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUseCaseError {
    pub fn new(kind: CreateUseCaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUseCaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUseCaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUseCaseErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUseCaseErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUseCaseErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUseCaseErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateUseCaseErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateUseCaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUseCaseErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            CreateUseCaseErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateUseCaseErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateUseCaseErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateUseCaseErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateUseCaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserError {
    pub kind: CreateUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserError {
    fn code(&self) -> Option<&str> {
        CreateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserError {
    pub fn new(kind: CreateUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::InvalidRequestException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            CreateUserErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateUserErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateUserErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateUserErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateUserErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserHierarchyGroupError {
    pub kind: CreateUserHierarchyGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserHierarchyGroupErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserHierarchyGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserHierarchyGroupErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            CreateUserHierarchyGroupErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateUserHierarchyGroupErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateUserHierarchyGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateUserHierarchyGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateUserHierarchyGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateUserHierarchyGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateUserHierarchyGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserHierarchyGroupError {
    fn code(&self) -> Option<&str> {
        CreateUserHierarchyGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserHierarchyGroupError {
    pub fn new(kind: CreateUserHierarchyGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserHierarchyGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserHierarchyGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserHierarchyGroupErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserHierarchyGroupErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserHierarchyGroupErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserHierarchyGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserHierarchyGroupErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserHierarchyGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserHierarchyGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateUserHierarchyGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserHierarchyGroupErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            CreateUserHierarchyGroupErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateUserHierarchyGroupErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateUserHierarchyGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateUserHierarchyGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateUserHierarchyGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateUserHierarchyGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateUserHierarchyGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteHoursOfOperationError {
    pub kind: DeleteHoursOfOperationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteHoursOfOperationErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteHoursOfOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteHoursOfOperationErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteHoursOfOperationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteHoursOfOperationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteHoursOfOperationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteHoursOfOperationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteHoursOfOperationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteHoursOfOperationError {
    fn code(&self) -> Option<&str> {
        DeleteHoursOfOperationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteHoursOfOperationError {
    pub fn new(kind: DeleteHoursOfOperationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteHoursOfOperationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteHoursOfOperationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteHoursOfOperationErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteHoursOfOperationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteHoursOfOperationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteHoursOfOperationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteHoursOfOperationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteHoursOfOperationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteHoursOfOperationErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteHoursOfOperationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteHoursOfOperationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteHoursOfOperationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteHoursOfOperationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteHoursOfOperationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInstanceError {
    pub kind: DeleteInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInstanceErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInstanceErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteInstanceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteInstanceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInstanceError {
    fn code(&self) -> Option<&str> {
        DeleteInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInstanceError {
    pub fn new(kind: DeleteInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInstanceErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteInstanceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteInstanceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteIntegrationAssociationError {
    pub kind: DeleteIntegrationAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteIntegrationAssociationErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteIntegrationAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteIntegrationAssociationErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            DeleteIntegrationAssociationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteIntegrationAssociationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteIntegrationAssociationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteIntegrationAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteIntegrationAssociationError {
    fn code(&self) -> Option<&str> {
        DeleteIntegrationAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteIntegrationAssociationError {
    pub fn new(kind: DeleteIntegrationAssociationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteIntegrationAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteIntegrationAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntegrationAssociationErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntegrationAssociationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntegrationAssociationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntegrationAssociationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteIntegrationAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteIntegrationAssociationErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteIntegrationAssociationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteIntegrationAssociationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteIntegrationAssociationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteIntegrationAssociationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteQuickConnectError {
    pub kind: DeleteQuickConnectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteQuickConnectErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteQuickConnectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteQuickConnectErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteQuickConnectErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteQuickConnectErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteQuickConnectErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteQuickConnectErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteQuickConnectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteQuickConnectError {
    fn code(&self) -> Option<&str> {
        DeleteQuickConnectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteQuickConnectError {
    pub fn new(kind: DeleteQuickConnectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteQuickConnectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteQuickConnectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQuickConnectErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQuickConnectErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQuickConnectErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQuickConnectErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQuickConnectErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteQuickConnectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteQuickConnectErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteQuickConnectErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteQuickConnectErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteQuickConnectErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteQuickConnectErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteQuickConnectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUseCaseError {
    pub kind: DeleteUseCaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUseCaseErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUseCaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUseCaseErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteUseCaseErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteUseCaseErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteUseCaseErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteUseCaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUseCaseError {
    fn code(&self) -> Option<&str> {
        DeleteUseCaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUseCaseError {
    pub fn new(kind: DeleteUseCaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUseCaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUseCaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUseCaseErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUseCaseErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUseCaseErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteUseCaseErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteUseCaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUseCaseErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteUseCaseErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteUseCaseErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteUseCaseErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteUseCaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserError {
    pub kind: DeleteUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserError {
    fn code(&self) -> Option<&str> {
        DeleteUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserError {
    pub fn new(kind: DeleteUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteUserErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteUserErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteUserErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserHierarchyGroupError {
    pub kind: DeleteUserHierarchyGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserHierarchyGroupErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserHierarchyGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserHierarchyGroupErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteUserHierarchyGroupErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteUserHierarchyGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteUserHierarchyGroupErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteUserHierarchyGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteUserHierarchyGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteUserHierarchyGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserHierarchyGroupError {
    fn code(&self) -> Option<&str> {
        DeleteUserHierarchyGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserHierarchyGroupError {
    pub fn new(kind: DeleteUserHierarchyGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserHierarchyGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserHierarchyGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserHierarchyGroupErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserHierarchyGroupErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserHierarchyGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserHierarchyGroupErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserHierarchyGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserHierarchyGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteUserHierarchyGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserHierarchyGroupErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteUserHierarchyGroupErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteUserHierarchyGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteUserHierarchyGroupErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteUserHierarchyGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteUserHierarchyGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteUserHierarchyGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAgentStatusError {
    pub kind: DescribeAgentStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAgentStatusErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAgentStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAgentStatusErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DescribeAgentStatusErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeAgentStatusErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeAgentStatusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAgentStatusErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAgentStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAgentStatusError {
    fn code(&self) -> Option<&str> {
        DescribeAgentStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAgentStatusError {
    pub fn new(kind: DescribeAgentStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAgentStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAgentStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAgentStatusErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAgentStatusErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAgentStatusErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAgentStatusErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAgentStatusErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeAgentStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAgentStatusErrorKind::InternalServiceException(_inner) => Some(_inner),
            DescribeAgentStatusErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeAgentStatusErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeAgentStatusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAgentStatusErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAgentStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeContactFlowError {
    pub kind: DescribeContactFlowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeContactFlowErrorKind {
    ContactFlowNotPublishedException(crate::error::ContactFlowNotPublishedException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeContactFlowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeContactFlowErrorKind::ContactFlowNotPublishedException(_inner) => _inner.fmt(f),
            DescribeContactFlowErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DescribeContactFlowErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeContactFlowErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeContactFlowErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeContactFlowErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeContactFlowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeContactFlowError {
    fn code(&self) -> Option<&str> {
        DescribeContactFlowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeContactFlowError {
    pub fn new(kind: DescribeContactFlowErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeContactFlowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeContactFlowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_contact_flow_not_published_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContactFlowErrorKind::ContactFlowNotPublishedException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContactFlowErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContactFlowErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContactFlowErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContactFlowErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContactFlowErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeContactFlowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeContactFlowErrorKind::ContactFlowNotPublishedException(_inner) => Some(_inner),
            DescribeContactFlowErrorKind::InternalServiceException(_inner) => Some(_inner),
            DescribeContactFlowErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeContactFlowErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeContactFlowErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeContactFlowErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeContactFlowErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeHoursOfOperationError {
    pub kind: DescribeHoursOfOperationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeHoursOfOperationErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeHoursOfOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeHoursOfOperationErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DescribeHoursOfOperationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeHoursOfOperationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeHoursOfOperationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeHoursOfOperationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeHoursOfOperationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeHoursOfOperationError {
    fn code(&self) -> Option<&str> {
        DescribeHoursOfOperationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeHoursOfOperationError {
    pub fn new(kind: DescribeHoursOfOperationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeHoursOfOperationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeHoursOfOperationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeHoursOfOperationErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeHoursOfOperationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeHoursOfOperationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeHoursOfOperationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeHoursOfOperationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeHoursOfOperationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeHoursOfOperationErrorKind::InternalServiceException(_inner) => Some(_inner),
            DescribeHoursOfOperationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeHoursOfOperationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeHoursOfOperationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeHoursOfOperationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeHoursOfOperationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInstanceError {
    pub kind: DescribeInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInstanceErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInstanceErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DescribeInstanceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeInstanceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInstanceError {
    fn code(&self) -> Option<&str> {
        DescribeInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInstanceError {
    pub fn new(kind: DescribeInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInstanceErrorKind::InternalServiceException(_inner) => Some(_inner),
            DescribeInstanceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeInstanceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInstanceAttributeError {
    pub kind: DescribeInstanceAttributeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInstanceAttributeErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInstanceAttributeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInstanceAttributeErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DescribeInstanceAttributeErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeInstanceAttributeErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeInstanceAttributeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeInstanceAttributeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeInstanceAttributeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInstanceAttributeError {
    fn code(&self) -> Option<&str> {
        DescribeInstanceAttributeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInstanceAttributeError {
    pub fn new(kind: DescribeInstanceAttributeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInstanceAttributeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInstanceAttributeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceAttributeErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceAttributeErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceAttributeErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceAttributeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceAttributeErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeInstanceAttributeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInstanceAttributeErrorKind::InternalServiceException(_inner) => Some(_inner),
            DescribeInstanceAttributeErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeInstanceAttributeErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeInstanceAttributeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeInstanceAttributeErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeInstanceAttributeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInstanceStorageConfigError {
    pub kind: DescribeInstanceStorageConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInstanceStorageConfigErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInstanceStorageConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInstanceStorageConfigErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            DescribeInstanceStorageConfigErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            DescribeInstanceStorageConfigErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeInstanceStorageConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeInstanceStorageConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeInstanceStorageConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInstanceStorageConfigError {
    fn code(&self) -> Option<&str> {
        DescribeInstanceStorageConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInstanceStorageConfigError {
    pub fn new(kind: DescribeInstanceStorageConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInstanceStorageConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInstanceStorageConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceStorageConfigErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceStorageConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceStorageConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceStorageConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInstanceStorageConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeInstanceStorageConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInstanceStorageConfigErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            DescribeInstanceStorageConfigErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            DescribeInstanceStorageConfigErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeInstanceStorageConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeInstanceStorageConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeInstanceStorageConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeQueueError {
    pub kind: DescribeQueueErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeQueueErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeQueueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeQueueErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DescribeQueueErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeQueueErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeQueueErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeQueueErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeQueueErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeQueueError {
    fn code(&self) -> Option<&str> {
        DescribeQueueError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeQueueError {
    pub fn new(kind: DescribeQueueErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeQueueErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeQueueErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueueErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueueErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueueErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueueErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeQueueErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DescribeQueueError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeQueueErrorKind::InternalServiceException(_inner) => Some(_inner),
            DescribeQueueErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeQueueErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeQueueErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeQueueErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeQueueErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeQuickConnectError {
    pub kind: DescribeQuickConnectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeQuickConnectErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeQuickConnectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeQuickConnectErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DescribeQuickConnectErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeQuickConnectErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeQuickConnectErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeQuickConnectErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeQuickConnectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeQuickConnectError {
    fn code(&self) -> Option<&str> {
        DescribeQuickConnectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeQuickConnectError {
    pub fn new(kind: DescribeQuickConnectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeQuickConnectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeQuickConnectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuickConnectErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuickConnectErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuickConnectErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuickConnectErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuickConnectErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeQuickConnectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeQuickConnectErrorKind::InternalServiceException(_inner) => Some(_inner),
            DescribeQuickConnectErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeQuickConnectErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeQuickConnectErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeQuickConnectErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeQuickConnectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRoutingProfileError {
    pub kind: DescribeRoutingProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRoutingProfileErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRoutingProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRoutingProfileErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DescribeRoutingProfileErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeRoutingProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeRoutingProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeRoutingProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeRoutingProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRoutingProfileError {
    fn code(&self) -> Option<&str> {
        DescribeRoutingProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRoutingProfileError {
    pub fn new(kind: DescribeRoutingProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRoutingProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRoutingProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoutingProfileErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoutingProfileErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoutingProfileErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoutingProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoutingProfileErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeRoutingProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRoutingProfileErrorKind::InternalServiceException(_inner) => Some(_inner),
            DescribeRoutingProfileErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeRoutingProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeRoutingProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeRoutingProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeRoutingProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUserError {
    pub kind: DescribeUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUserErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUserErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUserError {
    fn code(&self) -> Option<&str> {
        DescribeUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUserError {
    pub fn new(kind: DescribeUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeUserErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DescribeUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUserErrorKind::InternalServiceException(_inner) => Some(_inner),
            DescribeUserErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeUserErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeUserErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUserHierarchyGroupError {
    pub kind: DescribeUserHierarchyGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUserHierarchyGroupErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUserHierarchyGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUserHierarchyGroupErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DescribeUserHierarchyGroupErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeUserHierarchyGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeUserHierarchyGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeUserHierarchyGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeUserHierarchyGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUserHierarchyGroupError {
    fn code(&self) -> Option<&str> {
        DescribeUserHierarchyGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUserHierarchyGroupError {
    pub fn new(kind: DescribeUserHierarchyGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUserHierarchyGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUserHierarchyGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserHierarchyGroupErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserHierarchyGroupErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserHierarchyGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserHierarchyGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserHierarchyGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeUserHierarchyGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUserHierarchyGroupErrorKind::InternalServiceException(_inner) => Some(_inner),
            DescribeUserHierarchyGroupErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeUserHierarchyGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeUserHierarchyGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeUserHierarchyGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeUserHierarchyGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUserHierarchyStructureError {
    pub kind: DescribeUserHierarchyStructureErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUserHierarchyStructureErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUserHierarchyStructureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUserHierarchyStructureErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            DescribeUserHierarchyStructureErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            DescribeUserHierarchyStructureErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeUserHierarchyStructureErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeUserHierarchyStructureErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeUserHierarchyStructureErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUserHierarchyStructureError {
    fn code(&self) -> Option<&str> {
        DescribeUserHierarchyStructureError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUserHierarchyStructureError {
    pub fn new(kind: DescribeUserHierarchyStructureErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUserHierarchyStructureErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUserHierarchyStructureErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserHierarchyStructureErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserHierarchyStructureErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserHierarchyStructureErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserHierarchyStructureErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserHierarchyStructureErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeUserHierarchyStructureError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUserHierarchyStructureErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            DescribeUserHierarchyStructureErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            DescribeUserHierarchyStructureErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DescribeUserHierarchyStructureErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeUserHierarchyStructureErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeUserHierarchyStructureErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateApprovedOriginError {
    pub kind: DisassociateApprovedOriginErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateApprovedOriginErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateApprovedOriginError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateApprovedOriginErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DisassociateApprovedOriginErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DisassociateApprovedOriginErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DisassociateApprovedOriginErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisassociateApprovedOriginErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DisassociateApprovedOriginErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateApprovedOriginError {
    fn code(&self) -> Option<&str> {
        DisassociateApprovedOriginError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateApprovedOriginError {
    pub fn new(kind: DisassociateApprovedOriginErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateApprovedOriginErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateApprovedOriginErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateApprovedOriginErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateApprovedOriginErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateApprovedOriginErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateApprovedOriginErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateApprovedOriginErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DisassociateApprovedOriginError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateApprovedOriginErrorKind::InternalServiceException(_inner) => Some(_inner),
            DisassociateApprovedOriginErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DisassociateApprovedOriginErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DisassociateApprovedOriginErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisassociateApprovedOriginErrorKind::ThrottlingException(_inner) => Some(_inner),
            DisassociateApprovedOriginErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateBotError {
    pub kind: DisassociateBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateBotErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateBotErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DisassociateBotErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DisassociateBotErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisassociateBotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DisassociateBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateBotError {
    fn code(&self) -> Option<&str> {
        DisassociateBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateBotError {
    pub fn new(kind: DisassociateBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateBotErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateBotErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateBotErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DisassociateBotErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DisassociateBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateBotErrorKind::InternalServiceException(_inner) => Some(_inner),
            DisassociateBotErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DisassociateBotErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisassociateBotErrorKind::ThrottlingException(_inner) => Some(_inner),
            DisassociateBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateInstanceStorageConfigError {
    pub kind: DisassociateInstanceStorageConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateInstanceStorageConfigErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateInstanceStorageConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateInstanceStorageConfigErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateInstanceStorageConfigErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateInstanceStorageConfigErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateInstanceStorageConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateInstanceStorageConfigErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateInstanceStorageConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateInstanceStorageConfigError {
    fn code(&self) -> Option<&str> {
        DisassociateInstanceStorageConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateInstanceStorageConfigError {
    pub fn new(
        kind: DisassociateInstanceStorageConfigErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateInstanceStorageConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateInstanceStorageConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateInstanceStorageConfigErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateInstanceStorageConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateInstanceStorageConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateInstanceStorageConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateInstanceStorageConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DisassociateInstanceStorageConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateInstanceStorageConfigErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            DisassociateInstanceStorageConfigErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            DisassociateInstanceStorageConfigErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DisassociateInstanceStorageConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociateInstanceStorageConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            DisassociateInstanceStorageConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateLambdaFunctionError {
    pub kind: DisassociateLambdaFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateLambdaFunctionErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateLambdaFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateLambdaFunctionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DisassociateLambdaFunctionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DisassociateLambdaFunctionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DisassociateLambdaFunctionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisassociateLambdaFunctionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DisassociateLambdaFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateLambdaFunctionError {
    fn code(&self) -> Option<&str> {
        DisassociateLambdaFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateLambdaFunctionError {
    pub fn new(kind: DisassociateLambdaFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateLambdaFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateLambdaFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateLambdaFunctionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateLambdaFunctionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateLambdaFunctionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateLambdaFunctionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateLambdaFunctionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DisassociateLambdaFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateLambdaFunctionErrorKind::InternalServiceException(_inner) => Some(_inner),
            DisassociateLambdaFunctionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DisassociateLambdaFunctionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DisassociateLambdaFunctionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisassociateLambdaFunctionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DisassociateLambdaFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateLexBotError {
    pub kind: DisassociateLexBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateLexBotErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateLexBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateLexBotErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DisassociateLexBotErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DisassociateLexBotErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DisassociateLexBotErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisassociateLexBotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DisassociateLexBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateLexBotError {
    fn code(&self) -> Option<&str> {
        DisassociateLexBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateLexBotError {
    pub fn new(kind: DisassociateLexBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateLexBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateLexBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateLexBotErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateLexBotErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateLexBotErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateLexBotErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateLexBotErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DisassociateLexBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateLexBotErrorKind::InternalServiceException(_inner) => Some(_inner),
            DisassociateLexBotErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DisassociateLexBotErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DisassociateLexBotErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisassociateLexBotErrorKind::ThrottlingException(_inner) => Some(_inner),
            DisassociateLexBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateQueueQuickConnectsError {
    pub kind: DisassociateQueueQuickConnectsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateQueueQuickConnectsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateQueueQuickConnectsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateQueueQuickConnectsErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateQueueQuickConnectsErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateQueueQuickConnectsErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateQueueQuickConnectsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateQueueQuickConnectsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DisassociateQueueQuickConnectsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateQueueQuickConnectsError {
    fn code(&self) -> Option<&str> {
        DisassociateQueueQuickConnectsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateQueueQuickConnectsError {
    pub fn new(kind: DisassociateQueueQuickConnectsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateQueueQuickConnectsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateQueueQuickConnectsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateQueueQuickConnectsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateQueueQuickConnectsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateQueueQuickConnectsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateQueueQuickConnectsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateQueueQuickConnectsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DisassociateQueueQuickConnectsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateQueueQuickConnectsErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            DisassociateQueueQuickConnectsErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            DisassociateQueueQuickConnectsErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DisassociateQueueQuickConnectsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociateQueueQuickConnectsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DisassociateQueueQuickConnectsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateRoutingProfileQueuesError {
    pub kind: DisassociateRoutingProfileQueuesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateRoutingProfileQueuesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateRoutingProfileQueuesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateRoutingProfileQueuesErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateRoutingProfileQueuesErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateRoutingProfileQueuesErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateRoutingProfileQueuesErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateRoutingProfileQueuesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DisassociateRoutingProfileQueuesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateRoutingProfileQueuesError {
    fn code(&self) -> Option<&str> {
        DisassociateRoutingProfileQueuesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateRoutingProfileQueuesError {
    pub fn new(kind: DisassociateRoutingProfileQueuesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateRoutingProfileQueuesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateRoutingProfileQueuesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateRoutingProfileQueuesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateRoutingProfileQueuesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateRoutingProfileQueuesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateRoutingProfileQueuesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateRoutingProfileQueuesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DisassociateRoutingProfileQueuesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateRoutingProfileQueuesErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            DisassociateRoutingProfileQueuesErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            DisassociateRoutingProfileQueuesErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DisassociateRoutingProfileQueuesErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociateRoutingProfileQueuesErrorKind::ThrottlingException(_inner) => Some(_inner),
            DisassociateRoutingProfileQueuesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateSecurityKeyError {
    pub kind: DisassociateSecurityKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateSecurityKeyErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateSecurityKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateSecurityKeyErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DisassociateSecurityKeyErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DisassociateSecurityKeyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DisassociateSecurityKeyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisassociateSecurityKeyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DisassociateSecurityKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateSecurityKeyError {
    fn code(&self) -> Option<&str> {
        DisassociateSecurityKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateSecurityKeyError {
    pub fn new(kind: DisassociateSecurityKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateSecurityKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateSecurityKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateSecurityKeyErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateSecurityKeyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateSecurityKeyErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateSecurityKeyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateSecurityKeyErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DisassociateSecurityKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateSecurityKeyErrorKind::InternalServiceException(_inner) => Some(_inner),
            DisassociateSecurityKeyErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DisassociateSecurityKeyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DisassociateSecurityKeyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisassociateSecurityKeyErrorKind::ThrottlingException(_inner) => Some(_inner),
            DisassociateSecurityKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContactAttributesError {
    pub kind: GetContactAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContactAttributesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContactAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContactAttributesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetContactAttributesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetContactAttributesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetContactAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContactAttributesError {
    fn code(&self) -> Option<&str> {
        GetContactAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContactAttributesError {
    pub fn new(kind: GetContactAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContactAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContactAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContactAttributesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContactAttributesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContactAttributesErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for GetContactAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContactAttributesErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetContactAttributesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetContactAttributesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetContactAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCurrentMetricDataError {
    pub kind: GetCurrentMetricDataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCurrentMetricDataErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCurrentMetricDataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCurrentMetricDataErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetCurrentMetricDataErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetCurrentMetricDataErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetCurrentMetricDataErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetCurrentMetricDataErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetCurrentMetricDataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCurrentMetricDataError {
    fn code(&self) -> Option<&str> {
        GetCurrentMetricDataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCurrentMetricDataError {
    pub fn new(kind: GetCurrentMetricDataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCurrentMetricDataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCurrentMetricDataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCurrentMetricDataErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCurrentMetricDataErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCurrentMetricDataErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCurrentMetricDataErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCurrentMetricDataErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetCurrentMetricDataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCurrentMetricDataErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetCurrentMetricDataErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetCurrentMetricDataErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetCurrentMetricDataErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetCurrentMetricDataErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetCurrentMetricDataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFederationTokenError {
    pub kind: GetFederationTokenErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFederationTokenErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFederationTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFederationTokenErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            GetFederationTokenErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetFederationTokenErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetFederationTokenErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetFederationTokenErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetFederationTokenErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            GetFederationTokenErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFederationTokenError {
    fn code(&self) -> Option<&str> {
        GetFederationTokenError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFederationTokenError {
    pub fn new(kind: GetFederationTokenErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFederationTokenErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFederationTokenErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFederationTokenErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFederationTokenErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFederationTokenErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFederationTokenErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFederationTokenErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFederationTokenErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for GetFederationTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFederationTokenErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            GetFederationTokenErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetFederationTokenErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetFederationTokenErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetFederationTokenErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetFederationTokenErrorKind::UserNotFoundException(_inner) => Some(_inner),
            GetFederationTokenErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMetricDataError {
    pub kind: GetMetricDataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMetricDataErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMetricDataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMetricDataErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetMetricDataErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetMetricDataErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetMetricDataErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetMetricDataErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetMetricDataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMetricDataError {
    fn code(&self) -> Option<&str> {
        GetMetricDataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMetricDataError {
    pub fn new(kind: GetMetricDataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMetricDataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMetricDataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMetricDataErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMetricDataErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMetricDataErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMetricDataErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetMetricDataErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for GetMetricDataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMetricDataErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetMetricDataErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetMetricDataErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetMetricDataErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetMetricDataErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetMetricDataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAgentStatusesError {
    pub kind: ListAgentStatusesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAgentStatusesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAgentStatusesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAgentStatusesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListAgentStatusesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListAgentStatusesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListAgentStatusesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListAgentStatusesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAgentStatusesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAgentStatusesError {
    fn code(&self) -> Option<&str> {
        ListAgentStatusesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAgentStatusesError {
    pub fn new(kind: ListAgentStatusesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAgentStatusesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAgentStatusesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAgentStatusesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAgentStatusesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAgentStatusesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAgentStatusesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAgentStatusesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListAgentStatusesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAgentStatusesErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListAgentStatusesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListAgentStatusesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListAgentStatusesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListAgentStatusesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAgentStatusesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListApprovedOriginsError {
    pub kind: ListApprovedOriginsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListApprovedOriginsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListApprovedOriginsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListApprovedOriginsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListApprovedOriginsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListApprovedOriginsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListApprovedOriginsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListApprovedOriginsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListApprovedOriginsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListApprovedOriginsError {
    fn code(&self) -> Option<&str> {
        ListApprovedOriginsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListApprovedOriginsError {
    pub fn new(kind: ListApprovedOriginsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListApprovedOriginsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListApprovedOriginsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListApprovedOriginsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListApprovedOriginsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListApprovedOriginsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListApprovedOriginsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListApprovedOriginsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListApprovedOriginsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListApprovedOriginsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListApprovedOriginsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListApprovedOriginsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListApprovedOriginsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListApprovedOriginsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListApprovedOriginsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBotsError {
    pub kind: ListBotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBotsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBotsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBotsError {
    fn code(&self) -> Option<&str> {
        ListBotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBotsError {
    pub fn new(kind: ListBotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, ListBotsErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListBotsErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListBotsErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListBotsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListBotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBotsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListBotsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListBotsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListBotsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListBotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListContactFlowsError {
    pub kind: ListContactFlowsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListContactFlowsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListContactFlowsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListContactFlowsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListContactFlowsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListContactFlowsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListContactFlowsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListContactFlowsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListContactFlowsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListContactFlowsError {
    fn code(&self) -> Option<&str> {
        ListContactFlowsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListContactFlowsError {
    pub fn new(kind: ListContactFlowsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListContactFlowsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListContactFlowsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListContactFlowsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListContactFlowsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListContactFlowsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListContactFlowsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListContactFlowsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListContactFlowsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListContactFlowsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListContactFlowsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListContactFlowsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListContactFlowsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListContactFlowsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListContactFlowsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListHoursOfOperationsError {
    pub kind: ListHoursOfOperationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListHoursOfOperationsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListHoursOfOperationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListHoursOfOperationsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListHoursOfOperationsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListHoursOfOperationsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListHoursOfOperationsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListHoursOfOperationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListHoursOfOperationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListHoursOfOperationsError {
    fn code(&self) -> Option<&str> {
        ListHoursOfOperationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListHoursOfOperationsError {
    pub fn new(kind: ListHoursOfOperationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListHoursOfOperationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListHoursOfOperationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListHoursOfOperationsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListHoursOfOperationsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListHoursOfOperationsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListHoursOfOperationsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListHoursOfOperationsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListHoursOfOperationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListHoursOfOperationsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListHoursOfOperationsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListHoursOfOperationsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListHoursOfOperationsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListHoursOfOperationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListHoursOfOperationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInstanceAttributesError {
    pub kind: ListInstanceAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInstanceAttributesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInstanceAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInstanceAttributesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListInstanceAttributesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListInstanceAttributesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListInstanceAttributesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListInstanceAttributesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListInstanceAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInstanceAttributesError {
    fn code(&self) -> Option<&str> {
        ListInstanceAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInstanceAttributesError {
    pub fn new(kind: ListInstanceAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInstanceAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInstanceAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceAttributesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceAttributesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceAttributesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceAttributesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceAttributesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListInstanceAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInstanceAttributesErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListInstanceAttributesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListInstanceAttributesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListInstanceAttributesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListInstanceAttributesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListInstanceAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInstancesError {
    pub kind: ListInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInstancesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInstancesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListInstancesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInstancesError {
    fn code(&self) -> Option<&str> {
        ListInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInstancesError {
    pub fn new(kind: ListInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstancesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstancesErrorKind::InvalidRequestException(_)
        )
    }
}
impl std::error::Error for ListInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInstancesErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListInstancesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInstanceStorageConfigsError {
    pub kind: ListInstanceStorageConfigsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInstanceStorageConfigsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInstanceStorageConfigsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInstanceStorageConfigsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListInstanceStorageConfigsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListInstanceStorageConfigsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListInstanceStorageConfigsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListInstanceStorageConfigsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListInstanceStorageConfigsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInstanceStorageConfigsError {
    fn code(&self) -> Option<&str> {
        ListInstanceStorageConfigsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInstanceStorageConfigsError {
    pub fn new(kind: ListInstanceStorageConfigsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInstanceStorageConfigsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInstanceStorageConfigsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceStorageConfigsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceStorageConfigsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceStorageConfigsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceStorageConfigsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceStorageConfigsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListInstanceStorageConfigsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInstanceStorageConfigsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListInstanceStorageConfigsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListInstanceStorageConfigsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListInstanceStorageConfigsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListInstanceStorageConfigsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListInstanceStorageConfigsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListIntegrationAssociationsError {
    pub kind: ListIntegrationAssociationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListIntegrationAssociationsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListIntegrationAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListIntegrationAssociationsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListIntegrationAssociationsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListIntegrationAssociationsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListIntegrationAssociationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListIntegrationAssociationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListIntegrationAssociationsError {
    fn code(&self) -> Option<&str> {
        ListIntegrationAssociationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListIntegrationAssociationsError {
    pub fn new(kind: ListIntegrationAssociationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListIntegrationAssociationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListIntegrationAssociationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIntegrationAssociationsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIntegrationAssociationsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIntegrationAssociationsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIntegrationAssociationsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListIntegrationAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListIntegrationAssociationsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListIntegrationAssociationsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListIntegrationAssociationsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListIntegrationAssociationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListIntegrationAssociationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLambdaFunctionsError {
    pub kind: ListLambdaFunctionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLambdaFunctionsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLambdaFunctionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLambdaFunctionsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListLambdaFunctionsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListLambdaFunctionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListLambdaFunctionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListLambdaFunctionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListLambdaFunctionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLambdaFunctionsError {
    fn code(&self) -> Option<&str> {
        ListLambdaFunctionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLambdaFunctionsError {
    pub fn new(kind: ListLambdaFunctionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLambdaFunctionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLambdaFunctionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLambdaFunctionsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLambdaFunctionsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLambdaFunctionsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLambdaFunctionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLambdaFunctionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListLambdaFunctionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLambdaFunctionsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListLambdaFunctionsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListLambdaFunctionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListLambdaFunctionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListLambdaFunctionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListLambdaFunctionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLexBotsError {
    pub kind: ListLexBotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLexBotsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLexBotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLexBotsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListLexBotsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListLexBotsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListLexBotsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListLexBotsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListLexBotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLexBotsError {
    fn code(&self) -> Option<&str> {
        ListLexBotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLexBotsError {
    pub fn new(kind: ListLexBotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLexBotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLexBotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLexBotsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLexBotsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListLexBotsErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLexBotsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListLexBotsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListLexBotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLexBotsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListLexBotsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListLexBotsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListLexBotsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListLexBotsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListLexBotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPhoneNumbersError {
    pub kind: ListPhoneNumbersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPhoneNumbersErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPhoneNumbersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPhoneNumbersErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPhoneNumbersError {
    fn code(&self) -> Option<&str> {
        ListPhoneNumbersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPhoneNumbersError {
    pub fn new(kind: ListPhoneNumbersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPhoneNumbersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPhoneNumbersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListPhoneNumbersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPhoneNumbersErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPromptsError {
    pub kind: ListPromptsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPromptsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPromptsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPromptsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListPromptsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListPromptsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListPromptsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListPromptsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListPromptsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPromptsError {
    fn code(&self) -> Option<&str> {
        ListPromptsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPromptsError {
    pub fn new(kind: ListPromptsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPromptsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPromptsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPromptsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPromptsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListPromptsErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPromptsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListPromptsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListPromptsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPromptsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListPromptsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListPromptsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListPromptsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListPromptsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListPromptsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListQueueQuickConnectsError {
    pub kind: ListQueueQuickConnectsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListQueueQuickConnectsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListQueueQuickConnectsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListQueueQuickConnectsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListQueueQuickConnectsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListQueueQuickConnectsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListQueueQuickConnectsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListQueueQuickConnectsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListQueueQuickConnectsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListQueueQuickConnectsError {
    fn code(&self) -> Option<&str> {
        ListQueueQuickConnectsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListQueueQuickConnectsError {
    pub fn new(kind: ListQueueQuickConnectsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListQueueQuickConnectsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListQueueQuickConnectsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQueueQuickConnectsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQueueQuickConnectsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQueueQuickConnectsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQueueQuickConnectsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQueueQuickConnectsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListQueueQuickConnectsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListQueueQuickConnectsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListQueueQuickConnectsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListQueueQuickConnectsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListQueueQuickConnectsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListQueueQuickConnectsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListQueueQuickConnectsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListQueuesError {
    pub kind: ListQueuesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListQueuesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListQueuesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListQueuesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListQueuesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListQueuesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListQueuesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListQueuesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListQueuesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListQueuesError {
    fn code(&self) -> Option<&str> {
        ListQueuesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListQueuesError {
    pub fn new(kind: ListQueuesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListQueuesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListQueuesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, ListQueuesErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQueuesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListQueuesErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQueuesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListQueuesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListQueuesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListQueuesErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListQueuesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListQueuesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListQueuesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListQueuesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListQueuesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListQuickConnectsError {
    pub kind: ListQuickConnectsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListQuickConnectsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListQuickConnectsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListQuickConnectsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListQuickConnectsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListQuickConnectsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListQuickConnectsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListQuickConnectsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListQuickConnectsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListQuickConnectsError {
    fn code(&self) -> Option<&str> {
        ListQuickConnectsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListQuickConnectsError {
    pub fn new(kind: ListQuickConnectsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListQuickConnectsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListQuickConnectsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQuickConnectsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQuickConnectsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQuickConnectsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQuickConnectsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQuickConnectsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListQuickConnectsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListQuickConnectsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListQuickConnectsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListQuickConnectsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListQuickConnectsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListQuickConnectsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListQuickConnectsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRoutingProfileQueuesError {
    pub kind: ListRoutingProfileQueuesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRoutingProfileQueuesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRoutingProfileQueuesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRoutingProfileQueuesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListRoutingProfileQueuesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListRoutingProfileQueuesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListRoutingProfileQueuesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListRoutingProfileQueuesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListRoutingProfileQueuesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRoutingProfileQueuesError {
    fn code(&self) -> Option<&str> {
        ListRoutingProfileQueuesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRoutingProfileQueuesError {
    pub fn new(kind: ListRoutingProfileQueuesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRoutingProfileQueuesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRoutingProfileQueuesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoutingProfileQueuesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoutingProfileQueuesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoutingProfileQueuesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoutingProfileQueuesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoutingProfileQueuesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListRoutingProfileQueuesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRoutingProfileQueuesErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListRoutingProfileQueuesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListRoutingProfileQueuesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListRoutingProfileQueuesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListRoutingProfileQueuesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListRoutingProfileQueuesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRoutingProfilesError {
    pub kind: ListRoutingProfilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRoutingProfilesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRoutingProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRoutingProfilesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListRoutingProfilesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListRoutingProfilesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListRoutingProfilesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListRoutingProfilesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListRoutingProfilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRoutingProfilesError {
    fn code(&self) -> Option<&str> {
        ListRoutingProfilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRoutingProfilesError {
    pub fn new(kind: ListRoutingProfilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRoutingProfilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRoutingProfilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoutingProfilesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoutingProfilesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoutingProfilesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoutingProfilesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoutingProfilesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListRoutingProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRoutingProfilesErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListRoutingProfilesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListRoutingProfilesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListRoutingProfilesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListRoutingProfilesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListRoutingProfilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSecurityKeysError {
    pub kind: ListSecurityKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSecurityKeysErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSecurityKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSecurityKeysErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListSecurityKeysErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListSecurityKeysErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListSecurityKeysErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListSecurityKeysErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListSecurityKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSecurityKeysError {
    fn code(&self) -> Option<&str> {
        ListSecurityKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSecurityKeysError {
    pub fn new(kind: ListSecurityKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSecurityKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSecurityKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityKeysErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityKeysErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityKeysErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityKeysErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityKeysErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListSecurityKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSecurityKeysErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListSecurityKeysErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListSecurityKeysErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListSecurityKeysErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListSecurityKeysErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListSecurityKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSecurityProfilesError {
    pub kind: ListSecurityProfilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSecurityProfilesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSecurityProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSecurityProfilesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListSecurityProfilesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListSecurityProfilesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListSecurityProfilesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListSecurityProfilesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListSecurityProfilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSecurityProfilesError {
    fn code(&self) -> Option<&str> {
        ListSecurityProfilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSecurityProfilesError {
    pub fn new(kind: ListSecurityProfilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSecurityProfilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSecurityProfilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListSecurityProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSecurityProfilesErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListSecurityProfilesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListSecurityProfilesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListSecurityProfilesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListSecurityProfilesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListSecurityProfilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUseCasesError {
    pub kind: ListUseCasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUseCasesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUseCasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUseCasesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListUseCasesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListUseCasesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListUseCasesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListUseCasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUseCasesError {
    fn code(&self) -> Option<&str> {
        ListUseCasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUseCasesError {
    pub fn new(kind: ListUseCasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUseCasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUseCasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUseCasesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUseCasesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUseCasesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListUseCasesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListUseCasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUseCasesErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListUseCasesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListUseCasesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListUseCasesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListUseCasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUserHierarchyGroupsError {
    pub kind: ListUserHierarchyGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUserHierarchyGroupsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUserHierarchyGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUserHierarchyGroupsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListUserHierarchyGroupsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListUserHierarchyGroupsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListUserHierarchyGroupsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListUserHierarchyGroupsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListUserHierarchyGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUserHierarchyGroupsError {
    fn code(&self) -> Option<&str> {
        ListUserHierarchyGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUserHierarchyGroupsError {
    pub fn new(kind: ListUserHierarchyGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUserHierarchyGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUserHierarchyGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserHierarchyGroupsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserHierarchyGroupsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserHierarchyGroupsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserHierarchyGroupsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserHierarchyGroupsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListUserHierarchyGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUserHierarchyGroupsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListUserHierarchyGroupsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListUserHierarchyGroupsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListUserHierarchyGroupsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListUserHierarchyGroupsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListUserHierarchyGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUsersError {
    pub kind: ListUsersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUsersErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUsersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUsersErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUsersError {
    fn code(&self) -> Option<&str> {
        ListUsersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUsersError {
    pub fn new(kind: ListUsersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUsersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUsersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::InvalidParameterException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListUsersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUsersErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListUsersErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListUsersErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListUsersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListUsersErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListUsersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResumeContactRecordingError {
    pub kind: ResumeContactRecordingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResumeContactRecordingErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResumeContactRecordingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResumeContactRecordingErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ResumeContactRecordingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ResumeContactRecordingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ResumeContactRecordingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResumeContactRecordingError {
    fn code(&self) -> Option<&str> {
        ResumeContactRecordingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResumeContactRecordingError {
    pub fn new(kind: ResumeContactRecordingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResumeContactRecordingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResumeContactRecordingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResumeContactRecordingErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResumeContactRecordingErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResumeContactRecordingErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ResumeContactRecordingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResumeContactRecordingErrorKind::InternalServiceException(_inner) => Some(_inner),
            ResumeContactRecordingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ResumeContactRecordingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ResumeContactRecordingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartChatContactError {
    pub kind: StartChatContactErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartChatContactErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartChatContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartChatContactErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StartChatContactErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartChatContactErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StartChatContactErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartChatContactErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartChatContactErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartChatContactError {
    fn code(&self) -> Option<&str> {
        StartChatContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartChatContactError {
    pub fn new(kind: StartChatContactErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartChatContactErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartChatContactErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartChatContactErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartChatContactErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartChatContactErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartChatContactErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartChatContactErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for StartChatContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartChatContactErrorKind::InternalServiceException(_inner) => Some(_inner),
            StartChatContactErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartChatContactErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StartChatContactErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartChatContactErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartChatContactErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartContactRecordingError {
    pub kind: StartContactRecordingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartContactRecordingErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartContactRecordingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartContactRecordingErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StartContactRecordingErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartContactRecordingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StartContactRecordingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartContactRecordingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartContactRecordingError {
    fn code(&self) -> Option<&str> {
        StartContactRecordingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartContactRecordingError {
    pub fn new(kind: StartContactRecordingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartContactRecordingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartContactRecordingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContactRecordingErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContactRecordingErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContactRecordingErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartContactRecordingErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for StartContactRecordingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartContactRecordingErrorKind::InternalServiceException(_inner) => Some(_inner),
            StartContactRecordingErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartContactRecordingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StartContactRecordingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartContactRecordingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartOutboundVoiceContactError {
    pub kind: StartOutboundVoiceContactErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartOutboundVoiceContactErrorKind {
    DestinationNotAllowedException(crate::error::DestinationNotAllowedException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    OutboundContactNotPermittedException(crate::error::OutboundContactNotPermittedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartOutboundVoiceContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartOutboundVoiceContactErrorKind::DestinationNotAllowedException(_inner) => {
                _inner.fmt(f)
            }
            StartOutboundVoiceContactErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StartOutboundVoiceContactErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartOutboundVoiceContactErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StartOutboundVoiceContactErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartOutboundVoiceContactErrorKind::OutboundContactNotPermittedException(_inner) => {
                _inner.fmt(f)
            }
            StartOutboundVoiceContactErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartOutboundVoiceContactErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartOutboundVoiceContactError {
    fn code(&self) -> Option<&str> {
        StartOutboundVoiceContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartOutboundVoiceContactError {
    pub fn new(kind: StartOutboundVoiceContactErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartOutboundVoiceContactErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartOutboundVoiceContactErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_destination_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOutboundVoiceContactErrorKind::DestinationNotAllowedException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOutboundVoiceContactErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOutboundVoiceContactErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOutboundVoiceContactErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOutboundVoiceContactErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_outbound_contact_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOutboundVoiceContactErrorKind::OutboundContactNotPermittedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOutboundVoiceContactErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for StartOutboundVoiceContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartOutboundVoiceContactErrorKind::DestinationNotAllowedException(_inner) => {
                Some(_inner)
            }
            StartOutboundVoiceContactErrorKind::InternalServiceException(_inner) => Some(_inner),
            StartOutboundVoiceContactErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartOutboundVoiceContactErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StartOutboundVoiceContactErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartOutboundVoiceContactErrorKind::OutboundContactNotPermittedException(_inner) => {
                Some(_inner)
            }
            StartOutboundVoiceContactErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartOutboundVoiceContactErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartTaskContactError {
    pub kind: StartTaskContactErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartTaskContactErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartTaskContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartTaskContactErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StartTaskContactErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartTaskContactErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StartTaskContactErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartTaskContactErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            StartTaskContactErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartTaskContactErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartTaskContactError {
    fn code(&self) -> Option<&str> {
        StartTaskContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartTaskContactError {
    pub fn new(kind: StartTaskContactErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartTaskContactErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartTaskContactErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTaskContactErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTaskContactErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTaskContactErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTaskContactErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTaskContactErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTaskContactErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StartTaskContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartTaskContactErrorKind::InternalServiceException(_inner) => Some(_inner),
            StartTaskContactErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartTaskContactErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StartTaskContactErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartTaskContactErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            StartTaskContactErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartTaskContactErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopContactError {
    pub kind: StopContactErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopContactErrorKind {
    ContactNotFoundException(crate::error::ContactNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopContactErrorKind::ContactNotFoundException(_inner) => _inner.fmt(f),
            StopContactErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StopContactErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StopContactErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StopContactErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StopContactErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopContactError {
    fn code(&self) -> Option<&str> {
        StopContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopContactError {
    pub fn new(kind: StopContactErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopContactErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopContactErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_contact_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopContactErrorKind::ContactNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopContactErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopContactErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, StopContactErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopContactErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for StopContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopContactErrorKind::ContactNotFoundException(_inner) => Some(_inner),
            StopContactErrorKind::InternalServiceException(_inner) => Some(_inner),
            StopContactErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StopContactErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StopContactErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StopContactErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopContactRecordingError {
    pub kind: StopContactRecordingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopContactRecordingErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopContactRecordingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopContactRecordingErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StopContactRecordingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StopContactRecordingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StopContactRecordingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopContactRecordingError {
    fn code(&self) -> Option<&str> {
        StopContactRecordingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopContactRecordingError {
    pub fn new(kind: StopContactRecordingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopContactRecordingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopContactRecordingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopContactRecordingErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopContactRecordingErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopContactRecordingErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for StopContactRecordingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopContactRecordingErrorKind::InternalServiceException(_inner) => Some(_inner),
            StopContactRecordingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StopContactRecordingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StopContactRecordingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SuspendContactRecordingError {
    pub kind: SuspendContactRecordingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SuspendContactRecordingErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SuspendContactRecordingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SuspendContactRecordingErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            SuspendContactRecordingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SuspendContactRecordingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SuspendContactRecordingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SuspendContactRecordingError {
    fn code(&self) -> Option<&str> {
        SuspendContactRecordingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SuspendContactRecordingError {
    pub fn new(kind: SuspendContactRecordingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SuspendContactRecordingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SuspendContactRecordingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            SuspendContactRecordingErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SuspendContactRecordingErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SuspendContactRecordingErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for SuspendContactRecordingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SuspendContactRecordingErrorKind::InternalServiceException(_inner) => Some(_inner),
            SuspendContactRecordingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SuspendContactRecordingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SuspendContactRecordingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InternalServiceException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InternalServiceException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAgentStatusError {
    pub kind: UpdateAgentStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAgentStatusErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAgentStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAgentStatusErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            UpdateAgentStatusErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateAgentStatusErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateAgentStatusErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateAgentStatusErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateAgentStatusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAgentStatusErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateAgentStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAgentStatusError {
    fn code(&self) -> Option<&str> {
        UpdateAgentStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAgentStatusError {
    pub fn new(kind: UpdateAgentStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAgentStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAgentStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAgentStatusErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAgentStatusErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAgentStatusErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAgentStatusErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAgentStatusErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAgentStatusErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAgentStatusErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateAgentStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAgentStatusErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            UpdateAgentStatusErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateAgentStatusErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateAgentStatusErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateAgentStatusErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateAgentStatusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAgentStatusErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateAgentStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContactAttributesError {
    pub kind: UpdateContactAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContactAttributesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContactAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContactAttributesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateContactAttributesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateContactAttributesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateContactAttributesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateContactAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContactAttributesError {
    fn code(&self) -> Option<&str> {
        UpdateContactAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContactAttributesError {
    pub fn new(kind: UpdateContactAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContactAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContactAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactAttributesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactAttributesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactAttributesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactAttributesErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateContactAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContactAttributesErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateContactAttributesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateContactAttributesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateContactAttributesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateContactAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContactFlowContentError {
    pub kind: UpdateContactFlowContentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContactFlowContentErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidContactFlowException(crate::error::InvalidContactFlowException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContactFlowContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContactFlowContentErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateContactFlowContentErrorKind::InvalidContactFlowException(_inner) => _inner.fmt(f),
            UpdateContactFlowContentErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateContactFlowContentErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateContactFlowContentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateContactFlowContentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateContactFlowContentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContactFlowContentError {
    fn code(&self) -> Option<&str> {
        UpdateContactFlowContentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContactFlowContentError {
    pub fn new(kind: UpdateContactFlowContentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContactFlowContentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContactFlowContentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactFlowContentErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_contact_flow_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactFlowContentErrorKind::InvalidContactFlowException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactFlowContentErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactFlowContentErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactFlowContentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactFlowContentErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateContactFlowContentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContactFlowContentErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateContactFlowContentErrorKind::InvalidContactFlowException(_inner) => Some(_inner),
            UpdateContactFlowContentErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateContactFlowContentErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateContactFlowContentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateContactFlowContentErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateContactFlowContentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContactFlowNameError {
    pub kind: UpdateContactFlowNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContactFlowNameErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContactFlowNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContactFlowNameErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            UpdateContactFlowNameErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateContactFlowNameErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateContactFlowNameErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateContactFlowNameErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateContactFlowNameErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateContactFlowNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContactFlowNameError {
    fn code(&self) -> Option<&str> {
        UpdateContactFlowNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContactFlowNameError {
    pub fn new(kind: UpdateContactFlowNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContactFlowNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContactFlowNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactFlowNameErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactFlowNameErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactFlowNameErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactFlowNameErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactFlowNameErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactFlowNameErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateContactFlowNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContactFlowNameErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            UpdateContactFlowNameErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateContactFlowNameErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateContactFlowNameErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateContactFlowNameErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateContactFlowNameErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateContactFlowNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateHoursOfOperationError {
    pub kind: UpdateHoursOfOperationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateHoursOfOperationErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateHoursOfOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateHoursOfOperationErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            UpdateHoursOfOperationErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateHoursOfOperationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateHoursOfOperationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateHoursOfOperationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateHoursOfOperationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateHoursOfOperationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateHoursOfOperationError {
    fn code(&self) -> Option<&str> {
        UpdateHoursOfOperationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateHoursOfOperationError {
    pub fn new(kind: UpdateHoursOfOperationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateHoursOfOperationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateHoursOfOperationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateHoursOfOperationErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateHoursOfOperationErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateHoursOfOperationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateHoursOfOperationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateHoursOfOperationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateHoursOfOperationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateHoursOfOperationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateHoursOfOperationErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            UpdateHoursOfOperationErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateHoursOfOperationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateHoursOfOperationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateHoursOfOperationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateHoursOfOperationErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateHoursOfOperationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateInstanceAttributeError {
    pub kind: UpdateInstanceAttributeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateInstanceAttributeErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateInstanceAttributeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateInstanceAttributeErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateInstanceAttributeErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateInstanceAttributeErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateInstanceAttributeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateInstanceAttributeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateInstanceAttributeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateInstanceAttributeError {
    fn code(&self) -> Option<&str> {
        UpdateInstanceAttributeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateInstanceAttributeError {
    pub fn new(kind: UpdateInstanceAttributeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateInstanceAttributeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateInstanceAttributeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceAttributeErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceAttributeErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceAttributeErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceAttributeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceAttributeErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateInstanceAttributeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateInstanceAttributeErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateInstanceAttributeErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateInstanceAttributeErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateInstanceAttributeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateInstanceAttributeErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateInstanceAttributeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateInstanceStorageConfigError {
    pub kind: UpdateInstanceStorageConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateInstanceStorageConfigErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateInstanceStorageConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateInstanceStorageConfigErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateInstanceStorageConfigErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            UpdateInstanceStorageConfigErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateInstanceStorageConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateInstanceStorageConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateInstanceStorageConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateInstanceStorageConfigError {
    fn code(&self) -> Option<&str> {
        UpdateInstanceStorageConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateInstanceStorageConfigError {
    pub fn new(kind: UpdateInstanceStorageConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateInstanceStorageConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateInstanceStorageConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceStorageConfigErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceStorageConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceStorageConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceStorageConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceStorageConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateInstanceStorageConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateInstanceStorageConfigErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateInstanceStorageConfigErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateInstanceStorageConfigErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateInstanceStorageConfigErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateInstanceStorageConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateInstanceStorageConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateQueueHoursOfOperationError {
    pub kind: UpdateQueueHoursOfOperationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateQueueHoursOfOperationErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateQueueHoursOfOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateQueueHoursOfOperationErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateQueueHoursOfOperationErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            UpdateQueueHoursOfOperationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateQueueHoursOfOperationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateQueueHoursOfOperationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateQueueHoursOfOperationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateQueueHoursOfOperationError {
    fn code(&self) -> Option<&str> {
        UpdateQueueHoursOfOperationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateQueueHoursOfOperationError {
    pub fn new(kind: UpdateQueueHoursOfOperationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateQueueHoursOfOperationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateQueueHoursOfOperationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueHoursOfOperationErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueHoursOfOperationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueHoursOfOperationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueHoursOfOperationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueHoursOfOperationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateQueueHoursOfOperationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateQueueHoursOfOperationErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateQueueHoursOfOperationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateQueueHoursOfOperationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateQueueHoursOfOperationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateQueueHoursOfOperationErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateQueueHoursOfOperationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateQueueMaxContactsError {
    pub kind: UpdateQueueMaxContactsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateQueueMaxContactsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateQueueMaxContactsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateQueueMaxContactsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateQueueMaxContactsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateQueueMaxContactsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateQueueMaxContactsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateQueueMaxContactsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateQueueMaxContactsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateQueueMaxContactsError {
    fn code(&self) -> Option<&str> {
        UpdateQueueMaxContactsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateQueueMaxContactsError {
    pub fn new(kind: UpdateQueueMaxContactsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateQueueMaxContactsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateQueueMaxContactsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueMaxContactsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueMaxContactsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueMaxContactsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueMaxContactsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueMaxContactsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateQueueMaxContactsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateQueueMaxContactsErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateQueueMaxContactsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateQueueMaxContactsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateQueueMaxContactsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateQueueMaxContactsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateQueueMaxContactsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateQueueNameError {
    pub kind: UpdateQueueNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateQueueNameErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateQueueNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateQueueNameErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            UpdateQueueNameErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateQueueNameErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateQueueNameErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateQueueNameErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateQueueNameErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateQueueNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateQueueNameError {
    fn code(&self) -> Option<&str> {
        UpdateQueueNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateQueueNameError {
    pub fn new(kind: UpdateQueueNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateQueueNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateQueueNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueNameErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueNameErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueNameErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueNameErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueNameErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateQueueNameErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UpdateQueueNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateQueueNameErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            UpdateQueueNameErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateQueueNameErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateQueueNameErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateQueueNameErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateQueueNameErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateQueueNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateQueueOutboundCallerConfigError {
    pub kind: UpdateQueueOutboundCallerConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateQueueOutboundCallerConfigErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateQueueOutboundCallerConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateQueueOutboundCallerConfigErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            UpdateQueueOutboundCallerConfigErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            UpdateQueueOutboundCallerConfigErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateQueueOutboundCallerConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateQueueOutboundCallerConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateQueueOutboundCallerConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateQueueOutboundCallerConfigError {
    fn code(&self) -> Option<&str> {
        UpdateQueueOutboundCallerConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateQueueOutboundCallerConfigError {
    pub fn new(kind: UpdateQueueOutboundCallerConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateQueueOutboundCallerConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateQueueOutboundCallerConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueOutboundCallerConfigErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueOutboundCallerConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueOutboundCallerConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueOutboundCallerConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueOutboundCallerConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateQueueOutboundCallerConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateQueueOutboundCallerConfigErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            UpdateQueueOutboundCallerConfigErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            UpdateQueueOutboundCallerConfigErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            UpdateQueueOutboundCallerConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateQueueOutboundCallerConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateQueueOutboundCallerConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateQueueStatusError {
    pub kind: UpdateQueueStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateQueueStatusErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateQueueStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateQueueStatusErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateQueueStatusErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateQueueStatusErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateQueueStatusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateQueueStatusErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateQueueStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateQueueStatusError {
    fn code(&self) -> Option<&str> {
        UpdateQueueStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateQueueStatusError {
    pub fn new(kind: UpdateQueueStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateQueueStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateQueueStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueStatusErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueStatusErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueStatusErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueStatusErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQueueStatusErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateQueueStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateQueueStatusErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateQueueStatusErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateQueueStatusErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateQueueStatusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateQueueStatusErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateQueueStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateQuickConnectConfigError {
    pub kind: UpdateQuickConnectConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateQuickConnectConfigErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateQuickConnectConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateQuickConnectConfigErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateQuickConnectConfigErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateQuickConnectConfigErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateQuickConnectConfigErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateQuickConnectConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateQuickConnectConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateQuickConnectConfigError {
    fn code(&self) -> Option<&str> {
        UpdateQuickConnectConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateQuickConnectConfigError {
    pub fn new(kind: UpdateQuickConnectConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateQuickConnectConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateQuickConnectConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuickConnectConfigErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuickConnectConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuickConnectConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuickConnectConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuickConnectConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateQuickConnectConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateQuickConnectConfigErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateQuickConnectConfigErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateQuickConnectConfigErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateQuickConnectConfigErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateQuickConnectConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateQuickConnectConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateQuickConnectNameError {
    pub kind: UpdateQuickConnectNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateQuickConnectNameErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateQuickConnectNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateQuickConnectNameErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateQuickConnectNameErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateQuickConnectNameErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateQuickConnectNameErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateQuickConnectNameErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateQuickConnectNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateQuickConnectNameError {
    fn code(&self) -> Option<&str> {
        UpdateQuickConnectNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateQuickConnectNameError {
    pub fn new(kind: UpdateQuickConnectNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateQuickConnectNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateQuickConnectNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuickConnectNameErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuickConnectNameErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuickConnectNameErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuickConnectNameErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuickConnectNameErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateQuickConnectNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateQuickConnectNameErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateQuickConnectNameErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateQuickConnectNameErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateQuickConnectNameErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateQuickConnectNameErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateQuickConnectNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRoutingProfileConcurrencyError {
    pub kind: UpdateRoutingProfileConcurrencyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRoutingProfileConcurrencyErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRoutingProfileConcurrencyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRoutingProfileConcurrencyErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRoutingProfileConcurrencyErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRoutingProfileConcurrencyErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRoutingProfileConcurrencyErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRoutingProfileConcurrencyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateRoutingProfileConcurrencyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRoutingProfileConcurrencyError {
    fn code(&self) -> Option<&str> {
        UpdateRoutingProfileConcurrencyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRoutingProfileConcurrencyError {
    pub fn new(kind: UpdateRoutingProfileConcurrencyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRoutingProfileConcurrencyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRoutingProfileConcurrencyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileConcurrencyErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileConcurrencyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileConcurrencyErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileConcurrencyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileConcurrencyErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateRoutingProfileConcurrencyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRoutingProfileConcurrencyErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            UpdateRoutingProfileConcurrencyErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            UpdateRoutingProfileConcurrencyErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            UpdateRoutingProfileConcurrencyErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateRoutingProfileConcurrencyErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateRoutingProfileConcurrencyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRoutingProfileDefaultOutboundQueueError {
    pub kind: UpdateRoutingProfileDefaultOutboundQueueErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRoutingProfileDefaultOutboundQueueErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRoutingProfileDefaultOutboundQueueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::InvalidParameterException(
                _inner,
            ) => _inner.fmt(f),
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::ResourceNotFoundException(
                _inner,
            ) => _inner.fmt(f),
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRoutingProfileDefaultOutboundQueueError {
    fn code(&self) -> Option<&str> {
        UpdateRoutingProfileDefaultOutboundQueueError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRoutingProfileDefaultOutboundQueueError {
    pub fn new(
        kind: UpdateRoutingProfileDefaultOutboundQueueErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRoutingProfileDefaultOutboundQueueErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRoutingProfileDefaultOutboundQueueErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateRoutingProfileDefaultOutboundQueueError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::InvalidParameterException(
                _inner,
            ) => Some(_inner),
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::ResourceNotFoundException(
                _inner,
            ) => Some(_inner),
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            UpdateRoutingProfileDefaultOutboundQueueErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRoutingProfileNameError {
    pub kind: UpdateRoutingProfileNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRoutingProfileNameErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRoutingProfileNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRoutingProfileNameErrorKind::DuplicateResourceException(_inner) => _inner.fmt(f),
            UpdateRoutingProfileNameErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateRoutingProfileNameErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateRoutingProfileNameErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateRoutingProfileNameErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateRoutingProfileNameErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateRoutingProfileNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRoutingProfileNameError {
    fn code(&self) -> Option<&str> {
        UpdateRoutingProfileNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRoutingProfileNameError {
    pub fn new(kind: UpdateRoutingProfileNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRoutingProfileNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRoutingProfileNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileNameErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileNameErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileNameErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileNameErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileNameErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileNameErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateRoutingProfileNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRoutingProfileNameErrorKind::DuplicateResourceException(_inner) => Some(_inner),
            UpdateRoutingProfileNameErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateRoutingProfileNameErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateRoutingProfileNameErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateRoutingProfileNameErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateRoutingProfileNameErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateRoutingProfileNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRoutingProfileQueuesError {
    pub kind: UpdateRoutingProfileQueuesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRoutingProfileQueuesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRoutingProfileQueuesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRoutingProfileQueuesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateRoutingProfileQueuesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateRoutingProfileQueuesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateRoutingProfileQueuesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateRoutingProfileQueuesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateRoutingProfileQueuesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRoutingProfileQueuesError {
    fn code(&self) -> Option<&str> {
        UpdateRoutingProfileQueuesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRoutingProfileQueuesError {
    pub fn new(kind: UpdateRoutingProfileQueuesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRoutingProfileQueuesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRoutingProfileQueuesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileQueuesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileQueuesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileQueuesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileQueuesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoutingProfileQueuesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateRoutingProfileQueuesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRoutingProfileQueuesErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateRoutingProfileQueuesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateRoutingProfileQueuesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateRoutingProfileQueuesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateRoutingProfileQueuesErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateRoutingProfileQueuesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserHierarchyError {
    pub kind: UpdateUserHierarchyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserHierarchyErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserHierarchyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserHierarchyErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateUserHierarchyErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateUserHierarchyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateUserHierarchyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateUserHierarchyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateUserHierarchyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserHierarchyError {
    fn code(&self) -> Option<&str> {
        UpdateUserHierarchyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserHierarchyError {
    pub fn new(kind: UpdateUserHierarchyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserHierarchyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserHierarchyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateUserHierarchyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserHierarchyErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateUserHierarchyErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateUserHierarchyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateUserHierarchyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateUserHierarchyErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateUserHierarchyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserHierarchyGroupNameError {
    pub kind: UpdateUserHierarchyGroupNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserHierarchyGroupNameErrorKind {
    DuplicateResourceException(crate::error::DuplicateResourceException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserHierarchyGroupNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserHierarchyGroupNameErrorKind::DuplicateResourceException(_inner) => {
                _inner.fmt(f)
            }
            UpdateUserHierarchyGroupNameErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            UpdateUserHierarchyGroupNameErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            UpdateUserHierarchyGroupNameErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateUserHierarchyGroupNameErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateUserHierarchyGroupNameErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateUserHierarchyGroupNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserHierarchyGroupNameError {
    fn code(&self) -> Option<&str> {
        UpdateUserHierarchyGroupNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserHierarchyGroupNameError {
    pub fn new(kind: UpdateUserHierarchyGroupNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserHierarchyGroupNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserHierarchyGroupNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyGroupNameErrorKind::DuplicateResourceException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyGroupNameErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyGroupNameErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyGroupNameErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyGroupNameErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyGroupNameErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateUserHierarchyGroupNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserHierarchyGroupNameErrorKind::DuplicateResourceException(_inner) => {
                Some(_inner)
            }
            UpdateUserHierarchyGroupNameErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateUserHierarchyGroupNameErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            UpdateUserHierarchyGroupNameErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateUserHierarchyGroupNameErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateUserHierarchyGroupNameErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateUserHierarchyGroupNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserHierarchyStructureError {
    pub kind: UpdateUserHierarchyStructureErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserHierarchyStructureErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserHierarchyStructureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserHierarchyStructureErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            UpdateUserHierarchyStructureErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            UpdateUserHierarchyStructureErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateUserHierarchyStructureErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            UpdateUserHierarchyStructureErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateUserHierarchyStructureErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateUserHierarchyStructureErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserHierarchyStructureError {
    fn code(&self) -> Option<&str> {
        UpdateUserHierarchyStructureError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserHierarchyStructureError {
    pub fn new(kind: UpdateUserHierarchyStructureErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserHierarchyStructureErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserHierarchyStructureErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyStructureErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyStructureErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyStructureErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyStructureErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyStructureErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserHierarchyStructureErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateUserHierarchyStructureError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserHierarchyStructureErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateUserHierarchyStructureErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            UpdateUserHierarchyStructureErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateUserHierarchyStructureErrorKind::ResourceInUseException(_inner) => Some(_inner),
            UpdateUserHierarchyStructureErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateUserHierarchyStructureErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateUserHierarchyStructureErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserIdentityInfoError {
    pub kind: UpdateUserIdentityInfoErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserIdentityInfoErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserIdentityInfoError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserIdentityInfoErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateUserIdentityInfoErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateUserIdentityInfoErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateUserIdentityInfoErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateUserIdentityInfoErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateUserIdentityInfoErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserIdentityInfoError {
    fn code(&self) -> Option<&str> {
        UpdateUserIdentityInfoError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserIdentityInfoError {
    pub fn new(kind: UpdateUserIdentityInfoErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserIdentityInfoErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserIdentityInfoErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserIdentityInfoErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserIdentityInfoErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserIdentityInfoErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserIdentityInfoErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserIdentityInfoErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateUserIdentityInfoError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserIdentityInfoErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateUserIdentityInfoErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateUserIdentityInfoErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateUserIdentityInfoErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateUserIdentityInfoErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateUserIdentityInfoErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserPhoneConfigError {
    pub kind: UpdateUserPhoneConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserPhoneConfigErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserPhoneConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserPhoneConfigErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateUserPhoneConfigErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateUserPhoneConfigErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateUserPhoneConfigErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateUserPhoneConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateUserPhoneConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserPhoneConfigError {
    fn code(&self) -> Option<&str> {
        UpdateUserPhoneConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserPhoneConfigError {
    pub fn new(kind: UpdateUserPhoneConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserPhoneConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserPhoneConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPhoneConfigErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPhoneConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPhoneConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPhoneConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPhoneConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateUserPhoneConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserPhoneConfigErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateUserPhoneConfigErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateUserPhoneConfigErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateUserPhoneConfigErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateUserPhoneConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateUserPhoneConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserRoutingProfileError {
    pub kind: UpdateUserRoutingProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserRoutingProfileErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserRoutingProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserRoutingProfileErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateUserRoutingProfileErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateUserRoutingProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateUserRoutingProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateUserRoutingProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateUserRoutingProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserRoutingProfileError {
    fn code(&self) -> Option<&str> {
        UpdateUserRoutingProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserRoutingProfileError {
    pub fn new(kind: UpdateUserRoutingProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserRoutingProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserRoutingProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserRoutingProfileErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserRoutingProfileErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserRoutingProfileErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserRoutingProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserRoutingProfileErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateUserRoutingProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserRoutingProfileErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateUserRoutingProfileErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateUserRoutingProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateUserRoutingProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateUserRoutingProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateUserRoutingProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserSecurityProfilesError {
    pub kind: UpdateUserSecurityProfilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserSecurityProfilesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserSecurityProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserSecurityProfilesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateUserSecurityProfilesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateUserSecurityProfilesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateUserSecurityProfilesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateUserSecurityProfilesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateUserSecurityProfilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserSecurityProfilesError {
    fn code(&self) -> Option<&str> {
        UpdateUserSecurityProfilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserSecurityProfilesError {
    pub fn new(kind: UpdateUserSecurityProfilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserSecurityProfilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserSecurityProfilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserSecurityProfilesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserSecurityProfilesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserSecurityProfilesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserSecurityProfilesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserSecurityProfilesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateUserSecurityProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserSecurityProfilesErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateUserSecurityProfilesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateUserSecurityProfilesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateUserSecurityProfilesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateUserSecurityProfilesErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateUserSecurityProfilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The throttling limit has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ThrottlingException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException)
pub mod throttling_exception {
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException)
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException)
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>The specified resource was not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    /// <p>The message about the resource.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message about the resource.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The request is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRequestException {
    /// <p>The message about the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRequestException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRequestException {}
/// See [`InvalidRequestException`](crate::error::InvalidRequestException)
pub mod invalid_request_exception {
    /// A builder for [`InvalidRequestException`](crate::error::InvalidRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message about the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequestException`](crate::error::InvalidRequestException)
        pub fn build(self) -> crate::error::InvalidRequestException {
            crate::error::InvalidRequestException {
                message: self.message,
            }
        }
    }
}
impl InvalidRequestException {
    /// Creates a new builder-style object to manufacture [`InvalidRequestException`](crate::error::InvalidRequestException)
    pub fn builder() -> crate::error::invalid_request_exception::Builder {
        crate::error::invalid_request_exception::Builder::default()
    }
}

/// <p>One or more of the specified parameters are not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterException {
    /// <p>The message about the parameters.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterException {}
/// See [`InvalidParameterException`](crate::error::InvalidParameterException)
pub mod invalid_parameter_exception {
    /// A builder for [`InvalidParameterException`](crate::error::InvalidParameterException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message about the parameters.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterException`](crate::error::InvalidParameterException)
        pub fn build(self) -> crate::error::InvalidParameterException {
            crate::error::InvalidParameterException {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterException`](crate::error::InvalidParameterException)
    pub fn builder() -> crate::error::invalid_parameter_exception::Builder {
        crate::error::invalid_parameter_exception::Builder::default()
    }
}

/// <p>Request processing failed because of an error or failure with the service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServiceException {
    /// <p>The message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServiceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServiceException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServiceException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServiceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServiceException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServiceException {}
/// See [`InternalServiceException`](crate::error::InternalServiceException)
pub mod internal_service_exception {
    /// A builder for [`InternalServiceException`](crate::error::InternalServiceException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServiceException`](crate::error::InternalServiceException)
        pub fn build(self) -> crate::error::InternalServiceException {
            crate::error::InternalServiceException {
                message: self.message,
            }
        }
    }
}
impl InternalServiceException {
    /// Creates a new builder-style object to manufacture [`InternalServiceException`](crate::error::InternalServiceException)
    pub fn builder() -> crate::error::internal_service_exception::Builder {
        crate::error::internal_service_exception::Builder::default()
    }
}

/// <p>That resource is already in use. Please try another.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The type of resource.</p>
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The identifier for the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseException");
        formatter.field("message", &self.message);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_id", &self.resource_id);
        formatter.finish()
    }
}
impl ResourceInUseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseException {}
/// See [`ResourceInUseException`](crate::error::ResourceInUseException)
pub mod resource_in_use_exception {
    /// A builder for [`ResourceInUseException`](crate::error::ResourceInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The type of resource.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The identifier for the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseException`](crate::error::ResourceInUseException)
        pub fn build(self) -> crate::error::ResourceInUseException {
            crate::error::ResourceInUseException {
                message: self.message,
                resource_type: self.resource_type,
                resource_id: self.resource_id,
            }
        }
    }
}
impl ResourceInUseException {
    /// Creates a new builder-style object to manufacture [`ResourceInUseException`](crate::error::ResourceInUseException)
    pub fn builder() -> crate::error::resource_in_use_exception::Builder {
        crate::error::resource_in_use_exception::Builder::default()
    }
}

/// <p>A resource with the specified name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DuplicateResourceException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DuplicateResourceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DuplicateResourceException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DuplicateResourceException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateResourceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateResourceException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateResourceException {}
/// See [`DuplicateResourceException`](crate::error::DuplicateResourceException)
pub mod duplicate_resource_exception {
    /// A builder for [`DuplicateResourceException`](crate::error::DuplicateResourceException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateResourceException`](crate::error::DuplicateResourceException)
        pub fn build(self) -> crate::error::DuplicateResourceException {
            crate::error::DuplicateResourceException {
                message: self.message,
            }
        }
    }
}
impl DuplicateResourceException {
    /// Creates a new builder-style object to manufacture [`DuplicateResourceException`](crate::error::DuplicateResourceException)
    pub fn builder() -> crate::error::duplicate_resource_exception::Builder {
        crate::error::duplicate_resource_exception::Builder::default()
    }
}

/// <p>The contact flow is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidContactFlowException {
    /// <p>The problems with the contact flow. Please fix before trying again.</p>
    pub problems: std::option::Option<std::vec::Vec<crate::model::ProblemDetail>>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidContactFlowException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidContactFlowException");
        formatter.field("problems", &self.problems);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidContactFlowException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidContactFlowException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidContactFlowException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidContactFlowException {}
/// See [`InvalidContactFlowException`](crate::error::InvalidContactFlowException)
pub mod invalid_contact_flow_exception {
    /// A builder for [`InvalidContactFlowException`](crate::error::InvalidContactFlowException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) problems: std::option::Option<std::vec::Vec<crate::model::ProblemDetail>>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn problems(mut self, input: impl Into<crate::model::ProblemDetail>) -> Self {
            let mut v = self.problems.unwrap_or_default();
            v.push(input.into());
            self.problems = Some(v);
            self
        }
        pub fn set_problems(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProblemDetail>>,
        ) -> Self {
            self.problems = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidContactFlowException`](crate::error::InvalidContactFlowException)
        pub fn build(self) -> crate::error::InvalidContactFlowException {
            crate::error::InvalidContactFlowException {
                problems: self.problems,
                message: self.message,
            }
        }
    }
}
impl InvalidContactFlowException {
    /// Creates a new builder-style object to manufacture [`InvalidContactFlowException`](crate::error::InvalidContactFlowException)
    pub fn builder() -> crate::error::invalid_contact_flow_exception::Builder {
        crate::error::invalid_contact_flow_exception::Builder::default()
    }
}

/// <p>The allowed limit for the resource has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    /// <p>The message about the limit.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message about the limit.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>The contact with the specified ID is not active or does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContactNotFoundException {
    /// <p>The message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ContactNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContactNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ContactNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ContactNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ContactNotFoundException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for ContactNotFoundException {}
/// See [`ContactNotFoundException`](crate::error::ContactNotFoundException)
pub mod contact_not_found_exception {
    /// A builder for [`ContactNotFoundException`](crate::error::ContactNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactNotFoundException`](crate::error::ContactNotFoundException)
        pub fn build(self) -> crate::error::ContactNotFoundException {
            crate::error::ContactNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ContactNotFoundException {
    /// Creates a new builder-style object to manufacture [`ContactNotFoundException`](crate::error::ContactNotFoundException)
    pub fn builder() -> crate::error::contact_not_found_exception::Builder {
        crate::error::contact_not_found_exception::Builder::default()
    }
}

/// <p>The service quota has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceQuotaExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceQuotaExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceQuotaExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaExceededException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaExceededException {}
/// See [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
pub mod service_quota_exceeded_exception {
    /// A builder for [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
        pub fn build(self) -> crate::error::ServiceQuotaExceededException {
            crate::error::ServiceQuotaExceededException {
                message: self.message,
            }
        }
    }
}
impl ServiceQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    pub fn builder() -> crate::error::service_quota_exceeded_exception::Builder {
        crate::error::service_quota_exceeded_exception::Builder::default()
    }
}

/// <p>The contact is not permitted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutboundContactNotPermittedException {
    /// <p>The message about the contact.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OutboundContactNotPermittedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutboundContactNotPermittedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OutboundContactNotPermittedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OutboundContactNotPermittedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OutboundContactNotPermittedException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for OutboundContactNotPermittedException {}
/// See [`OutboundContactNotPermittedException`](crate::error::OutboundContactNotPermittedException)
pub mod outbound_contact_not_permitted_exception {
    /// A builder for [`OutboundContactNotPermittedException`](crate::error::OutboundContactNotPermittedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message about the contact.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OutboundContactNotPermittedException`](crate::error::OutboundContactNotPermittedException)
        pub fn build(self) -> crate::error::OutboundContactNotPermittedException {
            crate::error::OutboundContactNotPermittedException {
                message: self.message,
            }
        }
    }
}
impl OutboundContactNotPermittedException {
    /// Creates a new builder-style object to manufacture [`OutboundContactNotPermittedException`](crate::error::OutboundContactNotPermittedException)
    pub fn builder() -> crate::error::outbound_contact_not_permitted_exception::Builder {
        crate::error::outbound_contact_not_permitted_exception::Builder::default()
    }
}

/// <p>Outbound calls to the destination number are not allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DestinationNotAllowedException {
    /// <p>The message about the outbound calls.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DestinationNotAllowedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DestinationNotAllowedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DestinationNotAllowedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DestinationNotAllowedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DestinationNotAllowedException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for DestinationNotAllowedException {}
/// See [`DestinationNotAllowedException`](crate::error::DestinationNotAllowedException)
pub mod destination_not_allowed_exception {
    /// A builder for [`DestinationNotAllowedException`](crate::error::DestinationNotAllowedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message about the outbound calls.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DestinationNotAllowedException`](crate::error::DestinationNotAllowedException)
        pub fn build(self) -> crate::error::DestinationNotAllowedException {
            crate::error::DestinationNotAllowedException {
                message: self.message,
            }
        }
    }
}
impl DestinationNotAllowedException {
    /// Creates a new builder-style object to manufacture [`DestinationNotAllowedException`](crate::error::DestinationNotAllowedException)
    pub fn builder() -> crate::error::destination_not_allowed_exception::Builder {
        crate::error::destination_not_allowed_exception::Builder::default()
    }
}

/// <p>No user with the specified credentials was found in the Amazon Connect instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserNotFoundException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserNotFoundException {}
/// See [`UserNotFoundException`](crate::error::UserNotFoundException)
pub mod user_not_found_exception {
    /// A builder for [`UserNotFoundException`](crate::error::UserNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserNotFoundException`](crate::error::UserNotFoundException)
        pub fn build(self) -> crate::error::UserNotFoundException {
            crate::error::UserNotFoundException {
                message: self.message,
            }
        }
    }
}
impl UserNotFoundException {
    /// Creates a new builder-style object to manufacture [`UserNotFoundException`](crate::error::UserNotFoundException)
    pub fn builder() -> crate::error::user_not_found_exception::Builder {
        crate::error::user_not_found_exception::Builder::default()
    }
}

/// <p>The contact flow has not been published.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContactFlowNotPublishedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ContactFlowNotPublishedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContactFlowNotPublishedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ContactFlowNotPublishedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ContactFlowNotPublishedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ContactFlowNotPublishedException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for ContactFlowNotPublishedException {}
/// See [`ContactFlowNotPublishedException`](crate::error::ContactFlowNotPublishedException)
pub mod contact_flow_not_published_exception {
    /// A builder for [`ContactFlowNotPublishedException`](crate::error::ContactFlowNotPublishedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactFlowNotPublishedException`](crate::error::ContactFlowNotPublishedException)
        pub fn build(self) -> crate::error::ContactFlowNotPublishedException {
            crate::error::ContactFlowNotPublishedException {
                message: self.message,
            }
        }
    }
}
impl ContactFlowNotPublishedException {
    /// Creates a new builder-style object to manufacture [`ContactFlowNotPublishedException`](crate::error::ContactFlowNotPublishedException)
    pub fn builder() -> crate::error::contact_flow_not_published_exception::Builder {
        crate::error::contact_flow_not_published_exception::Builder::default()
    }
}

/// <p>A resource already has that name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceConflictException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceConflictException {}
/// See [`ResourceConflictException`](crate::error::ResourceConflictException)
pub mod resource_conflict_exception {
    /// A builder for [`ResourceConflictException`](crate::error::ResourceConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceConflictException`](crate::error::ResourceConflictException)
        pub fn build(self) -> crate::error::ResourceConflictException {
            crate::error::ResourceConflictException {
                message: self.message,
            }
        }
    }
}
impl ResourceConflictException {
    /// Creates a new builder-style object to manufacture [`ResourceConflictException`](crate::error::ResourceConflictException)
    pub fn builder() -> crate::error::resource_conflict_exception::Builder {
        crate::error::resource_conflict_exception::Builder::default()
    }
}
