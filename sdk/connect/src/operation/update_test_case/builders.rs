// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::update_test_case::_update_test_case_output::UpdateTestCaseOutputBuilder;

pub use crate::operation::update_test_case::_update_test_case_input::UpdateTestCaseInputBuilder;

impl crate::operation::update_test_case::builders::UpdateTestCaseInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::update_test_case::UpdateTestCaseOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_test_case::UpdateTestCaseError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.update_test_case();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `UpdateTestCase`.
///
/// <p>Updates any of the metadata for a test case, such as the name, description, and status or content of an existing test case. This API doesn't allow customers to update the tags of the test case resource for the specified Amazon Connect instance.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct UpdateTestCaseFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::update_test_case::builders::UpdateTestCaseInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::update_test_case::UpdateTestCaseOutput,
        crate::operation::update_test_case::UpdateTestCaseError,
    > for UpdateTestCaseFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::update_test_case::UpdateTestCaseOutput,
            crate::operation::update_test_case::UpdateTestCaseError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl UpdateTestCaseFluentBuilder {
    /// Creates a new `UpdateTestCaseFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the UpdateTestCase as a reference.
    pub fn as_input(&self) -> &crate::operation::update_test_case::builders::UpdateTestCaseInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::update_test_case::UpdateTestCaseOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_test_case::UpdateTestCaseError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::update_test_case::UpdateTestCase::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::update_test_case::UpdateTestCase::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::update_test_case::UpdateTestCaseOutput,
        crate::operation::update_test_case::UpdateTestCaseError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The identifier of the Amazon Connect instance.</p>
    pub fn instance_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.instance_id(input.into());
        self
    }
    /// <p>The identifier of the Amazon Connect instance.</p>
    pub fn set_instance_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_instance_id(input);
        self
    }
    /// <p>The identifier of the Amazon Connect instance.</p>
    pub fn get_instance_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_instance_id()
    }
    /// <p>The identifier of the test case to update.</p>
    pub fn test_case_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.test_case_id(input.into());
        self
    }
    /// <p>The identifier of the test case to update.</p>
    pub fn set_test_case_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_test_case_id(input);
        self
    }
    /// <p>The identifier of the test case to update.</p>
    pub fn get_test_case_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_test_case_id()
    }
    /// <p>The JSON string that represents the content of the test.</p>
    pub fn content(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.content(input.into());
        self
    }
    /// <p>The JSON string that represents the content of the test.</p>
    pub fn set_content(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_content(input);
        self
    }
    /// <p>The JSON string that represents the content of the test.</p>
    pub fn get_content(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_content()
    }
    /// <p>Defines the starting point for your test.</p>
    pub fn entry_point(mut self, input: crate::types::TestCaseEntryPoint) -> Self {
        self.inner = self.inner.entry_point(input);
        self
    }
    /// <p>Defines the starting point for your test.</p>
    pub fn set_entry_point(mut self, input: ::std::option::Option<crate::types::TestCaseEntryPoint>) -> Self {
        self.inner = self.inner.set_entry_point(input);
        self
    }
    /// <p>Defines the starting point for your test.</p>
    pub fn get_entry_point(&self) -> &::std::option::Option<crate::types::TestCaseEntryPoint> {
        self.inner.get_entry_point()
    }
    /// <p>Defines the test attributes for precise data representation.</p>
    pub fn initialization_data(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.initialization_data(input.into());
        self
    }
    /// <p>Defines the test attributes for precise data representation.</p>
    pub fn set_initialization_data(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_initialization_data(input);
        self
    }
    /// <p>Defines the test attributes for precise data representation.</p>
    pub fn get_initialization_data(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_initialization_data()
    }
    /// <p>The name of the test case.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>The name of the test case.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>The name of the test case.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>The description of the test case.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>The description of the test case.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>The description of the test case.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    /// <p>Indicates the test status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content. The SAVED status does not initiate validation of the content.</p>
    pub fn status(mut self, input: crate::types::TestCaseStatus) -> Self {
        self.inner = self.inner.status(input);
        self
    }
    /// <p>Indicates the test status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content. The SAVED status does not initiate validation of the content.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::TestCaseStatus>) -> Self {
        self.inner = self.inner.set_status(input);
        self
    }
    /// <p>Indicates the test status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content. The SAVED status does not initiate validation of the content.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::TestCaseStatus> {
        self.inner.get_status()
    }
    /// <p>The time at which the resource was last modified.</p>
    pub fn last_modified_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.inner = self.inner.last_modified_time(input);
        self
    }
    /// <p>The time at which the resource was last modified.</p>
    pub fn set_last_modified_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.inner = self.inner.set_last_modified_time(input);
        self
    }
    /// <p>The time at which the resource was last modified.</p>
    pub fn get_last_modified_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        self.inner.get_last_modified_time()
    }
    /// <p>The region in which the resource was last modified</p>
    pub fn last_modified_region(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.last_modified_region(input.into());
        self
    }
    /// <p>The region in which the resource was last modified</p>
    pub fn set_last_modified_region(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_last_modified_region(input);
        self
    }
    /// <p>The region in which the resource was last modified</p>
    pub fn get_last_modified_region(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_last_modified_region()
    }
}
