// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>With recurring prefetch, MediaTailor automatically prefetches ads for every avail that occurs during the retrieval window. The following configurations describe the MediaTailor behavior when prefetching ads for a live event.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RecurringRetrieval {
    /// <p>The dynamic variables to use for substitution during prefetch requests to the ADS.</p>
    pub dynamic_variables: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The number of seconds that MediaTailor waits after an ad avail before prefetching ads for the next avail. If not set, the default is 0 (no delay).</p>
    pub delay_after_avail_end_seconds: ::std::option::Option<i32>,
    /// <p>Indicates the type of traffic shaping used to limit the number of requests to the ADS at one time.</p>
    pub traffic_shaping_type: ::std::option::Option<crate::types::TrafficShapingType>,
    /// <p>The configuration that tells Elemental MediaTailor how many seconds to spread out requests to the ad decision server (ADS). Instead of sending ADS requests for all sessions at the same time, MediaTailor spreads the requests across the amount of time specified in the retrieval window.</p>
    pub traffic_shaping_retrieval_window: ::std::option::Option<crate::types::TrafficShapingRetrievalWindow>,
    /// <p>The configuration for TPS-based traffic shaping. This approach limits requests to the ad decision server (ADS) based on transactions per second and concurrent users.</p>
    pub traffic_shaping_tps_configuration: ::std::option::Option<crate::types::TrafficShapingTpsConfiguration>,
}
impl RecurringRetrieval {
    /// <p>The dynamic variables to use for substitution during prefetch requests to the ADS.</p>
    pub fn dynamic_variables(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.dynamic_variables.as_ref()
    }
    /// <p>The number of seconds that MediaTailor waits after an ad avail before prefetching ads for the next avail. If not set, the default is 0 (no delay).</p>
    pub fn delay_after_avail_end_seconds(&self) -> ::std::option::Option<i32> {
        self.delay_after_avail_end_seconds
    }
    /// <p>Indicates the type of traffic shaping used to limit the number of requests to the ADS at one time.</p>
    pub fn traffic_shaping_type(&self) -> ::std::option::Option<&crate::types::TrafficShapingType> {
        self.traffic_shaping_type.as_ref()
    }
    /// <p>The configuration that tells Elemental MediaTailor how many seconds to spread out requests to the ad decision server (ADS). Instead of sending ADS requests for all sessions at the same time, MediaTailor spreads the requests across the amount of time specified in the retrieval window.</p>
    pub fn traffic_shaping_retrieval_window(&self) -> ::std::option::Option<&crate::types::TrafficShapingRetrievalWindow> {
        self.traffic_shaping_retrieval_window.as_ref()
    }
    /// <p>The configuration for TPS-based traffic shaping. This approach limits requests to the ad decision server (ADS) based on transactions per second and concurrent users.</p>
    pub fn traffic_shaping_tps_configuration(&self) -> ::std::option::Option<&crate::types::TrafficShapingTpsConfiguration> {
        self.traffic_shaping_tps_configuration.as_ref()
    }
}
impl RecurringRetrieval {
    /// Creates a new builder-style object to manufacture [`RecurringRetrieval`](crate::types::RecurringRetrieval).
    pub fn builder() -> crate::types::builders::RecurringRetrievalBuilder {
        crate::types::builders::RecurringRetrievalBuilder::default()
    }
}

/// A builder for [`RecurringRetrieval`](crate::types::RecurringRetrieval).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct RecurringRetrievalBuilder {
    pub(crate) dynamic_variables: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) delay_after_avail_end_seconds: ::std::option::Option<i32>,
    pub(crate) traffic_shaping_type: ::std::option::Option<crate::types::TrafficShapingType>,
    pub(crate) traffic_shaping_retrieval_window: ::std::option::Option<crate::types::TrafficShapingRetrievalWindow>,
    pub(crate) traffic_shaping_tps_configuration: ::std::option::Option<crate::types::TrafficShapingTpsConfiguration>,
}
impl RecurringRetrievalBuilder {
    /// Adds a key-value pair to `dynamic_variables`.
    ///
    /// To override the contents of this collection use [`set_dynamic_variables`](Self::set_dynamic_variables).
    ///
    /// <p>The dynamic variables to use for substitution during prefetch requests to the ADS.</p>
    pub fn dynamic_variables(
        mut self,
        k: impl ::std::convert::Into<::std::string::String>,
        v: impl ::std::convert::Into<::std::string::String>,
    ) -> Self {
        let mut hash_map = self.dynamic_variables.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.dynamic_variables = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The dynamic variables to use for substitution during prefetch requests to the ADS.</p>
    pub fn set_dynamic_variables(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    ) -> Self {
        self.dynamic_variables = input;
        self
    }
    /// <p>The dynamic variables to use for substitution during prefetch requests to the ADS.</p>
    pub fn get_dynamic_variables(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.dynamic_variables
    }
    /// <p>The number of seconds that MediaTailor waits after an ad avail before prefetching ads for the next avail. If not set, the default is 0 (no delay).</p>
    pub fn delay_after_avail_end_seconds(mut self, input: i32) -> Self {
        self.delay_after_avail_end_seconds = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of seconds that MediaTailor waits after an ad avail before prefetching ads for the next avail. If not set, the default is 0 (no delay).</p>
    pub fn set_delay_after_avail_end_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.delay_after_avail_end_seconds = input;
        self
    }
    /// <p>The number of seconds that MediaTailor waits after an ad avail before prefetching ads for the next avail. If not set, the default is 0 (no delay).</p>
    pub fn get_delay_after_avail_end_seconds(&self) -> &::std::option::Option<i32> {
        &self.delay_after_avail_end_seconds
    }
    /// <p>Indicates the type of traffic shaping used to limit the number of requests to the ADS at one time.</p>
    pub fn traffic_shaping_type(mut self, input: crate::types::TrafficShapingType) -> Self {
        self.traffic_shaping_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates the type of traffic shaping used to limit the number of requests to the ADS at one time.</p>
    pub fn set_traffic_shaping_type(mut self, input: ::std::option::Option<crate::types::TrafficShapingType>) -> Self {
        self.traffic_shaping_type = input;
        self
    }
    /// <p>Indicates the type of traffic shaping used to limit the number of requests to the ADS at one time.</p>
    pub fn get_traffic_shaping_type(&self) -> &::std::option::Option<crate::types::TrafficShapingType> {
        &self.traffic_shaping_type
    }
    /// <p>The configuration that tells Elemental MediaTailor how many seconds to spread out requests to the ad decision server (ADS). Instead of sending ADS requests for all sessions at the same time, MediaTailor spreads the requests across the amount of time specified in the retrieval window.</p>
    pub fn traffic_shaping_retrieval_window(mut self, input: crate::types::TrafficShapingRetrievalWindow) -> Self {
        self.traffic_shaping_retrieval_window = ::std::option::Option::Some(input);
        self
    }
    /// <p>The configuration that tells Elemental MediaTailor how many seconds to spread out requests to the ad decision server (ADS). Instead of sending ADS requests for all sessions at the same time, MediaTailor spreads the requests across the amount of time specified in the retrieval window.</p>
    pub fn set_traffic_shaping_retrieval_window(mut self, input: ::std::option::Option<crate::types::TrafficShapingRetrievalWindow>) -> Self {
        self.traffic_shaping_retrieval_window = input;
        self
    }
    /// <p>The configuration that tells Elemental MediaTailor how many seconds to spread out requests to the ad decision server (ADS). Instead of sending ADS requests for all sessions at the same time, MediaTailor spreads the requests across the amount of time specified in the retrieval window.</p>
    pub fn get_traffic_shaping_retrieval_window(&self) -> &::std::option::Option<crate::types::TrafficShapingRetrievalWindow> {
        &self.traffic_shaping_retrieval_window
    }
    /// <p>The configuration for TPS-based traffic shaping. This approach limits requests to the ad decision server (ADS) based on transactions per second and concurrent users.</p>
    pub fn traffic_shaping_tps_configuration(mut self, input: crate::types::TrafficShapingTpsConfiguration) -> Self {
        self.traffic_shaping_tps_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The configuration for TPS-based traffic shaping. This approach limits requests to the ad decision server (ADS) based on transactions per second and concurrent users.</p>
    pub fn set_traffic_shaping_tps_configuration(mut self, input: ::std::option::Option<crate::types::TrafficShapingTpsConfiguration>) -> Self {
        self.traffic_shaping_tps_configuration = input;
        self
    }
    /// <p>The configuration for TPS-based traffic shaping. This approach limits requests to the ad decision server (ADS) based on transactions per second and concurrent users.</p>
    pub fn get_traffic_shaping_tps_configuration(&self) -> &::std::option::Option<crate::types::TrafficShapingTpsConfiguration> {
        &self.traffic_shaping_tps_configuration
    }
    /// Consumes the builder and constructs a [`RecurringRetrieval`](crate::types::RecurringRetrieval).
    pub fn build(self) -> crate::types::RecurringRetrieval {
        crate::types::RecurringRetrieval {
            dynamic_variables: self.dynamic_variables,
            delay_after_avail_end_seconds: self.delay_after_avail_end_seconds,
            traffic_shaping_type: self.traffic_shaping_type,
            traffic_shaping_retrieval_window: self.traffic_shaping_retrieval_window,
            traffic_shaping_tps_configuration: self.traffic_shaping_tps_configuration,
        }
    }
}
