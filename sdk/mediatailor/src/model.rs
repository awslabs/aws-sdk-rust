// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>VOD source configuration parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VodSource {
    /// <p>The ARN for the VOD source.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates when the VOD source was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The HTTP package configurations for the VOD source.</p>
    #[doc(hidden)]
    pub http_package_configurations:
        std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
    /// <p>The timestamp that indicates when the VOD source was last modified.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the source location that the VOD source is associated with.</p>
    #[doc(hidden)]
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name of the VOD source.</p>
    #[doc(hidden)]
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl VodSource {
    /// <p>The ARN for the VOD source.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The timestamp that indicates when the VOD source was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The HTTP package configurations for the VOD source.</p>
    pub fn http_package_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::HttpPackageConfiguration]> {
        self.http_package_configurations.as_deref()
    }
    /// <p>The timestamp that indicates when the VOD source was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The name of the source location that the VOD source is associated with.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags assigned to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The name of the VOD source.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl VodSource {
    /// Creates a new builder-style object to manufacture [`VodSource`](crate::model::VodSource).
    pub fn builder() -> crate::model::vod_source::Builder {
        crate::model::vod_source::Builder::default()
    }
}

/// See [`VodSource`](crate::model::VodSource).
pub mod vod_source {

    /// A builder for [`VodSource`](crate::model::VodSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) http_package_configurations:
            std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN for the VOD source.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN for the VOD source.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The timestamp that indicates when the VOD source was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the VOD source was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Appends an item to `http_package_configurations`.
        ///
        /// To override the contents of this collection use [`set_http_package_configurations`](Self::set_http_package_configurations).
        ///
        /// <p>The HTTP package configurations for the VOD source.</p>
        pub fn http_package_configurations(
            mut self,
            input: crate::model::HttpPackageConfiguration,
        ) -> Self {
            let mut v = self.http_package_configurations.unwrap_or_default();
            v.push(input);
            self.http_package_configurations = Some(v);
            self
        }
        /// <p>The HTTP package configurations for the VOD source.</p>
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.http_package_configurations = input;
            self
        }
        /// <p>The timestamp that indicates when the VOD source was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the VOD source was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The name of the source location that the VOD source is associated with.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location that the VOD source is associated with.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The name of the VOD source.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The name of the VOD source.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`VodSource`](crate::model::VodSource).
        pub fn build(self) -> crate::model::VodSource {
            crate::model::VodSource {
                arn: self.arn,
                creation_time: self.creation_time,
                http_package_configurations: self.http_package_configurations,
                last_modified_time: self.last_modified_time,
                source_location_name: self.source_location_name,
                tags: self.tags,
                vod_source_name: self.vod_source_name,
            }
        }
    }
}

/// <p>The HTTP package configuration properties for the requested VOD source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HttpPackageConfiguration {
    /// <p>The relative path to the URL for this VOD source. This is combined with <code>SourceLocation::HttpConfiguration::BaseUrl</code> to form a valid URL.</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::string::String>,
    /// <p>The name of the source group. This has to match one of the <code>Channel::Outputs::SourceGroup</code>.</p>
    #[doc(hidden)]
    pub source_group: std::option::Option<std::string::String>,
    /// <p>The streaming protocol for this package configuration. Supported values are <code>HLS</code> and <code>DASH</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::Type>,
}
impl HttpPackageConfiguration {
    /// <p>The relative path to the URL for this VOD source. This is combined with <code>SourceLocation::HttpConfiguration::BaseUrl</code> to form a valid URL.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>The name of the source group. This has to match one of the <code>Channel::Outputs::SourceGroup</code>.</p>
    pub fn source_group(&self) -> std::option::Option<&str> {
        self.source_group.as_deref()
    }
    /// <p>The streaming protocol for this package configuration. Supported values are <code>HLS</code> and <code>DASH</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::Type> {
        self.r#type.as_ref()
    }
}
impl HttpPackageConfiguration {
    /// Creates a new builder-style object to manufacture [`HttpPackageConfiguration`](crate::model::HttpPackageConfiguration).
    pub fn builder() -> crate::model::http_package_configuration::Builder {
        crate::model::http_package_configuration::Builder::default()
    }
}

/// See [`HttpPackageConfiguration`](crate::model::HttpPackageConfiguration).
pub mod http_package_configuration {

    /// A builder for [`HttpPackageConfiguration`](crate::model::HttpPackageConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) source_group: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::Type>,
    }
    impl Builder {
        /// <p>The relative path to the URL for this VOD source. This is combined with <code>SourceLocation::HttpConfiguration::BaseUrl</code> to form a valid URL.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The relative path to the URL for this VOD source. This is combined with <code>SourceLocation::HttpConfiguration::BaseUrl</code> to form a valid URL.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>The name of the source group. This has to match one of the <code>Channel::Outputs::SourceGroup</code>.</p>
        pub fn source_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_group = Some(input.into());
            self
        }
        /// <p>The name of the source group. This has to match one of the <code>Channel::Outputs::SourceGroup</code>.</p>
        pub fn set_source_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_group = input;
            self
        }
        /// <p>The streaming protocol for this package configuration. Supported values are <code>HLS</code> and <code>DASH</code>.</p>
        pub fn r#type(mut self, input: crate::model::Type) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The streaming protocol for this package configuration. Supported values are <code>HLS</code> and <code>DASH</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::Type>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`HttpPackageConfiguration`](crate::model::HttpPackageConfiguration).
        pub fn build(self) -> crate::model::HttpPackageConfiguration {
            crate::model::HttpPackageConfiguration {
                path: self.path,
                source_group: self.source_group,
                r#type: self.r#type,
            }
        }
    }
}

/// When writing a match expression against `Type`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let type = unimplemented!();
/// match type {
///     Type::Dash => { /* ... */ },
///     Type::Hls => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `type` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Type::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Type::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Type::NewFeature` is defined.
/// Specifically, when `type` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Type::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Type {
    #[allow(missing_docs)] // documentation missing in model
    Dash,
    #[allow(missing_docs)] // documentation missing in model
    Hls,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Type {
    fn from(s: &str) -> Self {
        match s {
            "DASH" => Type::Dash,
            "HLS" => Type::Hls,
            other => Type::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Type {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Type::from(s))
    }
}
impl Type {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Type::Dash => "DASH",
            Type::Hls => "HLS",
            Type::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DASH", "HLS"]
    }
}
impl AsRef<str> for Type {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A source location is a container for sources. For more information about source locations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-source-locations.html">Working with source locations</a> in the <i>MediaTailor User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceLocation {
    /// <p>The access configuration for the source location.</p>
    #[doc(hidden)]
    pub access_configuration: std::option::Option<crate::model::AccessConfiguration>,
    /// <p>The ARN of the SourceLocation.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates when the source location was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The default segment delivery configuration.</p>
    #[doc(hidden)]
    pub default_segment_delivery_configuration:
        std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
    /// <p>The HTTP configuration for the source location.</p>
    #[doc(hidden)]
    pub http_configuration: std::option::Option<crate::model::HttpConfiguration>,
    /// <p>The timestamp that indicates when the source location was last modified.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The segment delivery configurations for the source location.</p>
    #[doc(hidden)]
    pub segment_delivery_configurations:
        std::option::Option<std::vec::Vec<crate::model::SegmentDeliveryConfiguration>>,
    /// <p>The name of the source location.</p>
    #[doc(hidden)]
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl SourceLocation {
    /// <p>The access configuration for the source location.</p>
    pub fn access_configuration(&self) -> std::option::Option<&crate::model::AccessConfiguration> {
        self.access_configuration.as_ref()
    }
    /// <p>The ARN of the SourceLocation.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The timestamp that indicates when the source location was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The default segment delivery configuration.</p>
    pub fn default_segment_delivery_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DefaultSegmentDeliveryConfiguration> {
        self.default_segment_delivery_configuration.as_ref()
    }
    /// <p>The HTTP configuration for the source location.</p>
    pub fn http_configuration(&self) -> std::option::Option<&crate::model::HttpConfiguration> {
        self.http_configuration.as_ref()
    }
    /// <p>The timestamp that indicates when the source location was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The segment delivery configurations for the source location.</p>
    pub fn segment_delivery_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::SegmentDeliveryConfiguration]> {
        self.segment_delivery_configurations.as_deref()
    }
    /// <p>The name of the source location.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags assigned to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl SourceLocation {
    /// Creates a new builder-style object to manufacture [`SourceLocation`](crate::model::SourceLocation).
    pub fn builder() -> crate::model::source_location::Builder {
        crate::model::source_location::Builder::default()
    }
}

/// See [`SourceLocation`](crate::model::SourceLocation).
pub mod source_location {

    /// A builder for [`SourceLocation`](crate::model::SourceLocation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_configuration: std::option::Option<crate::model::AccessConfiguration>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) default_segment_delivery_configuration:
            std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        pub(crate) http_configuration: std::option::Option<crate::model::HttpConfiguration>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) segment_delivery_configurations:
            std::option::Option<std::vec::Vec<crate::model::SegmentDeliveryConfiguration>>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The access configuration for the source location.</p>
        pub fn access_configuration(mut self, input: crate::model::AccessConfiguration) -> Self {
            self.access_configuration = Some(input);
            self
        }
        /// <p>The access configuration for the source location.</p>
        pub fn set_access_configuration(
            mut self,
            input: std::option::Option<crate::model::AccessConfiguration>,
        ) -> Self {
            self.access_configuration = input;
            self
        }
        /// <p>The ARN of the SourceLocation.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the SourceLocation.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The timestamp that indicates when the source location was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the source location was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The default segment delivery configuration.</p>
        pub fn default_segment_delivery_configuration(
            mut self,
            input: crate::model::DefaultSegmentDeliveryConfiguration,
        ) -> Self {
            self.default_segment_delivery_configuration = Some(input);
            self
        }
        /// <p>The default segment delivery configuration.</p>
        pub fn set_default_segment_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        ) -> Self {
            self.default_segment_delivery_configuration = input;
            self
        }
        /// <p>The HTTP configuration for the source location.</p>
        pub fn http_configuration(mut self, input: crate::model::HttpConfiguration) -> Self {
            self.http_configuration = Some(input);
            self
        }
        /// <p>The HTTP configuration for the source location.</p>
        pub fn set_http_configuration(
            mut self,
            input: std::option::Option<crate::model::HttpConfiguration>,
        ) -> Self {
            self.http_configuration = input;
            self
        }
        /// <p>The timestamp that indicates when the source location was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the source location was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Appends an item to `segment_delivery_configurations`.
        ///
        /// To override the contents of this collection use [`set_segment_delivery_configurations`](Self::set_segment_delivery_configurations).
        ///
        /// <p>The segment delivery configurations for the source location.</p>
        pub fn segment_delivery_configurations(
            mut self,
            input: crate::model::SegmentDeliveryConfiguration,
        ) -> Self {
            let mut v = self.segment_delivery_configurations.unwrap_or_default();
            v.push(input);
            self.segment_delivery_configurations = Some(v);
            self
        }
        /// <p>The segment delivery configurations for the source location.</p>
        pub fn set_segment_delivery_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SegmentDeliveryConfiguration>>,
        ) -> Self {
            self.segment_delivery_configurations = input;
            self
        }
        /// <p>The name of the source location.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceLocation`](crate::model::SourceLocation).
        pub fn build(self) -> crate::model::SourceLocation {
            crate::model::SourceLocation {
                access_configuration: self.access_configuration,
                arn: self.arn,
                creation_time: self.creation_time,
                default_segment_delivery_configuration: self.default_segment_delivery_configuration,
                http_configuration: self.http_configuration,
                last_modified_time: self.last_modified_time,
                segment_delivery_configurations: self.segment_delivery_configurations,
                source_location_name: self.source_location_name,
                tags: self.tags,
            }
        }
    }
}

/// <p>The segment delivery configuration settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SegmentDeliveryConfiguration {
    /// <p>The base URL of the host or path of the segment delivery server that you're using to serve segments. This is typically a content delivery network (CDN). The URL can be absolute or relative. To use an absolute URL include the protocol, such as <code>https://example.com/some/path</code>. To use a relative URL specify the relative path, such as <code>/some/path*</code>.</p>
    #[doc(hidden)]
    pub base_url: std::option::Option<std::string::String>,
    /// <p>A unique identifier used to distinguish between multiple segment delivery configurations in a source location.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl SegmentDeliveryConfiguration {
    /// <p>The base URL of the host or path of the segment delivery server that you're using to serve segments. This is typically a content delivery network (CDN). The URL can be absolute or relative. To use an absolute URL include the protocol, such as <code>https://example.com/some/path</code>. To use a relative URL specify the relative path, such as <code>/some/path*</code>.</p>
    pub fn base_url(&self) -> std::option::Option<&str> {
        self.base_url.as_deref()
    }
    /// <p>A unique identifier used to distinguish between multiple segment delivery configurations in a source location.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl SegmentDeliveryConfiguration {
    /// Creates a new builder-style object to manufacture [`SegmentDeliveryConfiguration`](crate::model::SegmentDeliveryConfiguration).
    pub fn builder() -> crate::model::segment_delivery_configuration::Builder {
        crate::model::segment_delivery_configuration::Builder::default()
    }
}

/// See [`SegmentDeliveryConfiguration`](crate::model::SegmentDeliveryConfiguration).
pub mod segment_delivery_configuration {

    /// A builder for [`SegmentDeliveryConfiguration`](crate::model::SegmentDeliveryConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) base_url: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The base URL of the host or path of the segment delivery server that you're using to serve segments. This is typically a content delivery network (CDN). The URL can be absolute or relative. To use an absolute URL include the protocol, such as <code>https://example.com/some/path</code>. To use a relative URL specify the relative path, such as <code>/some/path*</code>.</p>
        pub fn base_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.base_url = Some(input.into());
            self
        }
        /// <p>The base URL of the host or path of the segment delivery server that you're using to serve segments. This is typically a content delivery network (CDN). The URL can be absolute or relative. To use an absolute URL include the protocol, such as <code>https://example.com/some/path</code>. To use a relative URL specify the relative path, such as <code>/some/path*</code>.</p>
        pub fn set_base_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.base_url = input;
            self
        }
        /// <p>A unique identifier used to distinguish between multiple segment delivery configurations in a source location.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A unique identifier used to distinguish between multiple segment delivery configurations in a source location.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`SegmentDeliveryConfiguration`](crate::model::SegmentDeliveryConfiguration).
        pub fn build(self) -> crate::model::SegmentDeliveryConfiguration {
            crate::model::SegmentDeliveryConfiguration {
                base_url: self.base_url,
                name: self.name,
            }
        }
    }
}

/// <p>The HTTP configuration for the source location.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HttpConfiguration {
    /// <p>The base URL for the source location host server. This string must include the protocol, such as <b>https://</b>.</p>
    #[doc(hidden)]
    pub base_url: std::option::Option<std::string::String>,
}
impl HttpConfiguration {
    /// <p>The base URL for the source location host server. This string must include the protocol, such as <b>https://</b>.</p>
    pub fn base_url(&self) -> std::option::Option<&str> {
        self.base_url.as_deref()
    }
}
impl HttpConfiguration {
    /// Creates a new builder-style object to manufacture [`HttpConfiguration`](crate::model::HttpConfiguration).
    pub fn builder() -> crate::model::http_configuration::Builder {
        crate::model::http_configuration::Builder::default()
    }
}

/// See [`HttpConfiguration`](crate::model::HttpConfiguration).
pub mod http_configuration {

    /// A builder for [`HttpConfiguration`](crate::model::HttpConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) base_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The base URL for the source location host server. This string must include the protocol, such as <b>https://</b>.</p>
        pub fn base_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.base_url = Some(input.into());
            self
        }
        /// <p>The base URL for the source location host server. This string must include the protocol, such as <b>https://</b>.</p>
        pub fn set_base_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.base_url = input;
            self
        }
        /// Consumes the builder and constructs a [`HttpConfiguration`](crate::model::HttpConfiguration).
        pub fn build(self) -> crate::model::HttpConfiguration {
            crate::model::HttpConfiguration {
                base_url: self.base_url,
            }
        }
    }
}

/// <p>The optional configuration for a server that serves segments. Use this if you want the segment delivery server to be different from the source location server. For example, you can configure your source location server to be an origination server, such as MediaPackage, and the segment delivery server to be a content delivery network (CDN), such as CloudFront. If you don't specify a segment delivery server, then the source location server is used.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultSegmentDeliveryConfiguration {
    /// <p>The hostname of the server that will be used to serve segments. This string must include the protocol, such as <b>https://</b>.</p>
    #[doc(hidden)]
    pub base_url: std::option::Option<std::string::String>,
}
impl DefaultSegmentDeliveryConfiguration {
    /// <p>The hostname of the server that will be used to serve segments. This string must include the protocol, such as <b>https://</b>.</p>
    pub fn base_url(&self) -> std::option::Option<&str> {
        self.base_url.as_deref()
    }
}
impl DefaultSegmentDeliveryConfiguration {
    /// Creates a new builder-style object to manufacture [`DefaultSegmentDeliveryConfiguration`](crate::model::DefaultSegmentDeliveryConfiguration).
    pub fn builder() -> crate::model::default_segment_delivery_configuration::Builder {
        crate::model::default_segment_delivery_configuration::Builder::default()
    }
}

/// See [`DefaultSegmentDeliveryConfiguration`](crate::model::DefaultSegmentDeliveryConfiguration).
pub mod default_segment_delivery_configuration {

    /// A builder for [`DefaultSegmentDeliveryConfiguration`](crate::model::DefaultSegmentDeliveryConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) base_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The hostname of the server that will be used to serve segments. This string must include the protocol, such as <b>https://</b>.</p>
        pub fn base_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.base_url = Some(input.into());
            self
        }
        /// <p>The hostname of the server that will be used to serve segments. This string must include the protocol, such as <b>https://</b>.</p>
        pub fn set_base_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.base_url = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultSegmentDeliveryConfiguration`](crate::model::DefaultSegmentDeliveryConfiguration).
        pub fn build(self) -> crate::model::DefaultSegmentDeliveryConfiguration {
            crate::model::DefaultSegmentDeliveryConfiguration {
                base_url: self.base_url,
            }
        }
    }
}

/// <p>Access configuration parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessConfiguration {
    /// <p>The type of authentication used to access content from <code>HttpConfiguration::BaseUrl</code> on your source location. Accepted value: <code>S3_SIGV4</code>.</p>
    /// <p> <code>S3_SIGV4</code> - AWS Signature Version 4 authentication for Amazon S3 hosted virtual-style access. If your source location base URL is an Amazon S3 bucket, MediaTailor can use AWS Signature Version 4 (SigV4) authentication to access the bucket where your source content is stored. Your MediaTailor source location baseURL must follow the S3 virtual hosted-style request URL format. For example, https://bucket-name.s3.Region.amazonaws.com/key-name.</p>
    /// <p>Before you can use <code>S3_SIGV4</code>, you must meet these requirements:</p>
    /// <p>• You must allow MediaTailor to access your S3 bucket by granting mediatailor.amazonaws.com principal access in IAM. For information about configuring access in IAM, see Access management in the IAM User Guide.</p>
    /// <p>• The mediatailor.amazonaws.com service principal must have permissions to read all top level manifests referenced by the VodSource packaging configurations.</p>
    /// <p>• The caller of the API must have s3:GetObject IAM permissions to read all top level manifests referenced by your MediaTailor VodSource packaging configurations.</p>
    #[doc(hidden)]
    pub access_type: std::option::Option<crate::model::AccessType>,
    /// <p>AWS Secrets Manager access token configuration parameters.</p>
    #[doc(hidden)]
    pub secrets_manager_access_token_configuration:
        std::option::Option<crate::model::SecretsManagerAccessTokenConfiguration>,
}
impl AccessConfiguration {
    /// <p>The type of authentication used to access content from <code>HttpConfiguration::BaseUrl</code> on your source location. Accepted value: <code>S3_SIGV4</code>.</p>
    /// <p> <code>S3_SIGV4</code> - AWS Signature Version 4 authentication for Amazon S3 hosted virtual-style access. If your source location base URL is an Amazon S3 bucket, MediaTailor can use AWS Signature Version 4 (SigV4) authentication to access the bucket where your source content is stored. Your MediaTailor source location baseURL must follow the S3 virtual hosted-style request URL format. For example, https://bucket-name.s3.Region.amazonaws.com/key-name.</p>
    /// <p>Before you can use <code>S3_SIGV4</code>, you must meet these requirements:</p>
    /// <p>• You must allow MediaTailor to access your S3 bucket by granting mediatailor.amazonaws.com principal access in IAM. For information about configuring access in IAM, see Access management in the IAM User Guide.</p>
    /// <p>• The mediatailor.amazonaws.com service principal must have permissions to read all top level manifests referenced by the VodSource packaging configurations.</p>
    /// <p>• The caller of the API must have s3:GetObject IAM permissions to read all top level manifests referenced by your MediaTailor VodSource packaging configurations.</p>
    pub fn access_type(&self) -> std::option::Option<&crate::model::AccessType> {
        self.access_type.as_ref()
    }
    /// <p>AWS Secrets Manager access token configuration parameters.</p>
    pub fn secrets_manager_access_token_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SecretsManagerAccessTokenConfiguration> {
        self.secrets_manager_access_token_configuration.as_ref()
    }
}
impl AccessConfiguration {
    /// Creates a new builder-style object to manufacture [`AccessConfiguration`](crate::model::AccessConfiguration).
    pub fn builder() -> crate::model::access_configuration::Builder {
        crate::model::access_configuration::Builder::default()
    }
}

/// See [`AccessConfiguration`](crate::model::AccessConfiguration).
pub mod access_configuration {

    /// A builder for [`AccessConfiguration`](crate::model::AccessConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_type: std::option::Option<crate::model::AccessType>,
        pub(crate) secrets_manager_access_token_configuration:
            std::option::Option<crate::model::SecretsManagerAccessTokenConfiguration>,
    }
    impl Builder {
        /// <p>The type of authentication used to access content from <code>HttpConfiguration::BaseUrl</code> on your source location. Accepted value: <code>S3_SIGV4</code>.</p>
        /// <p> <code>S3_SIGV4</code> - AWS Signature Version 4 authentication for Amazon S3 hosted virtual-style access. If your source location base URL is an Amazon S3 bucket, MediaTailor can use AWS Signature Version 4 (SigV4) authentication to access the bucket where your source content is stored. Your MediaTailor source location baseURL must follow the S3 virtual hosted-style request URL format. For example, https://bucket-name.s3.Region.amazonaws.com/key-name.</p>
        /// <p>Before you can use <code>S3_SIGV4</code>, you must meet these requirements:</p>
        /// <p>• You must allow MediaTailor to access your S3 bucket by granting mediatailor.amazonaws.com principal access in IAM. For information about configuring access in IAM, see Access management in the IAM User Guide.</p>
        /// <p>• The mediatailor.amazonaws.com service principal must have permissions to read all top level manifests referenced by the VodSource packaging configurations.</p>
        /// <p>• The caller of the API must have s3:GetObject IAM permissions to read all top level manifests referenced by your MediaTailor VodSource packaging configurations.</p>
        pub fn access_type(mut self, input: crate::model::AccessType) -> Self {
            self.access_type = Some(input);
            self
        }
        /// <p>The type of authentication used to access content from <code>HttpConfiguration::BaseUrl</code> on your source location. Accepted value: <code>S3_SIGV4</code>.</p>
        /// <p> <code>S3_SIGV4</code> - AWS Signature Version 4 authentication for Amazon S3 hosted virtual-style access. If your source location base URL is an Amazon S3 bucket, MediaTailor can use AWS Signature Version 4 (SigV4) authentication to access the bucket where your source content is stored. Your MediaTailor source location baseURL must follow the S3 virtual hosted-style request URL format. For example, https://bucket-name.s3.Region.amazonaws.com/key-name.</p>
        /// <p>Before you can use <code>S3_SIGV4</code>, you must meet these requirements:</p>
        /// <p>• You must allow MediaTailor to access your S3 bucket by granting mediatailor.amazonaws.com principal access in IAM. For information about configuring access in IAM, see Access management in the IAM User Guide.</p>
        /// <p>• The mediatailor.amazonaws.com service principal must have permissions to read all top level manifests referenced by the VodSource packaging configurations.</p>
        /// <p>• The caller of the API must have s3:GetObject IAM permissions to read all top level manifests referenced by your MediaTailor VodSource packaging configurations.</p>
        pub fn set_access_type(
            mut self,
            input: std::option::Option<crate::model::AccessType>,
        ) -> Self {
            self.access_type = input;
            self
        }
        /// <p>AWS Secrets Manager access token configuration parameters.</p>
        pub fn secrets_manager_access_token_configuration(
            mut self,
            input: crate::model::SecretsManagerAccessTokenConfiguration,
        ) -> Self {
            self.secrets_manager_access_token_configuration = Some(input);
            self
        }
        /// <p>AWS Secrets Manager access token configuration parameters.</p>
        pub fn set_secrets_manager_access_token_configuration(
            mut self,
            input: std::option::Option<crate::model::SecretsManagerAccessTokenConfiguration>,
        ) -> Self {
            self.secrets_manager_access_token_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessConfiguration`](crate::model::AccessConfiguration).
        pub fn build(self) -> crate::model::AccessConfiguration {
            crate::model::AccessConfiguration {
                access_type: self.access_type,
                secrets_manager_access_token_configuration: self
                    .secrets_manager_access_token_configuration,
            }
        }
    }
}

/// <p>AWS Secrets Manager access token configuration parameters. For information about Secrets Manager access token authentication, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-access-configuration-access-token.html">Working with AWS Secrets Manager access token authentication</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SecretsManagerAccessTokenConfiguration {
    /// <p>The name of the HTTP header used to supply the access token in requests to the source location.</p>
    #[doc(hidden)]
    pub header_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the access token.</p>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p>The AWS Secrets Manager <a href="https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html#SecretsManager-CreateSecret-request-SecretString.html">SecretString</a> key associated with the access token. MediaTailor uses the key to look up SecretString key and value pair containing the access token.</p>
    #[doc(hidden)]
    pub secret_string_key: std::option::Option<std::string::String>,
}
impl SecretsManagerAccessTokenConfiguration {
    /// <p>The name of the HTTP header used to supply the access token in requests to the source location.</p>
    pub fn header_name(&self) -> std::option::Option<&str> {
        self.header_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the access token.</p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p>The AWS Secrets Manager <a href="https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html#SecretsManager-CreateSecret-request-SecretString.html">SecretString</a> key associated with the access token. MediaTailor uses the key to look up SecretString key and value pair containing the access token.</p>
    pub fn secret_string_key(&self) -> std::option::Option<&str> {
        self.secret_string_key.as_deref()
    }
}
impl SecretsManagerAccessTokenConfiguration {
    /// Creates a new builder-style object to manufacture [`SecretsManagerAccessTokenConfiguration`](crate::model::SecretsManagerAccessTokenConfiguration).
    pub fn builder() -> crate::model::secrets_manager_access_token_configuration::Builder {
        crate::model::secrets_manager_access_token_configuration::Builder::default()
    }
}

/// See [`SecretsManagerAccessTokenConfiguration`](crate::model::SecretsManagerAccessTokenConfiguration).
pub mod secrets_manager_access_token_configuration {

    /// A builder for [`SecretsManagerAccessTokenConfiguration`](crate::model::SecretsManagerAccessTokenConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) header_name: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) secret_string_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the HTTP header used to supply the access token in requests to the source location.</p>
        pub fn header_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.header_name = Some(input.into());
            self
        }
        /// <p>The name of the HTTP header used to supply the access token in requests to the source location.</p>
        pub fn set_header_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.header_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the access token.</p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the access token.</p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// <p>The AWS Secrets Manager <a href="https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html#SecretsManager-CreateSecret-request-SecretString.html">SecretString</a> key associated with the access token. MediaTailor uses the key to look up SecretString key and value pair containing the access token.</p>
        pub fn secret_string_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_string_key = Some(input.into());
            self
        }
        /// <p>The AWS Secrets Manager <a href="https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html#SecretsManager-CreateSecret-request-SecretString.html">SecretString</a> key associated with the access token. MediaTailor uses the key to look up SecretString key and value pair containing the access token.</p>
        pub fn set_secret_string_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.secret_string_key = input;
            self
        }
        /// Consumes the builder and constructs a [`SecretsManagerAccessTokenConfiguration`](crate::model::SecretsManagerAccessTokenConfiguration).
        pub fn build(self) -> crate::model::SecretsManagerAccessTokenConfiguration {
            crate::model::SecretsManagerAccessTokenConfiguration {
                header_name: self.header_name,
                secret_arn: self.secret_arn,
                secret_string_key: self.secret_string_key,
            }
        }
    }
}

/// When writing a match expression against `AccessType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let accesstype = unimplemented!();
/// match accesstype {
///     AccessType::S3Sigv4 => { /* ... */ },
///     AccessType::SecretsManagerAccessToken => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `accesstype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AccessType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AccessType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AccessType::NewFeature` is defined.
/// Specifically, when `accesstype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AccessType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AccessType {
    #[allow(missing_docs)] // documentation missing in model
    S3Sigv4,
    #[allow(missing_docs)] // documentation missing in model
    SecretsManagerAccessToken,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AccessType {
    fn from(s: &str) -> Self {
        match s {
            "S3_SIGV4" => AccessType::S3Sigv4,
            "SECRETS_MANAGER_ACCESS_TOKEN" => AccessType::SecretsManagerAccessToken,
            other => AccessType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AccessType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AccessType::from(s))
    }
}
impl AccessType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AccessType::S3Sigv4 => "S3_SIGV4",
            AccessType::SecretsManagerAccessToken => "SECRETS_MANAGER_ACCESS_TOKEN",
            AccessType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["S3_SIGV4", "SECRETS_MANAGER_ACCESS_TOKEN"]
    }
}
impl AsRef<str> for AccessType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A prefetch schedule allows you to tell MediaTailor to fetch and prepare certain ads before an ad break happens. For more information about ad prefetching, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/prefetching-ads.html">Using ad prefetching</a> in the <i>MediaTailor User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PrefetchSchedule {
    /// <p>The Amazon Resource Name (ARN) of the prefetch schedule.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a <i>consumption window</i>. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.</p>
    #[doc(hidden)]
    pub consumption: std::option::Option<crate::model::PrefetchConsumption>,
    /// <p>The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the playback configuration to create the prefetch schedule for.</p>
    #[doc(hidden)]
    pub playback_configuration_name: std::option::Option<std::string::String>,
    /// <p>A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).</p>
    #[doc(hidden)]
    pub retrieval: std::option::Option<crate::model::PrefetchRetrieval>,
    /// <p>An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.</p>
    #[doc(hidden)]
    pub stream_id: std::option::Option<std::string::String>,
}
impl PrefetchSchedule {
    /// <p>The Amazon Resource Name (ARN) of the prefetch schedule.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a <i>consumption window</i>. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.</p>
    pub fn consumption(&self) -> std::option::Option<&crate::model::PrefetchConsumption> {
        self.consumption.as_ref()
    }
    /// <p>The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the playback configuration to create the prefetch schedule for.</p>
    pub fn playback_configuration_name(&self) -> std::option::Option<&str> {
        self.playback_configuration_name.as_deref()
    }
    /// <p>A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).</p>
    pub fn retrieval(&self) -> std::option::Option<&crate::model::PrefetchRetrieval> {
        self.retrieval.as_ref()
    }
    /// <p>An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
}
impl PrefetchSchedule {
    /// Creates a new builder-style object to manufacture [`PrefetchSchedule`](crate::model::PrefetchSchedule).
    pub fn builder() -> crate::model::prefetch_schedule::Builder {
        crate::model::prefetch_schedule::Builder::default()
    }
}

/// See [`PrefetchSchedule`](crate::model::PrefetchSchedule).
pub mod prefetch_schedule {

    /// A builder for [`PrefetchSchedule`](crate::model::PrefetchSchedule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) consumption: std::option::Option<crate::model::PrefetchConsumption>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) playback_configuration_name: std::option::Option<std::string::String>,
        pub(crate) retrieval: std::option::Option<crate::model::PrefetchRetrieval>,
        pub(crate) stream_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the prefetch schedule.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the prefetch schedule.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a <i>consumption window</i>. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.</p>
        pub fn consumption(mut self, input: crate::model::PrefetchConsumption) -> Self {
            self.consumption = Some(input);
            self
        }
        /// <p>Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a <i>consumption window</i>. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.</p>
        pub fn set_consumption(
            mut self,
            input: std::option::Option<crate::model::PrefetchConsumption>,
        ) -> Self {
            self.consumption = input;
            self
        }
        /// <p>The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the playback configuration to create the prefetch schedule for.</p>
        pub fn playback_configuration_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the playback configuration to create the prefetch schedule for.</p>
        pub fn set_playback_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = input;
            self
        }
        /// <p>A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).</p>
        pub fn retrieval(mut self, input: crate::model::PrefetchRetrieval) -> Self {
            self.retrieval = Some(input);
            self
        }
        /// <p>A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).</p>
        pub fn set_retrieval(
            mut self,
            input: std::option::Option<crate::model::PrefetchRetrieval>,
        ) -> Self {
            self.retrieval = input;
            self
        }
        /// <p>An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PrefetchSchedule`](crate::model::PrefetchSchedule).
        pub fn build(self) -> crate::model::PrefetchSchedule {
            crate::model::PrefetchSchedule {
                arn: self.arn,
                consumption: self.consumption,
                name: self.name,
                playback_configuration_name: self.playback_configuration_name,
                retrieval: self.retrieval,
                stream_id: self.stream_id,
            }
        }
    }
}

/// <p>A complex type that contains settings governing when MediaTailor prefetches ads, and which dynamic variables that MediaTailor includes in the request to the ad decision server.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PrefetchRetrieval {
    /// <p>The dynamic variables to use for substitution during prefetch requests to the ad decision server (ADS).</p>
    /// <p>You initially configure <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables.html">dynamic variables</a> for the ADS URL when you set up your playback configuration. When you specify <code>DynamicVariables</code> for prefetch retrieval, MediaTailor includes the dynamic variables in the request to the ADS.</p>
    #[doc(hidden)]
    pub dynamic_variables:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The time when prefetch retrieval ends for the ad break. Prefetching will be attempted for manifest requests that occur at or before this time.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when prefetch retrievals can start for this break. Ad prefetching will be attempted for manifest requests that occur at or after this time. Defaults to the current time. If not specified, the prefetch retrieval starts as soon as possible.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl PrefetchRetrieval {
    /// <p>The dynamic variables to use for substitution during prefetch requests to the ad decision server (ADS).</p>
    /// <p>You initially configure <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables.html">dynamic variables</a> for the ADS URL when you set up your playback configuration. When you specify <code>DynamicVariables</code> for prefetch retrieval, MediaTailor includes the dynamic variables in the request to the ADS.</p>
    pub fn dynamic_variables(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.dynamic_variables.as_ref()
    }
    /// <p>The time when prefetch retrieval ends for the ad break. Prefetching will be attempted for manifest requests that occur at or before this time.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The time when prefetch retrievals can start for this break. Ad prefetching will be attempted for manifest requests that occur at or after this time. Defaults to the current time. If not specified, the prefetch retrieval starts as soon as possible.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
}
impl PrefetchRetrieval {
    /// Creates a new builder-style object to manufacture [`PrefetchRetrieval`](crate::model::PrefetchRetrieval).
    pub fn builder() -> crate::model::prefetch_retrieval::Builder {
        crate::model::prefetch_retrieval::Builder::default()
    }
}

/// See [`PrefetchRetrieval`](crate::model::PrefetchRetrieval).
pub mod prefetch_retrieval {

    /// A builder for [`PrefetchRetrieval`](crate::model::PrefetchRetrieval).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dynamic_variables: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// Adds a key-value pair to `dynamic_variables`.
        ///
        /// To override the contents of this collection use [`set_dynamic_variables`](Self::set_dynamic_variables).
        ///
        /// <p>The dynamic variables to use for substitution during prefetch requests to the ad decision server (ADS).</p>
        /// <p>You initially configure <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables.html">dynamic variables</a> for the ADS URL when you set up your playback configuration. When you specify <code>DynamicVariables</code> for prefetch retrieval, MediaTailor includes the dynamic variables in the request to the ADS.</p>
        pub fn dynamic_variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.dynamic_variables.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.dynamic_variables = Some(hash_map);
            self
        }
        /// <p>The dynamic variables to use for substitution during prefetch requests to the ad decision server (ADS).</p>
        /// <p>You initially configure <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables.html">dynamic variables</a> for the ADS URL when you set up your playback configuration. When you specify <code>DynamicVariables</code> for prefetch retrieval, MediaTailor includes the dynamic variables in the request to the ADS.</p>
        pub fn set_dynamic_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.dynamic_variables = input;
            self
        }
        /// <p>The time when prefetch retrieval ends for the ad break. Prefetching will be attempted for manifest requests that occur at or before this time.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time when prefetch retrieval ends for the ad break. Prefetching will be attempted for manifest requests that occur at or before this time.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The time when prefetch retrievals can start for this break. Ad prefetching will be attempted for manifest requests that occur at or after this time. Defaults to the current time. If not specified, the prefetch retrieval starts as soon as possible.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time when prefetch retrievals can start for this break. Ad prefetching will be attempted for manifest requests that occur at or after this time. Defaults to the current time. If not specified, the prefetch retrieval starts as soon as possible.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PrefetchRetrieval`](crate::model::PrefetchRetrieval).
        pub fn build(self) -> crate::model::PrefetchRetrieval {
            crate::model::PrefetchRetrieval {
                dynamic_variables: self.dynamic_variables,
                end_time: self.end_time,
                start_time: self.start_time,
            }
        }
    }
}

/// <p>A complex type that contains settings that determine how and when that MediaTailor places prefetched ads into upcoming ad breaks.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PrefetchConsumption {
    /// <p>If you only want MediaTailor to insert prefetched ads into avails (ad breaks) that match specific dynamic variables, such as <code>scte.event_id</code>, set the avail matching criteria.</p>
    #[doc(hidden)]
    pub avail_matching_criteria:
        std::option::Option<std::vec::Vec<crate::model::AvailMatchingCriteria>>,
    /// <p>The time when MediaTailor no longer considers the prefetched ads for use in an ad break. MediaTailor automatically deletes prefetch schedules no less than seven days after the end time. If you'd like to manually delete the prefetch schedule, you can call <code>DeletePrefetchSchedule</code>.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when prefetched ads are considered for use in an ad break. If you don't specify <code>StartTime</code>, the prefetched ads are available after MediaTailor retrives them from the ad decision server.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl PrefetchConsumption {
    /// <p>If you only want MediaTailor to insert prefetched ads into avails (ad breaks) that match specific dynamic variables, such as <code>scte.event_id</code>, set the avail matching criteria.</p>
    pub fn avail_matching_criteria(
        &self,
    ) -> std::option::Option<&[crate::model::AvailMatchingCriteria]> {
        self.avail_matching_criteria.as_deref()
    }
    /// <p>The time when MediaTailor no longer considers the prefetched ads for use in an ad break. MediaTailor automatically deletes prefetch schedules no less than seven days after the end time. If you'd like to manually delete the prefetch schedule, you can call <code>DeletePrefetchSchedule</code>.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The time when prefetched ads are considered for use in an ad break. If you don't specify <code>StartTime</code>, the prefetched ads are available after MediaTailor retrives them from the ad decision server.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
}
impl PrefetchConsumption {
    /// Creates a new builder-style object to manufacture [`PrefetchConsumption`](crate::model::PrefetchConsumption).
    pub fn builder() -> crate::model::prefetch_consumption::Builder {
        crate::model::prefetch_consumption::Builder::default()
    }
}

/// See [`PrefetchConsumption`](crate::model::PrefetchConsumption).
pub mod prefetch_consumption {

    /// A builder for [`PrefetchConsumption`](crate::model::PrefetchConsumption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) avail_matching_criteria:
            std::option::Option<std::vec::Vec<crate::model::AvailMatchingCriteria>>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// Appends an item to `avail_matching_criteria`.
        ///
        /// To override the contents of this collection use [`set_avail_matching_criteria`](Self::set_avail_matching_criteria).
        ///
        /// <p>If you only want MediaTailor to insert prefetched ads into avails (ad breaks) that match specific dynamic variables, such as <code>scte.event_id</code>, set the avail matching criteria.</p>
        pub fn avail_matching_criteria(
            mut self,
            input: crate::model::AvailMatchingCriteria,
        ) -> Self {
            let mut v = self.avail_matching_criteria.unwrap_or_default();
            v.push(input);
            self.avail_matching_criteria = Some(v);
            self
        }
        /// <p>If you only want MediaTailor to insert prefetched ads into avails (ad breaks) that match specific dynamic variables, such as <code>scte.event_id</code>, set the avail matching criteria.</p>
        pub fn set_avail_matching_criteria(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AvailMatchingCriteria>>,
        ) -> Self {
            self.avail_matching_criteria = input;
            self
        }
        /// <p>The time when MediaTailor no longer considers the prefetched ads for use in an ad break. MediaTailor automatically deletes prefetch schedules no less than seven days after the end time. If you'd like to manually delete the prefetch schedule, you can call <code>DeletePrefetchSchedule</code>.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time when MediaTailor no longer considers the prefetched ads for use in an ad break. MediaTailor automatically deletes prefetch schedules no less than seven days after the end time. If you'd like to manually delete the prefetch schedule, you can call <code>DeletePrefetchSchedule</code>.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The time when prefetched ads are considered for use in an ad break. If you don't specify <code>StartTime</code>, the prefetched ads are available after MediaTailor retrives them from the ad decision server.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time when prefetched ads are considered for use in an ad break. If you don't specify <code>StartTime</code>, the prefetched ads are available after MediaTailor retrives them from the ad decision server.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PrefetchConsumption`](crate::model::PrefetchConsumption).
        pub fn build(self) -> crate::model::PrefetchConsumption {
            crate::model::PrefetchConsumption {
                avail_matching_criteria: self.avail_matching_criteria,
                end_time: self.end_time,
                start_time: self.start_time,
            }
        }
    }
}

/// <p>MediaTailor only places (consumes) prefetched ads if the ad break meets the criteria defined by the dynamic variables. This gives you granular control over which ad break to place the prefetched ads into.</p>
/// <p>As an example, let's say that you set <code>DynamicVariable</code> to <code>scte.event_id</code> and <code>Operator</code> to <code>EQUALS</code>, and your playback configuration has an ADS URL of <code>https://my.ads.server.com/path?&amp;podId=[scte.avail_num]&amp;event=[scte.event_id]&amp;duration=[session.avail_duration_secs]</code>. And the prefetch request to the ADS contains these values <code>https://my.ads.server.com/path?&amp;podId=3&amp;event=my-awesome-event&amp;duration=30</code>. MediaTailor will only insert the prefetched ads into the ad break if has a SCTE marker with an event id of <code>my-awesome-event</code>, since it must match the event id that MediaTailor uses to query the ADS.</p>
/// <p>You can specify up to five <code>AvailMatchingCriteria</code>. If you specify multiple <code>AvailMatchingCriteria</code>, MediaTailor combines them to match using a logical <code>AND</code>. You can model logical <code>OR</code> combinations by creating multiple prefetch schedules.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AvailMatchingCriteria {
    /// <p>The dynamic variable(s) that MediaTailor should use as avail matching criteria. MediaTailor only places the prefetched ads into the avail if the avail matches the criteria defined by the dynamic variable. For information about dynamic variables, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables.html">Using dynamic ad variables</a> in the <i>MediaTailor User Guide</i>.</p>
    /// <p>You can include up to 100 dynamic variables.</p>
    #[doc(hidden)]
    pub dynamic_variable: std::option::Option<std::string::String>,
    /// <p>For the <code>DynamicVariable</code> specified in <code>AvailMatchingCriteria</code>, the Operator that is used for the comparison.</p>
    #[doc(hidden)]
    pub operator: std::option::Option<crate::model::Operator>,
}
impl AvailMatchingCriteria {
    /// <p>The dynamic variable(s) that MediaTailor should use as avail matching criteria. MediaTailor only places the prefetched ads into the avail if the avail matches the criteria defined by the dynamic variable. For information about dynamic variables, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables.html">Using dynamic ad variables</a> in the <i>MediaTailor User Guide</i>.</p>
    /// <p>You can include up to 100 dynamic variables.</p>
    pub fn dynamic_variable(&self) -> std::option::Option<&str> {
        self.dynamic_variable.as_deref()
    }
    /// <p>For the <code>DynamicVariable</code> specified in <code>AvailMatchingCriteria</code>, the Operator that is used for the comparison.</p>
    pub fn operator(&self) -> std::option::Option<&crate::model::Operator> {
        self.operator.as_ref()
    }
}
impl AvailMatchingCriteria {
    /// Creates a new builder-style object to manufacture [`AvailMatchingCriteria`](crate::model::AvailMatchingCriteria).
    pub fn builder() -> crate::model::avail_matching_criteria::Builder {
        crate::model::avail_matching_criteria::Builder::default()
    }
}

/// See [`AvailMatchingCriteria`](crate::model::AvailMatchingCriteria).
pub mod avail_matching_criteria {

    /// A builder for [`AvailMatchingCriteria`](crate::model::AvailMatchingCriteria).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dynamic_variable: std::option::Option<std::string::String>,
        pub(crate) operator: std::option::Option<crate::model::Operator>,
    }
    impl Builder {
        /// <p>The dynamic variable(s) that MediaTailor should use as avail matching criteria. MediaTailor only places the prefetched ads into the avail if the avail matches the criteria defined by the dynamic variable. For information about dynamic variables, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables.html">Using dynamic ad variables</a> in the <i>MediaTailor User Guide</i>.</p>
        /// <p>You can include up to 100 dynamic variables.</p>
        pub fn dynamic_variable(mut self, input: impl Into<std::string::String>) -> Self {
            self.dynamic_variable = Some(input.into());
            self
        }
        /// <p>The dynamic variable(s) that MediaTailor should use as avail matching criteria. MediaTailor only places the prefetched ads into the avail if the avail matches the criteria defined by the dynamic variable. For information about dynamic variables, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables.html">Using dynamic ad variables</a> in the <i>MediaTailor User Guide</i>.</p>
        /// <p>You can include up to 100 dynamic variables.</p>
        pub fn set_dynamic_variable(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dynamic_variable = input;
            self
        }
        /// <p>For the <code>DynamicVariable</code> specified in <code>AvailMatchingCriteria</code>, the Operator that is used for the comparison.</p>
        pub fn operator(mut self, input: crate::model::Operator) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>For the <code>DynamicVariable</code> specified in <code>AvailMatchingCriteria</code>, the Operator that is used for the comparison.</p>
        pub fn set_operator(mut self, input: std::option::Option<crate::model::Operator>) -> Self {
            self.operator = input;
            self
        }
        /// Consumes the builder and constructs a [`AvailMatchingCriteria`](crate::model::AvailMatchingCriteria).
        pub fn build(self) -> crate::model::AvailMatchingCriteria {
            crate::model::AvailMatchingCriteria {
                dynamic_variable: self.dynamic_variable,
                operator: self.operator,
            }
        }
    }
}

/// When writing a match expression against `Operator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let operator = unimplemented!();
/// match operator {
///     Operator::Equals => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `operator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Operator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Operator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Operator::NewFeature` is defined.
/// Specifically, when `operator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Operator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Operator {
    #[allow(missing_docs)] // documentation missing in model
    Equals,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Operator {
    fn from(s: &str) -> Self {
        match s {
            "EQUALS" => Operator::Equals,
            other => Operator::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Operator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Operator::from(s))
    }
}
impl Operator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Operator::Equals => "EQUALS",
            Operator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EQUALS"]
    }
}
impl AsRef<str> for Operator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A playback configuration. For information about MediaTailor configurations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html">Working with configurations in AWS Elemental MediaTailor</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PlaybackConfiguration {
    /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    #[doc(hidden)]
    pub ad_decision_server_url: std::option::Option<std::string::String>,
    /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
    #[doc(hidden)]
    pub avail_suppression: std::option::Option<crate::model::AvailSuppression>,
    /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
    #[doc(hidden)]
    pub bumper: std::option::Option<crate::model::Bumper>,
    /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
    #[doc(hidden)]
    pub cdn_configuration: std::option::Option<crate::model::CdnConfiguration>,
    /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
    #[doc(hidden)]
    pub configuration_aliases: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    >,
    /// <p>The configuration for a DASH source.</p>
    #[doc(hidden)]
    pub dash_configuration: std::option::Option<crate::model::DashConfiguration>,
    /// <p>The configuration for HLS content.</p>
    #[doc(hidden)]
    pub hls_configuration: std::option::Option<crate::model::HlsConfiguration>,
    /// <p>The configuration for pre-roll ad insertion.</p>
    #[doc(hidden)]
    pub live_pre_roll_configuration: std::option::Option<crate::model::LivePreRollConfiguration>,
    /// <p>The Amazon CloudWatch log settings for a playback configuration.</p>
    #[doc(hidden)]
    pub log_configuration: std::option::Option<crate::model::LogConfiguration>,
    /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
    #[doc(hidden)]
    pub manifest_processing_rules: std::option::Option<crate::model::ManifestProcessingRules>,
    /// <p>The identifier for the playback configuration.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
    #[doc(hidden)]
    pub personalization_threshold_seconds: i32,
    /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
    #[doc(hidden)]
    pub playback_configuration_arn: std::option::Option<std::string::String>,
    /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor.</p>
    #[doc(hidden)]
    pub playback_endpoint_prefix: std::option::Option<std::string::String>,
    /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
    #[doc(hidden)]
    pub session_initialization_endpoint_prefix: std::option::Option<std::string::String>,
    /// <p>The URL for a video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
    #[doc(hidden)]
    pub slate_ad_url: std::option::Option<std::string::String>,
    /// <p>The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
    #[doc(hidden)]
    pub transcode_profile_name: std::option::Option<std::string::String>,
    /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
    #[doc(hidden)]
    pub video_content_source_url: std::option::Option<std::string::String>,
}
impl PlaybackConfiguration {
    /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    pub fn ad_decision_server_url(&self) -> std::option::Option<&str> {
        self.ad_decision_server_url.as_deref()
    }
    /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
    pub fn avail_suppression(&self) -> std::option::Option<&crate::model::AvailSuppression> {
        self.avail_suppression.as_ref()
    }
    /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
    pub fn bumper(&self) -> std::option::Option<&crate::model::Bumper> {
        self.bumper.as_ref()
    }
    /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
    pub fn cdn_configuration(&self) -> std::option::Option<&crate::model::CdnConfiguration> {
        self.cdn_configuration.as_ref()
    }
    /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
    pub fn configuration_aliases(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    > {
        self.configuration_aliases.as_ref()
    }
    /// <p>The configuration for a DASH source.</p>
    pub fn dash_configuration(&self) -> std::option::Option<&crate::model::DashConfiguration> {
        self.dash_configuration.as_ref()
    }
    /// <p>The configuration for HLS content.</p>
    pub fn hls_configuration(&self) -> std::option::Option<&crate::model::HlsConfiguration> {
        self.hls_configuration.as_ref()
    }
    /// <p>The configuration for pre-roll ad insertion.</p>
    pub fn live_pre_roll_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LivePreRollConfiguration> {
        self.live_pre_roll_configuration.as_ref()
    }
    /// <p>The Amazon CloudWatch log settings for a playback configuration.</p>
    pub fn log_configuration(&self) -> std::option::Option<&crate::model::LogConfiguration> {
        self.log_configuration.as_ref()
    }
    /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
    pub fn manifest_processing_rules(
        &self,
    ) -> std::option::Option<&crate::model::ManifestProcessingRules> {
        self.manifest_processing_rules.as_ref()
    }
    /// <p>The identifier for the playback configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
    pub fn personalization_threshold_seconds(&self) -> i32 {
        self.personalization_threshold_seconds
    }
    /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
    pub fn playback_configuration_arn(&self) -> std::option::Option<&str> {
        self.playback_configuration_arn.as_deref()
    }
    /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor.</p>
    pub fn playback_endpoint_prefix(&self) -> std::option::Option<&str> {
        self.playback_endpoint_prefix.as_deref()
    }
    /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
    pub fn session_initialization_endpoint_prefix(&self) -> std::option::Option<&str> {
        self.session_initialization_endpoint_prefix.as_deref()
    }
    /// <p>The URL for a video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
    pub fn slate_ad_url(&self) -> std::option::Option<&str> {
        self.slate_ad_url.as_deref()
    }
    /// <p>The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
    pub fn transcode_profile_name(&self) -> std::option::Option<&str> {
        self.transcode_profile_name.as_deref()
    }
    /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
    pub fn video_content_source_url(&self) -> std::option::Option<&str> {
        self.video_content_source_url.as_deref()
    }
}
impl PlaybackConfiguration {
    /// Creates a new builder-style object to manufacture [`PlaybackConfiguration`](crate::model::PlaybackConfiguration).
    pub fn builder() -> crate::model::playback_configuration::Builder {
        crate::model::playback_configuration::Builder::default()
    }
}

/// See [`PlaybackConfiguration`](crate::model::PlaybackConfiguration).
pub mod playback_configuration {

    /// A builder for [`PlaybackConfiguration`](crate::model::PlaybackConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ad_decision_server_url: std::option::Option<std::string::String>,
        pub(crate) avail_suppression: std::option::Option<crate::model::AvailSuppression>,
        pub(crate) bumper: std::option::Option<crate::model::Bumper>,
        pub(crate) cdn_configuration: std::option::Option<crate::model::CdnConfiguration>,
        pub(crate) configuration_aliases: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        >,
        pub(crate) dash_configuration: std::option::Option<crate::model::DashConfiguration>,
        pub(crate) hls_configuration: std::option::Option<crate::model::HlsConfiguration>,
        pub(crate) live_pre_roll_configuration:
            std::option::Option<crate::model::LivePreRollConfiguration>,
        pub(crate) log_configuration: std::option::Option<crate::model::LogConfiguration>,
        pub(crate) manifest_processing_rules:
            std::option::Option<crate::model::ManifestProcessingRules>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) personalization_threshold_seconds: std::option::Option<i32>,
        pub(crate) playback_configuration_arn: std::option::Option<std::string::String>,
        pub(crate) playback_endpoint_prefix: std::option::Option<std::string::String>,
        pub(crate) session_initialization_endpoint_prefix: std::option::Option<std::string::String>,
        pub(crate) slate_ad_url: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) transcode_profile_name: std::option::Option<std::string::String>,
        pub(crate) video_content_source_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
        pub fn ad_decision_server_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.ad_decision_server_url = Some(input.into());
            self
        }
        /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
        pub fn set_ad_decision_server_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ad_decision_server_url = input;
            self
        }
        /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
        pub fn avail_suppression(mut self, input: crate::model::AvailSuppression) -> Self {
            self.avail_suppression = Some(input);
            self
        }
        /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
        pub fn set_avail_suppression(
            mut self,
            input: std::option::Option<crate::model::AvailSuppression>,
        ) -> Self {
            self.avail_suppression = input;
            self
        }
        /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
        pub fn bumper(mut self, input: crate::model::Bumper) -> Self {
            self.bumper = Some(input);
            self
        }
        /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
        pub fn set_bumper(mut self, input: std::option::Option<crate::model::Bumper>) -> Self {
            self.bumper = input;
            self
        }
        /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
        pub fn cdn_configuration(mut self, input: crate::model::CdnConfiguration) -> Self {
            self.cdn_configuration = Some(input);
            self
        }
        /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
        pub fn set_cdn_configuration(
            mut self,
            input: std::option::Option<crate::model::CdnConfiguration>,
        ) -> Self {
            self.cdn_configuration = input;
            self
        }
        /// Adds a key-value pair to `configuration_aliases`.
        ///
        /// To override the contents of this collection use [`set_configuration_aliases`](Self::set_configuration_aliases).
        ///
        /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
        pub fn configuration_aliases(
            mut self,
            k: impl Into<std::string::String>,
            v: std::collections::HashMap<std::string::String, std::string::String>,
        ) -> Self {
            let mut hash_map = self.configuration_aliases.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.configuration_aliases = Some(hash_map);
            self
        }
        /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
        pub fn set_configuration_aliases(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::collections::HashMap<std::string::String, std::string::String>,
                >,
            >,
        ) -> Self {
            self.configuration_aliases = input;
            self
        }
        /// <p>The configuration for a DASH source.</p>
        pub fn dash_configuration(mut self, input: crate::model::DashConfiguration) -> Self {
            self.dash_configuration = Some(input);
            self
        }
        /// <p>The configuration for a DASH source.</p>
        pub fn set_dash_configuration(
            mut self,
            input: std::option::Option<crate::model::DashConfiguration>,
        ) -> Self {
            self.dash_configuration = input;
            self
        }
        /// <p>The configuration for HLS content.</p>
        pub fn hls_configuration(mut self, input: crate::model::HlsConfiguration) -> Self {
            self.hls_configuration = Some(input);
            self
        }
        /// <p>The configuration for HLS content.</p>
        pub fn set_hls_configuration(
            mut self,
            input: std::option::Option<crate::model::HlsConfiguration>,
        ) -> Self {
            self.hls_configuration = input;
            self
        }
        /// <p>The configuration for pre-roll ad insertion.</p>
        pub fn live_pre_roll_configuration(
            mut self,
            input: crate::model::LivePreRollConfiguration,
        ) -> Self {
            self.live_pre_roll_configuration = Some(input);
            self
        }
        /// <p>The configuration for pre-roll ad insertion.</p>
        pub fn set_live_pre_roll_configuration(
            mut self,
            input: std::option::Option<crate::model::LivePreRollConfiguration>,
        ) -> Self {
            self.live_pre_roll_configuration = input;
            self
        }
        /// <p>The Amazon CloudWatch log settings for a playback configuration.</p>
        pub fn log_configuration(mut self, input: crate::model::LogConfiguration) -> Self {
            self.log_configuration = Some(input);
            self
        }
        /// <p>The Amazon CloudWatch log settings for a playback configuration.</p>
        pub fn set_log_configuration(
            mut self,
            input: std::option::Option<crate::model::LogConfiguration>,
        ) -> Self {
            self.log_configuration = input;
            self
        }
        /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
        pub fn manifest_processing_rules(
            mut self,
            input: crate::model::ManifestProcessingRules,
        ) -> Self {
            self.manifest_processing_rules = Some(input);
            self
        }
        /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
        pub fn set_manifest_processing_rules(
            mut self,
            input: std::option::Option<crate::model::ManifestProcessingRules>,
        ) -> Self {
            self.manifest_processing_rules = input;
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
        pub fn personalization_threshold_seconds(mut self, input: i32) -> Self {
            self.personalization_threshold_seconds = Some(input);
            self
        }
        /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
        pub fn set_personalization_threshold_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.personalization_threshold_seconds = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
        pub fn playback_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.playback_configuration_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
        pub fn set_playback_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_configuration_arn = input;
            self
        }
        /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor.</p>
        pub fn playback_endpoint_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.playback_endpoint_prefix = Some(input.into());
            self
        }
        /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor.</p>
        pub fn set_playback_endpoint_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_endpoint_prefix = input;
            self
        }
        /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
        pub fn session_initialization_endpoint_prefix(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.session_initialization_endpoint_prefix = Some(input.into());
            self
        }
        /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
        pub fn set_session_initialization_endpoint_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.session_initialization_endpoint_prefix = input;
            self
        }
        /// <p>The URL for a video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
        pub fn slate_ad_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.slate_ad_url = Some(input.into());
            self
        }
        /// <p>The URL for a video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
        pub fn set_slate_ad_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.slate_ad_url = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
        pub fn transcode_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcode_profile_name = Some(input.into());
            self
        }
        /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
        pub fn set_transcode_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcode_profile_name = input;
            self
        }
        /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
        pub fn video_content_source_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.video_content_source_url = Some(input.into());
            self
        }
        /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
        pub fn set_video_content_source_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.video_content_source_url = input;
            self
        }
        /// Consumes the builder and constructs a [`PlaybackConfiguration`](crate::model::PlaybackConfiguration).
        pub fn build(self) -> crate::model::PlaybackConfiguration {
            crate::model::PlaybackConfiguration {
                ad_decision_server_url: self.ad_decision_server_url,
                avail_suppression: self.avail_suppression,
                bumper: self.bumper,
                cdn_configuration: self.cdn_configuration,
                configuration_aliases: self.configuration_aliases,
                dash_configuration: self.dash_configuration,
                hls_configuration: self.hls_configuration,
                live_pre_roll_configuration: self.live_pre_roll_configuration,
                log_configuration: self.log_configuration,
                manifest_processing_rules: self.manifest_processing_rules,
                name: self.name,
                personalization_threshold_seconds: self
                    .personalization_threshold_seconds
                    .unwrap_or_default(),
                playback_configuration_arn: self.playback_configuration_arn,
                playback_endpoint_prefix: self.playback_endpoint_prefix,
                session_initialization_endpoint_prefix: self.session_initialization_endpoint_prefix,
                slate_ad_url: self.slate_ad_url,
                tags: self.tags,
                transcode_profile_name: self.transcode_profile_name,
                video_content_source_url: self.video_content_source_url,
            }
        }
    }
}

/// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ManifestProcessingRules {
    /// <p>For HLS, when set to <code>true</code>, MediaTailor passes through <code>EXT-X-CUE-IN</code>, <code>EXT-X-CUE-OUT</code>, and <code>EXT-X-SPLICEPOINT-SCTE35</code> ad markers from the origin manifest to the MediaTailor personalized manifest.</p>
    /// <p>No logic is applied to these ad markers. For example, if <code>EXT-X-CUE-OUT</code> has a value of <code>60</code>, but no ads are filled for that ad break, MediaTailor will not set the value to <code>0</code>.</p>
    #[doc(hidden)]
    pub ad_marker_passthrough: std::option::Option<crate::model::AdMarkerPassthrough>,
}
impl ManifestProcessingRules {
    /// <p>For HLS, when set to <code>true</code>, MediaTailor passes through <code>EXT-X-CUE-IN</code>, <code>EXT-X-CUE-OUT</code>, and <code>EXT-X-SPLICEPOINT-SCTE35</code> ad markers from the origin manifest to the MediaTailor personalized manifest.</p>
    /// <p>No logic is applied to these ad markers. For example, if <code>EXT-X-CUE-OUT</code> has a value of <code>60</code>, but no ads are filled for that ad break, MediaTailor will not set the value to <code>0</code>.</p>
    pub fn ad_marker_passthrough(&self) -> std::option::Option<&crate::model::AdMarkerPassthrough> {
        self.ad_marker_passthrough.as_ref()
    }
}
impl ManifestProcessingRules {
    /// Creates a new builder-style object to manufacture [`ManifestProcessingRules`](crate::model::ManifestProcessingRules).
    pub fn builder() -> crate::model::manifest_processing_rules::Builder {
        crate::model::manifest_processing_rules::Builder::default()
    }
}

/// See [`ManifestProcessingRules`](crate::model::ManifestProcessingRules).
pub mod manifest_processing_rules {

    /// A builder for [`ManifestProcessingRules`](crate::model::ManifestProcessingRules).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ad_marker_passthrough: std::option::Option<crate::model::AdMarkerPassthrough>,
    }
    impl Builder {
        /// <p>For HLS, when set to <code>true</code>, MediaTailor passes through <code>EXT-X-CUE-IN</code>, <code>EXT-X-CUE-OUT</code>, and <code>EXT-X-SPLICEPOINT-SCTE35</code> ad markers from the origin manifest to the MediaTailor personalized manifest.</p>
        /// <p>No logic is applied to these ad markers. For example, if <code>EXT-X-CUE-OUT</code> has a value of <code>60</code>, but no ads are filled for that ad break, MediaTailor will not set the value to <code>0</code>.</p>
        pub fn ad_marker_passthrough(mut self, input: crate::model::AdMarkerPassthrough) -> Self {
            self.ad_marker_passthrough = Some(input);
            self
        }
        /// <p>For HLS, when set to <code>true</code>, MediaTailor passes through <code>EXT-X-CUE-IN</code>, <code>EXT-X-CUE-OUT</code>, and <code>EXT-X-SPLICEPOINT-SCTE35</code> ad markers from the origin manifest to the MediaTailor personalized manifest.</p>
        /// <p>No logic is applied to these ad markers. For example, if <code>EXT-X-CUE-OUT</code> has a value of <code>60</code>, but no ads are filled for that ad break, MediaTailor will not set the value to <code>0</code>.</p>
        pub fn set_ad_marker_passthrough(
            mut self,
            input: std::option::Option<crate::model::AdMarkerPassthrough>,
        ) -> Self {
            self.ad_marker_passthrough = input;
            self
        }
        /// Consumes the builder and constructs a [`ManifestProcessingRules`](crate::model::ManifestProcessingRules).
        pub fn build(self) -> crate::model::ManifestProcessingRules {
            crate::model::ManifestProcessingRules {
                ad_marker_passthrough: self.ad_marker_passthrough,
            }
        }
    }
}

/// <p>For HLS, when set to <code>true</code>, MediaTailor passes through <code>EXT-X-CUE-IN</code>, <code>EXT-X-CUE-OUT</code>, and <code>EXT-X-SPLICEPOINT-SCTE35</code> ad markers from the origin manifest to the MediaTailor personalized manifest.</p>
/// <p>No logic is applied to these ad markers. For example, if <code>EXT-X-CUE-OUT</code> has a value of <code>60</code>, but no ads are filled for that ad break, MediaTailor will not set the value to <code>0</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AdMarkerPassthrough {
    /// <p>Enables ad marker passthrough for your configuration.</p>
    #[doc(hidden)]
    pub enabled: bool,
}
impl AdMarkerPassthrough {
    /// <p>Enables ad marker passthrough for your configuration.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
impl AdMarkerPassthrough {
    /// Creates a new builder-style object to manufacture [`AdMarkerPassthrough`](crate::model::AdMarkerPassthrough).
    pub fn builder() -> crate::model::ad_marker_passthrough::Builder {
        crate::model::ad_marker_passthrough::Builder::default()
    }
}

/// See [`AdMarkerPassthrough`](crate::model::AdMarkerPassthrough).
pub mod ad_marker_passthrough {

    /// A builder for [`AdMarkerPassthrough`](crate::model::AdMarkerPassthrough).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Enables ad marker passthrough for your configuration.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Enables ad marker passthrough for your configuration.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AdMarkerPassthrough`](crate::model::AdMarkerPassthrough).
        pub fn build(self) -> crate::model::AdMarkerPassthrough {
            crate::model::AdMarkerPassthrough {
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}

/// <p>Returns Amazon CloudWatch log settings for a playback configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LogConfiguration {
    /// <p>The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and <code>percentEnabled</code> is set to <code>60</code>, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html">debug log mode</a>.</p>
    /// <p>Valid values: <code>0</code> - <code>100</code> </p>
    #[doc(hidden)]
    pub percent_enabled: i32,
}
impl LogConfiguration {
    /// <p>The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and <code>percentEnabled</code> is set to <code>60</code>, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html">debug log mode</a>.</p>
    /// <p>Valid values: <code>0</code> - <code>100</code> </p>
    pub fn percent_enabled(&self) -> i32 {
        self.percent_enabled
    }
}
impl LogConfiguration {
    /// Creates a new builder-style object to manufacture [`LogConfiguration`](crate::model::LogConfiguration).
    pub fn builder() -> crate::model::log_configuration::Builder {
        crate::model::log_configuration::Builder::default()
    }
}

/// See [`LogConfiguration`](crate::model::LogConfiguration).
pub mod log_configuration {

    /// A builder for [`LogConfiguration`](crate::model::LogConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) percent_enabled: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and <code>percentEnabled</code> is set to <code>60</code>, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html">debug log mode</a>.</p>
        /// <p>Valid values: <code>0</code> - <code>100</code> </p>
        pub fn percent_enabled(mut self, input: i32) -> Self {
            self.percent_enabled = Some(input);
            self
        }
        /// <p>The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and <code>percentEnabled</code> is set to <code>60</code>, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html">debug log mode</a>.</p>
        /// <p>Valid values: <code>0</code> - <code>100</code> </p>
        pub fn set_percent_enabled(mut self, input: std::option::Option<i32>) -> Self {
            self.percent_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`LogConfiguration`](crate::model::LogConfiguration).
        pub fn build(self) -> crate::model::LogConfiguration {
            crate::model::LogConfiguration {
                percent_enabled: self.percent_enabled.unwrap_or_default(),
            }
        }
    }
}

/// <p>The configuration for pre-roll ad insertion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LivePreRollConfiguration {
    /// <p>The URL for the ad decision server (ADS) for pre-roll ads. This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    #[doc(hidden)]
    pub ad_decision_server_url: std::option::Option<std::string::String>,
    /// <p>The maximum allowed duration for the pre-roll ad avail. AWS Elemental MediaTailor won't play pre-roll ads to exceed this duration, regardless of the total duration of ads that the ADS returns.</p>
    #[doc(hidden)]
    pub max_duration_seconds: i32,
}
impl LivePreRollConfiguration {
    /// <p>The URL for the ad decision server (ADS) for pre-roll ads. This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    pub fn ad_decision_server_url(&self) -> std::option::Option<&str> {
        self.ad_decision_server_url.as_deref()
    }
    /// <p>The maximum allowed duration for the pre-roll ad avail. AWS Elemental MediaTailor won't play pre-roll ads to exceed this duration, regardless of the total duration of ads that the ADS returns.</p>
    pub fn max_duration_seconds(&self) -> i32 {
        self.max_duration_seconds
    }
}
impl LivePreRollConfiguration {
    /// Creates a new builder-style object to manufacture [`LivePreRollConfiguration`](crate::model::LivePreRollConfiguration).
    pub fn builder() -> crate::model::live_pre_roll_configuration::Builder {
        crate::model::live_pre_roll_configuration::Builder::default()
    }
}

/// See [`LivePreRollConfiguration`](crate::model::LivePreRollConfiguration).
pub mod live_pre_roll_configuration {

    /// A builder for [`LivePreRollConfiguration`](crate::model::LivePreRollConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ad_decision_server_url: std::option::Option<std::string::String>,
        pub(crate) max_duration_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The URL for the ad decision server (ADS) for pre-roll ads. This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
        pub fn ad_decision_server_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.ad_decision_server_url = Some(input.into());
            self
        }
        /// <p>The URL for the ad decision server (ADS) for pre-roll ads. This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
        pub fn set_ad_decision_server_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ad_decision_server_url = input;
            self
        }
        /// <p>The maximum allowed duration for the pre-roll ad avail. AWS Elemental MediaTailor won't play pre-roll ads to exceed this duration, regardless of the total duration of ads that the ADS returns.</p>
        pub fn max_duration_seconds(mut self, input: i32) -> Self {
            self.max_duration_seconds = Some(input);
            self
        }
        /// <p>The maximum allowed duration for the pre-roll ad avail. AWS Elemental MediaTailor won't play pre-roll ads to exceed this duration, regardless of the total duration of ads that the ADS returns.</p>
        pub fn set_max_duration_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.max_duration_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`LivePreRollConfiguration`](crate::model::LivePreRollConfiguration).
        pub fn build(self) -> crate::model::LivePreRollConfiguration {
            crate::model::LivePreRollConfiguration {
                ad_decision_server_url: self.ad_decision_server_url,
                max_duration_seconds: self.max_duration_seconds.unwrap_or_default(),
            }
        }
    }
}

/// <p>The configuration for HLS content.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HlsConfiguration {
    /// <p>The URL that is used to initiate a playback session for devices that support Apple HLS. The session uses server-side reporting.</p>
    #[doc(hidden)]
    pub manifest_endpoint_prefix: std::option::Option<std::string::String>,
}
impl HlsConfiguration {
    /// <p>The URL that is used to initiate a playback session for devices that support Apple HLS. The session uses server-side reporting.</p>
    pub fn manifest_endpoint_prefix(&self) -> std::option::Option<&str> {
        self.manifest_endpoint_prefix.as_deref()
    }
}
impl HlsConfiguration {
    /// Creates a new builder-style object to manufacture [`HlsConfiguration`](crate::model::HlsConfiguration).
    pub fn builder() -> crate::model::hls_configuration::Builder {
        crate::model::hls_configuration::Builder::default()
    }
}

/// See [`HlsConfiguration`](crate::model::HlsConfiguration).
pub mod hls_configuration {

    /// A builder for [`HlsConfiguration`](crate::model::HlsConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) manifest_endpoint_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL that is used to initiate a playback session for devices that support Apple HLS. The session uses server-side reporting.</p>
        pub fn manifest_endpoint_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.manifest_endpoint_prefix = Some(input.into());
            self
        }
        /// <p>The URL that is used to initiate a playback session for devices that support Apple HLS. The session uses server-side reporting.</p>
        pub fn set_manifest_endpoint_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.manifest_endpoint_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`HlsConfiguration`](crate::model::HlsConfiguration).
        pub fn build(self) -> crate::model::HlsConfiguration {
            crate::model::HlsConfiguration {
                manifest_endpoint_prefix: self.manifest_endpoint_prefix,
            }
        }
    }
}

/// <p>The configuration for DASH content.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashConfiguration {
    /// <p>The URL generated by MediaTailor to initiate a playback session. The session uses server-side reporting. This setting is ignored in PUT operations.</p>
    #[doc(hidden)]
    pub manifest_endpoint_prefix: std::option::Option<std::string::String>,
    /// <p>The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are <code>DISABLED</code> and <code>EMT_DEFAULT</code>. The <code>EMT_DEFAULT</code> setting enables the inclusion of the tag and is the default value.</p>
    #[doc(hidden)]
    pub mpd_location: std::option::Option<std::string::String>,
    /// <p>The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to <code>SINGLE_PERIOD</code>. The default setting is <code>MULTI_PERIOD</code>. For multi-period manifests, omit this setting or set it to <code>MULTI_PERIOD</code>.</p>
    #[doc(hidden)]
    pub origin_manifest_type: std::option::Option<crate::model::OriginManifestType>,
}
impl DashConfiguration {
    /// <p>The URL generated by MediaTailor to initiate a playback session. The session uses server-side reporting. This setting is ignored in PUT operations.</p>
    pub fn manifest_endpoint_prefix(&self) -> std::option::Option<&str> {
        self.manifest_endpoint_prefix.as_deref()
    }
    /// <p>The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are <code>DISABLED</code> and <code>EMT_DEFAULT</code>. The <code>EMT_DEFAULT</code> setting enables the inclusion of the tag and is the default value.</p>
    pub fn mpd_location(&self) -> std::option::Option<&str> {
        self.mpd_location.as_deref()
    }
    /// <p>The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to <code>SINGLE_PERIOD</code>. The default setting is <code>MULTI_PERIOD</code>. For multi-period manifests, omit this setting or set it to <code>MULTI_PERIOD</code>.</p>
    pub fn origin_manifest_type(&self) -> std::option::Option<&crate::model::OriginManifestType> {
        self.origin_manifest_type.as_ref()
    }
}
impl DashConfiguration {
    /// Creates a new builder-style object to manufacture [`DashConfiguration`](crate::model::DashConfiguration).
    pub fn builder() -> crate::model::dash_configuration::Builder {
        crate::model::dash_configuration::Builder::default()
    }
}

/// See [`DashConfiguration`](crate::model::DashConfiguration).
pub mod dash_configuration {

    /// A builder for [`DashConfiguration`](crate::model::DashConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) manifest_endpoint_prefix: std::option::Option<std::string::String>,
        pub(crate) mpd_location: std::option::Option<std::string::String>,
        pub(crate) origin_manifest_type: std::option::Option<crate::model::OriginManifestType>,
    }
    impl Builder {
        /// <p>The URL generated by MediaTailor to initiate a playback session. The session uses server-side reporting. This setting is ignored in PUT operations.</p>
        pub fn manifest_endpoint_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.manifest_endpoint_prefix = Some(input.into());
            self
        }
        /// <p>The URL generated by MediaTailor to initiate a playback session. The session uses server-side reporting. This setting is ignored in PUT operations.</p>
        pub fn set_manifest_endpoint_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.manifest_endpoint_prefix = input;
            self
        }
        /// <p>The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are <code>DISABLED</code> and <code>EMT_DEFAULT</code>. The <code>EMT_DEFAULT</code> setting enables the inclusion of the tag and is the default value.</p>
        pub fn mpd_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.mpd_location = Some(input.into());
            self
        }
        /// <p>The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are <code>DISABLED</code> and <code>EMT_DEFAULT</code>. The <code>EMT_DEFAULT</code> setting enables the inclusion of the tag and is the default value.</p>
        pub fn set_mpd_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mpd_location = input;
            self
        }
        /// <p>The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to <code>SINGLE_PERIOD</code>. The default setting is <code>MULTI_PERIOD</code>. For multi-period manifests, omit this setting or set it to <code>MULTI_PERIOD</code>.</p>
        pub fn origin_manifest_type(mut self, input: crate::model::OriginManifestType) -> Self {
            self.origin_manifest_type = Some(input);
            self
        }
        /// <p>The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to <code>SINGLE_PERIOD</code>. The default setting is <code>MULTI_PERIOD</code>. For multi-period manifests, omit this setting or set it to <code>MULTI_PERIOD</code>.</p>
        pub fn set_origin_manifest_type(
            mut self,
            input: std::option::Option<crate::model::OriginManifestType>,
        ) -> Self {
            self.origin_manifest_type = input;
            self
        }
        /// Consumes the builder and constructs a [`DashConfiguration`](crate::model::DashConfiguration).
        pub fn build(self) -> crate::model::DashConfiguration {
            crate::model::DashConfiguration {
                manifest_endpoint_prefix: self.manifest_endpoint_prefix,
                mpd_location: self.mpd_location,
                origin_manifest_type: self.origin_manifest_type,
            }
        }
    }
}

/// When writing a match expression against `OriginManifestType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let originmanifesttype = unimplemented!();
/// match originmanifesttype {
///     OriginManifestType::MultiPeriod => { /* ... */ },
///     OriginManifestType::SinglePeriod => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `originmanifesttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OriginManifestType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OriginManifestType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OriginManifestType::NewFeature` is defined.
/// Specifically, when `originmanifesttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OriginManifestType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OriginManifestType {
    #[allow(missing_docs)] // documentation missing in model
    MultiPeriod,
    #[allow(missing_docs)] // documentation missing in model
    SinglePeriod,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OriginManifestType {
    fn from(s: &str) -> Self {
        match s {
            "MULTI_PERIOD" => OriginManifestType::MultiPeriod,
            "SINGLE_PERIOD" => OriginManifestType::SinglePeriod,
            other => {
                OriginManifestType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for OriginManifestType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OriginManifestType::from(s))
    }
}
impl OriginManifestType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OriginManifestType::MultiPeriod => "MULTI_PERIOD",
            OriginManifestType::SinglePeriod => "SINGLE_PERIOD",
            OriginManifestType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MULTI_PERIOD", "SINGLE_PERIOD"]
    }
}
impl AsRef<str> for OriginManifestType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CdnConfiguration {
    /// <p>A non-default content delivery network (CDN) to serve ad segments. By default, AWS Elemental MediaTailor uses Amazon CloudFront with default cache settings as its CDN for ad segments. To set up an alternate CDN, create a rule in your CDN for the origin ads.mediatailor.<i>&lt;region&gt;</i>.amazonaws.com. Then specify the rule's name in this <code>AdSegmentUrlPrefix</code>. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for ad segments.</p>
    #[doc(hidden)]
    pub ad_segment_url_prefix: std::option::Option<std::string::String>,
    /// <p>A content delivery network (CDN) to cache content segments, so that content requests don’t always have to go to the origin server. First, create a rule in your CDN for the content segment origin server. Then specify the rule's name in this <code>ContentSegmentUrlPrefix</code>. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for content segments.</p>
    #[doc(hidden)]
    pub content_segment_url_prefix: std::option::Option<std::string::String>,
}
impl CdnConfiguration {
    /// <p>A non-default content delivery network (CDN) to serve ad segments. By default, AWS Elemental MediaTailor uses Amazon CloudFront with default cache settings as its CDN for ad segments. To set up an alternate CDN, create a rule in your CDN for the origin ads.mediatailor.<i>&lt;region&gt;</i>.amazonaws.com. Then specify the rule's name in this <code>AdSegmentUrlPrefix</code>. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for ad segments.</p>
    pub fn ad_segment_url_prefix(&self) -> std::option::Option<&str> {
        self.ad_segment_url_prefix.as_deref()
    }
    /// <p>A content delivery network (CDN) to cache content segments, so that content requests don’t always have to go to the origin server. First, create a rule in your CDN for the content segment origin server. Then specify the rule's name in this <code>ContentSegmentUrlPrefix</code>. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for content segments.</p>
    pub fn content_segment_url_prefix(&self) -> std::option::Option<&str> {
        self.content_segment_url_prefix.as_deref()
    }
}
impl CdnConfiguration {
    /// Creates a new builder-style object to manufacture [`CdnConfiguration`](crate::model::CdnConfiguration).
    pub fn builder() -> crate::model::cdn_configuration::Builder {
        crate::model::cdn_configuration::Builder::default()
    }
}

/// See [`CdnConfiguration`](crate::model::CdnConfiguration).
pub mod cdn_configuration {

    /// A builder for [`CdnConfiguration`](crate::model::CdnConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ad_segment_url_prefix: std::option::Option<std::string::String>,
        pub(crate) content_segment_url_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A non-default content delivery network (CDN) to serve ad segments. By default, AWS Elemental MediaTailor uses Amazon CloudFront with default cache settings as its CDN for ad segments. To set up an alternate CDN, create a rule in your CDN for the origin ads.mediatailor.<i>&lt;region&gt;</i>.amazonaws.com. Then specify the rule's name in this <code>AdSegmentUrlPrefix</code>. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for ad segments.</p>
        pub fn ad_segment_url_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.ad_segment_url_prefix = Some(input.into());
            self
        }
        /// <p>A non-default content delivery network (CDN) to serve ad segments. By default, AWS Elemental MediaTailor uses Amazon CloudFront with default cache settings as its CDN for ad segments. To set up an alternate CDN, create a rule in your CDN for the origin ads.mediatailor.<i>&lt;region&gt;</i>.amazonaws.com. Then specify the rule's name in this <code>AdSegmentUrlPrefix</code>. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for ad segments.</p>
        pub fn set_ad_segment_url_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ad_segment_url_prefix = input;
            self
        }
        /// <p>A content delivery network (CDN) to cache content segments, so that content requests don’t always have to go to the origin server. First, create a rule in your CDN for the content segment origin server. Then specify the rule's name in this <code>ContentSegmentUrlPrefix</code>. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for content segments.</p>
        pub fn content_segment_url_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_segment_url_prefix = Some(input.into());
            self
        }
        /// <p>A content delivery network (CDN) to cache content segments, so that content requests don’t always have to go to the origin server. First, create a rule in your CDN for the content segment origin server. Then specify the rule's name in this <code>ContentSegmentUrlPrefix</code>. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for content segments.</p>
        pub fn set_content_segment_url_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_segment_url_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`CdnConfiguration`](crate::model::CdnConfiguration).
        pub fn build(self) -> crate::model::CdnConfiguration {
            crate::model::CdnConfiguration {
                ad_segment_url_prefix: self.ad_segment_url_prefix,
                content_segment_url_prefix: self.content_segment_url_prefix,
            }
        }
    }
}

/// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Bumper {
    /// <p>The URL for the end bumper asset.</p>
    #[doc(hidden)]
    pub end_url: std::option::Option<std::string::String>,
    /// <p>The URL for the start bumper asset.</p>
    #[doc(hidden)]
    pub start_url: std::option::Option<std::string::String>,
}
impl Bumper {
    /// <p>The URL for the end bumper asset.</p>
    pub fn end_url(&self) -> std::option::Option<&str> {
        self.end_url.as_deref()
    }
    /// <p>The URL for the start bumper asset.</p>
    pub fn start_url(&self) -> std::option::Option<&str> {
        self.start_url.as_deref()
    }
}
impl Bumper {
    /// Creates a new builder-style object to manufacture [`Bumper`](crate::model::Bumper).
    pub fn builder() -> crate::model::bumper::Builder {
        crate::model::bumper::Builder::default()
    }
}

/// See [`Bumper`](crate::model::Bumper).
pub mod bumper {

    /// A builder for [`Bumper`](crate::model::Bumper).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) end_url: std::option::Option<std::string::String>,
        pub(crate) start_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL for the end bumper asset.</p>
        pub fn end_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.end_url = Some(input.into());
            self
        }
        /// <p>The URL for the end bumper asset.</p>
        pub fn set_end_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.end_url = input;
            self
        }
        /// <p>The URL for the start bumper asset.</p>
        pub fn start_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_url = Some(input.into());
            self
        }
        /// <p>The URL for the start bumper asset.</p>
        pub fn set_start_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start_url = input;
            self
        }
        /// Consumes the builder and constructs a [`Bumper`](crate::model::Bumper).
        pub fn build(self) -> crate::model::Bumper {
            crate::model::Bumper {
                end_url: self.end_url,
                start_url: self.start_url,
            }
        }
    }
}

/// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AvailSuppression {
    /// <p>Sets the ad suppression mode. By default, ad suppression is off and all ad breaks are filled with ads or slate. When Mode is set to <code>BEHIND_LIVE_EDGE</code>, ad suppression is active and MediaTailor won't fill ad breaks on or behind the ad suppression Value time in the manifest lookback window.</p>
    #[doc(hidden)]
    pub mode: std::option::Option<crate::model::Mode>,
    /// <p>A live edge offset time in HH:MM:SS. MediaTailor won't fill ad breaks on or behind this time in the manifest lookback window. If Value is set to 00:00:00, it is in sync with the live edge, and MediaTailor won't fill any ad breaks on or behind the live edge. If you set a Value time, MediaTailor won't fill any ad breaks on or behind this time in the manifest lookback window. For example, if you set 00:45:00, then MediaTailor will fill ad breaks that occur within 45 minutes behind the live edge, but won't fill ad breaks on or behind 45 minutes behind the live edge.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl AvailSuppression {
    /// <p>Sets the ad suppression mode. By default, ad suppression is off and all ad breaks are filled with ads or slate. When Mode is set to <code>BEHIND_LIVE_EDGE</code>, ad suppression is active and MediaTailor won't fill ad breaks on or behind the ad suppression Value time in the manifest lookback window.</p>
    pub fn mode(&self) -> std::option::Option<&crate::model::Mode> {
        self.mode.as_ref()
    }
    /// <p>A live edge offset time in HH:MM:SS. MediaTailor won't fill ad breaks on or behind this time in the manifest lookback window. If Value is set to 00:00:00, it is in sync with the live edge, and MediaTailor won't fill any ad breaks on or behind the live edge. If you set a Value time, MediaTailor won't fill any ad breaks on or behind this time in the manifest lookback window. For example, if you set 00:45:00, then MediaTailor will fill ad breaks that occur within 45 minutes behind the live edge, but won't fill ad breaks on or behind 45 minutes behind the live edge.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl AvailSuppression {
    /// Creates a new builder-style object to manufacture [`AvailSuppression`](crate::model::AvailSuppression).
    pub fn builder() -> crate::model::avail_suppression::Builder {
        crate::model::avail_suppression::Builder::default()
    }
}

/// See [`AvailSuppression`](crate::model::AvailSuppression).
pub mod avail_suppression {

    /// A builder for [`AvailSuppression`](crate::model::AvailSuppression).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mode: std::option::Option<crate::model::Mode>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Sets the ad suppression mode. By default, ad suppression is off and all ad breaks are filled with ads or slate. When Mode is set to <code>BEHIND_LIVE_EDGE</code>, ad suppression is active and MediaTailor won't fill ad breaks on or behind the ad suppression Value time in the manifest lookback window.</p>
        pub fn mode(mut self, input: crate::model::Mode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>Sets the ad suppression mode. By default, ad suppression is off and all ad breaks are filled with ads or slate. When Mode is set to <code>BEHIND_LIVE_EDGE</code>, ad suppression is active and MediaTailor won't fill ad breaks on or behind the ad suppression Value time in the manifest lookback window.</p>
        pub fn set_mode(mut self, input: std::option::Option<crate::model::Mode>) -> Self {
            self.mode = input;
            self
        }
        /// <p>A live edge offset time in HH:MM:SS. MediaTailor won't fill ad breaks on or behind this time in the manifest lookback window. If Value is set to 00:00:00, it is in sync with the live edge, and MediaTailor won't fill any ad breaks on or behind the live edge. If you set a Value time, MediaTailor won't fill any ad breaks on or behind this time in the manifest lookback window. For example, if you set 00:45:00, then MediaTailor will fill ad breaks that occur within 45 minutes behind the live edge, but won't fill ad breaks on or behind 45 minutes behind the live edge.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A live edge offset time in HH:MM:SS. MediaTailor won't fill ad breaks on or behind this time in the manifest lookback window. If Value is set to 00:00:00, it is in sync with the live edge, and MediaTailor won't fill any ad breaks on or behind the live edge. If you set a Value time, MediaTailor won't fill any ad breaks on or behind this time in the manifest lookback window. For example, if you set 00:45:00, then MediaTailor will fill ad breaks that occur within 45 minutes behind the live edge, but won't fill ad breaks on or behind 45 minutes behind the live edge.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AvailSuppression`](crate::model::AvailSuppression).
        pub fn build(self) -> crate::model::AvailSuppression {
            crate::model::AvailSuppression {
                mode: self.mode,
                value: self.value,
            }
        }
    }
}

/// When writing a match expression against `Mode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let mode = unimplemented!();
/// match mode {
///     Mode::BehindLiveEdge => { /* ... */ },
///     Mode::Off => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `mode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Mode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Mode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Mode::NewFeature` is defined.
/// Specifically, when `mode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Mode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Mode {
    #[allow(missing_docs)] // documentation missing in model
    BehindLiveEdge,
    #[allow(missing_docs)] // documentation missing in model
    Off,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Mode {
    fn from(s: &str) -> Self {
        match s {
            "BEHIND_LIVE_EDGE" => Mode::BehindLiveEdge,
            "OFF" => Mode::Off,
            other => Mode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Mode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Mode::from(s))
    }
}
impl Mode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Mode::BehindLiveEdge => "BEHIND_LIVE_EDGE",
            Mode::Off => "OFF",
            Mode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BEHIND_LIVE_EDGE", "OFF"]
    }
}
impl AsRef<str> for Mode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration for DASH PUT operations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashConfigurationForPut {
    /// <p>The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are <code>DISABLED</code> and <code>EMT_DEFAULT</code>. The <code>EMT_DEFAULT</code> setting enables the inclusion of the tag and is the default value.</p>
    #[doc(hidden)]
    pub mpd_location: std::option::Option<std::string::String>,
    /// <p>The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to <code>SINGLE_PERIOD</code>. The default setting is <code>MULTI_PERIOD</code>. For multi-period manifests, omit this setting or set it to <code>MULTI_PERIOD</code>.</p>
    #[doc(hidden)]
    pub origin_manifest_type: std::option::Option<crate::model::OriginManifestType>,
}
impl DashConfigurationForPut {
    /// <p>The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are <code>DISABLED</code> and <code>EMT_DEFAULT</code>. The <code>EMT_DEFAULT</code> setting enables the inclusion of the tag and is the default value.</p>
    pub fn mpd_location(&self) -> std::option::Option<&str> {
        self.mpd_location.as_deref()
    }
    /// <p>The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to <code>SINGLE_PERIOD</code>. The default setting is <code>MULTI_PERIOD</code>. For multi-period manifests, omit this setting or set it to <code>MULTI_PERIOD</code>.</p>
    pub fn origin_manifest_type(&self) -> std::option::Option<&crate::model::OriginManifestType> {
        self.origin_manifest_type.as_ref()
    }
}
impl DashConfigurationForPut {
    /// Creates a new builder-style object to manufacture [`DashConfigurationForPut`](crate::model::DashConfigurationForPut).
    pub fn builder() -> crate::model::dash_configuration_for_put::Builder {
        crate::model::dash_configuration_for_put::Builder::default()
    }
}

/// See [`DashConfigurationForPut`](crate::model::DashConfigurationForPut).
pub mod dash_configuration_for_put {

    /// A builder for [`DashConfigurationForPut`](crate::model::DashConfigurationForPut).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mpd_location: std::option::Option<std::string::String>,
        pub(crate) origin_manifest_type: std::option::Option<crate::model::OriginManifestType>,
    }
    impl Builder {
        /// <p>The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are <code>DISABLED</code> and <code>EMT_DEFAULT</code>. The <code>EMT_DEFAULT</code> setting enables the inclusion of the tag and is the default value.</p>
        pub fn mpd_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.mpd_location = Some(input.into());
            self
        }
        /// <p>The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are <code>DISABLED</code> and <code>EMT_DEFAULT</code>. The <code>EMT_DEFAULT</code> setting enables the inclusion of the tag and is the default value.</p>
        pub fn set_mpd_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mpd_location = input;
            self
        }
        /// <p>The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to <code>SINGLE_PERIOD</code>. The default setting is <code>MULTI_PERIOD</code>. For multi-period manifests, omit this setting or set it to <code>MULTI_PERIOD</code>.</p>
        pub fn origin_manifest_type(mut self, input: crate::model::OriginManifestType) -> Self {
            self.origin_manifest_type = Some(input);
            self
        }
        /// <p>The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to <code>SINGLE_PERIOD</code>. The default setting is <code>MULTI_PERIOD</code>. For multi-period manifests, omit this setting or set it to <code>MULTI_PERIOD</code>.</p>
        pub fn set_origin_manifest_type(
            mut self,
            input: std::option::Option<crate::model::OriginManifestType>,
        ) -> Self {
            self.origin_manifest_type = input;
            self
        }
        /// Consumes the builder and constructs a [`DashConfigurationForPut`](crate::model::DashConfigurationForPut).
        pub fn build(self) -> crate::model::DashConfigurationForPut {
            crate::model::DashConfigurationForPut {
                mpd_location: self.mpd_location,
                origin_manifest_type: self.origin_manifest_type,
            }
        }
    }
}

/// <p>Live source configuration parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LiveSource {
    /// <p>The ARN for the live source.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates when the live source was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The HTTP package configurations for the live source.</p>
    #[doc(hidden)]
    pub http_package_configurations:
        std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
    /// <p>The timestamp that indicates when the live source was last modified.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name that's used to refer to a live source.</p>
    #[doc(hidden)]
    pub live_source_name: std::option::Option<std::string::String>,
    /// <p>The name of the source location.</p>
    #[doc(hidden)]
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl LiveSource {
    /// <p>The ARN for the live source.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The timestamp that indicates when the live source was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The HTTP package configurations for the live source.</p>
    pub fn http_package_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::HttpPackageConfiguration]> {
        self.http_package_configurations.as_deref()
    }
    /// <p>The timestamp that indicates when the live source was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The name that's used to refer to a live source.</p>
    pub fn live_source_name(&self) -> std::option::Option<&str> {
        self.live_source_name.as_deref()
    }
    /// <p>The name of the source location.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags assigned to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl LiveSource {
    /// Creates a new builder-style object to manufacture [`LiveSource`](crate::model::LiveSource).
    pub fn builder() -> crate::model::live_source::Builder {
        crate::model::live_source::Builder::default()
    }
}

/// See [`LiveSource`](crate::model::LiveSource).
pub mod live_source {

    /// A builder for [`LiveSource`](crate::model::LiveSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) http_package_configurations:
            std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) live_source_name: std::option::Option<std::string::String>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ARN for the live source.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN for the live source.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The timestamp that indicates when the live source was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the live source was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Appends an item to `http_package_configurations`.
        ///
        /// To override the contents of this collection use [`set_http_package_configurations`](Self::set_http_package_configurations).
        ///
        /// <p>The HTTP package configurations for the live source.</p>
        pub fn http_package_configurations(
            mut self,
            input: crate::model::HttpPackageConfiguration,
        ) -> Self {
            let mut v = self.http_package_configurations.unwrap_or_default();
            v.push(input);
            self.http_package_configurations = Some(v);
            self
        }
        /// <p>The HTTP package configurations for the live source.</p>
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.http_package_configurations = input;
            self
        }
        /// <p>The timestamp that indicates when the live source was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the live source was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The name that's used to refer to a live source.</p>
        pub fn live_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.live_source_name = Some(input.into());
            self
        }
        /// <p>The name that's used to refer to a live source.</p>
        pub fn set_live_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.live_source_name = input;
            self
        }
        /// <p>The name of the source location.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`LiveSource`](crate::model::LiveSource).
        pub fn build(self) -> crate::model::LiveSource {
            crate::model::LiveSource {
                arn: self.arn,
                creation_time: self.creation_time,
                http_package_configurations: self.http_package_configurations,
                last_modified_time: self.last_modified_time,
                live_source_name: self.live_source_name,
                source_location_name: self.source_location_name,
                tags: self.tags,
            }
        }
    }
}

/// <p>The properties for a schedule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScheduleEntry {
    /// <p>The approximate duration of this program, in seconds.</p>
    #[doc(hidden)]
    pub approximate_duration_seconds: i64,
    /// <p>The approximate time that the program will start playing.</p>
    #[doc(hidden)]
    pub approximate_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The ARN of the program.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the channel that uses this schedule.</p>
    #[doc(hidden)]
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The name of the live source used for the program.</p>
    #[doc(hidden)]
    pub live_source_name: std::option::Option<std::string::String>,
    /// <p>The name of the program.</p>
    #[doc(hidden)]
    pub program_name: std::option::Option<std::string::String>,
    /// <p>The schedule's ad break properties.</p>
    #[doc(hidden)]
    pub schedule_ad_breaks: std::option::Option<std::vec::Vec<crate::model::ScheduleAdBreak>>,
    /// <p>The type of schedule entry.</p>
    #[doc(hidden)]
    pub schedule_entry_type: std::option::Option<crate::model::ScheduleEntryType>,
    /// <p>The name of the source location.</p>
    #[doc(hidden)]
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The name of the VOD source.</p>
    #[doc(hidden)]
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl ScheduleEntry {
    /// <p>The approximate duration of this program, in seconds.</p>
    pub fn approximate_duration_seconds(&self) -> i64 {
        self.approximate_duration_seconds
    }
    /// <p>The approximate time that the program will start playing.</p>
    pub fn approximate_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.approximate_start_time.as_ref()
    }
    /// <p>The ARN of the program.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the channel that uses this schedule.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>The name of the live source used for the program.</p>
    pub fn live_source_name(&self) -> std::option::Option<&str> {
        self.live_source_name.as_deref()
    }
    /// <p>The name of the program.</p>
    pub fn program_name(&self) -> std::option::Option<&str> {
        self.program_name.as_deref()
    }
    /// <p>The schedule's ad break properties.</p>
    pub fn schedule_ad_breaks(&self) -> std::option::Option<&[crate::model::ScheduleAdBreak]> {
        self.schedule_ad_breaks.as_deref()
    }
    /// <p>The type of schedule entry.</p>
    pub fn schedule_entry_type(&self) -> std::option::Option<&crate::model::ScheduleEntryType> {
        self.schedule_entry_type.as_ref()
    }
    /// <p>The name of the source location.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The name of the VOD source.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl ScheduleEntry {
    /// Creates a new builder-style object to manufacture [`ScheduleEntry`](crate::model::ScheduleEntry).
    pub fn builder() -> crate::model::schedule_entry::Builder {
        crate::model::schedule_entry::Builder::default()
    }
}

/// See [`ScheduleEntry`](crate::model::ScheduleEntry).
pub mod schedule_entry {

    /// A builder for [`ScheduleEntry`](crate::model::ScheduleEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) approximate_duration_seconds: std::option::Option<i64>,
        pub(crate) approximate_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) live_source_name: std::option::Option<std::string::String>,
        pub(crate) program_name: std::option::Option<std::string::String>,
        pub(crate) schedule_ad_breaks:
            std::option::Option<std::vec::Vec<crate::model::ScheduleAdBreak>>,
        pub(crate) schedule_entry_type: std::option::Option<crate::model::ScheduleEntryType>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The approximate duration of this program, in seconds.</p>
        pub fn approximate_duration_seconds(mut self, input: i64) -> Self {
            self.approximate_duration_seconds = Some(input);
            self
        }
        /// <p>The approximate duration of this program, in seconds.</p>
        pub fn set_approximate_duration_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.approximate_duration_seconds = input;
            self
        }
        /// <p>The approximate time that the program will start playing.</p>
        pub fn approximate_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.approximate_start_time = Some(input);
            self
        }
        /// <p>The approximate time that the program will start playing.</p>
        pub fn set_approximate_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.approximate_start_time = input;
            self
        }
        /// <p>The ARN of the program.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the program.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the channel that uses this schedule.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The name of the channel that uses this schedule.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The name of the live source used for the program.</p>
        pub fn live_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.live_source_name = Some(input.into());
            self
        }
        /// <p>The name of the live source used for the program.</p>
        pub fn set_live_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.live_source_name = input;
            self
        }
        /// <p>The name of the program.</p>
        pub fn program_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.program_name = Some(input.into());
            self
        }
        /// <p>The name of the program.</p>
        pub fn set_program_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.program_name = input;
            self
        }
        /// Appends an item to `schedule_ad_breaks`.
        ///
        /// To override the contents of this collection use [`set_schedule_ad_breaks`](Self::set_schedule_ad_breaks).
        ///
        /// <p>The schedule's ad break properties.</p>
        pub fn schedule_ad_breaks(mut self, input: crate::model::ScheduleAdBreak) -> Self {
            let mut v = self.schedule_ad_breaks.unwrap_or_default();
            v.push(input);
            self.schedule_ad_breaks = Some(v);
            self
        }
        /// <p>The schedule's ad break properties.</p>
        pub fn set_schedule_ad_breaks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ScheduleAdBreak>>,
        ) -> Self {
            self.schedule_ad_breaks = input;
            self
        }
        /// <p>The type of schedule entry.</p>
        pub fn schedule_entry_type(mut self, input: crate::model::ScheduleEntryType) -> Self {
            self.schedule_entry_type = Some(input);
            self
        }
        /// <p>The type of schedule entry.</p>
        pub fn set_schedule_entry_type(
            mut self,
            input: std::option::Option<crate::model::ScheduleEntryType>,
        ) -> Self {
            self.schedule_entry_type = input;
            self
        }
        /// <p>The name of the source location.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// <p>The name of the VOD source.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The name of the VOD source.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduleEntry`](crate::model::ScheduleEntry).
        pub fn build(self) -> crate::model::ScheduleEntry {
            crate::model::ScheduleEntry {
                approximate_duration_seconds: self.approximate_duration_seconds.unwrap_or_default(),
                approximate_start_time: self.approximate_start_time,
                arn: self.arn,
                channel_name: self.channel_name,
                live_source_name: self.live_source_name,
                program_name: self.program_name,
                schedule_ad_breaks: self.schedule_ad_breaks,
                schedule_entry_type: self.schedule_entry_type,
                source_location_name: self.source_location_name,
                vod_source_name: self.vod_source_name,
            }
        }
    }
}

/// When writing a match expression against `ScheduleEntryType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let scheduleentrytype = unimplemented!();
/// match scheduleentrytype {
///     ScheduleEntryType::FillerSlate => { /* ... */ },
///     ScheduleEntryType::Program => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `scheduleentrytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ScheduleEntryType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ScheduleEntryType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ScheduleEntryType::NewFeature` is defined.
/// Specifically, when `scheduleentrytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ScheduleEntryType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduleEntryType {
    #[allow(missing_docs)] // documentation missing in model
    FillerSlate,
    #[allow(missing_docs)] // documentation missing in model
    Program,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ScheduleEntryType {
    fn from(s: &str) -> Self {
        match s {
            "FILLER_SLATE" => ScheduleEntryType::FillerSlate,
            "PROGRAM" => ScheduleEntryType::Program,
            other => {
                ScheduleEntryType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ScheduleEntryType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduleEntryType::from(s))
    }
}
impl ScheduleEntryType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScheduleEntryType::FillerSlate => "FILLER_SLATE",
            ScheduleEntryType::Program => "PROGRAM",
            ScheduleEntryType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FILLER_SLATE", "PROGRAM"]
    }
}
impl AsRef<str> for ScheduleEntryType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The schedule's ad break properties.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScheduleAdBreak {
    /// <p>The approximate duration of the ad break, in seconds.</p>
    #[doc(hidden)]
    pub approximate_duration_seconds: i64,
    /// <p>The approximate time that the ad will start playing.</p>
    #[doc(hidden)]
    pub approximate_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the source location containing the VOD source used for the ad break.</p>
    #[doc(hidden)]
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The name of the VOD source used for the ad break.</p>
    #[doc(hidden)]
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl ScheduleAdBreak {
    /// <p>The approximate duration of the ad break, in seconds.</p>
    pub fn approximate_duration_seconds(&self) -> i64 {
        self.approximate_duration_seconds
    }
    /// <p>The approximate time that the ad will start playing.</p>
    pub fn approximate_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.approximate_start_time.as_ref()
    }
    /// <p>The name of the source location containing the VOD source used for the ad break.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The name of the VOD source used for the ad break.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl ScheduleAdBreak {
    /// Creates a new builder-style object to manufacture [`ScheduleAdBreak`](crate::model::ScheduleAdBreak).
    pub fn builder() -> crate::model::schedule_ad_break::Builder {
        crate::model::schedule_ad_break::Builder::default()
    }
}

/// See [`ScheduleAdBreak`](crate::model::ScheduleAdBreak).
pub mod schedule_ad_break {

    /// A builder for [`ScheduleAdBreak`](crate::model::ScheduleAdBreak).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) approximate_duration_seconds: std::option::Option<i64>,
        pub(crate) approximate_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The approximate duration of the ad break, in seconds.</p>
        pub fn approximate_duration_seconds(mut self, input: i64) -> Self {
            self.approximate_duration_seconds = Some(input);
            self
        }
        /// <p>The approximate duration of the ad break, in seconds.</p>
        pub fn set_approximate_duration_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.approximate_duration_seconds = input;
            self
        }
        /// <p>The approximate time that the ad will start playing.</p>
        pub fn approximate_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.approximate_start_time = Some(input);
            self
        }
        /// <p>The approximate time that the ad will start playing.</p>
        pub fn set_approximate_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.approximate_start_time = input;
            self
        }
        /// <p>The name of the source location containing the VOD source used for the ad break.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location containing the VOD source used for the ad break.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// <p>The name of the VOD source used for the ad break.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The name of the VOD source used for the ad break.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduleAdBreak`](crate::model::ScheduleAdBreak).
        pub fn build(self) -> crate::model::ScheduleAdBreak {
            crate::model::ScheduleAdBreak {
                approximate_duration_seconds: self.approximate_duration_seconds.unwrap_or_default(),
                approximate_start_time: self.approximate_start_time,
                source_location_name: self.source_location_name,
                vod_source_name: self.vod_source_name,
            }
        }
    }
}

/// <p>The output item response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResponseOutputItem {
    /// <p>DASH manifest configuration settings.</p>
    #[doc(hidden)]
    pub dash_playlist_settings: std::option::Option<crate::model::DashPlaylistSettings>,
    /// <p>HLS manifest configuration settings.</p>
    #[doc(hidden)]
    pub hls_playlist_settings: std::option::Option<crate::model::HlsPlaylistSettings>,
    /// <p>The name of the manifest for the channel that will appear in the channel output's playback URL.</p>
    #[doc(hidden)]
    pub manifest_name: std::option::Option<std::string::String>,
    /// <p>The URL used for playback by content players.</p>
    #[doc(hidden)]
    pub playback_url: std::option::Option<std::string::String>,
    /// <p>A string used to associate a package configuration source group with a channel output.</p>
    #[doc(hidden)]
    pub source_group: std::option::Option<std::string::String>,
}
impl ResponseOutputItem {
    /// <p>DASH manifest configuration settings.</p>
    pub fn dash_playlist_settings(
        &self,
    ) -> std::option::Option<&crate::model::DashPlaylistSettings> {
        self.dash_playlist_settings.as_ref()
    }
    /// <p>HLS manifest configuration settings.</p>
    pub fn hls_playlist_settings(&self) -> std::option::Option<&crate::model::HlsPlaylistSettings> {
        self.hls_playlist_settings.as_ref()
    }
    /// <p>The name of the manifest for the channel that will appear in the channel output's playback URL.</p>
    pub fn manifest_name(&self) -> std::option::Option<&str> {
        self.manifest_name.as_deref()
    }
    /// <p>The URL used for playback by content players.</p>
    pub fn playback_url(&self) -> std::option::Option<&str> {
        self.playback_url.as_deref()
    }
    /// <p>A string used to associate a package configuration source group with a channel output.</p>
    pub fn source_group(&self) -> std::option::Option<&str> {
        self.source_group.as_deref()
    }
}
impl ResponseOutputItem {
    /// Creates a new builder-style object to manufacture [`ResponseOutputItem`](crate::model::ResponseOutputItem).
    pub fn builder() -> crate::model::response_output_item::Builder {
        crate::model::response_output_item::Builder::default()
    }
}

/// See [`ResponseOutputItem`](crate::model::ResponseOutputItem).
pub mod response_output_item {

    /// A builder for [`ResponseOutputItem`](crate::model::ResponseOutputItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dash_playlist_settings: std::option::Option<crate::model::DashPlaylistSettings>,
        pub(crate) hls_playlist_settings: std::option::Option<crate::model::HlsPlaylistSettings>,
        pub(crate) manifest_name: std::option::Option<std::string::String>,
        pub(crate) playback_url: std::option::Option<std::string::String>,
        pub(crate) source_group: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>DASH manifest configuration settings.</p>
        pub fn dash_playlist_settings(mut self, input: crate::model::DashPlaylistSettings) -> Self {
            self.dash_playlist_settings = Some(input);
            self
        }
        /// <p>DASH manifest configuration settings.</p>
        pub fn set_dash_playlist_settings(
            mut self,
            input: std::option::Option<crate::model::DashPlaylistSettings>,
        ) -> Self {
            self.dash_playlist_settings = input;
            self
        }
        /// <p>HLS manifest configuration settings.</p>
        pub fn hls_playlist_settings(mut self, input: crate::model::HlsPlaylistSettings) -> Self {
            self.hls_playlist_settings = Some(input);
            self
        }
        /// <p>HLS manifest configuration settings.</p>
        pub fn set_hls_playlist_settings(
            mut self,
            input: std::option::Option<crate::model::HlsPlaylistSettings>,
        ) -> Self {
            self.hls_playlist_settings = input;
            self
        }
        /// <p>The name of the manifest for the channel that will appear in the channel output's playback URL.</p>
        pub fn manifest_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.manifest_name = Some(input.into());
            self
        }
        /// <p>The name of the manifest for the channel that will appear in the channel output's playback URL.</p>
        pub fn set_manifest_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.manifest_name = input;
            self
        }
        /// <p>The URL used for playback by content players.</p>
        pub fn playback_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.playback_url = Some(input.into());
            self
        }
        /// <p>The URL used for playback by content players.</p>
        pub fn set_playback_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.playback_url = input;
            self
        }
        /// <p>A string used to associate a package configuration source group with a channel output.</p>
        pub fn source_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_group = Some(input.into());
            self
        }
        /// <p>A string used to associate a package configuration source group with a channel output.</p>
        pub fn set_source_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_group = input;
            self
        }
        /// Consumes the builder and constructs a [`ResponseOutputItem`](crate::model::ResponseOutputItem).
        pub fn build(self) -> crate::model::ResponseOutputItem {
            crate::model::ResponseOutputItem {
                dash_playlist_settings: self.dash_playlist_settings,
                hls_playlist_settings: self.hls_playlist_settings,
                manifest_name: self.manifest_name,
                playback_url: self.playback_url,
                source_group: self.source_group,
            }
        }
    }
}

/// <p>HLS playlist configuration parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HlsPlaylistSettings {
    /// <p>The total duration (in seconds) of each manifest. Minimum value: <code>30</code> seconds. Maximum value: <code>3600</code> seconds.</p>
    #[doc(hidden)]
    pub manifest_window_seconds: i32,
}
impl HlsPlaylistSettings {
    /// <p>The total duration (in seconds) of each manifest. Minimum value: <code>30</code> seconds. Maximum value: <code>3600</code> seconds.</p>
    pub fn manifest_window_seconds(&self) -> i32 {
        self.manifest_window_seconds
    }
}
impl HlsPlaylistSettings {
    /// Creates a new builder-style object to manufacture [`HlsPlaylistSettings`](crate::model::HlsPlaylistSettings).
    pub fn builder() -> crate::model::hls_playlist_settings::Builder {
        crate::model::hls_playlist_settings::Builder::default()
    }
}

/// See [`HlsPlaylistSettings`](crate::model::HlsPlaylistSettings).
pub mod hls_playlist_settings {

    /// A builder for [`HlsPlaylistSettings`](crate::model::HlsPlaylistSettings).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) manifest_window_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The total duration (in seconds) of each manifest. Minimum value: <code>30</code> seconds. Maximum value: <code>3600</code> seconds.</p>
        pub fn manifest_window_seconds(mut self, input: i32) -> Self {
            self.manifest_window_seconds = Some(input);
            self
        }
        /// <p>The total duration (in seconds) of each manifest. Minimum value: <code>30</code> seconds. Maximum value: <code>3600</code> seconds.</p>
        pub fn set_manifest_window_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.manifest_window_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`HlsPlaylistSettings`](crate::model::HlsPlaylistSettings).
        pub fn build(self) -> crate::model::HlsPlaylistSettings {
            crate::model::HlsPlaylistSettings {
                manifest_window_seconds: self.manifest_window_seconds.unwrap_or_default(),
            }
        }
    }
}

/// <p>Dash manifest configuration parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashPlaylistSettings {
    /// <p>The total duration (in seconds) of each manifest. Minimum value: <code>30</code> seconds. Maximum value: <code>3600</code> seconds.</p>
    #[doc(hidden)]
    pub manifest_window_seconds: i32,
    /// <p>Minimum amount of content (measured in seconds) that a player must keep available in the buffer. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
    #[doc(hidden)]
    pub min_buffer_time_seconds: i32,
    /// <p>Minimum amount of time (in seconds) that the player should wait before requesting updates to the manifest. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
    #[doc(hidden)]
    pub min_update_period_seconds: i32,
    /// <p>Amount of time (in seconds) that the player should be from the live point at the end of the manifest. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
    #[doc(hidden)]
    pub suggested_presentation_delay_seconds: i32,
}
impl DashPlaylistSettings {
    /// <p>The total duration (in seconds) of each manifest. Minimum value: <code>30</code> seconds. Maximum value: <code>3600</code> seconds.</p>
    pub fn manifest_window_seconds(&self) -> i32 {
        self.manifest_window_seconds
    }
    /// <p>Minimum amount of content (measured in seconds) that a player must keep available in the buffer. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
    pub fn min_buffer_time_seconds(&self) -> i32 {
        self.min_buffer_time_seconds
    }
    /// <p>Minimum amount of time (in seconds) that the player should wait before requesting updates to the manifest. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
    pub fn min_update_period_seconds(&self) -> i32 {
        self.min_update_period_seconds
    }
    /// <p>Amount of time (in seconds) that the player should be from the live point at the end of the manifest. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
    pub fn suggested_presentation_delay_seconds(&self) -> i32 {
        self.suggested_presentation_delay_seconds
    }
}
impl DashPlaylistSettings {
    /// Creates a new builder-style object to manufacture [`DashPlaylistSettings`](crate::model::DashPlaylistSettings).
    pub fn builder() -> crate::model::dash_playlist_settings::Builder {
        crate::model::dash_playlist_settings::Builder::default()
    }
}

/// See [`DashPlaylistSettings`](crate::model::DashPlaylistSettings).
pub mod dash_playlist_settings {

    /// A builder for [`DashPlaylistSettings`](crate::model::DashPlaylistSettings).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) manifest_window_seconds: std::option::Option<i32>,
        pub(crate) min_buffer_time_seconds: std::option::Option<i32>,
        pub(crate) min_update_period_seconds: std::option::Option<i32>,
        pub(crate) suggested_presentation_delay_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The total duration (in seconds) of each manifest. Minimum value: <code>30</code> seconds. Maximum value: <code>3600</code> seconds.</p>
        pub fn manifest_window_seconds(mut self, input: i32) -> Self {
            self.manifest_window_seconds = Some(input);
            self
        }
        /// <p>The total duration (in seconds) of each manifest. Minimum value: <code>30</code> seconds. Maximum value: <code>3600</code> seconds.</p>
        pub fn set_manifest_window_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.manifest_window_seconds = input;
            self
        }
        /// <p>Minimum amount of content (measured in seconds) that a player must keep available in the buffer. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
        pub fn min_buffer_time_seconds(mut self, input: i32) -> Self {
            self.min_buffer_time_seconds = Some(input);
            self
        }
        /// <p>Minimum amount of content (measured in seconds) that a player must keep available in the buffer. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
        pub fn set_min_buffer_time_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.min_buffer_time_seconds = input;
            self
        }
        /// <p>Minimum amount of time (in seconds) that the player should wait before requesting updates to the manifest. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
        pub fn min_update_period_seconds(mut self, input: i32) -> Self {
            self.min_update_period_seconds = Some(input);
            self
        }
        /// <p>Minimum amount of time (in seconds) that the player should wait before requesting updates to the manifest. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
        pub fn set_min_update_period_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.min_update_period_seconds = input;
            self
        }
        /// <p>Amount of time (in seconds) that the player should be from the live point at the end of the manifest. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
        pub fn suggested_presentation_delay_seconds(mut self, input: i32) -> Self {
            self.suggested_presentation_delay_seconds = Some(input);
            self
        }
        /// <p>Amount of time (in seconds) that the player should be from the live point at the end of the manifest. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
        pub fn set_suggested_presentation_delay_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.suggested_presentation_delay_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`DashPlaylistSettings`](crate::model::DashPlaylistSettings).
        pub fn build(self) -> crate::model::DashPlaylistSettings {
            crate::model::DashPlaylistSettings {
                manifest_window_seconds: self.manifest_window_seconds.unwrap_or_default(),
                min_buffer_time_seconds: self.min_buffer_time_seconds.unwrap_or_default(),
                min_update_period_seconds: self.min_update_period_seconds.unwrap_or_default(),
                suggested_presentation_delay_seconds: self
                    .suggested_presentation_delay_seconds
                    .unwrap_or_default(),
            }
        }
    }
}

/// <p>Slate VOD source configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SlateSource {
    /// <p>The name of the source location where the slate VOD source is stored.</p>
    #[doc(hidden)]
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The slate VOD source name. The VOD source must already exist in a source location before it can be used for slate.</p>
    #[doc(hidden)]
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl SlateSource {
    /// <p>The name of the source location where the slate VOD source is stored.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The slate VOD source name. The VOD source must already exist in a source location before it can be used for slate.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl SlateSource {
    /// Creates a new builder-style object to manufacture [`SlateSource`](crate::model::SlateSource).
    pub fn builder() -> crate::model::slate_source::Builder {
        crate::model::slate_source::Builder::default()
    }
}

/// See [`SlateSource`](crate::model::SlateSource).
pub mod slate_source {

    /// A builder for [`SlateSource`](crate::model::SlateSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the source location where the slate VOD source is stored.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location where the slate VOD source is stored.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// <p>The slate VOD source name. The VOD source must already exist in a source location before it can be used for slate.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The slate VOD source name. The VOD source must already exist in a source location before it can be used for slate.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`SlateSource`](crate::model::SlateSource).
        pub fn build(self) -> crate::model::SlateSource {
            crate::model::SlateSource {
                source_location_name: self.source_location_name,
                vod_source_name: self.vod_source_name,
            }
        }
    }
}

/// When writing a match expression against `ChannelState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let channelstate = unimplemented!();
/// match channelstate {
///     ChannelState::Running => { /* ... */ },
///     ChannelState::Stopped => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `channelstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChannelState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChannelState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChannelState::NewFeature` is defined.
/// Specifically, when `channelstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChannelState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChannelState {
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ChannelState {
    fn from(s: &str) -> Self {
        match s {
            "RUNNING" => ChannelState::Running,
            "STOPPED" => ChannelState::Stopped,
            other => ChannelState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ChannelState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ChannelState::from(s))
    }
}
impl ChannelState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChannelState::Running => "RUNNING",
            ChannelState::Stopped => "STOPPED",
            ChannelState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["RUNNING", "STOPPED"]
    }
}
impl AsRef<str> for ChannelState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Tier`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tier = unimplemented!();
/// match tier {
///     Tier::Basic => { /* ... */ },
///     Tier::Standard => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tier` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Tier::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Tier::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Tier::NewFeature` is defined.
/// Specifically, when `tier` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Tier::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Tier {
    #[allow(missing_docs)] // documentation missing in model
    Basic,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Tier {
    fn from(s: &str) -> Self {
        match s {
            "BASIC" => Tier::Basic,
            "STANDARD" => Tier::Standard,
            other => Tier::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Tier {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Tier::from(s))
    }
}
impl Tier {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Tier::Basic => "BASIC",
            Tier::Standard => "STANDARD",
            Tier::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BASIC", "STANDARD"]
    }
}
impl AsRef<str> for Tier {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PlaybackMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let playbackmode = unimplemented!();
/// match playbackmode {
///     PlaybackMode::Linear => { /* ... */ },
///     PlaybackMode::Loop => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `playbackmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PlaybackMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PlaybackMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PlaybackMode::NewFeature` is defined.
/// Specifically, when `playbackmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PlaybackMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PlaybackMode {
    #[allow(missing_docs)] // documentation missing in model
    Linear,
    #[allow(missing_docs)] // documentation missing in model
    Loop,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PlaybackMode {
    fn from(s: &str) -> Self {
        match s {
            "LINEAR" => PlaybackMode::Linear,
            "LOOP" => PlaybackMode::Loop,
            other => PlaybackMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PlaybackMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PlaybackMode::from(s))
    }
}
impl PlaybackMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PlaybackMode::Linear => "LINEAR",
            PlaybackMode::Loop => "LOOP",
            PlaybackMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LINEAR", "LOOP"]
    }
}
impl AsRef<str> for PlaybackMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The output configuration for this channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RequestOutputItem {
    /// <p>DASH manifest configuration parameters.</p>
    #[doc(hidden)]
    pub dash_playlist_settings: std::option::Option<crate::model::DashPlaylistSettings>,
    /// <p>HLS playlist configuration parameters.</p>
    #[doc(hidden)]
    pub hls_playlist_settings: std::option::Option<crate::model::HlsPlaylistSettings>,
    /// <p>The name of the manifest for the channel. The name appears in the <code>PlaybackUrl</code>.</p>
    #[doc(hidden)]
    pub manifest_name: std::option::Option<std::string::String>,
    /// <p>A string used to match which <code>HttpPackageConfiguration</code> is used for each <code>VodSource</code>.</p>
    #[doc(hidden)]
    pub source_group: std::option::Option<std::string::String>,
}
impl RequestOutputItem {
    /// <p>DASH manifest configuration parameters.</p>
    pub fn dash_playlist_settings(
        &self,
    ) -> std::option::Option<&crate::model::DashPlaylistSettings> {
        self.dash_playlist_settings.as_ref()
    }
    /// <p>HLS playlist configuration parameters.</p>
    pub fn hls_playlist_settings(&self) -> std::option::Option<&crate::model::HlsPlaylistSettings> {
        self.hls_playlist_settings.as_ref()
    }
    /// <p>The name of the manifest for the channel. The name appears in the <code>PlaybackUrl</code>.</p>
    pub fn manifest_name(&self) -> std::option::Option<&str> {
        self.manifest_name.as_deref()
    }
    /// <p>A string used to match which <code>HttpPackageConfiguration</code> is used for each <code>VodSource</code>.</p>
    pub fn source_group(&self) -> std::option::Option<&str> {
        self.source_group.as_deref()
    }
}
impl RequestOutputItem {
    /// Creates a new builder-style object to manufacture [`RequestOutputItem`](crate::model::RequestOutputItem).
    pub fn builder() -> crate::model::request_output_item::Builder {
        crate::model::request_output_item::Builder::default()
    }
}

/// See [`RequestOutputItem`](crate::model::RequestOutputItem).
pub mod request_output_item {

    /// A builder for [`RequestOutputItem`](crate::model::RequestOutputItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dash_playlist_settings: std::option::Option<crate::model::DashPlaylistSettings>,
        pub(crate) hls_playlist_settings: std::option::Option<crate::model::HlsPlaylistSettings>,
        pub(crate) manifest_name: std::option::Option<std::string::String>,
        pub(crate) source_group: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>DASH manifest configuration parameters.</p>
        pub fn dash_playlist_settings(mut self, input: crate::model::DashPlaylistSettings) -> Self {
            self.dash_playlist_settings = Some(input);
            self
        }
        /// <p>DASH manifest configuration parameters.</p>
        pub fn set_dash_playlist_settings(
            mut self,
            input: std::option::Option<crate::model::DashPlaylistSettings>,
        ) -> Self {
            self.dash_playlist_settings = input;
            self
        }
        /// <p>HLS playlist configuration parameters.</p>
        pub fn hls_playlist_settings(mut self, input: crate::model::HlsPlaylistSettings) -> Self {
            self.hls_playlist_settings = Some(input);
            self
        }
        /// <p>HLS playlist configuration parameters.</p>
        pub fn set_hls_playlist_settings(
            mut self,
            input: std::option::Option<crate::model::HlsPlaylistSettings>,
        ) -> Self {
            self.hls_playlist_settings = input;
            self
        }
        /// <p>The name of the manifest for the channel. The name appears in the <code>PlaybackUrl</code>.</p>
        pub fn manifest_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.manifest_name = Some(input.into());
            self
        }
        /// <p>The name of the manifest for the channel. The name appears in the <code>PlaybackUrl</code>.</p>
        pub fn set_manifest_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.manifest_name = input;
            self
        }
        /// <p>A string used to match which <code>HttpPackageConfiguration</code> is used for each <code>VodSource</code>.</p>
        pub fn source_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_group = Some(input.into());
            self
        }
        /// <p>A string used to match which <code>HttpPackageConfiguration</code> is used for each <code>VodSource</code>.</p>
        pub fn set_source_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_group = input;
            self
        }
        /// Consumes the builder and constructs a [`RequestOutputItem`](crate::model::RequestOutputItem).
        pub fn build(self) -> crate::model::RequestOutputItem {
            crate::model::RequestOutputItem {
                dash_playlist_settings: self.dash_playlist_settings,
                hls_playlist_settings: self.hls_playlist_settings,
                manifest_name: self.manifest_name,
                source_group: self.source_group,
            }
        }
    }
}

/// <p>The configuration parameters for a channel. For information about MediaTailor channels, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-channels.html">Working with channels</a> in the <i>MediaTailor User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Channel {
    /// <p>The ARN of the channel.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the channel.</p>
    #[doc(hidden)]
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>Returns the state whether the channel is running or not.</p>
    #[doc(hidden)]
    pub channel_state: std::option::Option<std::string::String>,
    /// <p>The timestamp of when the channel was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the <code>LINEAR</code> <code>PlaybackMode</code>. MediaTailor doesn't support filler slate for channels using the <code>LOOP</code> <code>PlaybackMode</code>.</p>
    #[doc(hidden)]
    pub filler_slate: std::option::Option<crate::model::SlateSource>,
    /// <p>The timestamp of when the channel was last modified.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The channel's output properties.</p>
    #[doc(hidden)]
    pub outputs: std::option::Option<std::vec::Vec<crate::model::ResponseOutputItem>>,
    /// <p>The type of playback mode for this channel.</p>
    /// <p> <code>LINEAR</code> - Programs play back-to-back only once.</p>
    /// <p> <code>LOOP</code> - Programs play back-to-back in an endless loop. When the last program in the schedule plays, playback loops back to the first program in the schedule.</p>
    #[doc(hidden)]
    pub playback_mode: std::option::Option<std::string::String>,
    /// <p>The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The tier for this channel. STANDARD tier channels can contain live programs.</p>
    #[doc(hidden)]
    pub tier: std::option::Option<std::string::String>,
}
impl Channel {
    /// <p>The ARN of the channel.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the channel.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>Returns the state whether the channel is running or not.</p>
    pub fn channel_state(&self) -> std::option::Option<&str> {
        self.channel_state.as_deref()
    }
    /// <p>The timestamp of when the channel was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the <code>LINEAR</code> <code>PlaybackMode</code>. MediaTailor doesn't support filler slate for channels using the <code>LOOP</code> <code>PlaybackMode</code>.</p>
    pub fn filler_slate(&self) -> std::option::Option<&crate::model::SlateSource> {
        self.filler_slate.as_ref()
    }
    /// <p>The timestamp of when the channel was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The channel's output properties.</p>
    pub fn outputs(&self) -> std::option::Option<&[crate::model::ResponseOutputItem]> {
        self.outputs.as_deref()
    }
    /// <p>The type of playback mode for this channel.</p>
    /// <p> <code>LINEAR</code> - Programs play back-to-back only once.</p>
    /// <p> <code>LOOP</code> - Programs play back-to-back in an endless loop. When the last program in the schedule plays, playback loops back to the first program in the schedule.</p>
    pub fn playback_mode(&self) -> std::option::Option<&str> {
        self.playback_mode.as_deref()
    }
    /// <p>The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The tier for this channel. STANDARD tier channels can contain live programs.</p>
    pub fn tier(&self) -> std::option::Option<&str> {
        self.tier.as_deref()
    }
}
impl Channel {
    /// Creates a new builder-style object to manufacture [`Channel`](crate::model::Channel).
    pub fn builder() -> crate::model::channel::Builder {
        crate::model::channel::Builder::default()
    }
}

/// See [`Channel`](crate::model::Channel).
pub mod channel {

    /// A builder for [`Channel`](crate::model::Channel).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) channel_state: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) filler_slate: std::option::Option<crate::model::SlateSource>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) outputs: std::option::Option<std::vec::Vec<crate::model::ResponseOutputItem>>,
        pub(crate) playback_mode: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) tier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the channel.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The name of the channel.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>Returns the state whether the channel is running or not.</p>
        pub fn channel_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_state = Some(input.into());
            self
        }
        /// <p>Returns the state whether the channel is running or not.</p>
        pub fn set_channel_state(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.channel_state = input;
            self
        }
        /// <p>The timestamp of when the channel was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp of when the channel was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the <code>LINEAR</code> <code>PlaybackMode</code>. MediaTailor doesn't support filler slate for channels using the <code>LOOP</code> <code>PlaybackMode</code>.</p>
        pub fn filler_slate(mut self, input: crate::model::SlateSource) -> Self {
            self.filler_slate = Some(input);
            self
        }
        /// <p>The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the <code>LINEAR</code> <code>PlaybackMode</code>. MediaTailor doesn't support filler slate for channels using the <code>LOOP</code> <code>PlaybackMode</code>.</p>
        pub fn set_filler_slate(
            mut self,
            input: std::option::Option<crate::model::SlateSource>,
        ) -> Self {
            self.filler_slate = input;
            self
        }
        /// <p>The timestamp of when the channel was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp of when the channel was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Appends an item to `outputs`.
        ///
        /// To override the contents of this collection use [`set_outputs`](Self::set_outputs).
        ///
        /// <p>The channel's output properties.</p>
        pub fn outputs(mut self, input: crate::model::ResponseOutputItem) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(input);
            self.outputs = Some(v);
            self
        }
        /// <p>The channel's output properties.</p>
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResponseOutputItem>>,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// <p>The type of playback mode for this channel.</p>
        /// <p> <code>LINEAR</code> - Programs play back-to-back only once.</p>
        /// <p> <code>LOOP</code> - Programs play back-to-back in an endless loop. When the last program in the schedule plays, playback loops back to the first program in the schedule.</p>
        pub fn playback_mode(mut self, input: impl Into<std::string::String>) -> Self {
            self.playback_mode = Some(input.into());
            self
        }
        /// <p>The type of playback mode for this channel.</p>
        /// <p> <code>LINEAR</code> - Programs play back-to-back only once.</p>
        /// <p> <code>LOOP</code> - Programs play back-to-back in an endless loop. When the last program in the schedule plays, playback loops back to the first program in the schedule.</p>
        pub fn set_playback_mode(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_mode = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The tier for this channel. STANDARD tier channels can contain live programs.</p>
        pub fn tier(mut self, input: impl Into<std::string::String>) -> Self {
            self.tier = Some(input.into());
            self
        }
        /// <p>The tier for this channel. STANDARD tier channels can contain live programs.</p>
        pub fn set_tier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tier = input;
            self
        }
        /// Consumes the builder and constructs a [`Channel`](crate::model::Channel).
        pub fn build(self) -> crate::model::Channel {
            crate::model::Channel {
                arn: self.arn,
                channel_name: self.channel_name,
                channel_state: self.channel_state,
                creation_time: self.creation_time,
                filler_slate: self.filler_slate,
                last_modified_time: self.last_modified_time,
                outputs: self.outputs,
                playback_mode: self.playback_mode,
                tags: self.tags,
                tier: self.tier,
            }
        }
    }
}

/// <p>Ad break configuration parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AdBreak {
    /// <p>The SCTE-35 ad insertion type. Accepted value: <code>SPLICE_INSERT</code>, <code>TIME_SIGNAL</code>.</p>
    #[doc(hidden)]
    pub message_type: std::option::Option<crate::model::MessageType>,
    /// <p>How long (in milliseconds) after the beginning of the program that an ad starts. This value must fall within 100ms of a segment boundary, otherwise the ad break will be skipped.</p>
    #[doc(hidden)]
    pub offset_millis: i64,
    /// <p>Ad break slate configuration.</p>
    #[doc(hidden)]
    pub slate: std::option::Option<crate::model::SlateSource>,
    /// <p>This defines the SCTE-35 <code>splice_insert()</code> message inserted around the ad. For information about using <code>splice_insert()</code>, see the SCTE-35 specficiaiton, section 9.7.3.1.</p>
    #[doc(hidden)]
    pub splice_insert_message: std::option::Option<crate::model::SpliceInsertMessage>,
    /// <p>Defines the SCTE-35 <code>time_signal</code> message inserted around the ad.</p>
    /// <p>Programs on a channel's schedule can be configured with one or more ad breaks. You can attach a <code>splice_insert</code> SCTE-35 message to the ad break. This message provides basic metadata about the ad break.</p>
    /// <p>See section 9.7.4 of the 2022 SCTE-35 specification for more information.</p>
    #[doc(hidden)]
    pub time_signal_message: std::option::Option<crate::model::TimeSignalMessage>,
}
impl AdBreak {
    /// <p>The SCTE-35 ad insertion type. Accepted value: <code>SPLICE_INSERT</code>, <code>TIME_SIGNAL</code>.</p>
    pub fn message_type(&self) -> std::option::Option<&crate::model::MessageType> {
        self.message_type.as_ref()
    }
    /// <p>How long (in milliseconds) after the beginning of the program that an ad starts. This value must fall within 100ms of a segment boundary, otherwise the ad break will be skipped.</p>
    pub fn offset_millis(&self) -> i64 {
        self.offset_millis
    }
    /// <p>Ad break slate configuration.</p>
    pub fn slate(&self) -> std::option::Option<&crate::model::SlateSource> {
        self.slate.as_ref()
    }
    /// <p>This defines the SCTE-35 <code>splice_insert()</code> message inserted around the ad. For information about using <code>splice_insert()</code>, see the SCTE-35 specficiaiton, section 9.7.3.1.</p>
    pub fn splice_insert_message(&self) -> std::option::Option<&crate::model::SpliceInsertMessage> {
        self.splice_insert_message.as_ref()
    }
    /// <p>Defines the SCTE-35 <code>time_signal</code> message inserted around the ad.</p>
    /// <p>Programs on a channel's schedule can be configured with one or more ad breaks. You can attach a <code>splice_insert</code> SCTE-35 message to the ad break. This message provides basic metadata about the ad break.</p>
    /// <p>See section 9.7.4 of the 2022 SCTE-35 specification for more information.</p>
    pub fn time_signal_message(&self) -> std::option::Option<&crate::model::TimeSignalMessage> {
        self.time_signal_message.as_ref()
    }
}
impl AdBreak {
    /// Creates a new builder-style object to manufacture [`AdBreak`](crate::model::AdBreak).
    pub fn builder() -> crate::model::ad_break::Builder {
        crate::model::ad_break::Builder::default()
    }
}

/// See [`AdBreak`](crate::model::AdBreak).
pub mod ad_break {

    /// A builder for [`AdBreak`](crate::model::AdBreak).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message_type: std::option::Option<crate::model::MessageType>,
        pub(crate) offset_millis: std::option::Option<i64>,
        pub(crate) slate: std::option::Option<crate::model::SlateSource>,
        pub(crate) splice_insert_message: std::option::Option<crate::model::SpliceInsertMessage>,
        pub(crate) time_signal_message: std::option::Option<crate::model::TimeSignalMessage>,
    }
    impl Builder {
        /// <p>The SCTE-35 ad insertion type. Accepted value: <code>SPLICE_INSERT</code>, <code>TIME_SIGNAL</code>.</p>
        pub fn message_type(mut self, input: crate::model::MessageType) -> Self {
            self.message_type = Some(input);
            self
        }
        /// <p>The SCTE-35 ad insertion type. Accepted value: <code>SPLICE_INSERT</code>, <code>TIME_SIGNAL</code>.</p>
        pub fn set_message_type(
            mut self,
            input: std::option::Option<crate::model::MessageType>,
        ) -> Self {
            self.message_type = input;
            self
        }
        /// <p>How long (in milliseconds) after the beginning of the program that an ad starts. This value must fall within 100ms of a segment boundary, otherwise the ad break will be skipped.</p>
        pub fn offset_millis(mut self, input: i64) -> Self {
            self.offset_millis = Some(input);
            self
        }
        /// <p>How long (in milliseconds) after the beginning of the program that an ad starts. This value must fall within 100ms of a segment boundary, otherwise the ad break will be skipped.</p>
        pub fn set_offset_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.offset_millis = input;
            self
        }
        /// <p>Ad break slate configuration.</p>
        pub fn slate(mut self, input: crate::model::SlateSource) -> Self {
            self.slate = Some(input);
            self
        }
        /// <p>Ad break slate configuration.</p>
        pub fn set_slate(mut self, input: std::option::Option<crate::model::SlateSource>) -> Self {
            self.slate = input;
            self
        }
        /// <p>This defines the SCTE-35 <code>splice_insert()</code> message inserted around the ad. For information about using <code>splice_insert()</code>, see the SCTE-35 specficiaiton, section 9.7.3.1.</p>
        pub fn splice_insert_message(mut self, input: crate::model::SpliceInsertMessage) -> Self {
            self.splice_insert_message = Some(input);
            self
        }
        /// <p>This defines the SCTE-35 <code>splice_insert()</code> message inserted around the ad. For information about using <code>splice_insert()</code>, see the SCTE-35 specficiaiton, section 9.7.3.1.</p>
        pub fn set_splice_insert_message(
            mut self,
            input: std::option::Option<crate::model::SpliceInsertMessage>,
        ) -> Self {
            self.splice_insert_message = input;
            self
        }
        /// <p>Defines the SCTE-35 <code>time_signal</code> message inserted around the ad.</p>
        /// <p>Programs on a channel's schedule can be configured with one or more ad breaks. You can attach a <code>splice_insert</code> SCTE-35 message to the ad break. This message provides basic metadata about the ad break.</p>
        /// <p>See section 9.7.4 of the 2022 SCTE-35 specification for more information.</p>
        pub fn time_signal_message(mut self, input: crate::model::TimeSignalMessage) -> Self {
            self.time_signal_message = Some(input);
            self
        }
        /// <p>Defines the SCTE-35 <code>time_signal</code> message inserted around the ad.</p>
        /// <p>Programs on a channel's schedule can be configured with one or more ad breaks. You can attach a <code>splice_insert</code> SCTE-35 message to the ad break. This message provides basic metadata about the ad break.</p>
        /// <p>See section 9.7.4 of the 2022 SCTE-35 specification for more information.</p>
        pub fn set_time_signal_message(
            mut self,
            input: std::option::Option<crate::model::TimeSignalMessage>,
        ) -> Self {
            self.time_signal_message = input;
            self
        }
        /// Consumes the builder and constructs a [`AdBreak`](crate::model::AdBreak).
        pub fn build(self) -> crate::model::AdBreak {
            crate::model::AdBreak {
                message_type: self.message_type,
                offset_millis: self.offset_millis.unwrap_or_default(),
                slate: self.slate,
                splice_insert_message: self.splice_insert_message,
                time_signal_message: self.time_signal_message,
            }
        }
    }
}

/// <p>The SCTE-35 <code>time_signal</code> message can be sent with one or more <code>segmentation_descriptor</code> messages. A <code>time_signal</code> message can be sent only if a single <code>segmentation_descriptor</code> message is sent.</p>
/// <p>The <code>time_signal</code> message contains only the <code>splice_time</code> field which is constructed using a given presentation timestamp. When sending a <code>time_signal</code> message, the <code>splice_command_type</code> field in the <code>splice_info_section</code> message is set to 6 (0x06).</p>
/// <p>See the <code>time_signal()</code> table of the 2022 SCTE-35 specification for more information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeSignalMessage {
    /// <p>The configurations for the SCTE-35 <code>segmentation_descriptor</code> message(s) sent with the <code>time_signal</code> message.</p>
    #[doc(hidden)]
    pub segmentation_descriptors:
        std::option::Option<std::vec::Vec<crate::model::SegmentationDescriptor>>,
}
impl TimeSignalMessage {
    /// <p>The configurations for the SCTE-35 <code>segmentation_descriptor</code> message(s) sent with the <code>time_signal</code> message.</p>
    pub fn segmentation_descriptors(
        &self,
    ) -> std::option::Option<&[crate::model::SegmentationDescriptor]> {
        self.segmentation_descriptors.as_deref()
    }
}
impl TimeSignalMessage {
    /// Creates a new builder-style object to manufacture [`TimeSignalMessage`](crate::model::TimeSignalMessage).
    pub fn builder() -> crate::model::time_signal_message::Builder {
        crate::model::time_signal_message::Builder::default()
    }
}

/// See [`TimeSignalMessage`](crate::model::TimeSignalMessage).
pub mod time_signal_message {

    /// A builder for [`TimeSignalMessage`](crate::model::TimeSignalMessage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) segmentation_descriptors:
            std::option::Option<std::vec::Vec<crate::model::SegmentationDescriptor>>,
    }
    impl Builder {
        /// Appends an item to `segmentation_descriptors`.
        ///
        /// To override the contents of this collection use [`set_segmentation_descriptors`](Self::set_segmentation_descriptors).
        ///
        /// <p>The configurations for the SCTE-35 <code>segmentation_descriptor</code> message(s) sent with the <code>time_signal</code> message.</p>
        pub fn segmentation_descriptors(
            mut self,
            input: crate::model::SegmentationDescriptor,
        ) -> Self {
            let mut v = self.segmentation_descriptors.unwrap_or_default();
            v.push(input);
            self.segmentation_descriptors = Some(v);
            self
        }
        /// <p>The configurations for the SCTE-35 <code>segmentation_descriptor</code> message(s) sent with the <code>time_signal</code> message.</p>
        pub fn set_segmentation_descriptors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SegmentationDescriptor>>,
        ) -> Self {
            self.segmentation_descriptors = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeSignalMessage`](crate::model::TimeSignalMessage).
        pub fn build(self) -> crate::model::TimeSignalMessage {
            crate::model::TimeSignalMessage {
                segmentation_descriptors: self.segmentation_descriptors,
            }
        }
    }
}

/// <p>The <code>segmentation_descriptor</code> message can contain advanced metadata fields, like content identifiers, to convey a wide range of information about the ad break. MediaTailor writes the ad metadata in the egress manifest as part of the <code>EXT-X-DATERANGE</code> or <code>EventStream</code> ad marker's SCTE-35 data.</p>
/// <p> <code>segmentation_descriptor</code> messages must be sent with the <code>time_signal</code> message type.</p>
/// <p>See the <code>segmentation_descriptor()</code> table of the 2022 SCTE-35 specification for more information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SegmentationDescriptor {
    /// <p>The Event Identifier to assign to the <code>segmentation_descriptor.segmentation_event_id</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The default value is 1.</p>
    #[doc(hidden)]
    pub segmentation_event_id: std::option::Option<i32>,
    /// <p>The Upid Type to assign to the <code>segmentation_descriptor.segmentation_upid_type</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 14.</p>
    #[doc(hidden)]
    pub segmentation_upid_type: std::option::Option<i32>,
    /// <p>The Upid to assign to the <code>segmentation_descriptor.segmentation_upid</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The value must be a hexadecimal string containing only the characters 0 though 9 and A through F. The default value is "" (an empty string).</p>
    #[doc(hidden)]
    pub segmentation_upid: std::option::Option<std::string::String>,
    /// <p>The Type Identifier to assign to the <code>segmentation_descriptor.segmentation_type_id</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 48.</p>
    #[doc(hidden)]
    pub segmentation_type_id: std::option::Option<i32>,
    /// <p>The segment number to assign to the <code>segmentation_descriptor.segment_num</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.</p>
    #[doc(hidden)]
    pub segment_num: std::option::Option<i32>,
    /// <p>The number of segments expected, which is assigned to the <code>segmentation_descriptor.segments_expectedS</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.</p>
    #[doc(hidden)]
    pub segments_expected: std::option::Option<i32>,
    /// <p>The sub-segment number to assign to the <code>segmentation_descriptor.sub_segment_num</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The defualt value is null.</p>
    #[doc(hidden)]
    pub sub_segment_num: std::option::Option<i32>,
    /// <p>The number of sub-segments expected, which is assigned to the <code>segmentation_descriptor.sub_segments_expected</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is null.</p>
    #[doc(hidden)]
    pub sub_segments_expected: std::option::Option<i32>,
}
impl SegmentationDescriptor {
    /// <p>The Event Identifier to assign to the <code>segmentation_descriptor.segmentation_event_id</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The default value is 1.</p>
    pub fn segmentation_event_id(&self) -> std::option::Option<i32> {
        self.segmentation_event_id
    }
    /// <p>The Upid Type to assign to the <code>segmentation_descriptor.segmentation_upid_type</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 14.</p>
    pub fn segmentation_upid_type(&self) -> std::option::Option<i32> {
        self.segmentation_upid_type
    }
    /// <p>The Upid to assign to the <code>segmentation_descriptor.segmentation_upid</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The value must be a hexadecimal string containing only the characters 0 though 9 and A through F. The default value is "" (an empty string).</p>
    pub fn segmentation_upid(&self) -> std::option::Option<&str> {
        self.segmentation_upid.as_deref()
    }
    /// <p>The Type Identifier to assign to the <code>segmentation_descriptor.segmentation_type_id</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 48.</p>
    pub fn segmentation_type_id(&self) -> std::option::Option<i32> {
        self.segmentation_type_id
    }
    /// <p>The segment number to assign to the <code>segmentation_descriptor.segment_num</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.</p>
    pub fn segment_num(&self) -> std::option::Option<i32> {
        self.segment_num
    }
    /// <p>The number of segments expected, which is assigned to the <code>segmentation_descriptor.segments_expectedS</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.</p>
    pub fn segments_expected(&self) -> std::option::Option<i32> {
        self.segments_expected
    }
    /// <p>The sub-segment number to assign to the <code>segmentation_descriptor.sub_segment_num</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The defualt value is null.</p>
    pub fn sub_segment_num(&self) -> std::option::Option<i32> {
        self.sub_segment_num
    }
    /// <p>The number of sub-segments expected, which is assigned to the <code>segmentation_descriptor.sub_segments_expected</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is null.</p>
    pub fn sub_segments_expected(&self) -> std::option::Option<i32> {
        self.sub_segments_expected
    }
}
impl SegmentationDescriptor {
    /// Creates a new builder-style object to manufacture [`SegmentationDescriptor`](crate::model::SegmentationDescriptor).
    pub fn builder() -> crate::model::segmentation_descriptor::Builder {
        crate::model::segmentation_descriptor::Builder::default()
    }
}

/// See [`SegmentationDescriptor`](crate::model::SegmentationDescriptor).
pub mod segmentation_descriptor {

    /// A builder for [`SegmentationDescriptor`](crate::model::SegmentationDescriptor).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) segmentation_event_id: std::option::Option<i32>,
        pub(crate) segmentation_upid_type: std::option::Option<i32>,
        pub(crate) segmentation_upid: std::option::Option<std::string::String>,
        pub(crate) segmentation_type_id: std::option::Option<i32>,
        pub(crate) segment_num: std::option::Option<i32>,
        pub(crate) segments_expected: std::option::Option<i32>,
        pub(crate) sub_segment_num: std::option::Option<i32>,
        pub(crate) sub_segments_expected: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Event Identifier to assign to the <code>segmentation_descriptor.segmentation_event_id</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The default value is 1.</p>
        pub fn segmentation_event_id(mut self, input: i32) -> Self {
            self.segmentation_event_id = Some(input);
            self
        }
        /// <p>The Event Identifier to assign to the <code>segmentation_descriptor.segmentation_event_id</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The default value is 1.</p>
        pub fn set_segmentation_event_id(mut self, input: std::option::Option<i32>) -> Self {
            self.segmentation_event_id = input;
            self
        }
        /// <p>The Upid Type to assign to the <code>segmentation_descriptor.segmentation_upid_type</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 14.</p>
        pub fn segmentation_upid_type(mut self, input: i32) -> Self {
            self.segmentation_upid_type = Some(input);
            self
        }
        /// <p>The Upid Type to assign to the <code>segmentation_descriptor.segmentation_upid_type</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 14.</p>
        pub fn set_segmentation_upid_type(mut self, input: std::option::Option<i32>) -> Self {
            self.segmentation_upid_type = input;
            self
        }
        /// <p>The Upid to assign to the <code>segmentation_descriptor.segmentation_upid</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The value must be a hexadecimal string containing only the characters 0 though 9 and A through F. The default value is "" (an empty string).</p>
        pub fn segmentation_upid(mut self, input: impl Into<std::string::String>) -> Self {
            self.segmentation_upid = Some(input.into());
            self
        }
        /// <p>The Upid to assign to the <code>segmentation_descriptor.segmentation_upid</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The value must be a hexadecimal string containing only the characters 0 though 9 and A through F. The default value is "" (an empty string).</p>
        pub fn set_segmentation_upid(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.segmentation_upid = input;
            self
        }
        /// <p>The Type Identifier to assign to the <code>segmentation_descriptor.segmentation_type_id</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 48.</p>
        pub fn segmentation_type_id(mut self, input: i32) -> Self {
            self.segmentation_type_id = Some(input);
            self
        }
        /// <p>The Type Identifier to assign to the <code>segmentation_descriptor.segmentation_type_id</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 48.</p>
        pub fn set_segmentation_type_id(mut self, input: std::option::Option<i32>) -> Self {
            self.segmentation_type_id = input;
            self
        }
        /// <p>The segment number to assign to the <code>segmentation_descriptor.segment_num</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.</p>
        pub fn segment_num(mut self, input: i32) -> Self {
            self.segment_num = Some(input);
            self
        }
        /// <p>The segment number to assign to the <code>segmentation_descriptor.segment_num</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.</p>
        pub fn set_segment_num(mut self, input: std::option::Option<i32>) -> Self {
            self.segment_num = input;
            self
        }
        /// <p>The number of segments expected, which is assigned to the <code>segmentation_descriptor.segments_expectedS</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.</p>
        pub fn segments_expected(mut self, input: i32) -> Self {
            self.segments_expected = Some(input);
            self
        }
        /// <p>The number of segments expected, which is assigned to the <code>segmentation_descriptor.segments_expectedS</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.</p>
        pub fn set_segments_expected(mut self, input: std::option::Option<i32>) -> Self {
            self.segments_expected = input;
            self
        }
        /// <p>The sub-segment number to assign to the <code>segmentation_descriptor.sub_segment_num</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The defualt value is null.</p>
        pub fn sub_segment_num(mut self, input: i32) -> Self {
            self.sub_segment_num = Some(input);
            self
        }
        /// <p>The sub-segment number to assign to the <code>segmentation_descriptor.sub_segment_num</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The defualt value is null.</p>
        pub fn set_sub_segment_num(mut self, input: std::option::Option<i32>) -> Self {
            self.sub_segment_num = input;
            self
        }
        /// <p>The number of sub-segments expected, which is assigned to the <code>segmentation_descriptor.sub_segments_expected</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is null.</p>
        pub fn sub_segments_expected(mut self, input: i32) -> Self {
            self.sub_segments_expected = Some(input);
            self
        }
        /// <p>The number of sub-segments expected, which is assigned to the <code>segmentation_descriptor.sub_segments_expected</code> message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is null.</p>
        pub fn set_sub_segments_expected(mut self, input: std::option::Option<i32>) -> Self {
            self.sub_segments_expected = input;
            self
        }
        /// Consumes the builder and constructs a [`SegmentationDescriptor`](crate::model::SegmentationDescriptor).
        pub fn build(self) -> crate::model::SegmentationDescriptor {
            crate::model::SegmentationDescriptor {
                segmentation_event_id: self.segmentation_event_id,
                segmentation_upid_type: self.segmentation_upid_type,
                segmentation_upid: self.segmentation_upid,
                segmentation_type_id: self.segmentation_type_id,
                segment_num: self.segment_num,
                segments_expected: self.segments_expected,
                sub_segment_num: self.sub_segment_num,
                sub_segments_expected: self.sub_segments_expected,
            }
        }
    }
}

/// <p>Splice insert message configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SpliceInsertMessage {
    /// <p>This is written to <code>splice_insert.avail_num</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>0</code>. Values must be between <code>0</code> and <code>256</code>, inclusive.</p>
    #[doc(hidden)]
    pub avail_num: i32,
    /// <p>This is written to <code>splice_insert.avails_expected</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>0</code>. Values must be between <code>0</code> and <code>256</code>, inclusive.</p>
    #[doc(hidden)]
    pub avails_expected: i32,
    /// <p>This is written to <code>splice_insert.splice_event_id</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>1</code>.</p>
    #[doc(hidden)]
    pub splice_event_id: i32,
    /// <p>This is written to <code>splice_insert.unique_program_id</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>0</code>. Values must be between <code>0</code> and <code>256</code>, inclusive.</p>
    #[doc(hidden)]
    pub unique_program_id: i32,
}
impl SpliceInsertMessage {
    /// <p>This is written to <code>splice_insert.avail_num</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>0</code>. Values must be between <code>0</code> and <code>256</code>, inclusive.</p>
    pub fn avail_num(&self) -> i32 {
        self.avail_num
    }
    /// <p>This is written to <code>splice_insert.avails_expected</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>0</code>. Values must be between <code>0</code> and <code>256</code>, inclusive.</p>
    pub fn avails_expected(&self) -> i32 {
        self.avails_expected
    }
    /// <p>This is written to <code>splice_insert.splice_event_id</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>1</code>.</p>
    pub fn splice_event_id(&self) -> i32 {
        self.splice_event_id
    }
    /// <p>This is written to <code>splice_insert.unique_program_id</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>0</code>. Values must be between <code>0</code> and <code>256</code>, inclusive.</p>
    pub fn unique_program_id(&self) -> i32 {
        self.unique_program_id
    }
}
impl SpliceInsertMessage {
    /// Creates a new builder-style object to manufacture [`SpliceInsertMessage`](crate::model::SpliceInsertMessage).
    pub fn builder() -> crate::model::splice_insert_message::Builder {
        crate::model::splice_insert_message::Builder::default()
    }
}

/// See [`SpliceInsertMessage`](crate::model::SpliceInsertMessage).
pub mod splice_insert_message {

    /// A builder for [`SpliceInsertMessage`](crate::model::SpliceInsertMessage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) avail_num: std::option::Option<i32>,
        pub(crate) avails_expected: std::option::Option<i32>,
        pub(crate) splice_event_id: std::option::Option<i32>,
        pub(crate) unique_program_id: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>This is written to <code>splice_insert.avail_num</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>0</code>. Values must be between <code>0</code> and <code>256</code>, inclusive.</p>
        pub fn avail_num(mut self, input: i32) -> Self {
            self.avail_num = Some(input);
            self
        }
        /// <p>This is written to <code>splice_insert.avail_num</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>0</code>. Values must be between <code>0</code> and <code>256</code>, inclusive.</p>
        pub fn set_avail_num(mut self, input: std::option::Option<i32>) -> Self {
            self.avail_num = input;
            self
        }
        /// <p>This is written to <code>splice_insert.avails_expected</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>0</code>. Values must be between <code>0</code> and <code>256</code>, inclusive.</p>
        pub fn avails_expected(mut self, input: i32) -> Self {
            self.avails_expected = Some(input);
            self
        }
        /// <p>This is written to <code>splice_insert.avails_expected</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>0</code>. Values must be between <code>0</code> and <code>256</code>, inclusive.</p>
        pub fn set_avails_expected(mut self, input: std::option::Option<i32>) -> Self {
            self.avails_expected = input;
            self
        }
        /// <p>This is written to <code>splice_insert.splice_event_id</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>1</code>.</p>
        pub fn splice_event_id(mut self, input: i32) -> Self {
            self.splice_event_id = Some(input);
            self
        }
        /// <p>This is written to <code>splice_insert.splice_event_id</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>1</code>.</p>
        pub fn set_splice_event_id(mut self, input: std::option::Option<i32>) -> Self {
            self.splice_event_id = input;
            self
        }
        /// <p>This is written to <code>splice_insert.unique_program_id</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>0</code>. Values must be between <code>0</code> and <code>256</code>, inclusive.</p>
        pub fn unique_program_id(mut self, input: i32) -> Self {
            self.unique_program_id = Some(input);
            self
        }
        /// <p>This is written to <code>splice_insert.unique_program_id</code>, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is <code>0</code>. Values must be between <code>0</code> and <code>256</code>, inclusive.</p>
        pub fn set_unique_program_id(mut self, input: std::option::Option<i32>) -> Self {
            self.unique_program_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SpliceInsertMessage`](crate::model::SpliceInsertMessage).
        pub fn build(self) -> crate::model::SpliceInsertMessage {
            crate::model::SpliceInsertMessage {
                avail_num: self.avail_num.unwrap_or_default(),
                avails_expected: self.avails_expected.unwrap_or_default(),
                splice_event_id: self.splice_event_id.unwrap_or_default(),
                unique_program_id: self.unique_program_id.unwrap_or_default(),
            }
        }
    }
}

/// When writing a match expression against `MessageType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let messagetype = unimplemented!();
/// match messagetype {
///     MessageType::SpliceInsert => { /* ... */ },
///     MessageType::TimeSignal => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `messagetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MessageType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MessageType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MessageType::NewFeature` is defined.
/// Specifically, when `messagetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MessageType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MessageType {
    #[allow(missing_docs)] // documentation missing in model
    SpliceInsert,
    #[allow(missing_docs)] // documentation missing in model
    TimeSignal,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MessageType {
    fn from(s: &str) -> Self {
        match s {
            "SPLICE_INSERT" => MessageType::SpliceInsert,
            "TIME_SIGNAL" => MessageType::TimeSignal,
            other => MessageType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MessageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MessageType::from(s))
    }
}
impl MessageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MessageType::SpliceInsert => "SPLICE_INSERT",
            MessageType::TimeSignal => "TIME_SIGNAL",
            MessageType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SPLICE_INSERT", "TIME_SIGNAL"]
    }
}
impl AsRef<str> for MessageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Schedule configuration parameters. A channel must be stopped before changes can be made to the schedule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScheduleConfiguration {
    /// <p>Program transition configurations.</p>
    #[doc(hidden)]
    pub transition: std::option::Option<crate::model::Transition>,
}
impl ScheduleConfiguration {
    /// <p>Program transition configurations.</p>
    pub fn transition(&self) -> std::option::Option<&crate::model::Transition> {
        self.transition.as_ref()
    }
}
impl ScheduleConfiguration {
    /// Creates a new builder-style object to manufacture [`ScheduleConfiguration`](crate::model::ScheduleConfiguration).
    pub fn builder() -> crate::model::schedule_configuration::Builder {
        crate::model::schedule_configuration::Builder::default()
    }
}

/// See [`ScheduleConfiguration`](crate::model::ScheduleConfiguration).
pub mod schedule_configuration {

    /// A builder for [`ScheduleConfiguration`](crate::model::ScheduleConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transition: std::option::Option<crate::model::Transition>,
    }
    impl Builder {
        /// <p>Program transition configurations.</p>
        pub fn transition(mut self, input: crate::model::Transition) -> Self {
            self.transition = Some(input);
            self
        }
        /// <p>Program transition configurations.</p>
        pub fn set_transition(
            mut self,
            input: std::option::Option<crate::model::Transition>,
        ) -> Self {
            self.transition = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduleConfiguration`](crate::model::ScheduleConfiguration).
        pub fn build(self) -> crate::model::ScheduleConfiguration {
            crate::model::ScheduleConfiguration {
                transition: self.transition,
            }
        }
    }
}

/// <p>Program transition configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Transition {
    /// <p>The duration of the live program in seconds.</p>
    #[doc(hidden)]
    pub duration_millis: i64,
    /// <p>The position where this program will be inserted relative to the <code>RelativePosition</code>.</p>
    #[doc(hidden)]
    pub relative_position: std::option::Option<crate::model::RelativePosition>,
    /// <p>The name of the program that this program will be inserted next to, as defined by <code>RelativePosition</code>.</p>
    #[doc(hidden)]
    pub relative_program: std::option::Option<std::string::String>,
    /// <p>The date and time that the program is scheduled to start, in epoch milliseconds.</p>
    #[doc(hidden)]
    pub scheduled_start_time_millis: i64,
    /// <p>Defines when the program plays in the schedule. You can set the value to <code>ABSOLUTE</code> or <code>RELATIVE</code>.</p>
    /// <p> <code>ABSOLUTE</code> - The program plays at a specific wall clock time. This setting can only be used for channels using the <code>LINEAR</code> <code>PlaybackMode</code>.</p>
    /// <p>Note the following considerations when using <code>ABSOLUTE</code> transitions:</p>
    /// <p>If the preceding program in the schedule has a duration that extends past the wall clock time, MediaTailor truncates the preceding program on a common segment boundary.</p>
    /// <p>If there are gaps in playback, MediaTailor plays the <code>FillerSlate</code> you configured for your linear channel.</p>
    /// <p> <code>RELATIVE</code> - The program is inserted into the schedule either before or after a program that you specify via <code>RelativePosition</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
}
impl Transition {
    /// <p>The duration of the live program in seconds.</p>
    pub fn duration_millis(&self) -> i64 {
        self.duration_millis
    }
    /// <p>The position where this program will be inserted relative to the <code>RelativePosition</code>.</p>
    pub fn relative_position(&self) -> std::option::Option<&crate::model::RelativePosition> {
        self.relative_position.as_ref()
    }
    /// <p>The name of the program that this program will be inserted next to, as defined by <code>RelativePosition</code>.</p>
    pub fn relative_program(&self) -> std::option::Option<&str> {
        self.relative_program.as_deref()
    }
    /// <p>The date and time that the program is scheduled to start, in epoch milliseconds.</p>
    pub fn scheduled_start_time_millis(&self) -> i64 {
        self.scheduled_start_time_millis
    }
    /// <p>Defines when the program plays in the schedule. You can set the value to <code>ABSOLUTE</code> or <code>RELATIVE</code>.</p>
    /// <p> <code>ABSOLUTE</code> - The program plays at a specific wall clock time. This setting can only be used for channels using the <code>LINEAR</code> <code>PlaybackMode</code>.</p>
    /// <p>Note the following considerations when using <code>ABSOLUTE</code> transitions:</p>
    /// <p>If the preceding program in the schedule has a duration that extends past the wall clock time, MediaTailor truncates the preceding program on a common segment boundary.</p>
    /// <p>If there are gaps in playback, MediaTailor plays the <code>FillerSlate</code> you configured for your linear channel.</p>
    /// <p> <code>RELATIVE</code> - The program is inserted into the schedule either before or after a program that you specify via <code>RelativePosition</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl Transition {
    /// Creates a new builder-style object to manufacture [`Transition`](crate::model::Transition).
    pub fn builder() -> crate::model::transition::Builder {
        crate::model::transition::Builder::default()
    }
}

/// See [`Transition`](crate::model::Transition).
pub mod transition {

    /// A builder for [`Transition`](crate::model::Transition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) duration_millis: std::option::Option<i64>,
        pub(crate) relative_position: std::option::Option<crate::model::RelativePosition>,
        pub(crate) relative_program: std::option::Option<std::string::String>,
        pub(crate) scheduled_start_time_millis: std::option::Option<i64>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The duration of the live program in seconds.</p>
        pub fn duration_millis(mut self, input: i64) -> Self {
            self.duration_millis = Some(input);
            self
        }
        /// <p>The duration of the live program in seconds.</p>
        pub fn set_duration_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.duration_millis = input;
            self
        }
        /// <p>The position where this program will be inserted relative to the <code>RelativePosition</code>.</p>
        pub fn relative_position(mut self, input: crate::model::RelativePosition) -> Self {
            self.relative_position = Some(input);
            self
        }
        /// <p>The position where this program will be inserted relative to the <code>RelativePosition</code>.</p>
        pub fn set_relative_position(
            mut self,
            input: std::option::Option<crate::model::RelativePosition>,
        ) -> Self {
            self.relative_position = input;
            self
        }
        /// <p>The name of the program that this program will be inserted next to, as defined by <code>RelativePosition</code>.</p>
        pub fn relative_program(mut self, input: impl Into<std::string::String>) -> Self {
            self.relative_program = Some(input.into());
            self
        }
        /// <p>The name of the program that this program will be inserted next to, as defined by <code>RelativePosition</code>.</p>
        pub fn set_relative_program(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relative_program = input;
            self
        }
        /// <p>The date and time that the program is scheduled to start, in epoch milliseconds.</p>
        pub fn scheduled_start_time_millis(mut self, input: i64) -> Self {
            self.scheduled_start_time_millis = Some(input);
            self
        }
        /// <p>The date and time that the program is scheduled to start, in epoch milliseconds.</p>
        pub fn set_scheduled_start_time_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.scheduled_start_time_millis = input;
            self
        }
        /// <p>Defines when the program plays in the schedule. You can set the value to <code>ABSOLUTE</code> or <code>RELATIVE</code>.</p>
        /// <p> <code>ABSOLUTE</code> - The program plays at a specific wall clock time. This setting can only be used for channels using the <code>LINEAR</code> <code>PlaybackMode</code>.</p>
        /// <p>Note the following considerations when using <code>ABSOLUTE</code> transitions:</p>
        /// <p>If the preceding program in the schedule has a duration that extends past the wall clock time, MediaTailor truncates the preceding program on a common segment boundary.</p>
        /// <p>If there are gaps in playback, MediaTailor plays the <code>FillerSlate</code> you configured for your linear channel.</p>
        /// <p> <code>RELATIVE</code> - The program is inserted into the schedule either before or after a program that you specify via <code>RelativePosition</code>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>Defines when the program plays in the schedule. You can set the value to <code>ABSOLUTE</code> or <code>RELATIVE</code>.</p>
        /// <p> <code>ABSOLUTE</code> - The program plays at a specific wall clock time. This setting can only be used for channels using the <code>LINEAR</code> <code>PlaybackMode</code>.</p>
        /// <p>Note the following considerations when using <code>ABSOLUTE</code> transitions:</p>
        /// <p>If the preceding program in the schedule has a duration that extends past the wall clock time, MediaTailor truncates the preceding program on a common segment boundary.</p>
        /// <p>If there are gaps in playback, MediaTailor plays the <code>FillerSlate</code> you configured for your linear channel.</p>
        /// <p> <code>RELATIVE</code> - The program is inserted into the schedule either before or after a program that you specify via <code>RelativePosition</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`Transition`](crate::model::Transition).
        pub fn build(self) -> crate::model::Transition {
            crate::model::Transition {
                duration_millis: self.duration_millis.unwrap_or_default(),
                relative_position: self.relative_position,
                relative_program: self.relative_program,
                scheduled_start_time_millis: self.scheduled_start_time_millis.unwrap_or_default(),
                r#type: self.r#type,
            }
        }
    }
}

/// When writing a match expression against `RelativePosition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let relativeposition = unimplemented!();
/// match relativeposition {
///     RelativePosition::AfterProgram => { /* ... */ },
///     RelativePosition::BeforeProgram => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `relativeposition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RelativePosition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RelativePosition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RelativePosition::NewFeature` is defined.
/// Specifically, when `relativeposition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RelativePosition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RelativePosition {
    #[allow(missing_docs)] // documentation missing in model
    AfterProgram,
    #[allow(missing_docs)] // documentation missing in model
    BeforeProgram,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RelativePosition {
    fn from(s: &str) -> Self {
        match s {
            "AFTER_PROGRAM" => RelativePosition::AfterProgram,
            "BEFORE_PROGRAM" => RelativePosition::BeforeProgram,
            other => RelativePosition::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RelativePosition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RelativePosition::from(s))
    }
}
impl RelativePosition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RelativePosition::AfterProgram => "AFTER_PROGRAM",
            RelativePosition::BeforeProgram => "BEFORE_PROGRAM",
            RelativePosition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AFTER_PROGRAM", "BEFORE_PROGRAM"]
    }
}
impl AsRef<str> for RelativePosition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Alert configuration parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Alert {
    /// <p>The code for the alert. For example, <code>NOT_PROCESSED</code>.</p>
    #[doc(hidden)]
    pub alert_code: std::option::Option<std::string::String>,
    /// <p>If an alert is generated for a resource, an explanation of the reason for the alert.</p>
    #[doc(hidden)]
    pub alert_message: std::option::Option<std::string::String>,
    /// <p>The timestamp when the alert was last modified.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Names (ARNs) related to this alert.</p>
    #[doc(hidden)]
    pub related_resource_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl Alert {
    /// <p>The code for the alert. For example, <code>NOT_PROCESSED</code>.</p>
    pub fn alert_code(&self) -> std::option::Option<&str> {
        self.alert_code.as_deref()
    }
    /// <p>If an alert is generated for a resource, an explanation of the reason for the alert.</p>
    pub fn alert_message(&self) -> std::option::Option<&str> {
        self.alert_message.as_deref()
    }
    /// <p>The timestamp when the alert was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The Amazon Resource Names (ARNs) related to this alert.</p>
    pub fn related_resource_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.related_resource_arns.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl Alert {
    /// Creates a new builder-style object to manufacture [`Alert`](crate::model::Alert).
    pub fn builder() -> crate::model::alert::Builder {
        crate::model::alert::Builder::default()
    }
}

/// See [`Alert`](crate::model::Alert).
pub mod alert {

    /// A builder for [`Alert`](crate::model::Alert).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alert_code: std::option::Option<std::string::String>,
        pub(crate) alert_message: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) related_resource_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The code for the alert. For example, <code>NOT_PROCESSED</code>.</p>
        pub fn alert_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.alert_code = Some(input.into());
            self
        }
        /// <p>The code for the alert. For example, <code>NOT_PROCESSED</code>.</p>
        pub fn set_alert_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alert_code = input;
            self
        }
        /// <p>If an alert is generated for a resource, an explanation of the reason for the alert.</p>
        pub fn alert_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.alert_message = Some(input.into());
            self
        }
        /// <p>If an alert is generated for a resource, an explanation of the reason for the alert.</p>
        pub fn set_alert_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.alert_message = input;
            self
        }
        /// <p>The timestamp when the alert was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp when the alert was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Appends an item to `related_resource_arns`.
        ///
        /// To override the contents of this collection use [`set_related_resource_arns`](Self::set_related_resource_arns).
        ///
        /// <p>The Amazon Resource Names (ARNs) related to this alert.</p>
        pub fn related_resource_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.related_resource_arns.unwrap_or_default();
            v.push(input.into());
            self.related_resource_arns = Some(v);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) related to this alert.</p>
        pub fn set_related_resource_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.related_resource_arns = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Alert`](crate::model::Alert).
        pub fn build(self) -> crate::model::Alert {
            crate::model::Alert {
                alert_code: self.alert_code,
                alert_message: self.alert_message,
                last_modified_time: self.last_modified_time,
                related_resource_arns: self.related_resource_arns,
                resource_arn: self.resource_arn,
            }
        }
    }
}
