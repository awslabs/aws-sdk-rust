// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_channel_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateChannelOutput, crate::error::CreateChannelError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateChannelError::unhandled)?;
    Err(crate::error::CreateChannelError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_channel_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateChannelOutput, crate::error::CreateChannelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_channel_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_create_channel(response.body().as_ref(), output)
                .map_err(crate::error::CreateChannelError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_program_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateProgramOutput, crate::error::CreateProgramError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateProgramError::unhandled)?;
    Err(crate::error::CreateProgramError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_program_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateProgramOutput, crate::error::CreateProgramError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_program_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_create_program(response.body().as_ref(), output)
                .map_err(crate::error::CreateProgramError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_source_location_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSourceLocationOutput,
    crate::error::CreateSourceLocationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateSourceLocationError::unhandled)?;
    Err(crate::error::CreateSourceLocationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_source_location_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSourceLocationOutput,
    crate::error::CreateSourceLocationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_source_location_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_source_location(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSourceLocationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vod_source_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateVodSourceOutput, crate::error::CreateVodSourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateVodSourceError::unhandled)?;
    Err(crate::error::CreateVodSourceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vod_source_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateVodSourceOutput, crate::error::CreateVodSourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vod_source_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_create_vod_source(response.body().as_ref(), output)
                .map_err(crate::error::CreateVodSourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_channel_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteChannelOutput, crate::error::DeleteChannelError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteChannelError::unhandled)?;
    Err(crate::error::DeleteChannelError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_channel_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteChannelOutput, crate::error::DeleteChannelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_channel_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_channel_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteChannelPolicyOutput,
    crate::error::DeleteChannelPolicyError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteChannelPolicyError::unhandled)?;
    Err(crate::error::DeleteChannelPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_channel_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteChannelPolicyOutput,
    crate::error::DeleteChannelPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_channel_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_playback_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePlaybackConfigurationOutput,
    crate::error::DeletePlaybackConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeletePlaybackConfigurationError::unhandled)?;
    Err(crate::error::DeletePlaybackConfigurationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_playback_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePlaybackConfigurationOutput,
    crate::error::DeletePlaybackConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_playback_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_program_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteProgramOutput, crate::error::DeleteProgramError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteProgramError::unhandled)?;
    Err(crate::error::DeleteProgramError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_program_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteProgramOutput, crate::error::DeleteProgramError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_program_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_source_location_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSourceLocationOutput,
    crate::error::DeleteSourceLocationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteSourceLocationError::unhandled)?;
    Err(crate::error::DeleteSourceLocationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_source_location_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSourceLocationOutput,
    crate::error::DeleteSourceLocationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_source_location_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vod_source_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteVodSourceOutput, crate::error::DeleteVodSourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteVodSourceError::unhandled)?;
    Err(crate::error::DeleteVodSourceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vod_source_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteVodSourceOutput, crate::error::DeleteVodSourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vod_source_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_channel_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeChannelOutput, crate::error::DescribeChannelError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeChannelError::unhandled)?;
    Err(crate::error::DescribeChannelError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_channel_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeChannelOutput, crate::error::DescribeChannelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_channel_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_describe_channel(response.body().as_ref(), output)
                .map_err(crate::error::DescribeChannelError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_program_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeProgramOutput, crate::error::DescribeProgramError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeProgramError::unhandled)?;
    Err(crate::error::DescribeProgramError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_program_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeProgramOutput, crate::error::DescribeProgramError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_program_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_describe_program(response.body().as_ref(), output)
                .map_err(crate::error::DescribeProgramError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_source_location_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSourceLocationOutput,
    crate::error::DescribeSourceLocationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeSourceLocationError::unhandled)?;
    Err(crate::error::DescribeSourceLocationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_source_location_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSourceLocationOutput,
    crate::error::DescribeSourceLocationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_source_location_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_source_location(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSourceLocationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vod_source_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeVodSourceOutput, crate::error::DescribeVodSourceError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeVodSourceError::unhandled)?;
    Err(crate::error::DescribeVodSourceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vod_source_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeVodSourceOutput, crate::error::DescribeVodSourceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vod_source_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_vod_source(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVodSourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_channel_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetChannelPolicyOutput, crate::error::GetChannelPolicyError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetChannelPolicyError::unhandled)?;
    Err(crate::error::GetChannelPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_channel_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetChannelPolicyOutput, crate::error::GetChannelPolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_channel_policy_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_get_channel_policy(response.body().as_ref(), output)
                .map_err(crate::error::GetChannelPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_channel_schedule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetChannelScheduleOutput,
    crate::error::GetChannelScheduleError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetChannelScheduleError::unhandled)?;
    Err(crate::error::GetChannelScheduleError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_channel_schedule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetChannelScheduleOutput,
    crate::error::GetChannelScheduleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_channel_schedule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_channel_schedule(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetChannelScheduleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_playback_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPlaybackConfigurationOutput,
    crate::error::GetPlaybackConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetPlaybackConfigurationError::unhandled)?;
    Err(crate::error::GetPlaybackConfigurationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_playback_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPlaybackConfigurationOutput,
    crate::error::GetPlaybackConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_playback_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_playback_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetPlaybackConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_channels_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListChannelsOutput, crate::error::ListChannelsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListChannelsError::unhandled)?;
    Err(crate::error::ListChannelsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_channels_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListChannelsOutput, crate::error::ListChannelsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_channels_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_channels(response.body().as_ref(), output)
            .map_err(crate::error::ListChannelsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_playback_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListPlaybackConfigurationsOutput,
    crate::error::ListPlaybackConfigurationsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListPlaybackConfigurationsError::unhandled)?;
    Err(crate::error::ListPlaybackConfigurationsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_playback_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListPlaybackConfigurationsOutput,
    crate::error::ListPlaybackConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_playback_configurations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_playback_configurations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListPlaybackConfigurationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_source_locations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSourceLocationsOutput,
    crate::error::ListSourceLocationsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSourceLocationsError::unhandled)?;
    Err(crate::error::ListSourceLocationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_source_locations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSourceLocationsOutput,
    crate::error::ListSourceLocationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_source_locations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_source_locations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSourceLocationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_tags_for_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_vod_sources_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListVodSourcesOutput, crate::error::ListVodSourcesError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListVodSourcesError::unhandled)?;
    Err(crate::error::ListVodSourcesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_vod_sources_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListVodSourcesOutput, crate::error::ListVodSourcesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_vod_sources_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_list_vod_sources(response.body().as_ref(), output)
                .map_err(crate::error::ListVodSourcesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_channel_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutChannelPolicyOutput, crate::error::PutChannelPolicyError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutChannelPolicyError::unhandled)?;
    Err(crate::error::PutChannelPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_channel_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutChannelPolicyOutput, crate::error::PutChannelPolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_channel_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_playback_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutPlaybackConfigurationOutput,
    crate::error::PutPlaybackConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutPlaybackConfigurationError::unhandled)?;
    Err(crate::error::PutPlaybackConfigurationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_playback_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutPlaybackConfigurationOutput,
    crate::error::PutPlaybackConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_playback_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_put_playback_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutPlaybackConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_channel_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartChannelOutput, crate::error::StartChannelError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::StartChannelError::unhandled)?;
    Err(crate::error::StartChannelError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_channel_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartChannelOutput, crate::error::StartChannelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_channel_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_channel_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopChannelOutput, crate::error::StopChannelError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::StopChannelError::unhandled)?;
    Err(crate::error::StopChannelError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_channel_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopChannelOutput, crate::error::StopChannelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_channel_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::TagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UntagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_channel_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateChannelOutput, crate::error::UpdateChannelError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateChannelError::unhandled)?;
    Err(crate::error::UpdateChannelError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_channel_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateChannelOutput, crate::error::UpdateChannelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_channel_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_update_channel(response.body().as_ref(), output)
                .map_err(crate::error::UpdateChannelError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_source_location_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSourceLocationOutput,
    crate::error::UpdateSourceLocationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateSourceLocationError::unhandled)?;
    Err(crate::error::UpdateSourceLocationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_source_location_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSourceLocationOutput,
    crate::error::UpdateSourceLocationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_source_location_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_source_location(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateSourceLocationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_vod_source_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateVodSourceOutput, crate::error::UpdateVodSourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateVodSourceError::unhandled)?;
    Err(crate::error::UpdateVodSourceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_vod_source_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateVodSourceOutput, crate::error::UpdateVodSourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_vod_source_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_update_vod_source(response.body().as_ref(), output)
                .map_err(crate::error::UpdateVodSourceError::unhandled)?;
        output.build()
    })
}
