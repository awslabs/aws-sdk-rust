// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`CreateChannelInput`](crate::input::CreateChannelInput)
pub mod create_channel_input {
    /// A builder for [`CreateChannelInput`](crate::input::CreateChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) outputs: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
        pub(crate) playback_mode: std::option::Option<crate::model::PlaybackMode>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        pub fn outputs(mut self, input: impl Into<crate::model::RequestOutputItem>) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(input.into());
            self.outputs = Some(v);
            self
        }
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// <p>The type of playback mode for this channel. The only supported value is LOOP.</p>
        pub fn playback_mode(mut self, input: crate::model::PlaybackMode) -> Self {
            self.playback_mode = Some(input);
            self
        }
        pub fn set_playback_mode(
            mut self,
            input: std::option::Option<crate::model::PlaybackMode>,
        ) -> Self {
            self.playback_mode = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateChannelInput`](crate::input::CreateChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreateChannelInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateChannelInput {
                channel_name: self.channel_name,
                outputs: self.outputs,
                playback_mode: self.playback_mode,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateChannelInputOperationOutputAlias = crate::operation::CreateChannel;
#[doc(hidden)]
pub type CreateChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateChannelInput {
    /// Consumes the builder and constructs an Operation<[`CreateChannel`](crate::operation::CreateChannel)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_channel(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateChannel::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateChannel",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_1 = &self.channel_name;
        let input_1 = input_1
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            })?;
        let channel_name = smithy_http::label::fmt_string(input_1, false);
        if channel_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/channel/{ChannelName}", ChannelName = channel_name)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateChannelInput`](crate::input::CreateChannelInput)
    pub fn builder() -> crate::input::create_channel_input::Builder {
        crate::input::create_channel_input::Builder::default()
    }
}

/// See [`CreateProgramInput`](crate::input::CreateProgramInput)
pub mod create_program_input {
    /// A builder for [`CreateProgramInput`](crate::input::CreateProgramInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ad_breaks: std::option::Option<std::vec::Vec<crate::model::AdBreak>>,
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) program_name: std::option::Option<std::string::String>,
        pub(crate) schedule_configuration: std::option::Option<crate::model::ScheduleConfiguration>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn ad_breaks(mut self, input: impl Into<crate::model::AdBreak>) -> Self {
            let mut v = self.ad_breaks.unwrap_or_default();
            v.push(input.into());
            self.ad_breaks = Some(v);
            self
        }
        pub fn set_ad_breaks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AdBreak>>,
        ) -> Self {
            self.ad_breaks = input;
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The identifier for the program you are working on.</p>
        pub fn program_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.program_name = Some(input.into());
            self
        }
        pub fn set_program_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.program_name = input;
            self
        }
        /// <p>The schedule configuration settings.</p>
        pub fn schedule_configuration(
            mut self,
            input: crate::model::ScheduleConfiguration,
        ) -> Self {
            self.schedule_configuration = Some(input);
            self
        }
        pub fn set_schedule_configuration(
            mut self,
            input: std::option::Option<crate::model::ScheduleConfiguration>,
        ) -> Self {
            self.schedule_configuration = input;
            self
        }
        /// <p>The name of the source location.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// <p>The name that's used to refer to a VOD source.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateProgramInput`](crate::input::CreateProgramInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreateProgramInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateProgramInput {
                ad_breaks: self.ad_breaks,
                channel_name: self.channel_name,
                program_name: self.program_name,
                schedule_configuration: self.schedule_configuration,
                source_location_name: self.source_location_name,
                vod_source_name: self.vod_source_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateProgramInputOperationOutputAlias = crate::operation::CreateProgram;
#[doc(hidden)]
pub type CreateProgramInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateProgramInput {
    /// Consumes the builder and constructs an Operation<[`CreateProgram`](crate::operation::CreateProgram)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateProgram,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_program(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateProgram::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateProgram",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_2 = &self.channel_name;
        let input_2 = input_2
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            })?;
        let channel_name = smithy_http::label::fmt_string(input_2, false);
        if channel_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            });
        }
        let input_3 = &self.program_name;
        let input_3 = input_3
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "program_name",
                details: "cannot be empty or unset",
            })?;
        let program_name = smithy_http::label::fmt_string(input_3, false);
        if program_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "program_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/channel/{ChannelName}/program/{ProgramName}",
            ChannelName = channel_name,
            ProgramName = program_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateProgramInput`](crate::input::CreateProgramInput)
    pub fn builder() -> crate::input::create_program_input::Builder {
        crate::input::create_program_input::Builder::default()
    }
}

/// See [`CreateSourceLocationInput`](crate::input::CreateSourceLocationInput)
pub mod create_source_location_input {
    /// A builder for [`CreateSourceLocationInput`](crate::input::CreateSourceLocationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_configuration: std::option::Option<crate::model::AccessConfiguration>,
        pub(crate) default_segment_delivery_configuration:
            std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        pub(crate) http_configuration: std::option::Option<crate::model::HttpConfiguration>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
        pub fn access_configuration(mut self, input: crate::model::AccessConfiguration) -> Self {
            self.access_configuration = Some(input);
            self
        }
        pub fn set_access_configuration(
            mut self,
            input: std::option::Option<crate::model::AccessConfiguration>,
        ) -> Self {
            self.access_configuration = input;
            self
        }
        /// <p>The optional configuration for the server that serves segments.</p>
        pub fn default_segment_delivery_configuration(
            mut self,
            input: crate::model::DefaultSegmentDeliveryConfiguration,
        ) -> Self {
            self.default_segment_delivery_configuration = Some(input);
            self
        }
        pub fn set_default_segment_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        ) -> Self {
            self.default_segment_delivery_configuration = input;
            self
        }
        /// <p>The source's HTTP package configurations.</p>
        pub fn http_configuration(mut self, input: crate::model::HttpConfiguration) -> Self {
            self.http_configuration = Some(input);
            self
        }
        pub fn set_http_configuration(
            mut self,
            input: std::option::Option<crate::model::HttpConfiguration>,
        ) -> Self {
            self.http_configuration = input;
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSourceLocationInput`](crate::input::CreateSourceLocationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateSourceLocationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateSourceLocationInput {
                access_configuration: self.access_configuration,
                default_segment_delivery_configuration: self.default_segment_delivery_configuration,
                http_configuration: self.http_configuration,
                source_location_name: self.source_location_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateSourceLocationInputOperationOutputAlias = crate::operation::CreateSourceLocation;
#[doc(hidden)]
pub type CreateSourceLocationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateSourceLocationInput {
    /// Consumes the builder and constructs an Operation<[`CreateSourceLocation`](crate::operation::CreateSourceLocation)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateSourceLocation,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_source_location(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateSourceLocation::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateSourceLocation",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_4 = &self.source_location_name;
        let input_4 = input_4
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "source_location_name",
                details: "cannot be empty or unset",
            })?;
        let source_location_name = smithy_http::label::fmt_string(input_4, false);
        if source_location_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "source_location_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/sourceLocation/{SourceLocationName}",
            SourceLocationName = source_location_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateSourceLocationInput`](crate::input::CreateSourceLocationInput)
    pub fn builder() -> crate::input::create_source_location_input::Builder {
        crate::input::create_source_location_input::Builder::default()
    }
}

/// See [`CreateVodSourceInput`](crate::input::CreateVodSourceInput)
pub mod create_vod_source_input {
    /// A builder for [`CreateVodSourceInput`](crate::input::CreateVodSourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) http_package_configurations:
            std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn http_package_configurations(
            mut self,
            input: impl Into<crate::model::HttpPackageConfiguration>,
        ) -> Self {
            let mut v = self.http_package_configurations.unwrap_or_default();
            v.push(input.into());
            self.http_package_configurations = Some(v);
            self
        }
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.http_package_configurations = input;
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVodSourceInput`](crate::input::CreateVodSourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateVodSourceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateVodSourceInput {
                http_package_configurations: self.http_package_configurations,
                source_location_name: self.source_location_name,
                tags: self.tags,
                vod_source_name: self.vod_source_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateVodSourceInputOperationOutputAlias = crate::operation::CreateVodSource;
#[doc(hidden)]
pub type CreateVodSourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateVodSourceInput {
    /// Consumes the builder and constructs an Operation<[`CreateVodSource`](crate::operation::CreateVodSource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateVodSource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_vod_source(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateVodSource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateVodSource",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_5 = &self.source_location_name;
        let input_5 = input_5
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "source_location_name",
                details: "cannot be empty or unset",
            })?;
        let source_location_name = smithy_http::label::fmt_string(input_5, false);
        if source_location_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "source_location_name",
                details: "cannot be empty or unset",
            });
        }
        let input_6 = &self.vod_source_name;
        let input_6 = input_6
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "vod_source_name",
                details: "cannot be empty or unset",
            })?;
        let vod_source_name = smithy_http::label::fmt_string(input_6, false);
        if vod_source_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "vod_source_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}",
            SourceLocationName = source_location_name,
            VodSourceName = vod_source_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateVodSourceInput`](crate::input::CreateVodSourceInput)
    pub fn builder() -> crate::input::create_vod_source_input::Builder {
        crate::input::create_vod_source_input::Builder::default()
    }
}

/// See [`DeleteChannelInput`](crate::input::DeleteChannelInput)
pub mod delete_channel_input {
    /// A builder for [`DeleteChannelInput`](crate::input::DeleteChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelInput`](crate::input::DeleteChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteChannelInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteChannelInput {
                channel_name: self.channel_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelInputOperationOutputAlias = crate::operation::DeleteChannel;
#[doc(hidden)]
pub type DeleteChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteChannelInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannel`](crate::operation::DeleteChannel)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteChannel::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteChannel",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_7 = &self.channel_name;
        let input_7 = input_7
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            })?;
        let channel_name = smithy_http::label::fmt_string(input_7, false);
        if channel_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/channel/{ChannelName}", ChannelName = channel_name)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelInput`](crate::input::DeleteChannelInput)
    pub fn builder() -> crate::input::delete_channel_input::Builder {
        crate::input::delete_channel_input::Builder::default()
    }
}

/// See [`DeleteChannelPolicyInput`](crate::input::DeleteChannelPolicyInput)
pub mod delete_channel_policy_input {
    /// A builder for [`DeleteChannelPolicyInput`](crate::input::DeleteChannelPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelPolicyInput`](crate::input::DeleteChannelPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteChannelPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteChannelPolicyInput {
                channel_name: self.channel_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelPolicyInputOperationOutputAlias = crate::operation::DeleteChannelPolicy;
#[doc(hidden)]
pub type DeleteChannelPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteChannelPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannelPolicy`](crate::operation::DeleteChannelPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteChannelPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteChannelPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteChannelPolicy",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_8 = &self.channel_name;
        let input_8 = input_8
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            })?;
        let channel_name = smithy_http::label::fmt_string(input_8, false);
        if channel_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/channel/{ChannelName}/policy",
            ChannelName = channel_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelPolicyInput`](crate::input::DeleteChannelPolicyInput)
    pub fn builder() -> crate::input::delete_channel_policy_input::Builder {
        crate::input::delete_channel_policy_input::Builder::default()
    }
}

/// See [`DeletePlaybackConfigurationInput`](crate::input::DeletePlaybackConfigurationInput)
pub mod delete_playback_configuration_input {
    /// A builder for [`DeletePlaybackConfigurationInput`](crate::input::DeletePlaybackConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletePlaybackConfigurationInput`](crate::input::DeletePlaybackConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeletePlaybackConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeletePlaybackConfigurationInput { name: self.name })
        }
    }
}
#[doc(hidden)]
pub type DeletePlaybackConfigurationInputOperationOutputAlias =
    crate::operation::DeletePlaybackConfiguration;
#[doc(hidden)]
pub type DeletePlaybackConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeletePlaybackConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeletePlaybackConfiguration`](crate::operation::DeletePlaybackConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeletePlaybackConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeletePlaybackConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeletePlaybackConfiguration",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_9 = &self.name;
        let input_9 = input_9
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "name",
                details: "cannot be empty or unset",
            })?;
        let name = smithy_http::label::fmt_string(input_9, false);
        if name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "name",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/playbackConfiguration/{Name}", Name = name)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeletePlaybackConfigurationInput`](crate::input::DeletePlaybackConfigurationInput)
    pub fn builder() -> crate::input::delete_playback_configuration_input::Builder {
        crate::input::delete_playback_configuration_input::Builder::default()
    }
}

/// See [`DeleteProgramInput`](crate::input::DeleteProgramInput)
pub mod delete_program_input {
    /// A builder for [`DeleteProgramInput`](crate::input::DeleteProgramInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) program_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The identifier for the program you are working on.</p>
        pub fn program_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.program_name = Some(input.into());
            self
        }
        pub fn set_program_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.program_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteProgramInput`](crate::input::DeleteProgramInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteProgramInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteProgramInput {
                channel_name: self.channel_name,
                program_name: self.program_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteProgramInputOperationOutputAlias = crate::operation::DeleteProgram;
#[doc(hidden)]
pub type DeleteProgramInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteProgramInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProgram`](crate::operation::DeleteProgram)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteProgram,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteProgram::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteProgram",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_10 = &self.channel_name;
        let input_10 =
            input_10
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                })?;
        let channel_name = smithy_http::label::fmt_string(input_10, false);
        if channel_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            });
        }
        let input_11 = &self.program_name;
        let input_11 =
            input_11
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "program_name",
                    details: "cannot be empty or unset",
                })?;
        let program_name = smithy_http::label::fmt_string(input_11, false);
        if program_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "program_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/channel/{ChannelName}/program/{ProgramName}",
            ChannelName = channel_name,
            ProgramName = program_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteProgramInput`](crate::input::DeleteProgramInput)
    pub fn builder() -> crate::input::delete_program_input::Builder {
        crate::input::delete_program_input::Builder::default()
    }
}

/// See [`DeleteSourceLocationInput`](crate::input::DeleteSourceLocationInput)
pub mod delete_source_location_input {
    /// A builder for [`DeleteSourceLocationInput`](crate::input::DeleteSourceLocationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_location_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSourceLocationInput`](crate::input::DeleteSourceLocationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteSourceLocationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteSourceLocationInput {
                source_location_name: self.source_location_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteSourceLocationInputOperationOutputAlias = crate::operation::DeleteSourceLocation;
#[doc(hidden)]
pub type DeleteSourceLocationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteSourceLocationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSourceLocation`](crate::operation::DeleteSourceLocation)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteSourceLocation,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteSourceLocation::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteSourceLocation",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_12 = &self.source_location_name;
        let input_12 =
            input_12
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                })?;
        let source_location_name = smithy_http::label::fmt_string(input_12, false);
        if source_location_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "source_location_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/sourceLocation/{SourceLocationName}",
            SourceLocationName = source_location_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteSourceLocationInput`](crate::input::DeleteSourceLocationInput)
    pub fn builder() -> crate::input::delete_source_location_input::Builder {
        crate::input::delete_source_location_input::Builder::default()
    }
}

/// See [`DeleteVodSourceInput`](crate::input::DeleteVodSourceInput)
pub mod delete_vod_source_input {
    /// A builder for [`DeleteVodSourceInput`](crate::input::DeleteVodSourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVodSourceInput`](crate::input::DeleteVodSourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteVodSourceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteVodSourceInput {
                source_location_name: self.source_location_name,
                vod_source_name: self.vod_source_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteVodSourceInputOperationOutputAlias = crate::operation::DeleteVodSource;
#[doc(hidden)]
pub type DeleteVodSourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteVodSourceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVodSource`](crate::operation::DeleteVodSource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteVodSource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteVodSource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteVodSource",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_13 = &self.source_location_name;
        let input_13 =
            input_13
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                })?;
        let source_location_name = smithy_http::label::fmt_string(input_13, false);
        if source_location_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "source_location_name",
                details: "cannot be empty or unset",
            });
        }
        let input_14 = &self.vod_source_name;
        let input_14 =
            input_14
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "vod_source_name",
                    details: "cannot be empty or unset",
                })?;
        let vod_source_name = smithy_http::label::fmt_string(input_14, false);
        if vod_source_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "vod_source_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}",
            SourceLocationName = source_location_name,
            VodSourceName = vod_source_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteVodSourceInput`](crate::input::DeleteVodSourceInput)
    pub fn builder() -> crate::input::delete_vod_source_input::Builder {
        crate::input::delete_vod_source_input::Builder::default()
    }
}

/// See [`DescribeChannelInput`](crate::input::DescribeChannelInput)
pub mod describe_channel_input {
    /// A builder for [`DescribeChannelInput`](crate::input::DescribeChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelInput`](crate::input::DescribeChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeChannelInput {
                channel_name: self.channel_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelInputOperationOutputAlias = crate::operation::DescribeChannel;
#[doc(hidden)]
pub type DescribeChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeChannelInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannel`](crate::operation::DescribeChannel)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeChannel::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeChannel",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_15 = &self.channel_name;
        let input_15 =
            input_15
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                })?;
        let channel_name = smithy_http::label::fmt_string(input_15, false);
        if channel_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/channel/{ChannelName}", ChannelName = channel_name)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelInput`](crate::input::DescribeChannelInput)
    pub fn builder() -> crate::input::describe_channel_input::Builder {
        crate::input::describe_channel_input::Builder::default()
    }
}

/// See [`DescribeProgramInput`](crate::input::DescribeProgramInput)
pub mod describe_program_input {
    /// A builder for [`DescribeProgramInput`](crate::input::DescribeProgramInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) program_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The identifier for the program you are working on.</p>
        pub fn program_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.program_name = Some(input.into());
            self
        }
        pub fn set_program_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.program_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeProgramInput`](crate::input::DescribeProgramInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeProgramInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeProgramInput {
                channel_name: self.channel_name,
                program_name: self.program_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeProgramInputOperationOutputAlias = crate::operation::DescribeProgram;
#[doc(hidden)]
pub type DescribeProgramInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeProgramInput {
    /// Consumes the builder and constructs an Operation<[`DescribeProgram`](crate::operation::DescribeProgram)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeProgram,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeProgram::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeProgram",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_16 = &self.channel_name;
        let input_16 =
            input_16
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                })?;
        let channel_name = smithy_http::label::fmt_string(input_16, false);
        if channel_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            });
        }
        let input_17 = &self.program_name;
        let input_17 =
            input_17
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "program_name",
                    details: "cannot be empty or unset",
                })?;
        let program_name = smithy_http::label::fmt_string(input_17, false);
        if program_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "program_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/channel/{ChannelName}/program/{ProgramName}",
            ChannelName = channel_name,
            ProgramName = program_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeProgramInput`](crate::input::DescribeProgramInput)
    pub fn builder() -> crate::input::describe_program_input::Builder {
        crate::input::describe_program_input::Builder::default()
    }
}

/// See [`DescribeSourceLocationInput`](crate::input::DescribeSourceLocationInput)
pub mod describe_source_location_input {
    /// A builder for [`DescribeSourceLocationInput`](crate::input::DescribeSourceLocationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_location_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeSourceLocationInput`](crate::input::DescribeSourceLocationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeSourceLocationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeSourceLocationInput {
                source_location_name: self.source_location_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeSourceLocationInputOperationOutputAlias = crate::operation::DescribeSourceLocation;
#[doc(hidden)]
pub type DescribeSourceLocationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeSourceLocationInput {
    /// Consumes the builder and constructs an Operation<[`DescribeSourceLocation`](crate::operation::DescribeSourceLocation)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeSourceLocation,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeSourceLocation::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeSourceLocation",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_18 = &self.source_location_name;
        let input_18 =
            input_18
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                })?;
        let source_location_name = smithy_http::label::fmt_string(input_18, false);
        if source_location_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "source_location_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/sourceLocation/{SourceLocationName}",
            SourceLocationName = source_location_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeSourceLocationInput`](crate::input::DescribeSourceLocationInput)
    pub fn builder() -> crate::input::describe_source_location_input::Builder {
        crate::input::describe_source_location_input::Builder::default()
    }
}

/// See [`DescribeVodSourceInput`](crate::input::DescribeVodSourceInput)
pub mod describe_vod_source_input {
    /// A builder for [`DescribeVodSourceInput`](crate::input::DescribeVodSourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeVodSourceInput`](crate::input::DescribeVodSourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeVodSourceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeVodSourceInput {
                source_location_name: self.source_location_name,
                vod_source_name: self.vod_source_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeVodSourceInputOperationOutputAlias = crate::operation::DescribeVodSource;
#[doc(hidden)]
pub type DescribeVodSourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeVodSourceInput {
    /// Consumes the builder and constructs an Operation<[`DescribeVodSource`](crate::operation::DescribeVodSource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeVodSource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeVodSource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeVodSource",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_19 = &self.source_location_name;
        let input_19 =
            input_19
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                })?;
        let source_location_name = smithy_http::label::fmt_string(input_19, false);
        if source_location_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "source_location_name",
                details: "cannot be empty or unset",
            });
        }
        let input_20 = &self.vod_source_name;
        let input_20 =
            input_20
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "vod_source_name",
                    details: "cannot be empty or unset",
                })?;
        let vod_source_name = smithy_http::label::fmt_string(input_20, false);
        if vod_source_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "vod_source_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}",
            SourceLocationName = source_location_name,
            VodSourceName = vod_source_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeVodSourceInput`](crate::input::DescribeVodSourceInput)
    pub fn builder() -> crate::input::describe_vod_source_input::Builder {
        crate::input::describe_vod_source_input::Builder::default()
    }
}

/// See [`GetChannelPolicyInput`](crate::input::GetChannelPolicyInput)
pub mod get_channel_policy_input {
    /// A builder for [`GetChannelPolicyInput`](crate::input::GetChannelPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetChannelPolicyInput`](crate::input::GetChannelPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetChannelPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetChannelPolicyInput {
                channel_name: self.channel_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetChannelPolicyInputOperationOutputAlias = crate::operation::GetChannelPolicy;
#[doc(hidden)]
pub type GetChannelPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetChannelPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetChannelPolicy`](crate::operation::GetChannelPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetChannelPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetChannelPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetChannelPolicy",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_21 = &self.channel_name;
        let input_21 =
            input_21
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                })?;
        let channel_name = smithy_http::label::fmt_string(input_21, false);
        if channel_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/channel/{ChannelName}/policy",
            ChannelName = channel_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetChannelPolicyInput`](crate::input::GetChannelPolicyInput)
    pub fn builder() -> crate::input::get_channel_policy_input::Builder {
        crate::input::get_channel_policy_input::Builder::default()
    }
}

/// See [`GetChannelScheduleInput`](crate::input::GetChannelScheduleInput)
pub mod get_channel_schedule_input {
    /// A builder for [`GetChannelScheduleInput`](crate::input::GetChannelScheduleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) duration_minutes: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The schedule duration in minutes. The maximum duration is 4320 minutes (three days).</p>
        pub fn duration_minutes(mut self, input: impl Into<std::string::String>) -> Self {
            self.duration_minutes = Some(input.into());
            self
        }
        pub fn set_duration_minutes(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.duration_minutes = input;
            self
        }
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetChannelScheduleInput`](crate::input::GetChannelScheduleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetChannelScheduleInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetChannelScheduleInput {
                channel_name: self.channel_name,
                duration_minutes: self.duration_minutes,
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetChannelScheduleInputOperationOutputAlias = crate::operation::GetChannelSchedule;
#[doc(hidden)]
pub type GetChannelScheduleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetChannelScheduleInput {
    /// Consumes the builder and constructs an Operation<[`GetChannelSchedule`](crate::operation::GetChannelSchedule)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetChannelSchedule,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetChannelSchedule::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetChannelSchedule",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_22 = &self.channel_name;
        let input_22 =
            input_22
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                })?;
        let channel_name = smithy_http::label::fmt_string(input_22, false);
        if channel_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/channel/{ChannelName}/schedule",
            ChannelName = channel_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_23) = &self.duration_minutes {
            query.push_kv(
                "durationMinutes",
                &smithy_http::query::fmt_string(&inner_23),
            );
        }
        if self.max_results != 0 {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(self.max_results).encode(),
            );
        }
        if let Some(inner_24) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_24));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetChannelScheduleInput`](crate::input::GetChannelScheduleInput)
    pub fn builder() -> crate::input::get_channel_schedule_input::Builder {
        crate::input::get_channel_schedule_input::Builder::default()
    }
}

/// See [`GetPlaybackConfigurationInput`](crate::input::GetPlaybackConfigurationInput)
pub mod get_playback_configuration_input {
    /// A builder for [`GetPlaybackConfigurationInput`](crate::input::GetPlaybackConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPlaybackConfigurationInput`](crate::input::GetPlaybackConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetPlaybackConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetPlaybackConfigurationInput { name: self.name })
        }
    }
}
#[doc(hidden)]
pub type GetPlaybackConfigurationInputOperationOutputAlias =
    crate::operation::GetPlaybackConfiguration;
#[doc(hidden)]
pub type GetPlaybackConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetPlaybackConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetPlaybackConfiguration`](crate::operation::GetPlaybackConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetPlaybackConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetPlaybackConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetPlaybackConfiguration",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_25 = &self.name;
        let input_25 =
            input_25
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "name",
                    details: "cannot be empty or unset",
                })?;
        let name = smithy_http::label::fmt_string(input_25, false);
        if name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "name",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/playbackConfiguration/{Name}", Name = name)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetPlaybackConfigurationInput`](crate::input::GetPlaybackConfigurationInput)
    pub fn builder() -> crate::input::get_playback_configuration_input::Builder {
        crate::input::get_playback_configuration_input::Builder::default()
    }
}

/// See [`ListAlertsInput`](crate::input::ListAlertsInput)
pub mod list_alerts_input {
    /// A builder for [`ListAlertsInput`](crate::input::ListAlertsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAlertsInput`](crate::input::ListAlertsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListAlertsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListAlertsInput {
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAlertsInputOperationOutputAlias = crate::operation::ListAlerts;
#[doc(hidden)]
pub type ListAlertsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListAlertsInput {
    /// Consumes the builder and constructs an Operation<[`ListAlerts`](crate::operation::ListAlerts)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListAlerts,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListAlerts::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListAlerts",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/alerts").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if self.max_results != 0 {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(self.max_results).encode(),
            );
        }
        if let Some(inner_26) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_26));
        }
        if let Some(inner_27) = &self.resource_arn {
            query.push_kv("resourceArn", &smithy_http::query::fmt_string(&inner_27));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListAlertsInput`](crate::input::ListAlertsInput)
    pub fn builder() -> crate::input::list_alerts_input::Builder {
        crate::input::list_alerts_input::Builder::default()
    }
}

/// See [`ListChannelsInput`](crate::input::ListChannelsInput)
pub mod list_channels_input {
    /// A builder for [`ListChannelsInput`](crate::input::ListChannelsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelsInput`](crate::input::ListChannelsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListChannelsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListChannelsInput {
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelsInputOperationOutputAlias = crate::operation::ListChannels;
#[doc(hidden)]
pub type ListChannelsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListChannelsInput {
    /// Consumes the builder and constructs an Operation<[`ListChannels`](crate::operation::ListChannels)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListChannels,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListChannels::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListChannels",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/channels").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if self.max_results != 0 {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(self.max_results).encode(),
            );
        }
        if let Some(inner_28) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_28));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListChannelsInput`](crate::input::ListChannelsInput)
    pub fn builder() -> crate::input::list_channels_input::Builder {
        crate::input::list_channels_input::Builder::default()
    }
}

/// See [`ListPlaybackConfigurationsInput`](crate::input::ListPlaybackConfigurationsInput)
pub mod list_playback_configurations_input {
    /// A builder for [`ListPlaybackConfigurationsInput`](crate::input::ListPlaybackConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Maximum number of records to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPlaybackConfigurationsInput`](crate::input::ListPlaybackConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListPlaybackConfigurationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListPlaybackConfigurationsInput {
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPlaybackConfigurationsInputOperationOutputAlias =
    crate::operation::ListPlaybackConfigurations;
#[doc(hidden)]
pub type ListPlaybackConfigurationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListPlaybackConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`ListPlaybackConfigurations`](crate::operation::ListPlaybackConfigurations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListPlaybackConfigurations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListPlaybackConfigurations::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListPlaybackConfigurations",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/playbackConfigurations").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if self.max_results != 0 {
            query.push_kv(
                "MaxResults",
                &smithy_types::primitive::Encoder::from(self.max_results).encode(),
            );
        }
        if let Some(inner_29) = &self.next_token {
            query.push_kv("NextToken", &smithy_http::query::fmt_string(&inner_29));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListPlaybackConfigurationsInput`](crate::input::ListPlaybackConfigurationsInput)
    pub fn builder() -> crate::input::list_playback_configurations_input::Builder {
        crate::input::list_playback_configurations_input::Builder::default()
    }
}

/// See [`ListSourceLocationsInput`](crate::input::ListSourceLocationsInput)
pub mod list_source_locations_input {
    /// A builder for [`ListSourceLocationsInput`](crate::input::ListSourceLocationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSourceLocationsInput`](crate::input::ListSourceLocationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListSourceLocationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListSourceLocationsInput {
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListSourceLocationsInputOperationOutputAlias = crate::operation::ListSourceLocations;
#[doc(hidden)]
pub type ListSourceLocationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListSourceLocationsInput {
    /// Consumes the builder and constructs an Operation<[`ListSourceLocations`](crate::operation::ListSourceLocations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListSourceLocations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListSourceLocations::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListSourceLocations",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/sourceLocations").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if self.max_results != 0 {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(self.max_results).encode(),
            );
        }
        if let Some(inner_30) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_30));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListSourceLocationsInput`](crate::input::ListSourceLocationsInput)
    pub fn builder() -> crate::input::list_source_locations_input::Builder {
        crate::input::list_source_locations_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListTagsForResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListTagsForResource",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_31 = &self.resource_arn;
        let input_31 =
            input_31
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                })?;
        let resource_arn = smithy_http::label::fmt_string(input_31, false);
        if resource_arn.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "resource_arn",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListVodSourcesInput`](crate::input::ListVodSourcesInput)
pub mod list_vod_sources_input {
    /// A builder for [`ListVodSourcesInput`](crate::input::ListVodSourcesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVodSourcesInput`](crate::input::ListVodSourcesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListVodSourcesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListVodSourcesInput {
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
                source_location_name: self.source_location_name,
            })
        }
    }
}
#[doc(hidden)]
pub type ListVodSourcesInputOperationOutputAlias = crate::operation::ListVodSources;
#[doc(hidden)]
pub type ListVodSourcesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListVodSourcesInput {
    /// Consumes the builder and constructs an Operation<[`ListVodSources`](crate::operation::ListVodSources)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListVodSources,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListVodSources::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListVodSources",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_32 = &self.source_location_name;
        let input_32 =
            input_32
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                })?;
        let source_location_name = smithy_http::label::fmt_string(input_32, false);
        if source_location_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "source_location_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/sourceLocation/{SourceLocationName}/vodSources",
            SourceLocationName = source_location_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if self.max_results != 0 {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(self.max_results).encode(),
            );
        }
        if let Some(inner_33) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_33));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListVodSourcesInput`](crate::input::ListVodSourcesInput)
    pub fn builder() -> crate::input::list_vod_sources_input::Builder {
        crate::input::list_vod_sources_input::Builder::default()
    }
}

/// See [`PutChannelPolicyInput`](crate::input::PutChannelPolicyInput)
pub mod put_channel_policy_input {
    /// A builder for [`PutChannelPolicyInput`](crate::input::PutChannelPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>Adds an IAM role that determines the permissions of your channel.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// Consumes the builder and constructs a [`PutChannelPolicyInput`](crate::input::PutChannelPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutChannelPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutChannelPolicyInput {
                channel_name: self.channel_name,
                policy: self.policy,
            })
        }
    }
}
#[doc(hidden)]
pub type PutChannelPolicyInputOperationOutputAlias = crate::operation::PutChannelPolicy;
#[doc(hidden)]
pub type PutChannelPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutChannelPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutChannelPolicy`](crate::operation::PutChannelPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutChannelPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_put_channel_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutChannelPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutChannelPolicy",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_34 = &self.channel_name;
        let input_34 =
            input_34
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                })?;
        let channel_name = smithy_http::label::fmt_string(input_34, false);
        if channel_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/channel/{ChannelName}/policy",
            ChannelName = channel_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutChannelPolicyInput`](crate::input::PutChannelPolicyInput)
    pub fn builder() -> crate::input::put_channel_policy_input::Builder {
        crate::input::put_channel_policy_input::Builder::default()
    }
}

/// See [`PutPlaybackConfigurationInput`](crate::input::PutPlaybackConfigurationInput)
pub mod put_playback_configuration_input {
    /// A builder for [`PutPlaybackConfigurationInput`](crate::input::PutPlaybackConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ad_decision_server_url: std::option::Option<std::string::String>,
        pub(crate) avail_suppression: std::option::Option<crate::model::AvailSuppression>,
        pub(crate) bumper: std::option::Option<crate::model::Bumper>,
        pub(crate) cdn_configuration: std::option::Option<crate::model::CdnConfiguration>,
        pub(crate) configuration_aliases: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        >,
        pub(crate) dash_configuration: std::option::Option<crate::model::DashConfigurationForPut>,
        pub(crate) live_pre_roll_configuration:
            std::option::Option<crate::model::LivePreRollConfiguration>,
        pub(crate) manifest_processing_rules:
            std::option::Option<crate::model::ManifestProcessingRules>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) personalization_threshold_seconds: std::option::Option<i32>,
        pub(crate) slate_ad_url: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) transcode_profile_name: std::option::Option<std::string::String>,
        pub(crate) video_content_source_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
        pub fn ad_decision_server_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.ad_decision_server_url = Some(input.into());
            self
        }
        pub fn set_ad_decision_server_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ad_decision_server_url = input;
            self
        }
        /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
        pub fn avail_suppression(mut self, input: crate::model::AvailSuppression) -> Self {
            self.avail_suppression = Some(input);
            self
        }
        pub fn set_avail_suppression(
            mut self,
            input: std::option::Option<crate::model::AvailSuppression>,
        ) -> Self {
            self.avail_suppression = input;
            self
        }
        /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
        pub fn bumper(mut self, input: crate::model::Bumper) -> Self {
            self.bumper = Some(input);
            self
        }
        pub fn set_bumper(mut self, input: std::option::Option<crate::model::Bumper>) -> Self {
            self.bumper = input;
            self
        }
        /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
        pub fn cdn_configuration(mut self, input: crate::model::CdnConfiguration) -> Self {
            self.cdn_configuration = Some(input);
            self
        }
        pub fn set_cdn_configuration(
            mut self,
            input: std::option::Option<crate::model::CdnConfiguration>,
        ) -> Self {
            self.cdn_configuration = input;
            self
        }
        pub fn configuration_aliases(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::collections::HashMap<std::string::String, std::string::String>>,
        ) -> Self {
            let mut hash_map = self.configuration_aliases.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.configuration_aliases = Some(hash_map);
            self
        }
        pub fn set_configuration_aliases(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::collections::HashMap<std::string::String, std::string::String>,
                >,
            >,
        ) -> Self {
            self.configuration_aliases = input;
            self
        }
        /// <p>The configuration for DASH content.</p>
        pub fn dash_configuration(mut self, input: crate::model::DashConfigurationForPut) -> Self {
            self.dash_configuration = Some(input);
            self
        }
        pub fn set_dash_configuration(
            mut self,
            input: std::option::Option<crate::model::DashConfigurationForPut>,
        ) -> Self {
            self.dash_configuration = input;
            self
        }
        /// <p>The configuration for pre-roll ad insertion.</p>
        pub fn live_pre_roll_configuration(
            mut self,
            input: crate::model::LivePreRollConfiguration,
        ) -> Self {
            self.live_pre_roll_configuration = Some(input);
            self
        }
        pub fn set_live_pre_roll_configuration(
            mut self,
            input: std::option::Option<crate::model::LivePreRollConfiguration>,
        ) -> Self {
            self.live_pre_roll_configuration = input;
            self
        }
        /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
        pub fn manifest_processing_rules(
            mut self,
            input: crate::model::ManifestProcessingRules,
        ) -> Self {
            self.manifest_processing_rules = Some(input);
            self
        }
        pub fn set_manifest_processing_rules(
            mut self,
            input: std::option::Option<crate::model::ManifestProcessingRules>,
        ) -> Self {
            self.manifest_processing_rules = input;
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
        pub fn personalization_threshold_seconds(mut self, input: i32) -> Self {
            self.personalization_threshold_seconds = Some(input);
            self
        }
        pub fn set_personalization_threshold_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.personalization_threshold_seconds = input;
            self
        }
        /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
        pub fn slate_ad_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.slate_ad_url = Some(input.into());
            self
        }
        pub fn set_slate_ad_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.slate_ad_url = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
        pub fn transcode_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcode_profile_name = Some(input.into());
            self
        }
        pub fn set_transcode_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcode_profile_name = input;
            self
        }
        /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
        pub fn video_content_source_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.video_content_source_url = Some(input.into());
            self
        }
        pub fn set_video_content_source_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.video_content_source_url = input;
            self
        }
        /// Consumes the builder and constructs a [`PutPlaybackConfigurationInput`](crate::input::PutPlaybackConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutPlaybackConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutPlaybackConfigurationInput {
                ad_decision_server_url: self.ad_decision_server_url,
                avail_suppression: self.avail_suppression,
                bumper: self.bumper,
                cdn_configuration: self.cdn_configuration,
                configuration_aliases: self.configuration_aliases,
                dash_configuration: self.dash_configuration,
                live_pre_roll_configuration: self.live_pre_roll_configuration,
                manifest_processing_rules: self.manifest_processing_rules,
                name: self.name,
                personalization_threshold_seconds: self
                    .personalization_threshold_seconds
                    .unwrap_or_default(),
                slate_ad_url: self.slate_ad_url,
                tags: self.tags,
                transcode_profile_name: self.transcode_profile_name,
                video_content_source_url: self.video_content_source_url,
            })
        }
    }
}
#[doc(hidden)]
pub type PutPlaybackConfigurationInputOperationOutputAlias =
    crate::operation::PutPlaybackConfiguration;
#[doc(hidden)]
pub type PutPlaybackConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutPlaybackConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutPlaybackConfiguration`](crate::operation::PutPlaybackConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutPlaybackConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_put_playback_configuration(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutPlaybackConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutPlaybackConfiguration",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/playbackConfiguration").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutPlaybackConfigurationInput`](crate::input::PutPlaybackConfigurationInput)
    pub fn builder() -> crate::input::put_playback_configuration_input::Builder {
        crate::input::put_playback_configuration_input::Builder::default()
    }
}

/// See [`StartChannelInput`](crate::input::StartChannelInput)
pub mod start_channel_input {
    /// A builder for [`StartChannelInput`](crate::input::StartChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// Consumes the builder and constructs a [`StartChannelInput`](crate::input::StartChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::StartChannelInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::StartChannelInput {
                channel_name: self.channel_name,
            })
        }
    }
}
#[doc(hidden)]
pub type StartChannelInputOperationOutputAlias = crate::operation::StartChannel;
#[doc(hidden)]
pub type StartChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartChannelInput {
    /// Consumes the builder and constructs an Operation<[`StartChannel`](crate::operation::StartChannel)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::StartChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::StartChannel::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "StartChannel",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_35 = &self.channel_name;
        let input_35 =
            input_35
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                })?;
        let channel_name = smithy_http::label::fmt_string(input_35, false);
        if channel_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/channel/{ChannelName}/start",
            ChannelName = channel_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartChannelInput`](crate::input::StartChannelInput)
    pub fn builder() -> crate::input::start_channel_input::Builder {
        crate::input::start_channel_input::Builder::default()
    }
}

/// See [`StopChannelInput`](crate::input::StopChannelInput)
pub mod stop_channel_input {
    /// A builder for [`StopChannelInput`](crate::input::StopChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// Consumes the builder and constructs a [`StopChannelInput`](crate::input::StopChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::StopChannelInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::StopChannelInput {
                channel_name: self.channel_name,
            })
        }
    }
}
#[doc(hidden)]
pub type StopChannelInputOperationOutputAlias = crate::operation::StopChannel;
#[doc(hidden)]
pub type StopChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StopChannelInput {
    /// Consumes the builder and constructs an Operation<[`StopChannel`](crate::operation::StopChannel)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::StopChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::StopChannel::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "StopChannel",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_36 = &self.channel_name;
        let input_36 =
            input_36
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                })?;
        let channel_name = smithy_http::label::fmt_string(input_36, false);
        if channel_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/channel/{ChannelName}/stop",
            ChannelName = channel_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StopChannelInput`](crate::input::StopChannelInput)
    pub fn builder() -> crate::input::stop_channel_input::Builder {
        crate::input::stop_channel_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::TagResourceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_tag_resource(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::TagResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "TagResource",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_37 = &self.resource_arn;
        let input_37 =
            input_37
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                })?;
        let resource_arn = smithy_http::label::fmt_string(input_37, false);
        if resource_arn.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "resource_arn",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UntagResourceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UntagResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UntagResource",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_38 = &self.resource_arn;
        let input_38 =
            input_38
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                })?;
        let resource_arn = smithy_http::label::fmt_string(input_38, false);
        if resource_arn.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "resource_arn",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
            .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_39) = &self.tag_keys {
            for inner_40 in inner_39 {
                query.push_kv("tagKeys", &smithy_http::query::fmt_string(&inner_40));
            }
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateChannelInput`](crate::input::UpdateChannelInput)
pub mod update_channel_input {
    /// A builder for [`UpdateChannelInput`](crate::input::UpdateChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) outputs: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        pub fn outputs(mut self, input: impl Into<crate::model::RequestOutputItem>) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(input.into());
            self.outputs = Some(v);
            self
        }
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateChannelInput`](crate::input::UpdateChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UpdateChannelInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateChannelInput {
                channel_name: self.channel_name,
                outputs: self.outputs,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateChannelInputOperationOutputAlias = crate::operation::UpdateChannel;
#[doc(hidden)]
pub type UpdateChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateChannelInput {
    /// Consumes the builder and constructs an Operation<[`UpdateChannel`](crate::operation::UpdateChannel)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_update_channel(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateChannel::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateChannel",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_41 = &self.channel_name;
        let input_41 =
            input_41
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                })?;
        let channel_name = smithy_http::label::fmt_string(input_41, false);
        if channel_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "channel_name",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/channel/{ChannelName}", ChannelName = channel_name)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateChannelInput`](crate::input::UpdateChannelInput)
    pub fn builder() -> crate::input::update_channel_input::Builder {
        crate::input::update_channel_input::Builder::default()
    }
}

/// See [`UpdateSourceLocationInput`](crate::input::UpdateSourceLocationInput)
pub mod update_source_location_input {
    /// A builder for [`UpdateSourceLocationInput`](crate::input::UpdateSourceLocationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_configuration: std::option::Option<crate::model::AccessConfiguration>,
        pub(crate) default_segment_delivery_configuration:
            std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        pub(crate) http_configuration: std::option::Option<crate::model::HttpConfiguration>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
        pub fn access_configuration(mut self, input: crate::model::AccessConfiguration) -> Self {
            self.access_configuration = Some(input);
            self
        }
        pub fn set_access_configuration(
            mut self,
            input: std::option::Option<crate::model::AccessConfiguration>,
        ) -> Self {
            self.access_configuration = input;
            self
        }
        /// <p>The optional configuration for the host server that serves segments.</p>
        pub fn default_segment_delivery_configuration(
            mut self,
            input: crate::model::DefaultSegmentDeliveryConfiguration,
        ) -> Self {
            self.default_segment_delivery_configuration = Some(input);
            self
        }
        pub fn set_default_segment_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        ) -> Self {
            self.default_segment_delivery_configuration = input;
            self
        }
        /// <p>The HTTP configuration for the source location.</p>
        pub fn http_configuration(mut self, input: crate::model::HttpConfiguration) -> Self {
            self.http_configuration = Some(input);
            self
        }
        pub fn set_http_configuration(
            mut self,
            input: std::option::Option<crate::model::HttpConfiguration>,
        ) -> Self {
            self.http_configuration = input;
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSourceLocationInput`](crate::input::UpdateSourceLocationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateSourceLocationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateSourceLocationInput {
                access_configuration: self.access_configuration,
                default_segment_delivery_configuration: self.default_segment_delivery_configuration,
                http_configuration: self.http_configuration,
                source_location_name: self.source_location_name,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateSourceLocationInputOperationOutputAlias = crate::operation::UpdateSourceLocation;
#[doc(hidden)]
pub type UpdateSourceLocationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateSourceLocationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSourceLocation`](crate::operation::UpdateSourceLocation)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateSourceLocation,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_source_location(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateSourceLocation::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateSourceLocation",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_42 = &self.source_location_name;
        let input_42 =
            input_42
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                })?;
        let source_location_name = smithy_http::label::fmt_string(input_42, false);
        if source_location_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "source_location_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/sourceLocation/{SourceLocationName}",
            SourceLocationName = source_location_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateSourceLocationInput`](crate::input::UpdateSourceLocationInput)
    pub fn builder() -> crate::input::update_source_location_input::Builder {
        crate::input::update_source_location_input::Builder::default()
    }
}

/// See [`UpdateVodSourceInput`](crate::input::UpdateVodSourceInput)
pub mod update_vod_source_input {
    /// A builder for [`UpdateVodSourceInput`](crate::input::UpdateVodSourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) http_package_configurations:
            std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn http_package_configurations(
            mut self,
            input: impl Into<crate::model::HttpPackageConfiguration>,
        ) -> Self {
            let mut v = self.http_package_configurations.unwrap_or_default();
            v.push(input.into());
            self.http_package_configurations = Some(v);
            self
        }
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.http_package_configurations = input;
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVodSourceInput`](crate::input::UpdateVodSourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateVodSourceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateVodSourceInput {
                http_package_configurations: self.http_package_configurations,
                source_location_name: self.source_location_name,
                vod_source_name: self.vod_source_name,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateVodSourceInputOperationOutputAlias = crate::operation::UpdateVodSource;
#[doc(hidden)]
pub type UpdateVodSourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateVodSourceInput {
    /// Consumes the builder and constructs an Operation<[`UpdateVodSource`](crate::operation::UpdateVodSource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateVodSource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_vod_source(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateVodSource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateVodSource",
                "mediatailor",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_43 = &self.source_location_name;
        let input_43 =
            input_43
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                })?;
        let source_location_name = smithy_http::label::fmt_string(input_43, false);
        if source_location_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "source_location_name",
                details: "cannot be empty or unset",
            });
        }
        let input_44 = &self.vod_source_name;
        let input_44 =
            input_44
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "vod_source_name",
                    details: "cannot be empty or unset",
                })?;
        let vod_source_name = smithy_http::label::fmt_string(input_44, false);
        if vod_source_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "vod_source_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}",
            SourceLocationName = source_location_name,
            VodSourceName = vod_source_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateVodSourceInput`](crate::input::UpdateVodSourceInput)
    pub fn builder() -> crate::input::update_vod_source_input::Builder {
        crate::input::update_vod_source_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateVodSourceInput {
    /// <p>An array of HTTP package configurations for the VOD source on this account.</p>
    pub http_package_configurations:
        std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The identifier for the VOD source you are working on.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateVodSourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateVodSourceInput");
        formatter.field(
            "http_package_configurations",
            &self.http_package_configurations,
        );
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSourceLocationInput {
    /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
    pub access_configuration: std::option::Option<crate::model::AccessConfiguration>,
    /// <p>The optional configuration for the host server that serves segments.</p>
    pub default_segment_delivery_configuration:
        std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
    /// <p>The HTTP configuration for the source location.</p>
    pub http_configuration: std::option::Option<crate::model::HttpConfiguration>,
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateSourceLocationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSourceLocationInput");
        formatter.field("access_configuration", &self.access_configuration);
        formatter.field(
            "default_segment_delivery_configuration",
            &self.default_segment_delivery_configuration,
        );
        formatter.field("http_configuration", &self.http_configuration);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The channel's output properties.</p>
    pub outputs: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
}
impl std::fmt::Debug for UpdateChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("outputs", &self.outputs);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A comma-separated list of the tag keys to remove from the playback configuration.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A comma-separated list of tag key:value pairs.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StopChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopChannelInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartChannelInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutPlaybackConfigurationInput {
    /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    pub ad_decision_server_url: std::option::Option<std::string::String>,
    /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
    pub avail_suppression: std::option::Option<crate::model::AvailSuppression>,
    /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
    pub bumper: std::option::Option<crate::model::Bumper>,
    /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
    pub cdn_configuration: std::option::Option<crate::model::CdnConfiguration>,
    /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
    pub configuration_aliases: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    >,
    /// <p>The configuration for DASH content.</p>
    pub dash_configuration: std::option::Option<crate::model::DashConfigurationForPut>,
    /// <p>The configuration for pre-roll ad insertion.</p>
    pub live_pre_roll_configuration: std::option::Option<crate::model::LivePreRollConfiguration>,
    /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
    pub manifest_processing_rules: std::option::Option<crate::model::ManifestProcessingRules>,
    /// <p>The identifier for the playback configuration.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
    pub personalization_threshold_seconds: i32,
    /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
    pub slate_ad_url: std::option::Option<std::string::String>,
    /// <p>The tags to assign to the playback configuration.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
    pub transcode_profile_name: std::option::Option<std::string::String>,
    /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
    pub video_content_source_url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutPlaybackConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutPlaybackConfigurationInput");
        formatter.field("ad_decision_server_url", &self.ad_decision_server_url);
        formatter.field("avail_suppression", &self.avail_suppression);
        formatter.field("bumper", &self.bumper);
        formatter.field("cdn_configuration", &self.cdn_configuration);
        formatter.field("configuration_aliases", &self.configuration_aliases);
        formatter.field("dash_configuration", &self.dash_configuration);
        formatter.field(
            "live_pre_roll_configuration",
            &self.live_pre_roll_configuration,
        );
        formatter.field("manifest_processing_rules", &self.manifest_processing_rules);
        formatter.field("name", &self.name);
        formatter.field(
            "personalization_threshold_seconds",
            &self.personalization_threshold_seconds,
        );
        formatter.field("slate_ad_url", &self.slate_ad_url);
        formatter.field("tags", &self.tags);
        formatter.field("transcode_profile_name", &self.transcode_profile_name);
        formatter.field("video_content_source_url", &self.video_content_source_url);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutChannelPolicyInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>Adds an IAM role that determines the permissions of your channel.</p>
    pub policy: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutChannelPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutChannelPolicyInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("policy", &self.policy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListVodSourcesInput {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub max_results: i32,
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListVodSourcesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListVodSourcesInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSourceLocationsInput {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub max_results: i32,
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListSourceLocationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSourceLocationsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPlaybackConfigurationsInput {
    /// <p>Maximum number of records to return.</p>
    pub max_results: i32,
    /// <p>Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListPlaybackConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPlaybackConfigurationsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelsInput {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub max_results: i32,
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListChannelsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAlertsInput {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub max_results: i32,
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListAlertsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAlertsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPlaybackConfigurationInput {
    /// <p>The identifier for the playback configuration.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetPlaybackConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPlaybackConfigurationInput");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetChannelScheduleInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The schedule duration in minutes. The maximum duration is 4320 minutes (three days).</p>
    pub duration_minutes: std::option::Option<std::string::String>,
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub max_results: i32,
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetChannelScheduleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetChannelScheduleInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("duration_minutes", &self.duration_minutes);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetChannelPolicyInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetChannelPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetChannelPolicyInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeVodSourceInput {
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The identifier for the VOD source you are working on.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeVodSourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeVodSourceInput");
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSourceLocationInput {
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeSourceLocationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSourceLocationInput");
        formatter.field("source_location_name", &self.source_location_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProgramInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The identifier for the program you are working on.</p>
    pub program_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeProgramInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProgramInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("program_name", &self.program_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVodSourceInput {
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The identifier for the VOD source you are working on.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteVodSourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVodSourceInput");
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSourceLocationInput {
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteSourceLocationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSourceLocationInput");
        formatter.field("source_location_name", &self.source_location_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProgramInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The identifier for the program you are working on.</p>
    pub program_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteProgramInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProgramInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("program_name", &self.program_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePlaybackConfigurationInput {
    /// <p>The identifier for the playback configuration.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeletePlaybackConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePlaybackConfigurationInput");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelPolicyInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteChannelPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelPolicyInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateVodSourceInput {
    /// <p>An array of HTTP package configuration parameters for this VOD source.</p>
    pub http_package_configurations:
        std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags to assign to the VOD source.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The identifier for the VOD source you are working on.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateVodSourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateVodSourceInput");
        formatter.field(
            "http_package_configurations",
            &self.http_package_configurations,
        );
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("tags", &self.tags);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSourceLocationInput {
    /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
    pub access_configuration: std::option::Option<crate::model::AccessConfiguration>,
    /// <p>The optional configuration for the server that serves segments.</p>
    pub default_segment_delivery_configuration:
        std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
    /// <p>The source's HTTP package configurations.</p>
    pub http_configuration: std::option::Option<crate::model::HttpConfiguration>,
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags to assign to the source location.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for CreateSourceLocationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSourceLocationInput");
        formatter.field("access_configuration", &self.access_configuration);
        formatter.field(
            "default_segment_delivery_configuration",
            &self.default_segment_delivery_configuration,
        );
        formatter.field("http_configuration", &self.http_configuration);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProgramInput {
    /// <p>The ad break configuration settings.</p>
    pub ad_breaks: std::option::Option<std::vec::Vec<crate::model::AdBreak>>,
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The identifier for the program you are working on.</p>
    pub program_name: std::option::Option<std::string::String>,
    /// <p>The schedule configuration settings.</p>
    pub schedule_configuration: std::option::Option<crate::model::ScheduleConfiguration>,
    /// <p>The name of the source location.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The name that's used to refer to a VOD source.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateProgramInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProgramInput");
        formatter.field("ad_breaks", &self.ad_breaks);
        formatter.field("channel_name", &self.channel_name);
        formatter.field("program_name", &self.program_name);
        formatter.field("schedule_configuration", &self.schedule_configuration);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The channel's output properties.</p>
    pub outputs: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
    /// <p>The type of playback mode for this channel. The only supported value is LOOP.</p>
    pub playback_mode: std::option::Option<crate::model::PlaybackMode>,
    /// <p>The tags to assign to the channel.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for CreateChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("outputs", &self.outputs);
        formatter.field("playback_mode", &self.playback_mode);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
