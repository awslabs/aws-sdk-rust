// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`ConfigureLogsForPlaybackConfigurationInput`](crate::input::ConfigureLogsForPlaybackConfigurationInput)
pub mod configure_logs_for_playback_configuration_input {
    /// A builder for [`ConfigureLogsForPlaybackConfigurationInput`](crate::input::ConfigureLogsForPlaybackConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) percent_enabled: std::option::Option<i32>,
        pub(crate) playback_configuration_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to 60, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html">debug log mode</a>.</p> <p>Valid values: 0 - 100</p>
        pub fn percent_enabled(mut self, input: i32) -> Self {
            self.percent_enabled = Some(input);
            self
        }
        /// <p>The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to 60, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html">debug log mode</a>.</p> <p>Valid values: 0 - 100</p>
        pub fn set_percent_enabled(mut self, input: std::option::Option<i32>) -> Self {
            self.percent_enabled = input;
            self
        }
        /// <p>The name of the playback configuration.</p>
        pub fn playback_configuration_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the playback configuration.</p>
        pub fn set_playback_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigureLogsForPlaybackConfigurationInput`](crate::input::ConfigureLogsForPlaybackConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ConfigureLogsForPlaybackConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ConfigureLogsForPlaybackConfigurationInput {
                percent_enabled: self.percent_enabled.unwrap_or_default(),
                playback_configuration_name: self.playback_configuration_name,
            })
        }
    }
}
#[doc(hidden)]
pub type ConfigureLogsForPlaybackConfigurationInputOperationOutputAlias =
    crate::operation::ConfigureLogsForPlaybackConfiguration;
#[doc(hidden)]
pub type ConfigureLogsForPlaybackConfigurationInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl ConfigureLogsForPlaybackConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`ConfigureLogsForPlaybackConfiguration`](crate::operation::ConfigureLogsForPlaybackConfiguration)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ConfigureLogsForPlaybackConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ConfigureLogsForPlaybackConfigurationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/configureLogs/playbackConfiguration")
                .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ConfigureLogsForPlaybackConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ConfigureLogsForPlaybackConfigurationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_configure_logs_for_playback_configuration(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ConfigureLogsForPlaybackConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ConfigureLogsForPlaybackConfiguration",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ConfigureLogsForPlaybackConfigurationInput`](crate::input::ConfigureLogsForPlaybackConfigurationInput)
    pub fn builder() -> crate::input::configure_logs_for_playback_configuration_input::Builder {
        crate::input::configure_logs_for_playback_configuration_input::Builder::default()
    }
}

/// See [`CreateChannelInput`](crate::input::CreateChannelInput)
pub mod create_channel_input {
    /// A builder for [`CreateChannelInput`](crate::input::CreateChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) filler_slate: std::option::Option<crate::model::SlateSource>,
        pub(crate) outputs: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
        pub(crate) playback_mode: std::option::Option<crate::model::PlaybackMode>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses a LINEAR PlaybackMode.</p>
        pub fn filler_slate(mut self, input: crate::model::SlateSource) -> Self {
            self.filler_slate = Some(input);
            self
        }
        /// <p>The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses a LINEAR PlaybackMode.</p>
        pub fn set_filler_slate(
            mut self,
            input: std::option::Option<crate::model::SlateSource>,
        ) -> Self {
            self.filler_slate = input;
            self
        }
        /// Appends an item to `outputs`.
        ///
        /// To override the contents of this collection use [`set_outputs`](Self::set_outputs).
        ///
        /// <p>The channel's output properties.</p>
        pub fn outputs(mut self, input: impl Into<crate::model::RequestOutputItem>) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(input.into());
            self.outputs = Some(v);
            self
        }
        /// <p>The channel's output properties.</p>
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// <p>The type of playback mode to use for this channel.</p> <p>LINEAR - The programs in the schedule play once back-to-back in the schedule.</p> <p>LOOP - The programs in the schedule play back-to-back in an endless loop. When the last program in the schedule stops playing, playback loops back to the first program in the schedule.</p>
        pub fn playback_mode(mut self, input: crate::model::PlaybackMode) -> Self {
            self.playback_mode = Some(input);
            self
        }
        /// <p>The type of playback mode to use for this channel.</p> <p>LINEAR - The programs in the schedule play once back-to-back in the schedule.</p> <p>LOOP - The programs in the schedule play back-to-back in an endless loop. When the last program in the schedule stops playing, playback loops back to the first program in the schedule.</p>
        pub fn set_playback_mode(
            mut self,
            input: std::option::Option<crate::model::PlaybackMode>,
        ) -> Self {
            self.playback_mode = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to assign to the channel.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags to assign to the channel.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateChannelInput`](crate::input::CreateChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateChannelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateChannelInput {
                channel_name: self.channel_name,
                filler_slate: self.filler_slate,
                outputs: self.outputs,
                playback_mode: self.playback_mode,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateChannelInputOperationOutputAlias = crate::operation::CreateChannel;
#[doc(hidden)]
pub type CreateChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateChannelInput {
    /// Consumes the builder and constructs an Operation<[`CreateChannel`](crate::operation::CreateChannel)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateChannelInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_1 = &_input.channel_name;
            let input_1 =
                input_1
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_name",
                        details: "cannot be empty or unset",
                    })?;
            let channel_name = aws_smithy_http::label::fmt_string(input_1, false);
            if channel_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/channel/{ChannelName}", ChannelName = channel_name)
                .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateChannelInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateChannelInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_create_channel(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateChannel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateChannel",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateChannelInput`](crate::input::CreateChannelInput)
    pub fn builder() -> crate::input::create_channel_input::Builder {
        crate::input::create_channel_input::Builder::default()
    }
}

/// See [`CreatePrefetchScheduleInput`](crate::input::CreatePrefetchScheduleInput)
pub mod create_prefetch_schedule_input {
    /// A builder for [`CreatePrefetchScheduleInput`](crate::input::CreatePrefetchScheduleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) consumption: std::option::Option<crate::model::PrefetchConsumption>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) playback_configuration_name: std::option::Option<std::string::String>,
        pub(crate) retrieval: std::option::Option<crate::model::PrefetchRetrieval>,
        pub(crate) stream_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The configuration settings for MediaTailor's <i>consumption</i> of the prefetched ads from the ad decision server. Each consumption configuration contains an end time and an optional start time that define the <i>consumption window</i>. Prefetch schedules automatically expire no earlier than seven days after the end time.</p>
        pub fn consumption(mut self, input: crate::model::PrefetchConsumption) -> Self {
            self.consumption = Some(input);
            self
        }
        /// <p>The configuration settings for MediaTailor's <i>consumption</i> of the prefetched ads from the ad decision server. Each consumption configuration contains an end time and an optional start time that define the <i>consumption window</i>. Prefetch schedules automatically expire no earlier than seven days after the end time.</p>
        pub fn set_consumption(
            mut self,
            input: std::option::Option<crate::model::PrefetchConsumption>,
        ) -> Self {
            self.consumption = input;
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the playback configuration.</p>
        pub fn playback_configuration_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the playback configuration.</p>
        pub fn set_playback_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = input;
            self
        }
        /// <p>The configuration settings for retrieval of prefetched ads from the ad decision server. Only one set of prefetched ads will be retrieved and subsequently consumed for each ad break.</p>
        pub fn retrieval(mut self, input: crate::model::PrefetchRetrieval) -> Self {
            self.retrieval = Some(input);
            self
        }
        /// <p>The configuration settings for retrieval of prefetched ads from the ad decision server. Only one set of prefetched ads will be retrieved and subsequently consumed for each ad break.</p>
        pub fn set_retrieval(
            mut self,
            input: std::option::Option<crate::model::PrefetchRetrieval>,
        ) -> Self {
            self.retrieval = input;
            self
        }
        /// <p>An optional stream identifier that MediaTailor uses to prefetch ads for multiple streams that use the same playback configuration. If StreamId is specified, MediaTailor returns all of the prefetch schedules with an exact match on StreamId. If not specified, MediaTailor returns all of the prefetch schedules for the playback configuration, regardless of StreamId.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>An optional stream identifier that MediaTailor uses to prefetch ads for multiple streams that use the same playback configuration. If StreamId is specified, MediaTailor returns all of the prefetch schedules with an exact match on StreamId. If not specified, MediaTailor returns all of the prefetch schedules for the playback configuration, regardless of StreamId.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CreatePrefetchScheduleInput`](crate::input::CreatePrefetchScheduleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreatePrefetchScheduleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreatePrefetchScheduleInput {
                consumption: self.consumption,
                name: self.name,
                playback_configuration_name: self.playback_configuration_name,
                retrieval: self.retrieval,
                stream_id: self.stream_id,
            })
        }
    }
}
#[doc(hidden)]
pub type CreatePrefetchScheduleInputOperationOutputAlias = crate::operation::CreatePrefetchSchedule;
#[doc(hidden)]
pub type CreatePrefetchScheduleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreatePrefetchScheduleInput {
    /// Consumes the builder and constructs an Operation<[`CreatePrefetchSchedule`](crate::operation::CreatePrefetchSchedule)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreatePrefetchSchedule,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreatePrefetchScheduleInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_2 = &_input.playback_configuration_name;
            let input_2 =
                input_2
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "playback_configuration_name",
                        details: "cannot be empty or unset",
                    })?;
            let playback_configuration_name = aws_smithy_http::label::fmt_string(input_2, false);
            if playback_configuration_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "playback_configuration_name",
                    details: "cannot be empty or unset",
                });
            }
            let input_3 = &_input.name;
            let input_3 =
                input_3
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "name",
                        details: "cannot be empty or unset",
                    })?;
            let name = aws_smithy_http::label::fmt_string(input_3, false);
            if name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/prefetchSchedule/{PlaybackConfigurationName}/{Name}",
                PlaybackConfigurationName = playback_configuration_name,
                Name = name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreatePrefetchScheduleInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreatePrefetchScheduleInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_prefetch_schedule(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreatePrefetchSchedule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreatePrefetchSchedule",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreatePrefetchScheduleInput`](crate::input::CreatePrefetchScheduleInput)
    pub fn builder() -> crate::input::create_prefetch_schedule_input::Builder {
        crate::input::create_prefetch_schedule_input::Builder::default()
    }
}

/// See [`CreateProgramInput`](crate::input::CreateProgramInput)
pub mod create_program_input {
    /// A builder for [`CreateProgramInput`](crate::input::CreateProgramInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ad_breaks: std::option::Option<std::vec::Vec<crate::model::AdBreak>>,
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) program_name: std::option::Option<std::string::String>,
        pub(crate) schedule_configuration: std::option::Option<crate::model::ScheduleConfiguration>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `ad_breaks`.
        ///
        /// To override the contents of this collection use [`set_ad_breaks`](Self::set_ad_breaks).
        ///
        /// <p>The ad break configuration settings.</p>
        pub fn ad_breaks(mut self, input: impl Into<crate::model::AdBreak>) -> Self {
            let mut v = self.ad_breaks.unwrap_or_default();
            v.push(input.into());
            self.ad_breaks = Some(v);
            self
        }
        /// <p>The ad break configuration settings.</p>
        pub fn set_ad_breaks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AdBreak>>,
        ) -> Self {
            self.ad_breaks = input;
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The identifier for the program you are working on.</p>
        pub fn program_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.program_name = Some(input.into());
            self
        }
        /// <p>The identifier for the program you are working on.</p>
        pub fn set_program_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.program_name = input;
            self
        }
        /// <p>The schedule configuration settings.</p>
        pub fn schedule_configuration(
            mut self,
            input: crate::model::ScheduleConfiguration,
        ) -> Self {
            self.schedule_configuration = Some(input);
            self
        }
        /// <p>The schedule configuration settings.</p>
        pub fn set_schedule_configuration(
            mut self,
            input: std::option::Option<crate::model::ScheduleConfiguration>,
        ) -> Self {
            self.schedule_configuration = input;
            self
        }
        /// <p>The name of the source location.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// <p>The name that's used to refer to a VOD source.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The name that's used to refer to a VOD source.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateProgramInput`](crate::input::CreateProgramInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateProgramInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateProgramInput {
                ad_breaks: self.ad_breaks,
                channel_name: self.channel_name,
                program_name: self.program_name,
                schedule_configuration: self.schedule_configuration,
                source_location_name: self.source_location_name,
                vod_source_name: self.vod_source_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateProgramInputOperationOutputAlias = crate::operation::CreateProgram;
#[doc(hidden)]
pub type CreateProgramInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateProgramInput {
    /// Consumes the builder and constructs an Operation<[`CreateProgram`](crate::operation::CreateProgram)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateProgram,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateProgramInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_4 = &_input.channel_name;
            let input_4 =
                input_4
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_name",
                        details: "cannot be empty or unset",
                    })?;
            let channel_name = aws_smithy_http::label::fmt_string(input_4, false);
            if channel_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                });
            }
            let input_5 = &_input.program_name;
            let input_5 =
                input_5
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "program_name",
                        details: "cannot be empty or unset",
                    })?;
            let program_name = aws_smithy_http::label::fmt_string(input_5, false);
            if program_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "program_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channel/{ChannelName}/program/{ProgramName}",
                ChannelName = channel_name,
                ProgramName = program_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateProgramInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateProgramInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_create_program(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateProgram::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateProgram",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateProgramInput`](crate::input::CreateProgramInput)
    pub fn builder() -> crate::input::create_program_input::Builder {
        crate::input::create_program_input::Builder::default()
    }
}

/// See [`CreateSourceLocationInput`](crate::input::CreateSourceLocationInput)
pub mod create_source_location_input {
    /// A builder for [`CreateSourceLocationInput`](crate::input::CreateSourceLocationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_configuration: std::option::Option<crate::model::AccessConfiguration>,
        pub(crate) default_segment_delivery_configuration:
            std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        pub(crate) http_configuration: std::option::Option<crate::model::HttpConfiguration>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
        pub fn access_configuration(mut self, input: crate::model::AccessConfiguration) -> Self {
            self.access_configuration = Some(input);
            self
        }
        /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
        pub fn set_access_configuration(
            mut self,
            input: std::option::Option<crate::model::AccessConfiguration>,
        ) -> Self {
            self.access_configuration = input;
            self
        }
        /// <p>The optional configuration for the server that serves segments.</p>
        pub fn default_segment_delivery_configuration(
            mut self,
            input: crate::model::DefaultSegmentDeliveryConfiguration,
        ) -> Self {
            self.default_segment_delivery_configuration = Some(input);
            self
        }
        /// <p>The optional configuration for the server that serves segments.</p>
        pub fn set_default_segment_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        ) -> Self {
            self.default_segment_delivery_configuration = input;
            self
        }
        /// <p>The source's HTTP package configurations.</p>
        pub fn http_configuration(mut self, input: crate::model::HttpConfiguration) -> Self {
            self.http_configuration = Some(input);
            self
        }
        /// <p>The source's HTTP package configurations.</p>
        pub fn set_http_configuration(
            mut self,
            input: std::option::Option<crate::model::HttpConfiguration>,
        ) -> Self {
            self.http_configuration = input;
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to assign to the source location.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags to assign to the source location.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSourceLocationInput`](crate::input::CreateSourceLocationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateSourceLocationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateSourceLocationInput {
                access_configuration: self.access_configuration,
                default_segment_delivery_configuration: self.default_segment_delivery_configuration,
                http_configuration: self.http_configuration,
                source_location_name: self.source_location_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateSourceLocationInputOperationOutputAlias = crate::operation::CreateSourceLocation;
#[doc(hidden)]
pub type CreateSourceLocationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateSourceLocationInput {
    /// Consumes the builder and constructs an Operation<[`CreateSourceLocation`](crate::operation::CreateSourceLocation)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateSourceLocation,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateSourceLocationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_6 = &_input.source_location_name;
            let input_6 =
                input_6
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "source_location_name",
                        details: "cannot be empty or unset",
                    })?;
            let source_location_name = aws_smithy_http::label::fmt_string(input_6, false);
            if source_location_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/sourceLocation/{SourceLocationName}",
                SourceLocationName = source_location_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateSourceLocationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateSourceLocationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_source_location(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateSourceLocation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateSourceLocation",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateSourceLocationInput`](crate::input::CreateSourceLocationInput)
    pub fn builder() -> crate::input::create_source_location_input::Builder {
        crate::input::create_source_location_input::Builder::default()
    }
}

/// See [`CreateVodSourceInput`](crate::input::CreateVodSourceInput)
pub mod create_vod_source_input {
    /// A builder for [`CreateVodSourceInput`](crate::input::CreateVodSourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) http_package_configurations:
            std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `http_package_configurations`.
        ///
        /// To override the contents of this collection use [`set_http_package_configurations`](Self::set_http_package_configurations).
        ///
        /// <p>An array of HTTP package configuration parameters for this VOD source.</p>
        pub fn http_package_configurations(
            mut self,
            input: impl Into<crate::model::HttpPackageConfiguration>,
        ) -> Self {
            let mut v = self.http_package_configurations.unwrap_or_default();
            v.push(input.into());
            self.http_package_configurations = Some(v);
            self
        }
        /// <p>An array of HTTP package configuration parameters for this VOD source.</p>
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.http_package_configurations = input;
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to assign to the VOD source.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags to assign to the VOD source.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVodSourceInput`](crate::input::CreateVodSourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateVodSourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateVodSourceInput {
                http_package_configurations: self.http_package_configurations,
                source_location_name: self.source_location_name,
                tags: self.tags,
                vod_source_name: self.vod_source_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateVodSourceInputOperationOutputAlias = crate::operation::CreateVodSource;
#[doc(hidden)]
pub type CreateVodSourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateVodSourceInput {
    /// Consumes the builder and constructs an Operation<[`CreateVodSource`](crate::operation::CreateVodSource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateVodSource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateVodSourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_7 = &_input.source_location_name;
            let input_7 =
                input_7
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "source_location_name",
                        details: "cannot be empty or unset",
                    })?;
            let source_location_name = aws_smithy_http::label::fmt_string(input_7, false);
            if source_location_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                });
            }
            let input_8 = &_input.vod_source_name;
            let input_8 =
                input_8
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "vod_source_name",
                        details: "cannot be empty or unset",
                    })?;
            let vod_source_name = aws_smithy_http::label::fmt_string(input_8, false);
            if vod_source_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "vod_source_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}",
                SourceLocationName = source_location_name,
                VodSourceName = vod_source_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateVodSourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateVodSourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_vod_source(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateVodSource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateVodSource",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateVodSourceInput`](crate::input::CreateVodSourceInput)
    pub fn builder() -> crate::input::create_vod_source_input::Builder {
        crate::input::create_vod_source_input::Builder::default()
    }
}

/// See [`DeleteChannelInput`](crate::input::DeleteChannelInput)
pub mod delete_channel_input {
    /// A builder for [`DeleteChannelInput`](crate::input::DeleteChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelInput`](crate::input::DeleteChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteChannelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteChannelInput {
                channel_name: self.channel_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelInputOperationOutputAlias = crate::operation::DeleteChannel;
#[doc(hidden)]
pub type DeleteChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteChannelInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannel`](crate::operation::DeleteChannel)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteChannelInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_9 = &_input.channel_name;
            let input_9 =
                input_9
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_name",
                        details: "cannot be empty or unset",
                    })?;
            let channel_name = aws_smithy_http::label::fmt_string(input_9, false);
            if channel_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/channel/{ChannelName}", ChannelName = channel_name)
                .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteChannelInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteChannelInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteChannel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteChannel",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelInput`](crate::input::DeleteChannelInput)
    pub fn builder() -> crate::input::delete_channel_input::Builder {
        crate::input::delete_channel_input::Builder::default()
    }
}

/// See [`DeleteChannelPolicyInput`](crate::input::DeleteChannelPolicyInput)
pub mod delete_channel_policy_input {
    /// A builder for [`DeleteChannelPolicyInput`](crate::input::DeleteChannelPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelPolicyInput`](crate::input::DeleteChannelPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteChannelPolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteChannelPolicyInput {
                channel_name: self.channel_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelPolicyInputOperationOutputAlias = crate::operation::DeleteChannelPolicy;
#[doc(hidden)]
pub type DeleteChannelPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteChannelPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannelPolicy`](crate::operation::DeleteChannelPolicy)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteChannelPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteChannelPolicyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_10 = &_input.channel_name;
            let input_10 =
                input_10
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_name",
                        details: "cannot be empty or unset",
                    })?;
            let channel_name = aws_smithy_http::label::fmt_string(input_10, false);
            if channel_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channel/{ChannelName}/policy",
                ChannelName = channel_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteChannelPolicyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteChannelPolicyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteChannelPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteChannelPolicy",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelPolicyInput`](crate::input::DeleteChannelPolicyInput)
    pub fn builder() -> crate::input::delete_channel_policy_input::Builder {
        crate::input::delete_channel_policy_input::Builder::default()
    }
}

/// See [`DeletePlaybackConfigurationInput`](crate::input::DeletePlaybackConfigurationInput)
pub mod delete_playback_configuration_input {
    /// A builder for [`DeletePlaybackConfigurationInput`](crate::input::DeletePlaybackConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletePlaybackConfigurationInput`](crate::input::DeletePlaybackConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeletePlaybackConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeletePlaybackConfigurationInput { name: self.name })
        }
    }
}
#[doc(hidden)]
pub type DeletePlaybackConfigurationInputOperationOutputAlias =
    crate::operation::DeletePlaybackConfiguration;
#[doc(hidden)]
pub type DeletePlaybackConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeletePlaybackConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeletePlaybackConfiguration`](crate::operation::DeletePlaybackConfiguration)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeletePlaybackConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeletePlaybackConfigurationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_11 = &_input.name;
            let input_11 =
                input_11
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "name",
                        details: "cannot be empty or unset",
                    })?;
            let name = aws_smithy_http::label::fmt_string(input_11, false);
            if name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "name",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/playbackConfiguration/{Name}", Name = name)
                .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeletePlaybackConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeletePlaybackConfigurationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeletePlaybackConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeletePlaybackConfiguration",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeletePlaybackConfigurationInput`](crate::input::DeletePlaybackConfigurationInput)
    pub fn builder() -> crate::input::delete_playback_configuration_input::Builder {
        crate::input::delete_playback_configuration_input::Builder::default()
    }
}

/// See [`DeletePrefetchScheduleInput`](crate::input::DeletePrefetchScheduleInput)
pub mod delete_prefetch_schedule_input {
    /// A builder for [`DeletePrefetchScheduleInput`](crate::input::DeletePrefetchScheduleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) playback_configuration_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the playback configuration.</p>
        pub fn playback_configuration_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the playback configuration.</p>
        pub fn set_playback_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletePrefetchScheduleInput`](crate::input::DeletePrefetchScheduleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeletePrefetchScheduleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeletePrefetchScheduleInput {
                name: self.name,
                playback_configuration_name: self.playback_configuration_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeletePrefetchScheduleInputOperationOutputAlias = crate::operation::DeletePrefetchSchedule;
#[doc(hidden)]
pub type DeletePrefetchScheduleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeletePrefetchScheduleInput {
    /// Consumes the builder and constructs an Operation<[`DeletePrefetchSchedule`](crate::operation::DeletePrefetchSchedule)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeletePrefetchSchedule,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeletePrefetchScheduleInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_12 = &_input.playback_configuration_name;
            let input_12 =
                input_12
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "playback_configuration_name",
                        details: "cannot be empty or unset",
                    })?;
            let playback_configuration_name = aws_smithy_http::label::fmt_string(input_12, false);
            if playback_configuration_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "playback_configuration_name",
                    details: "cannot be empty or unset",
                });
            }
            let input_13 = &_input.name;
            let input_13 =
                input_13
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "name",
                        details: "cannot be empty or unset",
                    })?;
            let name = aws_smithy_http::label::fmt_string(input_13, false);
            if name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/prefetchSchedule/{PlaybackConfigurationName}/{Name}",
                PlaybackConfigurationName = playback_configuration_name,
                Name = name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeletePrefetchScheduleInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeletePrefetchScheduleInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeletePrefetchSchedule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeletePrefetchSchedule",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeletePrefetchScheduleInput`](crate::input::DeletePrefetchScheduleInput)
    pub fn builder() -> crate::input::delete_prefetch_schedule_input::Builder {
        crate::input::delete_prefetch_schedule_input::Builder::default()
    }
}

/// See [`DeleteProgramInput`](crate::input::DeleteProgramInput)
pub mod delete_program_input {
    /// A builder for [`DeleteProgramInput`](crate::input::DeleteProgramInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) program_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The identifier for the program you are working on.</p>
        pub fn program_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.program_name = Some(input.into());
            self
        }
        /// <p>The identifier for the program you are working on.</p>
        pub fn set_program_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.program_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteProgramInput`](crate::input::DeleteProgramInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteProgramInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteProgramInput {
                channel_name: self.channel_name,
                program_name: self.program_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteProgramInputOperationOutputAlias = crate::operation::DeleteProgram;
#[doc(hidden)]
pub type DeleteProgramInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteProgramInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProgram`](crate::operation::DeleteProgram)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteProgram,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteProgramInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_14 = &_input.channel_name;
            let input_14 =
                input_14
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_name",
                        details: "cannot be empty or unset",
                    })?;
            let channel_name = aws_smithy_http::label::fmt_string(input_14, false);
            if channel_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                });
            }
            let input_15 = &_input.program_name;
            let input_15 =
                input_15
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "program_name",
                        details: "cannot be empty or unset",
                    })?;
            let program_name = aws_smithy_http::label::fmt_string(input_15, false);
            if program_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "program_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channel/{ChannelName}/program/{ProgramName}",
                ChannelName = channel_name,
                ProgramName = program_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteProgramInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteProgramInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteProgram::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteProgram",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteProgramInput`](crate::input::DeleteProgramInput)
    pub fn builder() -> crate::input::delete_program_input::Builder {
        crate::input::delete_program_input::Builder::default()
    }
}

/// See [`DeleteSourceLocationInput`](crate::input::DeleteSourceLocationInput)
pub mod delete_source_location_input {
    /// A builder for [`DeleteSourceLocationInput`](crate::input::DeleteSourceLocationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_location_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSourceLocationInput`](crate::input::DeleteSourceLocationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteSourceLocationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteSourceLocationInput {
                source_location_name: self.source_location_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteSourceLocationInputOperationOutputAlias = crate::operation::DeleteSourceLocation;
#[doc(hidden)]
pub type DeleteSourceLocationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteSourceLocationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSourceLocation`](crate::operation::DeleteSourceLocation)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteSourceLocation,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteSourceLocationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_16 = &_input.source_location_name;
            let input_16 =
                input_16
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "source_location_name",
                        details: "cannot be empty or unset",
                    })?;
            let source_location_name = aws_smithy_http::label::fmt_string(input_16, false);
            if source_location_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/sourceLocation/{SourceLocationName}",
                SourceLocationName = source_location_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteSourceLocationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteSourceLocationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteSourceLocation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteSourceLocation",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteSourceLocationInput`](crate::input::DeleteSourceLocationInput)
    pub fn builder() -> crate::input::delete_source_location_input::Builder {
        crate::input::delete_source_location_input::Builder::default()
    }
}

/// See [`DeleteVodSourceInput`](crate::input::DeleteVodSourceInput)
pub mod delete_vod_source_input {
    /// A builder for [`DeleteVodSourceInput`](crate::input::DeleteVodSourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVodSourceInput`](crate::input::DeleteVodSourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteVodSourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteVodSourceInput {
                source_location_name: self.source_location_name,
                vod_source_name: self.vod_source_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteVodSourceInputOperationOutputAlias = crate::operation::DeleteVodSource;
#[doc(hidden)]
pub type DeleteVodSourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteVodSourceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVodSource`](crate::operation::DeleteVodSource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteVodSource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteVodSourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_17 = &_input.source_location_name;
            let input_17 =
                input_17
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "source_location_name",
                        details: "cannot be empty or unset",
                    })?;
            let source_location_name = aws_smithy_http::label::fmt_string(input_17, false);
            if source_location_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                });
            }
            let input_18 = &_input.vod_source_name;
            let input_18 =
                input_18
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "vod_source_name",
                        details: "cannot be empty or unset",
                    })?;
            let vod_source_name = aws_smithy_http::label::fmt_string(input_18, false);
            if vod_source_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "vod_source_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}",
                SourceLocationName = source_location_name,
                VodSourceName = vod_source_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteVodSourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteVodSourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteVodSource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteVodSource",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteVodSourceInput`](crate::input::DeleteVodSourceInput)
    pub fn builder() -> crate::input::delete_vod_source_input::Builder {
        crate::input::delete_vod_source_input::Builder::default()
    }
}

/// See [`DescribeChannelInput`](crate::input::DescribeChannelInput)
pub mod describe_channel_input {
    /// A builder for [`DescribeChannelInput`](crate::input::DescribeChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelInput`](crate::input::DescribeChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeChannelInput {
                channel_name: self.channel_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelInputOperationOutputAlias = crate::operation::DescribeChannel;
#[doc(hidden)]
pub type DescribeChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeChannelInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannel`](crate::operation::DescribeChannel)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeChannelInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_19 = &_input.channel_name;
            let input_19 =
                input_19
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_name",
                        details: "cannot be empty or unset",
                    })?;
            let channel_name = aws_smithy_http::label::fmt_string(input_19, false);
            if channel_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/channel/{ChannelName}", ChannelName = channel_name)
                .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeChannelInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeChannelInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeChannel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeChannel",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelInput`](crate::input::DescribeChannelInput)
    pub fn builder() -> crate::input::describe_channel_input::Builder {
        crate::input::describe_channel_input::Builder::default()
    }
}

/// See [`DescribeProgramInput`](crate::input::DescribeProgramInput)
pub mod describe_program_input {
    /// A builder for [`DescribeProgramInput`](crate::input::DescribeProgramInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) program_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The identifier for the program you are working on.</p>
        pub fn program_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.program_name = Some(input.into());
            self
        }
        /// <p>The identifier for the program you are working on.</p>
        pub fn set_program_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.program_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeProgramInput`](crate::input::DescribeProgramInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeProgramInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeProgramInput {
                channel_name: self.channel_name,
                program_name: self.program_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeProgramInputOperationOutputAlias = crate::operation::DescribeProgram;
#[doc(hidden)]
pub type DescribeProgramInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeProgramInput {
    /// Consumes the builder and constructs an Operation<[`DescribeProgram`](crate::operation::DescribeProgram)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeProgram,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeProgramInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_20 = &_input.channel_name;
            let input_20 =
                input_20
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_name",
                        details: "cannot be empty or unset",
                    })?;
            let channel_name = aws_smithy_http::label::fmt_string(input_20, false);
            if channel_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                });
            }
            let input_21 = &_input.program_name;
            let input_21 =
                input_21
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "program_name",
                        details: "cannot be empty or unset",
                    })?;
            let program_name = aws_smithy_http::label::fmt_string(input_21, false);
            if program_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "program_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channel/{ChannelName}/program/{ProgramName}",
                ChannelName = channel_name,
                ProgramName = program_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeProgramInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeProgramInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeProgram::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeProgram",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeProgramInput`](crate::input::DescribeProgramInput)
    pub fn builder() -> crate::input::describe_program_input::Builder {
        crate::input::describe_program_input::Builder::default()
    }
}

/// See [`DescribeSourceLocationInput`](crate::input::DescribeSourceLocationInput)
pub mod describe_source_location_input {
    /// A builder for [`DescribeSourceLocationInput`](crate::input::DescribeSourceLocationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_location_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeSourceLocationInput`](crate::input::DescribeSourceLocationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeSourceLocationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeSourceLocationInput {
                source_location_name: self.source_location_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeSourceLocationInputOperationOutputAlias = crate::operation::DescribeSourceLocation;
#[doc(hidden)]
pub type DescribeSourceLocationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeSourceLocationInput {
    /// Consumes the builder and constructs an Operation<[`DescribeSourceLocation`](crate::operation::DescribeSourceLocation)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeSourceLocation,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeSourceLocationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_22 = &_input.source_location_name;
            let input_22 =
                input_22
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "source_location_name",
                        details: "cannot be empty or unset",
                    })?;
            let source_location_name = aws_smithy_http::label::fmt_string(input_22, false);
            if source_location_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/sourceLocation/{SourceLocationName}",
                SourceLocationName = source_location_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeSourceLocationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeSourceLocationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeSourceLocation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeSourceLocation",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeSourceLocationInput`](crate::input::DescribeSourceLocationInput)
    pub fn builder() -> crate::input::describe_source_location_input::Builder {
        crate::input::describe_source_location_input::Builder::default()
    }
}

/// See [`DescribeVodSourceInput`](crate::input::DescribeVodSourceInput)
pub mod describe_vod_source_input {
    /// A builder for [`DescribeVodSourceInput`](crate::input::DescribeVodSourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeVodSourceInput`](crate::input::DescribeVodSourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeVodSourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeVodSourceInput {
                source_location_name: self.source_location_name,
                vod_source_name: self.vod_source_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeVodSourceInputOperationOutputAlias = crate::operation::DescribeVodSource;
#[doc(hidden)]
pub type DescribeVodSourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeVodSourceInput {
    /// Consumes the builder and constructs an Operation<[`DescribeVodSource`](crate::operation::DescribeVodSource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeVodSource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeVodSourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_23 = &_input.source_location_name;
            let input_23 =
                input_23
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "source_location_name",
                        details: "cannot be empty or unset",
                    })?;
            let source_location_name = aws_smithy_http::label::fmt_string(input_23, false);
            if source_location_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                });
            }
            let input_24 = &_input.vod_source_name;
            let input_24 =
                input_24
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "vod_source_name",
                        details: "cannot be empty or unset",
                    })?;
            let vod_source_name = aws_smithy_http::label::fmt_string(input_24, false);
            if vod_source_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "vod_source_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}",
                SourceLocationName = source_location_name,
                VodSourceName = vod_source_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeVodSourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeVodSourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeVodSource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeVodSource",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeVodSourceInput`](crate::input::DescribeVodSourceInput)
    pub fn builder() -> crate::input::describe_vod_source_input::Builder {
        crate::input::describe_vod_source_input::Builder::default()
    }
}

/// See [`GetChannelPolicyInput`](crate::input::GetChannelPolicyInput)
pub mod get_channel_policy_input {
    /// A builder for [`GetChannelPolicyInput`](crate::input::GetChannelPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetChannelPolicyInput`](crate::input::GetChannelPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetChannelPolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetChannelPolicyInput {
                channel_name: self.channel_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetChannelPolicyInputOperationOutputAlias = crate::operation::GetChannelPolicy;
#[doc(hidden)]
pub type GetChannelPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetChannelPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetChannelPolicy`](crate::operation::GetChannelPolicy)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetChannelPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetChannelPolicyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_25 = &_input.channel_name;
            let input_25 =
                input_25
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_name",
                        details: "cannot be empty or unset",
                    })?;
            let channel_name = aws_smithy_http::label::fmt_string(input_25, false);
            if channel_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channel/{ChannelName}/policy",
                ChannelName = channel_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetChannelPolicyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetChannelPolicyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetChannelPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetChannelPolicy",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetChannelPolicyInput`](crate::input::GetChannelPolicyInput)
    pub fn builder() -> crate::input::get_channel_policy_input::Builder {
        crate::input::get_channel_policy_input::Builder::default()
    }
}

/// See [`GetChannelScheduleInput`](crate::input::GetChannelScheduleInput)
pub mod get_channel_schedule_input {
    /// A builder for [`GetChannelScheduleInput`](crate::input::GetChannelScheduleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) duration_minutes: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The schedule duration in minutes. The maximum duration is 4320 minutes (three days).</p>
        pub fn duration_minutes(mut self, input: impl Into<std::string::String>) -> Self {
            self.duration_minutes = Some(input.into());
            self
        }
        /// <p>The schedule duration in minutes. The maximum duration is 4320 minutes (three days).</p>
        pub fn set_duration_minutes(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.duration_minutes = input;
            self
        }
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetChannelScheduleInput`](crate::input::GetChannelScheduleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetChannelScheduleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetChannelScheduleInput {
                channel_name: self.channel_name,
                duration_minutes: self.duration_minutes,
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetChannelScheduleInputOperationOutputAlias = crate::operation::GetChannelSchedule;
#[doc(hidden)]
pub type GetChannelScheduleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetChannelScheduleInput {
    /// Consumes the builder and constructs an Operation<[`GetChannelSchedule`](crate::operation::GetChannelSchedule)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetChannelSchedule,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetChannelScheduleInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_26 = &_input.channel_name;
            let input_26 =
                input_26
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_name",
                        details: "cannot be empty or unset",
                    })?;
            let channel_name = aws_smithy_http::label::fmt_string(input_26, false);
            if channel_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channel/{ChannelName}/schedule",
                ChannelName = channel_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetChannelScheduleInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_27) = &_input.duration_minutes {
                query.push_kv(
                    "durationMinutes",
                    &aws_smithy_http::query::fmt_string(&inner_27),
                );
            }
            if _input.max_results != 0 {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                );
            }
            if let Some(inner_28) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_28));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetChannelScheduleInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetChannelScheduleInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetChannelSchedule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetChannelSchedule",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetChannelScheduleInput`](crate::input::GetChannelScheduleInput)
    pub fn builder() -> crate::input::get_channel_schedule_input::Builder {
        crate::input::get_channel_schedule_input::Builder::default()
    }
}

/// See [`GetPlaybackConfigurationInput`](crate::input::GetPlaybackConfigurationInput)
pub mod get_playback_configuration_input {
    /// A builder for [`GetPlaybackConfigurationInput`](crate::input::GetPlaybackConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPlaybackConfigurationInput`](crate::input::GetPlaybackConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetPlaybackConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetPlaybackConfigurationInput { name: self.name })
        }
    }
}
#[doc(hidden)]
pub type GetPlaybackConfigurationInputOperationOutputAlias =
    crate::operation::GetPlaybackConfiguration;
#[doc(hidden)]
pub type GetPlaybackConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetPlaybackConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetPlaybackConfiguration`](crate::operation::GetPlaybackConfiguration)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetPlaybackConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetPlaybackConfigurationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_29 = &_input.name;
            let input_29 =
                input_29
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "name",
                        details: "cannot be empty or unset",
                    })?;
            let name = aws_smithy_http::label::fmt_string(input_29, false);
            if name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "name",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/playbackConfiguration/{Name}", Name = name)
                .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetPlaybackConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetPlaybackConfigurationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetPlaybackConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetPlaybackConfiguration",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetPlaybackConfigurationInput`](crate::input::GetPlaybackConfigurationInput)
    pub fn builder() -> crate::input::get_playback_configuration_input::Builder {
        crate::input::get_playback_configuration_input::Builder::default()
    }
}

/// See [`GetPrefetchScheduleInput`](crate::input::GetPrefetchScheduleInput)
pub mod get_prefetch_schedule_input {
    /// A builder for [`GetPrefetchScheduleInput`](crate::input::GetPrefetchScheduleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) playback_configuration_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the playback configuration.</p>
        pub fn playback_configuration_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the playback configuration.</p>
        pub fn set_playback_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPrefetchScheduleInput`](crate::input::GetPrefetchScheduleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetPrefetchScheduleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetPrefetchScheduleInput {
                name: self.name,
                playback_configuration_name: self.playback_configuration_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetPrefetchScheduleInputOperationOutputAlias = crate::operation::GetPrefetchSchedule;
#[doc(hidden)]
pub type GetPrefetchScheduleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetPrefetchScheduleInput {
    /// Consumes the builder and constructs an Operation<[`GetPrefetchSchedule`](crate::operation::GetPrefetchSchedule)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetPrefetchSchedule,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetPrefetchScheduleInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_30 = &_input.playback_configuration_name;
            let input_30 =
                input_30
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "playback_configuration_name",
                        details: "cannot be empty or unset",
                    })?;
            let playback_configuration_name = aws_smithy_http::label::fmt_string(input_30, false);
            if playback_configuration_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "playback_configuration_name",
                    details: "cannot be empty or unset",
                });
            }
            let input_31 = &_input.name;
            let input_31 =
                input_31
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "name",
                        details: "cannot be empty or unset",
                    })?;
            let name = aws_smithy_http::label::fmt_string(input_31, false);
            if name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/prefetchSchedule/{PlaybackConfigurationName}/{Name}",
                PlaybackConfigurationName = playback_configuration_name,
                Name = name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetPrefetchScheduleInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetPrefetchScheduleInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetPrefetchSchedule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetPrefetchSchedule",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetPrefetchScheduleInput`](crate::input::GetPrefetchScheduleInput)
    pub fn builder() -> crate::input::get_prefetch_schedule_input::Builder {
        crate::input::get_prefetch_schedule_input::Builder::default()
    }
}

/// See [`ListAlertsInput`](crate::input::ListAlertsInput)
pub mod list_alerts_input {
    /// A builder for [`ListAlertsInput`](crate::input::ListAlertsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAlertsInput`](crate::input::ListAlertsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAlertsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAlertsInput {
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAlertsInputOperationOutputAlias = crate::operation::ListAlerts;
#[doc(hidden)]
pub type ListAlertsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListAlertsInput {
    /// Consumes the builder and constructs an Operation<[`ListAlerts`](crate::operation::ListAlerts)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAlerts,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListAlertsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/alerts").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::ListAlertsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if _input.max_results != 0 {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                );
            }
            if let Some(inner_32) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_32));
            }
            if let Some(inner_33) = &_input.resource_arn {
                query.push_kv(
                    "resourceArn",
                    &aws_smithy_http::query::fmt_string(&inner_33),
                );
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListAlertsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListAlertsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAlerts::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAlerts",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListAlertsInput`](crate::input::ListAlertsInput)
    pub fn builder() -> crate::input::list_alerts_input::Builder {
        crate::input::list_alerts_input::Builder::default()
    }
}

/// See [`ListChannelsInput`](crate::input::ListChannelsInput)
pub mod list_channels_input {
    /// A builder for [`ListChannelsInput`](crate::input::ListChannelsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelsInput`](crate::input::ListChannelsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListChannelsInput {
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelsInputOperationOutputAlias = crate::operation::ListChannels;
#[doc(hidden)]
pub type ListChannelsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListChannelsInput {
    /// Consumes the builder and constructs an Operation<[`ListChannels`](crate::operation::ListChannels)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListChannels,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListChannelsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/channels").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::ListChannelsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if _input.max_results != 0 {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                );
            }
            if let Some(inner_34) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_34));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListChannelsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListChannelsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannels::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListChannels",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListChannelsInput`](crate::input::ListChannelsInput)
    pub fn builder() -> crate::input::list_channels_input::Builder {
        crate::input::list_channels_input::Builder::default()
    }
}

/// See [`ListPlaybackConfigurationsInput`](crate::input::ListPlaybackConfigurationsInput)
pub mod list_playback_configurations_input {
    /// A builder for [`ListPlaybackConfigurationsInput`](crate::input::ListPlaybackConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Maximum number of records to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of records to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPlaybackConfigurationsInput`](crate::input::ListPlaybackConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListPlaybackConfigurationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListPlaybackConfigurationsInput {
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPlaybackConfigurationsInputOperationOutputAlias =
    crate::operation::ListPlaybackConfigurations;
#[doc(hidden)]
pub type ListPlaybackConfigurationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListPlaybackConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`ListPlaybackConfigurations`](crate::operation::ListPlaybackConfigurations)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPlaybackConfigurations,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListPlaybackConfigurationsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/playbackConfigurations").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::ListPlaybackConfigurationsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if _input.max_results != 0 {
                query.push_kv(
                    "MaxResults",
                    aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                );
            }
            if let Some(inner_35) = &_input.next_token {
                query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_35));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListPlaybackConfigurationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListPlaybackConfigurationsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPlaybackConfigurations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPlaybackConfigurations",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListPlaybackConfigurationsInput`](crate::input::ListPlaybackConfigurationsInput)
    pub fn builder() -> crate::input::list_playback_configurations_input::Builder {
        crate::input::list_playback_configurations_input::Builder::default()
    }
}

/// See [`ListPrefetchSchedulesInput`](crate::input::ListPrefetchSchedulesInput)
pub mod list_prefetch_schedules_input {
    /// A builder for [`ListPrefetchSchedulesInput`](crate::input::ListPrefetchSchedulesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) playback_configuration_name: std::option::Option<std::string::String>,
        pub(crate) stream_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of prefetch schedules that you want MediaTailor to return in response to the current request. If the playback configuration has more than MaxResults prefetch schedules, use the value of NextToken in the response to get the next page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of prefetch schedules that you want MediaTailor to return in response to the current request. If the playback configuration has more than MaxResults prefetch schedules, use the value of NextToken in the response to get the next page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>(Optional) If the playback configuration has more than MaxResults prefetch schedules, use NextToken to get the second and subsequent pages of results.</p> <p>For the first ListPrefetchSchedulesRequest request, omit this value.</p> <p>For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request.</p> <p>If the previous response didn't include a NextToken element, there are no more prefetch schedules to get.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>(Optional) If the playback configuration has more than MaxResults prefetch schedules, use NextToken to get the second and subsequent pages of results.</p> <p>For the first ListPrefetchSchedulesRequest request, omit this value.</p> <p>For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request.</p> <p>If the previous response didn't include a NextToken element, there are no more prefetch schedules to get.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The name of the playback configuration.</p>
        pub fn playback_configuration_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the playback configuration.</p>
        pub fn set_playback_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = input;
            self
        }
        /// <p>An optional filtering parameter whereby MediaTailor filters the prefetch schedules to include only specific streams.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>An optional filtering parameter whereby MediaTailor filters the prefetch schedules to include only specific streams.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPrefetchSchedulesInput`](crate::input::ListPrefetchSchedulesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListPrefetchSchedulesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListPrefetchSchedulesInput {
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
                playback_configuration_name: self.playback_configuration_name,
                stream_id: self.stream_id,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPrefetchSchedulesInputOperationOutputAlias = crate::operation::ListPrefetchSchedules;
#[doc(hidden)]
pub type ListPrefetchSchedulesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListPrefetchSchedulesInput {
    /// Consumes the builder and constructs an Operation<[`ListPrefetchSchedules`](crate::operation::ListPrefetchSchedules)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPrefetchSchedules,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListPrefetchSchedulesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_36 = &_input.playback_configuration_name;
            let input_36 =
                input_36
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "playback_configuration_name",
                        details: "cannot be empty or unset",
                    })?;
            let playback_configuration_name = aws_smithy_http::label::fmt_string(input_36, false);
            if playback_configuration_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "playback_configuration_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/prefetchSchedule/{PlaybackConfigurationName}",
                PlaybackConfigurationName = playback_configuration_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListPrefetchSchedulesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListPrefetchSchedulesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_prefetch_schedules(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPrefetchSchedules::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPrefetchSchedules",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListPrefetchSchedulesInput`](crate::input::ListPrefetchSchedulesInput)
    pub fn builder() -> crate::input::list_prefetch_schedules_input::Builder {
        crate::input::list_prefetch_schedules_input::Builder::default()
    }
}

/// See [`ListSourceLocationsInput`](crate::input::ListSourceLocationsInput)
pub mod list_source_locations_input {
    /// A builder for [`ListSourceLocationsInput`](crate::input::ListSourceLocationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSourceLocationsInput`](crate::input::ListSourceLocationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListSourceLocationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListSourceLocationsInput {
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListSourceLocationsInputOperationOutputAlias = crate::operation::ListSourceLocations;
#[doc(hidden)]
pub type ListSourceLocationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListSourceLocationsInput {
    /// Consumes the builder and constructs an Operation<[`ListSourceLocations`](crate::operation::ListSourceLocations)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSourceLocations,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListSourceLocationsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/sourceLocations").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::ListSourceLocationsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if _input.max_results != 0 {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                );
            }
            if let Some(inner_37) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_37));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListSourceLocationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListSourceLocationsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSourceLocations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSourceLocations",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListSourceLocationsInput`](crate::input::ListSourceLocationsInput)
    pub fn builder() -> crate::input::list_source_locations_input::Builder {
        crate::input::list_source_locations_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListTagsForResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_38 = &_input.resource_arn;
            let input_38 =
                input_38
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "resource_arn",
                        details: "cannot be empty or unset",
                    })?;
            let resource_arn = aws_smithy_http::label::fmt_string(input_38, false);
            if resource_arn.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
                .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListTagsForResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListTagsForResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListVodSourcesInput`](crate::input::ListVodSourcesInput)
pub mod list_vod_sources_input {
    /// A builder for [`ListVodSourcesInput`](crate::input::ListVodSourcesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVodSourcesInput`](crate::input::ListVodSourcesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListVodSourcesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListVodSourcesInput {
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
                source_location_name: self.source_location_name,
            })
        }
    }
}
#[doc(hidden)]
pub type ListVodSourcesInputOperationOutputAlias = crate::operation::ListVodSources;
#[doc(hidden)]
pub type ListVodSourcesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListVodSourcesInput {
    /// Consumes the builder and constructs an Operation<[`ListVodSources`](crate::operation::ListVodSources)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListVodSources,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListVodSourcesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_39 = &_input.source_location_name;
            let input_39 =
                input_39
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "source_location_name",
                        details: "cannot be empty or unset",
                    })?;
            let source_location_name = aws_smithy_http::label::fmt_string(input_39, false);
            if source_location_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/sourceLocation/{SourceLocationName}/vodSources",
                SourceLocationName = source_location_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::ListVodSourcesInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if _input.max_results != 0 {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                );
            }
            if let Some(inner_40) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_40));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListVodSourcesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListVodSourcesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListVodSources::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListVodSources",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListVodSourcesInput`](crate::input::ListVodSourcesInput)
    pub fn builder() -> crate::input::list_vod_sources_input::Builder {
        crate::input::list_vod_sources_input::Builder::default()
    }
}

/// See [`PutChannelPolicyInput`](crate::input::PutChannelPolicyInput)
pub mod put_channel_policy_input {
    /// A builder for [`PutChannelPolicyInput`](crate::input::PutChannelPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>Adds an IAM role that determines the permissions of your channel.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        /// <p>Adds an IAM role that determines the permissions of your channel.</p>
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// Consumes the builder and constructs a [`PutChannelPolicyInput`](crate::input::PutChannelPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutChannelPolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutChannelPolicyInput {
                channel_name: self.channel_name,
                policy: self.policy,
            })
        }
    }
}
#[doc(hidden)]
pub type PutChannelPolicyInputOperationOutputAlias = crate::operation::PutChannelPolicy;
#[doc(hidden)]
pub type PutChannelPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutChannelPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutChannelPolicy`](crate::operation::PutChannelPolicy)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutChannelPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutChannelPolicyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_41 = &_input.channel_name;
            let input_41 =
                input_41
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_name",
                        details: "cannot be empty or unset",
                    })?;
            let channel_name = aws_smithy_http::label::fmt_string(input_41, false);
            if channel_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channel/{ChannelName}/policy",
                ChannelName = channel_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutChannelPolicyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutChannelPolicyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_put_channel_policy(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutChannelPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutChannelPolicy",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutChannelPolicyInput`](crate::input::PutChannelPolicyInput)
    pub fn builder() -> crate::input::put_channel_policy_input::Builder {
        crate::input::put_channel_policy_input::Builder::default()
    }
}

/// See [`PutPlaybackConfigurationInput`](crate::input::PutPlaybackConfigurationInput)
pub mod put_playback_configuration_input {
    /// A builder for [`PutPlaybackConfigurationInput`](crate::input::PutPlaybackConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ad_decision_server_url: std::option::Option<std::string::String>,
        pub(crate) avail_suppression: std::option::Option<crate::model::AvailSuppression>,
        pub(crate) bumper: std::option::Option<crate::model::Bumper>,
        pub(crate) cdn_configuration: std::option::Option<crate::model::CdnConfiguration>,
        pub(crate) configuration_aliases: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        >,
        pub(crate) dash_configuration: std::option::Option<crate::model::DashConfigurationForPut>,
        pub(crate) live_pre_roll_configuration:
            std::option::Option<crate::model::LivePreRollConfiguration>,
        pub(crate) manifest_processing_rules:
            std::option::Option<crate::model::ManifestProcessingRules>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) personalization_threshold_seconds: std::option::Option<i32>,
        pub(crate) slate_ad_url: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) transcode_profile_name: std::option::Option<std::string::String>,
        pub(crate) video_content_source_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
        pub fn ad_decision_server_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.ad_decision_server_url = Some(input.into());
            self
        }
        /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
        pub fn set_ad_decision_server_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ad_decision_server_url = input;
            self
        }
        /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
        pub fn avail_suppression(mut self, input: crate::model::AvailSuppression) -> Self {
            self.avail_suppression = Some(input);
            self
        }
        /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
        pub fn set_avail_suppression(
            mut self,
            input: std::option::Option<crate::model::AvailSuppression>,
        ) -> Self {
            self.avail_suppression = input;
            self
        }
        /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
        pub fn bumper(mut self, input: crate::model::Bumper) -> Self {
            self.bumper = Some(input);
            self
        }
        /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
        pub fn set_bumper(mut self, input: std::option::Option<crate::model::Bumper>) -> Self {
            self.bumper = input;
            self
        }
        /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
        pub fn cdn_configuration(mut self, input: crate::model::CdnConfiguration) -> Self {
            self.cdn_configuration = Some(input);
            self
        }
        /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
        pub fn set_cdn_configuration(
            mut self,
            input: std::option::Option<crate::model::CdnConfiguration>,
        ) -> Self {
            self.cdn_configuration = input;
            self
        }
        /// Adds a key-value pair to `configuration_aliases`.
        ///
        /// To override the contents of this collection use [`set_configuration_aliases`](Self::set_configuration_aliases).
        ///
        /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
        pub fn configuration_aliases(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::collections::HashMap<std::string::String, std::string::String>>,
        ) -> Self {
            let mut hash_map = self.configuration_aliases.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.configuration_aliases = Some(hash_map);
            self
        }
        /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
        pub fn set_configuration_aliases(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::collections::HashMap<std::string::String, std::string::String>,
                >,
            >,
        ) -> Self {
            self.configuration_aliases = input;
            self
        }
        /// <p>The configuration for DASH content.</p>
        pub fn dash_configuration(mut self, input: crate::model::DashConfigurationForPut) -> Self {
            self.dash_configuration = Some(input);
            self
        }
        /// <p>The configuration for DASH content.</p>
        pub fn set_dash_configuration(
            mut self,
            input: std::option::Option<crate::model::DashConfigurationForPut>,
        ) -> Self {
            self.dash_configuration = input;
            self
        }
        /// <p>The configuration for pre-roll ad insertion.</p>
        pub fn live_pre_roll_configuration(
            mut self,
            input: crate::model::LivePreRollConfiguration,
        ) -> Self {
            self.live_pre_roll_configuration = Some(input);
            self
        }
        /// <p>The configuration for pre-roll ad insertion.</p>
        pub fn set_live_pre_roll_configuration(
            mut self,
            input: std::option::Option<crate::model::LivePreRollConfiguration>,
        ) -> Self {
            self.live_pre_roll_configuration = input;
            self
        }
        /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
        pub fn manifest_processing_rules(
            mut self,
            input: crate::model::ManifestProcessingRules,
        ) -> Self {
            self.manifest_processing_rules = Some(input);
            self
        }
        /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
        pub fn set_manifest_processing_rules(
            mut self,
            input: std::option::Option<crate::model::ManifestProcessingRules>,
        ) -> Self {
            self.manifest_processing_rules = input;
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
        pub fn personalization_threshold_seconds(mut self, input: i32) -> Self {
            self.personalization_threshold_seconds = Some(input);
            self
        }
        /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
        pub fn set_personalization_threshold_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.personalization_threshold_seconds = input;
            self
        }
        /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
        pub fn slate_ad_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.slate_ad_url = Some(input.into());
            self
        }
        /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
        pub fn set_slate_ad_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.slate_ad_url = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to assign to the playback configuration.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags to assign to the playback configuration.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
        pub fn transcode_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcode_profile_name = Some(input.into());
            self
        }
        /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
        pub fn set_transcode_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcode_profile_name = input;
            self
        }
        /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
        pub fn video_content_source_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.video_content_source_url = Some(input.into());
            self
        }
        /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
        pub fn set_video_content_source_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.video_content_source_url = input;
            self
        }
        /// Consumes the builder and constructs a [`PutPlaybackConfigurationInput`](crate::input::PutPlaybackConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutPlaybackConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutPlaybackConfigurationInput {
                ad_decision_server_url: self.ad_decision_server_url,
                avail_suppression: self.avail_suppression,
                bumper: self.bumper,
                cdn_configuration: self.cdn_configuration,
                configuration_aliases: self.configuration_aliases,
                dash_configuration: self.dash_configuration,
                live_pre_roll_configuration: self.live_pre_roll_configuration,
                manifest_processing_rules: self.manifest_processing_rules,
                name: self.name,
                personalization_threshold_seconds: self
                    .personalization_threshold_seconds
                    .unwrap_or_default(),
                slate_ad_url: self.slate_ad_url,
                tags: self.tags,
                transcode_profile_name: self.transcode_profile_name,
                video_content_source_url: self.video_content_source_url,
            })
        }
    }
}
#[doc(hidden)]
pub type PutPlaybackConfigurationInputOperationOutputAlias =
    crate::operation::PutPlaybackConfiguration;
#[doc(hidden)]
pub type PutPlaybackConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutPlaybackConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutPlaybackConfiguration`](crate::operation::PutPlaybackConfiguration)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutPlaybackConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutPlaybackConfigurationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/playbackConfiguration").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutPlaybackConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutPlaybackConfigurationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_put_playback_configuration(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutPlaybackConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutPlaybackConfiguration",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutPlaybackConfigurationInput`](crate::input::PutPlaybackConfigurationInput)
    pub fn builder() -> crate::input::put_playback_configuration_input::Builder {
        crate::input::put_playback_configuration_input::Builder::default()
    }
}

/// See [`StartChannelInput`](crate::input::StartChannelInput)
pub mod start_channel_input {
    /// A builder for [`StartChannelInput`](crate::input::StartChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// Consumes the builder and constructs a [`StartChannelInput`](crate::input::StartChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartChannelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartChannelInput {
                channel_name: self.channel_name,
            })
        }
    }
}
#[doc(hidden)]
pub type StartChannelInputOperationOutputAlias = crate::operation::StartChannel;
#[doc(hidden)]
pub type StartChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartChannelInput {
    /// Consumes the builder and constructs an Operation<[`StartChannel`](crate::operation::StartChannel)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartChannelInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_42 = &_input.channel_name;
            let input_42 =
                input_42
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_name",
                        details: "cannot be empty or unset",
                    })?;
            let channel_name = aws_smithy_http::label::fmt_string(input_42, false);
            if channel_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channel/{ChannelName}/start",
                ChannelName = channel_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartChannelInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartChannelInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartChannel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartChannel",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartChannelInput`](crate::input::StartChannelInput)
    pub fn builder() -> crate::input::start_channel_input::Builder {
        crate::input::start_channel_input::Builder::default()
    }
}

/// See [`StopChannelInput`](crate::input::StopChannelInput)
pub mod stop_channel_input {
    /// A builder for [`StopChannelInput`](crate::input::StopChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// Consumes the builder and constructs a [`StopChannelInput`](crate::input::StopChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StopChannelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StopChannelInput {
                channel_name: self.channel_name,
            })
        }
    }
}
#[doc(hidden)]
pub type StopChannelInputOperationOutputAlias = crate::operation::StopChannel;
#[doc(hidden)]
pub type StopChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StopChannelInput {
    /// Consumes the builder and constructs an Operation<[`StopChannel`](crate::operation::StopChannel)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StopChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StopChannelInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_43 = &_input.channel_name;
            let input_43 =
                input_43
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_name",
                        details: "cannot be empty or unset",
                    })?;
            let channel_name = aws_smithy_http::label::fmt_string(input_43, false);
            if channel_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channel/{ChannelName}/stop",
                ChannelName = channel_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StopChannelInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StopChannelInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StopChannel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StopChannel",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StopChannelInput`](crate::input::StopChannelInput)
    pub fn builder() -> crate::input::stop_channel_input::Builder {
        crate::input::stop_channel_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A comma-separated list of tag key:value pairs.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A comma-separated list of tag key:value pairs.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::TagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_44 = &_input.resource_arn;
            let input_44 =
                input_44
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "resource_arn",
                        details: "cannot be empty or unset",
                    })?;
            let resource_arn = aws_smithy_http::label::fmt_string(input_44, false);
            if resource_arn.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
                .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::TagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::TagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>A comma-separated list of the tag keys to remove from the playback configuration.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>A comma-separated list of the tag keys to remove from the playback configuration.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UntagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UntagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_45 = &_input.resource_arn;
            let input_45 =
                input_45
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "resource_arn",
                        details: "cannot be empty or unset",
                    })?;
            let resource_arn = aws_smithy_http::label::fmt_string(input_45, false);
            if resource_arn.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
                .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::UntagResourceInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_46) = &_input.tag_keys {
                for inner_47 in inner_46 {
                    query.push_kv("tagKeys", &aws_smithy_http::query::fmt_string(&inner_47));
                }
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UntagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UntagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateChannelInput`](crate::input::UpdateChannelInput)
pub mod update_channel_input {
    /// A builder for [`UpdateChannelInput`](crate::input::UpdateChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) outputs: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
    }
    impl Builder {
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// Appends an item to `outputs`.
        ///
        /// To override the contents of this collection use [`set_outputs`](Self::set_outputs).
        ///
        /// <p>The channel's output properties.</p>
        pub fn outputs(mut self, input: impl Into<crate::model::RequestOutputItem>) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(input.into());
            self.outputs = Some(v);
            self
        }
        /// <p>The channel's output properties.</p>
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateChannelInput`](crate::input::UpdateChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateChannelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateChannelInput {
                channel_name: self.channel_name,
                outputs: self.outputs,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateChannelInputOperationOutputAlias = crate::operation::UpdateChannel;
#[doc(hidden)]
pub type UpdateChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateChannelInput {
    /// Consumes the builder and constructs an Operation<[`UpdateChannel`](crate::operation::UpdateChannel)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateChannelInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_48 = &_input.channel_name;
            let input_48 =
                input_48
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_name",
                        details: "cannot be empty or unset",
                    })?;
            let channel_name = aws_smithy_http::label::fmt_string(input_48, false);
            if channel_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "channel_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/channel/{ChannelName}", ChannelName = channel_name)
                .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateChannelInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateChannelInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_update_channel(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateChannel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateChannel",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateChannelInput`](crate::input::UpdateChannelInput)
    pub fn builder() -> crate::input::update_channel_input::Builder {
        crate::input::update_channel_input::Builder::default()
    }
}

/// See [`UpdateSourceLocationInput`](crate::input::UpdateSourceLocationInput)
pub mod update_source_location_input {
    /// A builder for [`UpdateSourceLocationInput`](crate::input::UpdateSourceLocationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_configuration: std::option::Option<crate::model::AccessConfiguration>,
        pub(crate) default_segment_delivery_configuration:
            std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        pub(crate) http_configuration: std::option::Option<crate::model::HttpConfiguration>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
        pub fn access_configuration(mut self, input: crate::model::AccessConfiguration) -> Self {
            self.access_configuration = Some(input);
            self
        }
        /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
        pub fn set_access_configuration(
            mut self,
            input: std::option::Option<crate::model::AccessConfiguration>,
        ) -> Self {
            self.access_configuration = input;
            self
        }
        /// <p>The optional configuration for the host server that serves segments.</p>
        pub fn default_segment_delivery_configuration(
            mut self,
            input: crate::model::DefaultSegmentDeliveryConfiguration,
        ) -> Self {
            self.default_segment_delivery_configuration = Some(input);
            self
        }
        /// <p>The optional configuration for the host server that serves segments.</p>
        pub fn set_default_segment_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        ) -> Self {
            self.default_segment_delivery_configuration = input;
            self
        }
        /// <p>The HTTP configuration for the source location.</p>
        pub fn http_configuration(mut self, input: crate::model::HttpConfiguration) -> Self {
            self.http_configuration = Some(input);
            self
        }
        /// <p>The HTTP configuration for the source location.</p>
        pub fn set_http_configuration(
            mut self,
            input: std::option::Option<crate::model::HttpConfiguration>,
        ) -> Self {
            self.http_configuration = input;
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSourceLocationInput`](crate::input::UpdateSourceLocationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateSourceLocationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateSourceLocationInput {
                access_configuration: self.access_configuration,
                default_segment_delivery_configuration: self.default_segment_delivery_configuration,
                http_configuration: self.http_configuration,
                source_location_name: self.source_location_name,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateSourceLocationInputOperationOutputAlias = crate::operation::UpdateSourceLocation;
#[doc(hidden)]
pub type UpdateSourceLocationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateSourceLocationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSourceLocation`](crate::operation::UpdateSourceLocation)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateSourceLocation,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateSourceLocationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_49 = &_input.source_location_name;
            let input_49 =
                input_49
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "source_location_name",
                        details: "cannot be empty or unset",
                    })?;
            let source_location_name = aws_smithy_http::label::fmt_string(input_49, false);
            if source_location_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/sourceLocation/{SourceLocationName}",
                SourceLocationName = source_location_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateSourceLocationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateSourceLocationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_source_location(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateSourceLocation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateSourceLocation",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateSourceLocationInput`](crate::input::UpdateSourceLocationInput)
    pub fn builder() -> crate::input::update_source_location_input::Builder {
        crate::input::update_source_location_input::Builder::default()
    }
}

/// See [`UpdateVodSourceInput`](crate::input::UpdateVodSourceInput)
pub mod update_vod_source_input {
    /// A builder for [`UpdateVodSourceInput`](crate::input::UpdateVodSourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) http_package_configurations:
            std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `http_package_configurations`.
        ///
        /// To override the contents of this collection use [`set_http_package_configurations`](Self::set_http_package_configurations).
        ///
        /// <p>An array of HTTP package configurations for the VOD source on this account.</p>
        pub fn http_package_configurations(
            mut self,
            input: impl Into<crate::model::HttpPackageConfiguration>,
        ) -> Self {
            let mut v = self.http_package_configurations.unwrap_or_default();
            v.push(input.into());
            self.http_package_configurations = Some(v);
            self
        }
        /// <p>An array of HTTP package configurations for the VOD source on this account.</p>
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.http_package_configurations = input;
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVodSourceInput`](crate::input::UpdateVodSourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateVodSourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateVodSourceInput {
                http_package_configurations: self.http_package_configurations,
                source_location_name: self.source_location_name,
                vod_source_name: self.vod_source_name,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateVodSourceInputOperationOutputAlias = crate::operation::UpdateVodSource;
#[doc(hidden)]
pub type UpdateVodSourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateVodSourceInput {
    /// Consumes the builder and constructs an Operation<[`UpdateVodSource`](crate::operation::UpdateVodSource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateVodSource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateVodSourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_50 = &_input.source_location_name;
            let input_50 =
                input_50
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "source_location_name",
                        details: "cannot be empty or unset",
                    })?;
            let source_location_name = aws_smithy_http::label::fmt_string(input_50, false);
            if source_location_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "source_location_name",
                    details: "cannot be empty or unset",
                });
            }
            let input_51 = &_input.vod_source_name;
            let input_51 =
                input_51
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "vod_source_name",
                        details: "cannot be empty or unset",
                    })?;
            let vod_source_name = aws_smithy_http::label::fmt_string(input_51, false);
            if vod_source_name.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "vod_source_name",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}",
                SourceLocationName = source_location_name,
                VodSourceName = vod_source_name
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateVodSourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateVodSourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_vod_source(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateVodSource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateVodSource",
            "mediatailor",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateVodSourceInput`](crate::input::UpdateVodSourceInput)
    pub fn builder() -> crate::input::update_vod_source_input::Builder {
        crate::input::update_vod_source_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateVodSourceInput {
    /// <p>An array of HTTP package configurations for the VOD source on this account.</p>
    pub http_package_configurations:
        std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The identifier for the VOD source you are working on.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl UpdateVodSourceInput {
    /// <p>An array of HTTP package configurations for the VOD source on this account.</p>
    pub fn http_package_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::HttpPackageConfiguration]> {
        self.http_package_configurations.as_deref()
    }
    /// <p>The identifier for the source location you are working on.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The identifier for the VOD source you are working on.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl std::fmt::Debug for UpdateVodSourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateVodSourceInput");
        formatter.field(
            "http_package_configurations",
            &self.http_package_configurations,
        );
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSourceLocationInput {
    /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
    pub access_configuration: std::option::Option<crate::model::AccessConfiguration>,
    /// <p>The optional configuration for the host server that serves segments.</p>
    pub default_segment_delivery_configuration:
        std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
    /// <p>The HTTP configuration for the source location.</p>
    pub http_configuration: std::option::Option<crate::model::HttpConfiguration>,
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
}
impl UpdateSourceLocationInput {
    /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
    pub fn access_configuration(&self) -> std::option::Option<&crate::model::AccessConfiguration> {
        self.access_configuration.as_ref()
    }
    /// <p>The optional configuration for the host server that serves segments.</p>
    pub fn default_segment_delivery_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DefaultSegmentDeliveryConfiguration> {
        self.default_segment_delivery_configuration.as_ref()
    }
    /// <p>The HTTP configuration for the source location.</p>
    pub fn http_configuration(&self) -> std::option::Option<&crate::model::HttpConfiguration> {
        self.http_configuration.as_ref()
    }
    /// <p>The identifier for the source location you are working on.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
}
impl std::fmt::Debug for UpdateSourceLocationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSourceLocationInput");
        formatter.field("access_configuration", &self.access_configuration);
        formatter.field(
            "default_segment_delivery_configuration",
            &self.default_segment_delivery_configuration,
        );
        formatter.field("http_configuration", &self.http_configuration);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The channel's output properties.</p>
    pub outputs: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
}
impl UpdateChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>The channel's output properties.</p>
    pub fn outputs(&self) -> std::option::Option<&[crate::model::RequestOutputItem]> {
        self.outputs.as_deref()
    }
}
impl std::fmt::Debug for UpdateChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("outputs", &self.outputs);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A comma-separated list of the tag keys to remove from the playback configuration.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>A comma-separated list of the tag keys to remove from the playback configuration.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A comma-separated list of tag key:value pairs.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>A comma-separated list of tag key:value pairs.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
}
impl StopChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
}
impl std::fmt::Debug for StopChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopChannelInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
}
impl StartChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
}
impl std::fmt::Debug for StartChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartChannelInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutPlaybackConfigurationInput {
    /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    pub ad_decision_server_url: std::option::Option<std::string::String>,
    /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
    pub avail_suppression: std::option::Option<crate::model::AvailSuppression>,
    /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
    pub bumper: std::option::Option<crate::model::Bumper>,
    /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
    pub cdn_configuration: std::option::Option<crate::model::CdnConfiguration>,
    /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
    pub configuration_aliases: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    >,
    /// <p>The configuration for DASH content.</p>
    pub dash_configuration: std::option::Option<crate::model::DashConfigurationForPut>,
    /// <p>The configuration for pre-roll ad insertion.</p>
    pub live_pre_roll_configuration: std::option::Option<crate::model::LivePreRollConfiguration>,
    /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
    pub manifest_processing_rules: std::option::Option<crate::model::ManifestProcessingRules>,
    /// <p>The identifier for the playback configuration.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
    pub personalization_threshold_seconds: i32,
    /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
    pub slate_ad_url: std::option::Option<std::string::String>,
    /// <p>The tags to assign to the playback configuration.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
    pub transcode_profile_name: std::option::Option<std::string::String>,
    /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
    pub video_content_source_url: std::option::Option<std::string::String>,
}
impl PutPlaybackConfigurationInput {
    /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    pub fn ad_decision_server_url(&self) -> std::option::Option<&str> {
        self.ad_decision_server_url.as_deref()
    }
    /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
    pub fn avail_suppression(&self) -> std::option::Option<&crate::model::AvailSuppression> {
        self.avail_suppression.as_ref()
    }
    /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
    pub fn bumper(&self) -> std::option::Option<&crate::model::Bumper> {
        self.bumper.as_ref()
    }
    /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
    pub fn cdn_configuration(&self) -> std::option::Option<&crate::model::CdnConfiguration> {
        self.cdn_configuration.as_ref()
    }
    /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
    pub fn configuration_aliases(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    > {
        self.configuration_aliases.as_ref()
    }
    /// <p>The configuration for DASH content.</p>
    pub fn dash_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DashConfigurationForPut> {
        self.dash_configuration.as_ref()
    }
    /// <p>The configuration for pre-roll ad insertion.</p>
    pub fn live_pre_roll_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LivePreRollConfiguration> {
        self.live_pre_roll_configuration.as_ref()
    }
    /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
    pub fn manifest_processing_rules(
        &self,
    ) -> std::option::Option<&crate::model::ManifestProcessingRules> {
        self.manifest_processing_rules.as_ref()
    }
    /// <p>The identifier for the playback configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
    pub fn personalization_threshold_seconds(&self) -> i32 {
        self.personalization_threshold_seconds
    }
    /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
    pub fn slate_ad_url(&self) -> std::option::Option<&str> {
        self.slate_ad_url.as_deref()
    }
    /// <p>The tags to assign to the playback configuration.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
    pub fn transcode_profile_name(&self) -> std::option::Option<&str> {
        self.transcode_profile_name.as_deref()
    }
    /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
    pub fn video_content_source_url(&self) -> std::option::Option<&str> {
        self.video_content_source_url.as_deref()
    }
}
impl std::fmt::Debug for PutPlaybackConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutPlaybackConfigurationInput");
        formatter.field("ad_decision_server_url", &self.ad_decision_server_url);
        formatter.field("avail_suppression", &self.avail_suppression);
        formatter.field("bumper", &self.bumper);
        formatter.field("cdn_configuration", &self.cdn_configuration);
        formatter.field("configuration_aliases", &self.configuration_aliases);
        formatter.field("dash_configuration", &self.dash_configuration);
        formatter.field(
            "live_pre_roll_configuration",
            &self.live_pre_roll_configuration,
        );
        formatter.field("manifest_processing_rules", &self.manifest_processing_rules);
        formatter.field("name", &self.name);
        formatter.field(
            "personalization_threshold_seconds",
            &self.personalization_threshold_seconds,
        );
        formatter.field("slate_ad_url", &self.slate_ad_url);
        formatter.field("tags", &self.tags);
        formatter.field("transcode_profile_name", &self.transcode_profile_name);
        formatter.field("video_content_source_url", &self.video_content_source_url);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutChannelPolicyInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>Adds an IAM role that determines the permissions of your channel.</p>
    pub policy: std::option::Option<std::string::String>,
}
impl PutChannelPolicyInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>Adds an IAM role that determines the permissions of your channel.</p>
    pub fn policy(&self) -> std::option::Option<&str> {
        self.policy.as_deref()
    }
}
impl std::fmt::Debug for PutChannelPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutChannelPolicyInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("policy", &self.policy);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListVodSourcesInput {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub max_results: i32,
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
}
impl ListVodSourcesInput {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The identifier for the source location you are working on.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
}
impl std::fmt::Debug for ListVodSourcesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListVodSourcesInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSourceLocationsInput {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub max_results: i32,
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListSourceLocationsInput {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListSourceLocationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSourceLocationsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPrefetchSchedulesInput {
    /// <p>The maximum number of prefetch schedules that you want MediaTailor to return in response to the current request. If the playback configuration has more than MaxResults prefetch schedules, use the value of NextToken in the response to get the next page of results.</p>
    pub max_results: i32,
    /// <p>(Optional) If the playback configuration has more than MaxResults prefetch schedules, use NextToken to get the second and subsequent pages of results.</p> <p>For the first ListPrefetchSchedulesRequest request, omit this value.</p> <p>For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request.</p> <p>If the previous response didn't include a NextToken element, there are no more prefetch schedules to get.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The name of the playback configuration.</p>
    pub playback_configuration_name: std::option::Option<std::string::String>,
    /// <p>An optional filtering parameter whereby MediaTailor filters the prefetch schedules to include only specific streams.</p>
    pub stream_id: std::option::Option<std::string::String>,
}
impl ListPrefetchSchedulesInput {
    /// <p>The maximum number of prefetch schedules that you want MediaTailor to return in response to the current request. If the playback configuration has more than MaxResults prefetch schedules, use the value of NextToken in the response to get the next page of results.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>(Optional) If the playback configuration has more than MaxResults prefetch schedules, use NextToken to get the second and subsequent pages of results.</p> <p>For the first ListPrefetchSchedulesRequest request, omit this value.</p> <p>For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request.</p> <p>If the previous response didn't include a NextToken element, there are no more prefetch schedules to get.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The name of the playback configuration.</p>
    pub fn playback_configuration_name(&self) -> std::option::Option<&str> {
        self.playback_configuration_name.as_deref()
    }
    /// <p>An optional filtering parameter whereby MediaTailor filters the prefetch schedules to include only specific streams.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
}
impl std::fmt::Debug for ListPrefetchSchedulesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPrefetchSchedulesInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field(
            "playback_configuration_name",
            &self.playback_configuration_name,
        );
        formatter.field("stream_id", &self.stream_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPlaybackConfigurationsInput {
    /// <p>Maximum number of records to return.</p>
    pub max_results: i32,
    /// <p>Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListPlaybackConfigurationsInput {
    /// <p>Maximum number of records to return.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListPlaybackConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPlaybackConfigurationsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelsInput {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub max_results: i32,
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListChannelsInput {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListChannelsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAlertsInput {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub max_results: i32,
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListAlertsInput {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for ListAlertsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAlertsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPrefetchScheduleInput {
    /// <p>The identifier for the playback configuration.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the playback configuration.</p>
    pub playback_configuration_name: std::option::Option<std::string::String>,
}
impl GetPrefetchScheduleInput {
    /// <p>The identifier for the playback configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the playback configuration.</p>
    pub fn playback_configuration_name(&self) -> std::option::Option<&str> {
        self.playback_configuration_name.as_deref()
    }
}
impl std::fmt::Debug for GetPrefetchScheduleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPrefetchScheduleInput");
        formatter.field("name", &self.name);
        formatter.field(
            "playback_configuration_name",
            &self.playback_configuration_name,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPlaybackConfigurationInput {
    /// <p>The identifier for the playback configuration.</p>
    pub name: std::option::Option<std::string::String>,
}
impl GetPlaybackConfigurationInput {
    /// <p>The identifier for the playback configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for GetPlaybackConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPlaybackConfigurationInput");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetChannelScheduleInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The schedule duration in minutes. The maximum duration is 4320 minutes (three days).</p>
    pub duration_minutes: std::option::Option<std::string::String>,
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub max_results: i32,
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetChannelScheduleInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>The schedule duration in minutes. The maximum duration is 4320 minutes (three days).</p>
    pub fn duration_minutes(&self) -> std::option::Option<&str> {
        self.duration_minutes.as_deref()
    }
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetChannelScheduleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetChannelScheduleInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("duration_minutes", &self.duration_minutes);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetChannelPolicyInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
}
impl GetChannelPolicyInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
}
impl std::fmt::Debug for GetChannelPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetChannelPolicyInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeVodSourceInput {
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The identifier for the VOD source you are working on.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl DescribeVodSourceInput {
    /// <p>The identifier for the source location you are working on.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The identifier for the VOD source you are working on.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeVodSourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeVodSourceInput");
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSourceLocationInput {
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
}
impl DescribeSourceLocationInput {
    /// <p>The identifier for the source location you are working on.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeSourceLocationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSourceLocationInput");
        formatter.field("source_location_name", &self.source_location_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProgramInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The identifier for the program you are working on.</p>
    pub program_name: std::option::Option<std::string::String>,
}
impl DescribeProgramInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>The identifier for the program you are working on.</p>
    pub fn program_name(&self) -> std::option::Option<&str> {
        self.program_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeProgramInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProgramInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("program_name", &self.program_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
}
impl DescribeChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVodSourceInput {
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The identifier for the VOD source you are working on.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl DeleteVodSourceInput {
    /// <p>The identifier for the source location you are working on.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The identifier for the VOD source you are working on.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteVodSourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVodSourceInput");
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSourceLocationInput {
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
}
impl DeleteSourceLocationInput {
    /// <p>The identifier for the source location you are working on.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteSourceLocationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSourceLocationInput");
        formatter.field("source_location_name", &self.source_location_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProgramInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The identifier for the program you are working on.</p>
    pub program_name: std::option::Option<std::string::String>,
}
impl DeleteProgramInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>The identifier for the program you are working on.</p>
    pub fn program_name(&self) -> std::option::Option<&str> {
        self.program_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteProgramInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProgramInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("program_name", &self.program_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePrefetchScheduleInput {
    /// <p>The identifier for the playback configuration.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the playback configuration.</p>
    pub playback_configuration_name: std::option::Option<std::string::String>,
}
impl DeletePrefetchScheduleInput {
    /// <p>The identifier for the playback configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the playback configuration.</p>
    pub fn playback_configuration_name(&self) -> std::option::Option<&str> {
        self.playback_configuration_name.as_deref()
    }
}
impl std::fmt::Debug for DeletePrefetchScheduleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePrefetchScheduleInput");
        formatter.field("name", &self.name);
        formatter.field(
            "playback_configuration_name",
            &self.playback_configuration_name,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePlaybackConfigurationInput {
    /// <p>The identifier for the playback configuration.</p>
    pub name: std::option::Option<std::string::String>,
}
impl DeletePlaybackConfigurationInput {
    /// <p>The identifier for the playback configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for DeletePlaybackConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePlaybackConfigurationInput");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelPolicyInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
}
impl DeleteChannelPolicyInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteChannelPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelPolicyInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
}
impl DeleteChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateVodSourceInput {
    /// <p>An array of HTTP package configuration parameters for this VOD source.</p>
    pub http_package_configurations:
        std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags to assign to the VOD source.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The identifier for the VOD source you are working on.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl CreateVodSourceInput {
    /// <p>An array of HTTP package configuration parameters for this VOD source.</p>
    pub fn http_package_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::HttpPackageConfiguration]> {
        self.http_package_configurations.as_deref()
    }
    /// <p>The identifier for the source location you are working on.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags to assign to the VOD source.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The identifier for the VOD source you are working on.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl std::fmt::Debug for CreateVodSourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateVodSourceInput");
        formatter.field(
            "http_package_configurations",
            &self.http_package_configurations,
        );
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("tags", &self.tags);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSourceLocationInput {
    /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
    pub access_configuration: std::option::Option<crate::model::AccessConfiguration>,
    /// <p>The optional configuration for the server that serves segments.</p>
    pub default_segment_delivery_configuration:
        std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
    /// <p>The source's HTTP package configurations.</p>
    pub http_configuration: std::option::Option<crate::model::HttpConfiguration>,
    /// <p>The identifier for the source location you are working on.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags to assign to the source location.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateSourceLocationInput {
    /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
    pub fn access_configuration(&self) -> std::option::Option<&crate::model::AccessConfiguration> {
        self.access_configuration.as_ref()
    }
    /// <p>The optional configuration for the server that serves segments.</p>
    pub fn default_segment_delivery_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DefaultSegmentDeliveryConfiguration> {
        self.default_segment_delivery_configuration.as_ref()
    }
    /// <p>The source's HTTP package configurations.</p>
    pub fn http_configuration(&self) -> std::option::Option<&crate::model::HttpConfiguration> {
        self.http_configuration.as_ref()
    }
    /// <p>The identifier for the source location you are working on.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags to assign to the source location.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for CreateSourceLocationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSourceLocationInput");
        formatter.field("access_configuration", &self.access_configuration);
        formatter.field(
            "default_segment_delivery_configuration",
            &self.default_segment_delivery_configuration,
        );
        formatter.field("http_configuration", &self.http_configuration);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProgramInput {
    /// <p>The ad break configuration settings.</p>
    pub ad_breaks: std::option::Option<std::vec::Vec<crate::model::AdBreak>>,
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The identifier for the program you are working on.</p>
    pub program_name: std::option::Option<std::string::String>,
    /// <p>The schedule configuration settings.</p>
    pub schedule_configuration: std::option::Option<crate::model::ScheduleConfiguration>,
    /// <p>The name of the source location.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The name that's used to refer to a VOD source.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl CreateProgramInput {
    /// <p>The ad break configuration settings.</p>
    pub fn ad_breaks(&self) -> std::option::Option<&[crate::model::AdBreak]> {
        self.ad_breaks.as_deref()
    }
    /// <p>The identifier for the channel you are working on.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>The identifier for the program you are working on.</p>
    pub fn program_name(&self) -> std::option::Option<&str> {
        self.program_name.as_deref()
    }
    /// <p>The schedule configuration settings.</p>
    pub fn schedule_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ScheduleConfiguration> {
        self.schedule_configuration.as_ref()
    }
    /// <p>The name of the source location.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The name that's used to refer to a VOD source.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl std::fmt::Debug for CreateProgramInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProgramInput");
        formatter.field("ad_breaks", &self.ad_breaks);
        formatter.field("channel_name", &self.channel_name);
        formatter.field("program_name", &self.program_name);
        formatter.field("schedule_configuration", &self.schedule_configuration);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePrefetchScheduleInput {
    /// <p>The configuration settings for MediaTailor's <i>consumption</i> of the prefetched ads from the ad decision server. Each consumption configuration contains an end time and an optional start time that define the <i>consumption window</i>. Prefetch schedules automatically expire no earlier than seven days after the end time.</p>
    pub consumption: std::option::Option<crate::model::PrefetchConsumption>,
    /// <p>The identifier for the playback configuration.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the playback configuration.</p>
    pub playback_configuration_name: std::option::Option<std::string::String>,
    /// <p>The configuration settings for retrieval of prefetched ads from the ad decision server. Only one set of prefetched ads will be retrieved and subsequently consumed for each ad break.</p>
    pub retrieval: std::option::Option<crate::model::PrefetchRetrieval>,
    /// <p>An optional stream identifier that MediaTailor uses to prefetch ads for multiple streams that use the same playback configuration. If StreamId is specified, MediaTailor returns all of the prefetch schedules with an exact match on StreamId. If not specified, MediaTailor returns all of the prefetch schedules for the playback configuration, regardless of StreamId.</p>
    pub stream_id: std::option::Option<std::string::String>,
}
impl CreatePrefetchScheduleInput {
    /// <p>The configuration settings for MediaTailor's <i>consumption</i> of the prefetched ads from the ad decision server. Each consumption configuration contains an end time and an optional start time that define the <i>consumption window</i>. Prefetch schedules automatically expire no earlier than seven days after the end time.</p>
    pub fn consumption(&self) -> std::option::Option<&crate::model::PrefetchConsumption> {
        self.consumption.as_ref()
    }
    /// <p>The identifier for the playback configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the playback configuration.</p>
    pub fn playback_configuration_name(&self) -> std::option::Option<&str> {
        self.playback_configuration_name.as_deref()
    }
    /// <p>The configuration settings for retrieval of prefetched ads from the ad decision server. Only one set of prefetched ads will be retrieved and subsequently consumed for each ad break.</p>
    pub fn retrieval(&self) -> std::option::Option<&crate::model::PrefetchRetrieval> {
        self.retrieval.as_ref()
    }
    /// <p>An optional stream identifier that MediaTailor uses to prefetch ads for multiple streams that use the same playback configuration. If StreamId is specified, MediaTailor returns all of the prefetch schedules with an exact match on StreamId. If not specified, MediaTailor returns all of the prefetch schedules for the playback configuration, regardless of StreamId.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
}
impl std::fmt::Debug for CreatePrefetchScheduleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePrefetchScheduleInput");
        formatter.field("consumption", &self.consumption);
        formatter.field("name", &self.name);
        formatter.field(
            "playback_configuration_name",
            &self.playback_configuration_name,
        );
        formatter.field("retrieval", &self.retrieval);
        formatter.field("stream_id", &self.stream_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses a LINEAR PlaybackMode.</p>
    pub filler_slate: std::option::Option<crate::model::SlateSource>,
    /// <p>The channel's output properties.</p>
    pub outputs: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
    /// <p>The type of playback mode to use for this channel.</p> <p>LINEAR - The programs in the schedule play once back-to-back in the schedule.</p> <p>LOOP - The programs in the schedule play back-to-back in an endless loop. When the last program in the schedule stops playing, playback loops back to the first program in the schedule.</p>
    pub playback_mode: std::option::Option<crate::model::PlaybackMode>,
    /// <p>The tags to assign to the channel.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateChannelInput {
    /// <p>The identifier for the channel you are working on.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses a LINEAR PlaybackMode.</p>
    pub fn filler_slate(&self) -> std::option::Option<&crate::model::SlateSource> {
        self.filler_slate.as_ref()
    }
    /// <p>The channel's output properties.</p>
    pub fn outputs(&self) -> std::option::Option<&[crate::model::RequestOutputItem]> {
        self.outputs.as_deref()
    }
    /// <p>The type of playback mode to use for this channel.</p> <p>LINEAR - The programs in the schedule play once back-to-back in the schedule.</p> <p>LOOP - The programs in the schedule play back-to-back in an endless loop. When the last program in the schedule stops playing, playback loops back to the first program in the schedule.</p>
    pub fn playback_mode(&self) -> std::option::Option<&crate::model::PlaybackMode> {
        self.playback_mode.as_ref()
    }
    /// <p>The tags to assign to the channel.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for CreateChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelInput");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("filler_slate", &self.filler_slate);
        formatter.field("outputs", &self.outputs);
        formatter.field("playback_mode", &self.playback_mode);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>Configures Amazon CloudWatch log settings for a playback configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConfigureLogsForPlaybackConfigurationInput {
    /// <p>The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to 60, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html">debug log mode</a>.</p> <p>Valid values: 0 - 100</p>
    pub percent_enabled: i32,
    /// <p>The name of the playback configuration.</p>
    pub playback_configuration_name: std::option::Option<std::string::String>,
}
impl ConfigureLogsForPlaybackConfigurationInput {
    /// <p>The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to 60, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html">debug log mode</a>.</p> <p>Valid values: 0 - 100</p>
    pub fn percent_enabled(&self) -> i32 {
        self.percent_enabled
    }
    /// <p>The name of the playback configuration.</p>
    pub fn playback_configuration_name(&self) -> std::option::Option<&str> {
        self.playback_configuration_name.as_deref()
    }
}
impl std::fmt::Debug for ConfigureLogsForPlaybackConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConfigureLogsForPlaybackConfigurationInput");
        formatter.field("percent_enabled", &self.percent_enabled);
        formatter.field(
            "playback_configuration_name",
            &self.playback_configuration_name,
        );
        formatter.finish()
    }
}
