// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_channel(&self) -> fluent_builders::CreateChannel<C> {
        fluent_builders::CreateChannel::new(self.handle.clone())
    }
    pub fn create_program(&self) -> fluent_builders::CreateProgram<C> {
        fluent_builders::CreateProgram::new(self.handle.clone())
    }
    pub fn create_source_location(&self) -> fluent_builders::CreateSourceLocation<C> {
        fluent_builders::CreateSourceLocation::new(self.handle.clone())
    }
    pub fn create_vod_source(&self) -> fluent_builders::CreateVodSource<C> {
        fluent_builders::CreateVodSource::new(self.handle.clone())
    }
    pub fn delete_channel(&self) -> fluent_builders::DeleteChannel<C> {
        fluent_builders::DeleteChannel::new(self.handle.clone())
    }
    pub fn delete_channel_policy(&self) -> fluent_builders::DeleteChannelPolicy<C> {
        fluent_builders::DeleteChannelPolicy::new(self.handle.clone())
    }
    pub fn delete_playback_configuration(&self) -> fluent_builders::DeletePlaybackConfiguration<C> {
        fluent_builders::DeletePlaybackConfiguration::new(self.handle.clone())
    }
    pub fn delete_program(&self) -> fluent_builders::DeleteProgram<C> {
        fluent_builders::DeleteProgram::new(self.handle.clone())
    }
    pub fn delete_source_location(&self) -> fluent_builders::DeleteSourceLocation<C> {
        fluent_builders::DeleteSourceLocation::new(self.handle.clone())
    }
    pub fn delete_vod_source(&self) -> fluent_builders::DeleteVodSource<C> {
        fluent_builders::DeleteVodSource::new(self.handle.clone())
    }
    pub fn describe_channel(&self) -> fluent_builders::DescribeChannel<C> {
        fluent_builders::DescribeChannel::new(self.handle.clone())
    }
    pub fn describe_program(&self) -> fluent_builders::DescribeProgram<C> {
        fluent_builders::DescribeProgram::new(self.handle.clone())
    }
    pub fn describe_source_location(&self) -> fluent_builders::DescribeSourceLocation<C> {
        fluent_builders::DescribeSourceLocation::new(self.handle.clone())
    }
    pub fn describe_vod_source(&self) -> fluent_builders::DescribeVodSource<C> {
        fluent_builders::DescribeVodSource::new(self.handle.clone())
    }
    pub fn get_channel_policy(&self) -> fluent_builders::GetChannelPolicy<C> {
        fluent_builders::GetChannelPolicy::new(self.handle.clone())
    }
    pub fn get_channel_schedule(&self) -> fluent_builders::GetChannelSchedule<C> {
        fluent_builders::GetChannelSchedule::new(self.handle.clone())
    }
    pub fn get_playback_configuration(&self) -> fluent_builders::GetPlaybackConfiguration<C> {
        fluent_builders::GetPlaybackConfiguration::new(self.handle.clone())
    }
    pub fn list_channels(&self) -> fluent_builders::ListChannels<C> {
        fluent_builders::ListChannels::new(self.handle.clone())
    }
    pub fn list_playback_configurations(&self) -> fluent_builders::ListPlaybackConfigurations<C> {
        fluent_builders::ListPlaybackConfigurations::new(self.handle.clone())
    }
    pub fn list_source_locations(&self) -> fluent_builders::ListSourceLocations<C> {
        fluent_builders::ListSourceLocations::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_vod_sources(&self) -> fluent_builders::ListVodSources<C> {
        fluent_builders::ListVodSources::new(self.handle.clone())
    }
    pub fn put_channel_policy(&self) -> fluent_builders::PutChannelPolicy<C> {
        fluent_builders::PutChannelPolicy::new(self.handle.clone())
    }
    pub fn put_playback_configuration(&self) -> fluent_builders::PutPlaybackConfiguration<C> {
        fluent_builders::PutPlaybackConfiguration::new(self.handle.clone())
    }
    pub fn start_channel(&self) -> fluent_builders::StartChannel<C> {
        fluent_builders::StartChannel::new(self.handle.clone())
    }
    pub fn stop_channel(&self) -> fluent_builders::StopChannel<C> {
        fluent_builders::StopChannel::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_channel(&self) -> fluent_builders::UpdateChannel<C> {
        fluent_builders::UpdateChannel::new(self.handle.clone())
    }
    pub fn update_source_location(&self) -> fluent_builders::UpdateSourceLocation<C> {
        fluent_builders::UpdateSourceLocation::new(self.handle.clone())
    }
    pub fn update_vod_source(&self) -> fluent_builders::UpdateVodSource<C> {
        fluent_builders::UpdateVodSource::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_channel_input::Builder,
    }
    impl<C> CreateChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateChannelOutput,
            smithy_http::result::SdkError<crate::error::CreateChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
        /// <p>The channel's output properties.</p>
        pub fn outputs(mut self, inp: impl Into<crate::model::RequestOutputItem>) -> Self {
            self.inner = self.inner.outputs(inp);
            self
        }
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
        ) -> Self {
            self.inner = self.inner.set_outputs(input);
            self
        }
        /// <p>The type of playback mode for this channel. The only supported value is LOOP.</p>
        pub fn playback_mode(mut self, input: crate::model::PlaybackMode) -> Self {
            self.inner = self.inner.playback_mode(input);
            self
        }
        pub fn set_playback_mode(
            mut self,
            input: std::option::Option<crate::model::PlaybackMode>,
        ) -> Self {
            self.inner = self.inner.set_playback_mode(input);
            self
        }
        /// <p>The tags to assign to the channel.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateProgram<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_program_input::Builder,
    }
    impl<C> CreateProgram<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateProgramOutput,
            smithy_http::result::SdkError<crate::error::CreateProgramError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ad break configuration settings.</p>
        pub fn ad_breaks(mut self, inp: impl Into<crate::model::AdBreak>) -> Self {
            self.inner = self.inner.ad_breaks(inp);
            self
        }
        pub fn set_ad_breaks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AdBreak>>,
        ) -> Self {
            self.inner = self.inner.set_ad_breaks(input);
            self
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
        /// <p>The identifier for the program you are working on.</p>
        pub fn program_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.program_name(input);
            self
        }
        pub fn set_program_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_program_name(input);
            self
        }
        /// <p>The schedule configuration settings.</p>
        pub fn schedule_configuration(
            mut self,
            input: crate::model::ScheduleConfiguration,
        ) -> Self {
            self.inner = self.inner.schedule_configuration(input);
            self
        }
        pub fn set_schedule_configuration(
            mut self,
            input: std::option::Option<crate::model::ScheduleConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_schedule_configuration(input);
            self
        }
        /// <p>The name of the source location.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_location_name(input);
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_location_name(input);
            self
        }
        /// <p>The name that's used to refer to a VOD source.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vod_source_name(input);
            self
        }
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vod_source_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSourceLocation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_source_location_input::Builder,
    }
    impl<C> CreateSourceLocation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSourceLocationOutput,
            smithy_http::result::SdkError<crate::error::CreateSourceLocationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
        pub fn access_configuration(mut self, input: crate::model::AccessConfiguration) -> Self {
            self.inner = self.inner.access_configuration(input);
            self
        }
        pub fn set_access_configuration(
            mut self,
            input: std::option::Option<crate::model::AccessConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_access_configuration(input);
            self
        }
        /// <p>The optional configuration for the server that serves segments.</p>
        pub fn default_segment_delivery_configuration(
            mut self,
            input: crate::model::DefaultSegmentDeliveryConfiguration,
        ) -> Self {
            self.inner = self.inner.default_segment_delivery_configuration(input);
            self
        }
        pub fn set_default_segment_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_default_segment_delivery_configuration(input);
            self
        }
        /// <p>The source's HTTP package configurations.</p>
        pub fn http_configuration(mut self, input: crate::model::HttpConfiguration) -> Self {
            self.inner = self.inner.http_configuration(input);
            self
        }
        pub fn set_http_configuration(
            mut self,
            input: std::option::Option<crate::model::HttpConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_http_configuration(input);
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_location_name(input);
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_location_name(input);
            self
        }
        /// <p>The tags to assign to the source location.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVodSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_vod_source_input::Builder,
    }
    impl<C> CreateVodSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVodSourceOutput,
            smithy_http::result::SdkError<crate::error::CreateVodSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array of HTTP package configuration parameters for this VOD source.</p>
        pub fn http_package_configurations(
            mut self,
            inp: impl Into<crate::model::HttpPackageConfiguration>,
        ) -> Self {
            self.inner = self.inner.http_package_configurations(inp);
            self
        }
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.inner = self.inner.set_http_package_configurations(input);
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_location_name(input);
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_location_name(input);
            self
        }
        /// <p>The tags to assign to the VOD source.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vod_source_name(input);
            self
        }
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vod_source_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_channel_input::Builder,
    }
    impl<C> DeleteChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteChannelOutput,
            smithy_http::result::SdkError<crate::error::DeleteChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteChannelPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_channel_policy_input::Builder,
    }
    impl<C> DeleteChannelPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteChannelPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteChannelPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePlaybackConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_playback_configuration_input::Builder,
    }
    impl<C> DeletePlaybackConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePlaybackConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeletePlaybackConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteProgram<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_program_input::Builder,
    }
    impl<C> DeleteProgram<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteProgramOutput,
            smithy_http::result::SdkError<crate::error::DeleteProgramError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
        /// <p>The identifier for the program you are working on.</p>
        pub fn program_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.program_name(input);
            self
        }
        pub fn set_program_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_program_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSourceLocation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_source_location_input::Builder,
    }
    impl<C> DeleteSourceLocation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSourceLocationOutput,
            smithy_http::result::SdkError<crate::error::DeleteSourceLocationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_location_name(input);
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_location_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVodSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_vod_source_input::Builder,
    }
    impl<C> DeleteVodSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVodSourceOutput,
            smithy_http::result::SdkError<crate::error::DeleteVodSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_location_name(input);
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_location_name(input);
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vod_source_name(input);
            self
        }
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vod_source_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_channel_input::Builder,
    }
    impl<C> DescribeChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeChannelOutput,
            smithy_http::result::SdkError<crate::error::DescribeChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeProgram<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_program_input::Builder,
    }
    impl<C> DescribeProgram<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeProgramOutput,
            smithy_http::result::SdkError<crate::error::DescribeProgramError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
        /// <p>The identifier for the program you are working on.</p>
        pub fn program_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.program_name(input);
            self
        }
        pub fn set_program_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_program_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSourceLocation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_source_location_input::Builder,
    }
    impl<C> DescribeSourceLocation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSourceLocationOutput,
            smithy_http::result::SdkError<crate::error::DescribeSourceLocationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_location_name(input);
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_location_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVodSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vod_source_input::Builder,
    }
    impl<C> DescribeVodSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVodSourceOutput,
            smithy_http::result::SdkError<crate::error::DescribeVodSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_location_name(input);
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_location_name(input);
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vod_source_name(input);
            self
        }
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vod_source_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetChannelPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_channel_policy_input::Builder,
    }
    impl<C> GetChannelPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetChannelPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetChannelPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetChannelSchedule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_channel_schedule_input::Builder,
    }
    impl<C> GetChannelSchedule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetChannelScheduleOutput,
            smithy_http::result::SdkError<crate::error::GetChannelScheduleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
        /// <p>The schedule duration in minutes. The maximum duration is 4320 minutes (three days).</p>
        pub fn duration_minutes(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.duration_minutes(input);
            self
        }
        pub fn set_duration_minutes(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_duration_minutes(input);
            self
        }
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPlaybackConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_playback_configuration_input::Builder,
    }
    impl<C> GetPlaybackConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPlaybackConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetPlaybackConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListChannels<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_channels_input::Builder,
    }
    impl<C> ListChannels<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListChannelsOutput,
            smithy_http::result::SdkError<crate::error::ListChannelsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPlaybackConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_playback_configurations_input::Builder,
    }
    impl<C> ListPlaybackConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPlaybackConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListPlaybackConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Maximum number of records to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSourceLocations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_source_locations_input::Builder,
    }
    impl<C> ListSourceLocations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSourceLocationsOutput,
            smithy_http::result::SdkError<crate::error::ListSourceLocationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListVodSources<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_vod_sources_input::Builder,
    }
    impl<C> ListVodSources<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListVodSourcesOutput,
            smithy_http::result::SdkError<crate::error::ListVodSourcesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_location_name(input);
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_location_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutChannelPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_channel_policy_input::Builder,
    }
    impl<C> PutChannelPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutChannelPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutChannelPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
        /// <p>Adds an IAM role that determines the permissions of your channel.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutPlaybackConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_playback_configuration_input::Builder,
    }
    impl<C> PutPlaybackConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutPlaybackConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutPlaybackConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
        pub fn ad_decision_server_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ad_decision_server_url(input);
            self
        }
        pub fn set_ad_decision_server_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ad_decision_server_url(input);
            self
        }
        /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
        pub fn avail_suppression(mut self, input: crate::model::AvailSuppression) -> Self {
            self.inner = self.inner.avail_suppression(input);
            self
        }
        pub fn set_avail_suppression(
            mut self,
            input: std::option::Option<crate::model::AvailSuppression>,
        ) -> Self {
            self.inner = self.inner.set_avail_suppression(input);
            self
        }
        /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
        pub fn bumper(mut self, input: crate::model::Bumper) -> Self {
            self.inner = self.inner.bumper(input);
            self
        }
        pub fn set_bumper(mut self, input: std::option::Option<crate::model::Bumper>) -> Self {
            self.inner = self.inner.set_bumper(input);
            self
        }
        /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
        pub fn cdn_configuration(mut self, input: crate::model::CdnConfiguration) -> Self {
            self.inner = self.inner.cdn_configuration(input);
            self
        }
        pub fn set_cdn_configuration(
            mut self,
            input: std::option::Option<crate::model::CdnConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_cdn_configuration(input);
            self
        }
        /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
        pub fn configuration_aliases(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::collections::HashMap<std::string::String, std::string::String>>,
        ) -> Self {
            self.inner = self.inner.configuration_aliases(k, v);
            self
        }
        pub fn set_configuration_aliases(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::collections::HashMap<std::string::String, std::string::String>,
                >,
            >,
        ) -> Self {
            self.inner = self.inner.set_configuration_aliases(input);
            self
        }
        /// <p>The configuration for DASH content.</p>
        pub fn dash_configuration(mut self, input: crate::model::DashConfigurationForPut) -> Self {
            self.inner = self.inner.dash_configuration(input);
            self
        }
        pub fn set_dash_configuration(
            mut self,
            input: std::option::Option<crate::model::DashConfigurationForPut>,
        ) -> Self {
            self.inner = self.inner.set_dash_configuration(input);
            self
        }
        /// <p>The configuration for pre-roll ad insertion.</p>
        pub fn live_pre_roll_configuration(
            mut self,
            input: crate::model::LivePreRollConfiguration,
        ) -> Self {
            self.inner = self.inner.live_pre_roll_configuration(input);
            self
        }
        pub fn set_live_pre_roll_configuration(
            mut self,
            input: std::option::Option<crate::model::LivePreRollConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_live_pre_roll_configuration(input);
            self
        }
        /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
        pub fn manifest_processing_rules(
            mut self,
            input: crate::model::ManifestProcessingRules,
        ) -> Self {
            self.inner = self.inner.manifest_processing_rules(input);
            self
        }
        pub fn set_manifest_processing_rules(
            mut self,
            input: std::option::Option<crate::model::ManifestProcessingRules>,
        ) -> Self {
            self.inner = self.inner.set_manifest_processing_rules(input);
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
        pub fn personalization_threshold_seconds(mut self, input: i32) -> Self {
            self.inner = self.inner.personalization_threshold_seconds(input);
            self
        }
        pub fn set_personalization_threshold_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_personalization_threshold_seconds(input);
            self
        }
        /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
        pub fn slate_ad_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.slate_ad_url(input);
            self
        }
        pub fn set_slate_ad_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_slate_ad_url(input);
            self
        }
        /// <p>The tags to assign to the playback configuration.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
        pub fn transcode_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transcode_profile_name(input);
            self
        }
        pub fn set_transcode_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transcode_profile_name(input);
            self
        }
        /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
        pub fn video_content_source_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.video_content_source_url(input);
            self
        }
        pub fn set_video_content_source_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_video_content_source_url(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_channel_input::Builder,
    }
    impl<C> StartChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartChannelOutput,
            smithy_http::result::SdkError<crate::error::StartChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_channel_input::Builder,
    }
    impl<C> StopChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopChannelOutput,
            smithy_http::result::SdkError<crate::error::StopChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A comma-separated list of tag key:value pairs.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A comma-separated list of the tag keys to remove from the playback configuration.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_channel_input::Builder,
    }
    impl<C> UpdateChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateChannelOutput,
            smithy_http::result::SdkError<crate::error::UpdateChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the channel you are working on.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_name(input);
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_name(input);
            self
        }
        /// <p>The channel's output properties.</p>
        pub fn outputs(mut self, inp: impl Into<crate::model::RequestOutputItem>) -> Self {
            self.inner = self.inner.outputs(inp);
            self
        }
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RequestOutputItem>>,
        ) -> Self {
            self.inner = self.inner.set_outputs(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSourceLocation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_source_location_input::Builder,
    }
    impl<C> UpdateSourceLocation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateSourceLocationOutput,
            smithy_http::result::SdkError<crate::error::UpdateSourceLocationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
        pub fn access_configuration(mut self, input: crate::model::AccessConfiguration) -> Self {
            self.inner = self.inner.access_configuration(input);
            self
        }
        pub fn set_access_configuration(
            mut self,
            input: std::option::Option<crate::model::AccessConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_access_configuration(input);
            self
        }
        /// <p>The optional configuration for the host server that serves segments.</p>
        pub fn default_segment_delivery_configuration(
            mut self,
            input: crate::model::DefaultSegmentDeliveryConfiguration,
        ) -> Self {
            self.inner = self.inner.default_segment_delivery_configuration(input);
            self
        }
        pub fn set_default_segment_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_default_segment_delivery_configuration(input);
            self
        }
        /// <p>The HTTP configuration for the source location.</p>
        pub fn http_configuration(mut self, input: crate::model::HttpConfiguration) -> Self {
            self.inner = self.inner.http_configuration(input);
            self
        }
        pub fn set_http_configuration(
            mut self,
            input: std::option::Option<crate::model::HttpConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_http_configuration(input);
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_location_name(input);
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_location_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateVodSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_vod_source_input::Builder,
    }
    impl<C> UpdateVodSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateVodSourceOutput,
            smithy_http::result::SdkError<crate::error::UpdateVodSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array of HTTP package configurations for the VOD source on this account.</p>
        pub fn http_package_configurations(
            mut self,
            inp: impl Into<crate::model::HttpPackageConfiguration>,
        ) -> Self {
            self.inner = self.inner.http_package_configurations(inp);
            self
        }
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.inner = self.inner.set_http_package_configurations(input);
            self
        }
        /// <p>The identifier for the source location you are working on.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_location_name(input);
            self
        }
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_location_name(input);
            self
        }
        /// <p>The identifier for the VOD source you are working on.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vod_source_name(input);
            self
        }
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vod_source_name(input);
            self
        }
    }
}
