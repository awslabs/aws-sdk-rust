// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateVodSourceOutput {
    /// <p>The ARN of the VOD source.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates when the VOD source was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The HTTP package configurations.</p>
    pub http_package_configurations:
        std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
    /// <p>The last modified time of the VOD source.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the source location associated with the VOD source.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the VOD source.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name of the VOD source.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl UpdateVodSourceOutput {
    /// <p>The ARN of the VOD source.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The timestamp that indicates when the VOD source was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The HTTP package configurations.</p>
    pub fn http_package_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::HttpPackageConfiguration]> {
        self.http_package_configurations.as_deref()
    }
    /// <p>The last modified time of the VOD source.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The name of the source location associated with the VOD source.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags assigned to the VOD source.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The name of the VOD source.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl std::fmt::Debug for UpdateVodSourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateVodSourceOutput");
        formatter.field("arn", &self.arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "http_package_configurations",
            &self.http_package_configurations,
        );
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("tags", &self.tags);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}
/// See [`UpdateVodSourceOutput`](crate::output::UpdateVodSourceOutput)
pub mod update_vod_source_output {

    /// A builder for [`UpdateVodSourceOutput`](crate::output::UpdateVodSourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) http_package_configurations:
            std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the VOD source.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the VOD source.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The timestamp that indicates when the VOD source was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the VOD source was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Appends an item to `http_package_configurations`.
        ///
        /// To override the contents of this collection use [`set_http_package_configurations`](Self::set_http_package_configurations).
        ///
        /// <p>The HTTP package configurations.</p>
        pub fn http_package_configurations(
            mut self,
            input: crate::model::HttpPackageConfiguration,
        ) -> Self {
            let mut v = self.http_package_configurations.unwrap_or_default();
            v.push(input);
            self.http_package_configurations = Some(v);
            self
        }
        /// <p>The HTTP package configurations.</p>
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.http_package_configurations = input;
            self
        }
        /// <p>The last modified time of the VOD source.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last modified time of the VOD source.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The name of the source location associated with the VOD source.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location associated with the VOD source.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the VOD source.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the VOD source.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The name of the VOD source.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The name of the VOD source.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVodSourceOutput`](crate::output::UpdateVodSourceOutput)
        pub fn build(self) -> crate::output::UpdateVodSourceOutput {
            crate::output::UpdateVodSourceOutput {
                arn: self.arn,
                creation_time: self.creation_time,
                http_package_configurations: self.http_package_configurations,
                last_modified_time: self.last_modified_time,
                source_location_name: self.source_location_name,
                tags: self.tags,
                vod_source_name: self.vod_source_name,
            }
        }
    }
}
impl UpdateVodSourceOutput {
    /// Creates a new builder-style object to manufacture [`UpdateVodSourceOutput`](crate::output::UpdateVodSourceOutput)
    pub fn builder() -> crate::output::update_vod_source_output::Builder {
        crate::output::update_vod_source_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSourceLocationOutput {
    /// <p>The access configuration for the source location.</p>
    pub access_configuration: std::option::Option<crate::model::AccessConfiguration>,
    /// <p>The ARN of the source location.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates when the source location was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The default segment delivery configuration settings.</p>
    pub default_segment_delivery_configuration:
        std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
    /// <p>The HTTP package configuration settings for the source location.</p>
    pub http_configuration: std::option::Option<crate::model::HttpConfiguration>,
    /// <p>The timestamp that indicates when the source location was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A list of the segment delivery configurations associated with this resource.</p>
    pub segment_delivery_configurations:
        std::option::Option<std::vec::Vec<crate::model::SegmentDeliveryConfiguration>>,
    /// <p>The name of the source location.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the source location.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl UpdateSourceLocationOutput {
    /// <p>The access configuration for the source location.</p>
    pub fn access_configuration(&self) -> std::option::Option<&crate::model::AccessConfiguration> {
        self.access_configuration.as_ref()
    }
    /// <p>The ARN of the source location.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The timestamp that indicates when the source location was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The default segment delivery configuration settings.</p>
    pub fn default_segment_delivery_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DefaultSegmentDeliveryConfiguration> {
        self.default_segment_delivery_configuration.as_ref()
    }
    /// <p>The HTTP package configuration settings for the source location.</p>
    pub fn http_configuration(&self) -> std::option::Option<&crate::model::HttpConfiguration> {
        self.http_configuration.as_ref()
    }
    /// <p>The timestamp that indicates when the source location was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>A list of the segment delivery configurations associated with this resource.</p>
    pub fn segment_delivery_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::SegmentDeliveryConfiguration]> {
        self.segment_delivery_configurations.as_deref()
    }
    /// <p>The name of the source location.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags assigned to the source location.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for UpdateSourceLocationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSourceLocationOutput");
        formatter.field("access_configuration", &self.access_configuration);
        formatter.field("arn", &self.arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "default_segment_delivery_configuration",
            &self.default_segment_delivery_configuration,
        );
        formatter.field("http_configuration", &self.http_configuration);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "segment_delivery_configurations",
            &self.segment_delivery_configurations,
        );
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`UpdateSourceLocationOutput`](crate::output::UpdateSourceLocationOutput)
pub mod update_source_location_output {

    /// A builder for [`UpdateSourceLocationOutput`](crate::output::UpdateSourceLocationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_configuration: std::option::Option<crate::model::AccessConfiguration>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) default_segment_delivery_configuration:
            std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        pub(crate) http_configuration: std::option::Option<crate::model::HttpConfiguration>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) segment_delivery_configurations:
            std::option::Option<std::vec::Vec<crate::model::SegmentDeliveryConfiguration>>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The access configuration for the source location.</p>
        pub fn access_configuration(mut self, input: crate::model::AccessConfiguration) -> Self {
            self.access_configuration = Some(input);
            self
        }
        /// <p>The access configuration for the source location.</p>
        pub fn set_access_configuration(
            mut self,
            input: std::option::Option<crate::model::AccessConfiguration>,
        ) -> Self {
            self.access_configuration = input;
            self
        }
        /// <p>The ARN of the source location.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the source location.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The timestamp that indicates when the source location was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the source location was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The default segment delivery configuration settings.</p>
        pub fn default_segment_delivery_configuration(
            mut self,
            input: crate::model::DefaultSegmentDeliveryConfiguration,
        ) -> Self {
            self.default_segment_delivery_configuration = Some(input);
            self
        }
        /// <p>The default segment delivery configuration settings.</p>
        pub fn set_default_segment_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        ) -> Self {
            self.default_segment_delivery_configuration = input;
            self
        }
        /// <p>The HTTP package configuration settings for the source location.</p>
        pub fn http_configuration(mut self, input: crate::model::HttpConfiguration) -> Self {
            self.http_configuration = Some(input);
            self
        }
        /// <p>The HTTP package configuration settings for the source location.</p>
        pub fn set_http_configuration(
            mut self,
            input: std::option::Option<crate::model::HttpConfiguration>,
        ) -> Self {
            self.http_configuration = input;
            self
        }
        /// <p>The timestamp that indicates when the source location was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the source location was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Appends an item to `segment_delivery_configurations`.
        ///
        /// To override the contents of this collection use [`set_segment_delivery_configurations`](Self::set_segment_delivery_configurations).
        ///
        /// <p>A list of the segment delivery configurations associated with this resource.</p>
        pub fn segment_delivery_configurations(
            mut self,
            input: crate::model::SegmentDeliveryConfiguration,
        ) -> Self {
            let mut v = self.segment_delivery_configurations.unwrap_or_default();
            v.push(input);
            self.segment_delivery_configurations = Some(v);
            self
        }
        /// <p>A list of the segment delivery configurations associated with this resource.</p>
        pub fn set_segment_delivery_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SegmentDeliveryConfiguration>>,
        ) -> Self {
            self.segment_delivery_configurations = input;
            self
        }
        /// <p>The name of the source location.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the source location.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the source location.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSourceLocationOutput`](crate::output::UpdateSourceLocationOutput)
        pub fn build(self) -> crate::output::UpdateSourceLocationOutput {
            crate::output::UpdateSourceLocationOutput {
                access_configuration: self.access_configuration,
                arn: self.arn,
                creation_time: self.creation_time,
                default_segment_delivery_configuration: self.default_segment_delivery_configuration,
                http_configuration: self.http_configuration,
                last_modified_time: self.last_modified_time,
                segment_delivery_configurations: self.segment_delivery_configurations,
                source_location_name: self.source_location_name,
                tags: self.tags,
            }
        }
    }
}
impl UpdateSourceLocationOutput {
    /// Creates a new builder-style object to manufacture [`UpdateSourceLocationOutput`](crate::output::UpdateSourceLocationOutput)
    pub fn builder() -> crate::output::update_source_location_output::Builder {
        crate::output::update_source_location_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateLiveSourceOutput {
    /// <p>The ARN of the live source.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates when the live source was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The HTTP package configurations.</p>
    pub http_package_configurations:
        std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
    /// <p>The timestamp that indicates when the live source was modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the live source.</p>
    pub live_source_name: std::option::Option<std::string::String>,
    /// <p>The name of the source location associated with the VOD source.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the live source.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl UpdateLiveSourceOutput {
    /// <p>The ARN of the live source.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The timestamp that indicates when the live source was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The HTTP package configurations.</p>
    pub fn http_package_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::HttpPackageConfiguration]> {
        self.http_package_configurations.as_deref()
    }
    /// <p>The timestamp that indicates when the live source was modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The name of the live source.</p>
    pub fn live_source_name(&self) -> std::option::Option<&str> {
        self.live_source_name.as_deref()
    }
    /// <p>The name of the source location associated with the VOD source.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags assigned to the live source.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for UpdateLiveSourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateLiveSourceOutput");
        formatter.field("arn", &self.arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "http_package_configurations",
            &self.http_package_configurations,
        );
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("live_source_name", &self.live_source_name);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`UpdateLiveSourceOutput`](crate::output::UpdateLiveSourceOutput)
pub mod update_live_source_output {

    /// A builder for [`UpdateLiveSourceOutput`](crate::output::UpdateLiveSourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) http_package_configurations:
            std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) live_source_name: std::option::Option<std::string::String>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ARN of the live source.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the live source.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The timestamp that indicates when the live source was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the live source was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Appends an item to `http_package_configurations`.
        ///
        /// To override the contents of this collection use [`set_http_package_configurations`](Self::set_http_package_configurations).
        ///
        /// <p>The HTTP package configurations.</p>
        pub fn http_package_configurations(
            mut self,
            input: crate::model::HttpPackageConfiguration,
        ) -> Self {
            let mut v = self.http_package_configurations.unwrap_or_default();
            v.push(input);
            self.http_package_configurations = Some(v);
            self
        }
        /// <p>The HTTP package configurations.</p>
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.http_package_configurations = input;
            self
        }
        /// <p>The timestamp that indicates when the live source was modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the live source was modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The name of the live source.</p>
        pub fn live_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.live_source_name = Some(input.into());
            self
        }
        /// <p>The name of the live source.</p>
        pub fn set_live_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.live_source_name = input;
            self
        }
        /// <p>The name of the source location associated with the VOD source.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location associated with the VOD source.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the live source.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the live source.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateLiveSourceOutput`](crate::output::UpdateLiveSourceOutput)
        pub fn build(self) -> crate::output::UpdateLiveSourceOutput {
            crate::output::UpdateLiveSourceOutput {
                arn: self.arn,
                creation_time: self.creation_time,
                http_package_configurations: self.http_package_configurations,
                last_modified_time: self.last_modified_time,
                live_source_name: self.live_source_name,
                source_location_name: self.source_location_name,
                tags: self.tags,
            }
        }
    }
}
impl UpdateLiveSourceOutput {
    /// Creates a new builder-style object to manufacture [`UpdateLiveSourceOutput`](crate::output::UpdateLiveSourceOutput)
    pub fn builder() -> crate::output::update_live_source_output::Builder {
        crate::output::update_live_source_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelOutput {
    /// <p>The ARN of the channel.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the channel.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>Indicates whether the channel is in a running state or not.</p>
    pub channel_state: std::option::Option<crate::model::ChannelState>,
    /// <p>The timestamp of when the channel was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Contains information about the slate used to fill gaps between programs in the schedule.</p>
    pub filler_slate: std::option::Option<crate::model::SlateSource>,
    /// <p>The timestamp of when the channel was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The channel's output properties.</p>
    pub outputs: std::option::Option<std::vec::Vec<crate::model::ResponseOutputItem>>,
    /// <p>The channel's playback mode.</p>
    pub playback_mode: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the channel.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The channel's tier.</p>
    pub tier: std::option::Option<std::string::String>,
}
impl UpdateChannelOutput {
    /// <p>The ARN of the channel.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the channel.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>Indicates whether the channel is in a running state or not.</p>
    pub fn channel_state(&self) -> std::option::Option<&crate::model::ChannelState> {
        self.channel_state.as_ref()
    }
    /// <p>The timestamp of when the channel was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Contains information about the slate used to fill gaps between programs in the schedule.</p>
    pub fn filler_slate(&self) -> std::option::Option<&crate::model::SlateSource> {
        self.filler_slate.as_ref()
    }
    /// <p>The timestamp of when the channel was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The channel's output properties.</p>
    pub fn outputs(&self) -> std::option::Option<&[crate::model::ResponseOutputItem]> {
        self.outputs.as_deref()
    }
    /// <p>The channel's playback mode.</p>
    pub fn playback_mode(&self) -> std::option::Option<&str> {
        self.playback_mode.as_deref()
    }
    /// <p>The tags assigned to the channel.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The channel's tier.</p>
    pub fn tier(&self) -> std::option::Option<&str> {
        self.tier.as_deref()
    }
}
impl std::fmt::Debug for UpdateChannelOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelOutput");
        formatter.field("arn", &self.arn);
        formatter.field("channel_name", &self.channel_name);
        formatter.field("channel_state", &self.channel_state);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("filler_slate", &self.filler_slate);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("outputs", &self.outputs);
        formatter.field("playback_mode", &self.playback_mode);
        formatter.field("tags", &self.tags);
        formatter.field("tier", &self.tier);
        formatter.finish()
    }
}
/// See [`UpdateChannelOutput`](crate::output::UpdateChannelOutput)
pub mod update_channel_output {

    /// A builder for [`UpdateChannelOutput`](crate::output::UpdateChannelOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) channel_state: std::option::Option<crate::model::ChannelState>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) filler_slate: std::option::Option<crate::model::SlateSource>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) outputs: std::option::Option<std::vec::Vec<crate::model::ResponseOutputItem>>,
        pub(crate) playback_mode: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) tier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the channel.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The name of the channel.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>Indicates whether the channel is in a running state or not.</p>
        pub fn channel_state(mut self, input: crate::model::ChannelState) -> Self {
            self.channel_state = Some(input);
            self
        }
        /// <p>Indicates whether the channel is in a running state or not.</p>
        pub fn set_channel_state(
            mut self,
            input: std::option::Option<crate::model::ChannelState>,
        ) -> Self {
            self.channel_state = input;
            self
        }
        /// <p>The timestamp of when the channel was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp of when the channel was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Contains information about the slate used to fill gaps between programs in the schedule.</p>
        pub fn filler_slate(mut self, input: crate::model::SlateSource) -> Self {
            self.filler_slate = Some(input);
            self
        }
        /// <p>Contains information about the slate used to fill gaps between programs in the schedule.</p>
        pub fn set_filler_slate(
            mut self,
            input: std::option::Option<crate::model::SlateSource>,
        ) -> Self {
            self.filler_slate = input;
            self
        }
        /// <p>The timestamp of when the channel was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp of when the channel was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Appends an item to `outputs`.
        ///
        /// To override the contents of this collection use [`set_outputs`](Self::set_outputs).
        ///
        /// <p>The channel's output properties.</p>
        pub fn outputs(mut self, input: crate::model::ResponseOutputItem) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(input);
            self.outputs = Some(v);
            self
        }
        /// <p>The channel's output properties.</p>
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResponseOutputItem>>,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// <p>The channel's playback mode.</p>
        pub fn playback_mode(mut self, input: impl Into<std::string::String>) -> Self {
            self.playback_mode = Some(input.into());
            self
        }
        /// <p>The channel's playback mode.</p>
        pub fn set_playback_mode(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_mode = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the channel.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the channel.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The channel's tier.</p>
        pub fn tier(mut self, input: impl Into<std::string::String>) -> Self {
            self.tier = Some(input.into());
            self
        }
        /// <p>The channel's tier.</p>
        pub fn set_tier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tier = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateChannelOutput`](crate::output::UpdateChannelOutput)
        pub fn build(self) -> crate::output::UpdateChannelOutput {
            crate::output::UpdateChannelOutput {
                arn: self.arn,
                channel_name: self.channel_name,
                channel_state: self.channel_state,
                creation_time: self.creation_time,
                filler_slate: self.filler_slate,
                last_modified_time: self.last_modified_time,
                outputs: self.outputs,
                playback_mode: self.playback_mode,
                tags: self.tags,
                tier: self.tier,
            }
        }
    }
}
impl UpdateChannelOutput {
    /// Creates a new builder-style object to manufacture [`UpdateChannelOutput`](crate::output::UpdateChannelOutput)
    pub fn builder() -> crate::output::update_channel_output::Builder {
        crate::output::update_channel_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceOutput {}
impl std::fmt::Debug for UntagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceOutput");
        formatter.finish()
    }
}
/// See [`UntagResourceOutput`](crate::output::UntagResourceOutput)
pub mod untag_resource_output {

    /// A builder for [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UntagResourceOutput`](crate::output::UntagResourceOutput)
        pub fn build(self) -> crate::output::UntagResourceOutput {
            crate::output::UntagResourceOutput {}
        }
    }
}
impl UntagResourceOutput {
    /// Creates a new builder-style object to manufacture [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    pub fn builder() -> crate::output::untag_resource_output::Builder {
        crate::output::untag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceOutput {}
impl std::fmt::Debug for TagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceOutput");
        formatter.finish()
    }
}
/// See [`TagResourceOutput`](crate::output::TagResourceOutput)
pub mod tag_resource_output {

    /// A builder for [`TagResourceOutput`](crate::output::TagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`TagResourceOutput`](crate::output::TagResourceOutput)
        pub fn build(self) -> crate::output::TagResourceOutput {
            crate::output::TagResourceOutput {}
        }
    }
}
impl TagResourceOutput {
    /// Creates a new builder-style object to manufacture [`TagResourceOutput`](crate::output::TagResourceOutput)
    pub fn builder() -> crate::output::tag_resource_output::Builder {
        crate::output::tag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopChannelOutput {}
impl std::fmt::Debug for StopChannelOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopChannelOutput");
        formatter.finish()
    }
}
/// See [`StopChannelOutput`](crate::output::StopChannelOutput)
pub mod stop_channel_output {

    /// A builder for [`StopChannelOutput`](crate::output::StopChannelOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`StopChannelOutput`](crate::output::StopChannelOutput)
        pub fn build(self) -> crate::output::StopChannelOutput {
            crate::output::StopChannelOutput {}
        }
    }
}
impl StopChannelOutput {
    /// Creates a new builder-style object to manufacture [`StopChannelOutput`](crate::output::StopChannelOutput)
    pub fn builder() -> crate::output::stop_channel_output::Builder {
        crate::output::stop_channel_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartChannelOutput {}
impl std::fmt::Debug for StartChannelOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartChannelOutput");
        formatter.finish()
    }
}
/// See [`StartChannelOutput`](crate::output::StartChannelOutput)
pub mod start_channel_output {

    /// A builder for [`StartChannelOutput`](crate::output::StartChannelOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`StartChannelOutput`](crate::output::StartChannelOutput)
        pub fn build(self) -> crate::output::StartChannelOutput {
            crate::output::StartChannelOutput {}
        }
    }
}
impl StartChannelOutput {
    /// Creates a new builder-style object to manufacture [`StartChannelOutput`](crate::output::StartChannelOutput)
    pub fn builder() -> crate::output::start_channel_output::Builder {
        crate::output::start_channel_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutPlaybackConfigurationOutput {
    /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    pub ad_decision_server_url: std::option::Option<std::string::String>,
    /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
    pub avail_suppression: std::option::Option<crate::model::AvailSuppression>,
    /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
    pub bumper: std::option::Option<crate::model::Bumper>,
    /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
    pub cdn_configuration: std::option::Option<crate::model::CdnConfiguration>,
    /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
    pub configuration_aliases: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    >,
    /// <p>The configuration for DASH content.</p>
    pub dash_configuration: std::option::Option<crate::model::DashConfiguration>,
    /// <p>The configuration for HLS content.</p>
    pub hls_configuration: std::option::Option<crate::model::HlsConfiguration>,
    /// <p>The configuration for pre-roll ad insertion.</p>
    pub live_pre_roll_configuration: std::option::Option<crate::model::LivePreRollConfiguration>,
    /// <p>The Amazon CloudWatch log settings for a playback configuration.</p>
    pub log_configuration: std::option::Option<crate::model::LogConfiguration>,
    /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
    pub manifest_processing_rules: std::option::Option<crate::model::ManifestProcessingRules>,
    /// <p>The identifier for the playback configuration.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
    pub personalization_threshold_seconds: i32,
    /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
    pub playback_configuration_arn: std::option::Option<std::string::String>,
    /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.</p>
    pub playback_endpoint_prefix: std::option::Option<std::string::String>,
    /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
    pub session_initialization_endpoint_prefix: std::option::Option<std::string::String>,
    /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
    pub slate_ad_url: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the playback configuration.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
    pub transcode_profile_name: std::option::Option<std::string::String>,
    /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
    pub video_content_source_url: std::option::Option<std::string::String>,
}
impl PutPlaybackConfigurationOutput {
    /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    pub fn ad_decision_server_url(&self) -> std::option::Option<&str> {
        self.ad_decision_server_url.as_deref()
    }
    /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
    pub fn avail_suppression(&self) -> std::option::Option<&crate::model::AvailSuppression> {
        self.avail_suppression.as_ref()
    }
    /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
    pub fn bumper(&self) -> std::option::Option<&crate::model::Bumper> {
        self.bumper.as_ref()
    }
    /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
    pub fn cdn_configuration(&self) -> std::option::Option<&crate::model::CdnConfiguration> {
        self.cdn_configuration.as_ref()
    }
    /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
    pub fn configuration_aliases(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    > {
        self.configuration_aliases.as_ref()
    }
    /// <p>The configuration for DASH content.</p>
    pub fn dash_configuration(&self) -> std::option::Option<&crate::model::DashConfiguration> {
        self.dash_configuration.as_ref()
    }
    /// <p>The configuration for HLS content.</p>
    pub fn hls_configuration(&self) -> std::option::Option<&crate::model::HlsConfiguration> {
        self.hls_configuration.as_ref()
    }
    /// <p>The configuration for pre-roll ad insertion.</p>
    pub fn live_pre_roll_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LivePreRollConfiguration> {
        self.live_pre_roll_configuration.as_ref()
    }
    /// <p>The Amazon CloudWatch log settings for a playback configuration.</p>
    pub fn log_configuration(&self) -> std::option::Option<&crate::model::LogConfiguration> {
        self.log_configuration.as_ref()
    }
    /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
    pub fn manifest_processing_rules(
        &self,
    ) -> std::option::Option<&crate::model::ManifestProcessingRules> {
        self.manifest_processing_rules.as_ref()
    }
    /// <p>The identifier for the playback configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
    pub fn personalization_threshold_seconds(&self) -> i32 {
        self.personalization_threshold_seconds
    }
    /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
    pub fn playback_configuration_arn(&self) -> std::option::Option<&str> {
        self.playback_configuration_arn.as_deref()
    }
    /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.</p>
    pub fn playback_endpoint_prefix(&self) -> std::option::Option<&str> {
        self.playback_endpoint_prefix.as_deref()
    }
    /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
    pub fn session_initialization_endpoint_prefix(&self) -> std::option::Option<&str> {
        self.session_initialization_endpoint_prefix.as_deref()
    }
    /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
    pub fn slate_ad_url(&self) -> std::option::Option<&str> {
        self.slate_ad_url.as_deref()
    }
    /// <p>The tags assigned to the playback configuration.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
    pub fn transcode_profile_name(&self) -> std::option::Option<&str> {
        self.transcode_profile_name.as_deref()
    }
    /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
    pub fn video_content_source_url(&self) -> std::option::Option<&str> {
        self.video_content_source_url.as_deref()
    }
}
impl std::fmt::Debug for PutPlaybackConfigurationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutPlaybackConfigurationOutput");
        formatter.field("ad_decision_server_url", &self.ad_decision_server_url);
        formatter.field("avail_suppression", &self.avail_suppression);
        formatter.field("bumper", &self.bumper);
        formatter.field("cdn_configuration", &self.cdn_configuration);
        formatter.field("configuration_aliases", &self.configuration_aliases);
        formatter.field("dash_configuration", &self.dash_configuration);
        formatter.field("hls_configuration", &self.hls_configuration);
        formatter.field(
            "live_pre_roll_configuration",
            &self.live_pre_roll_configuration,
        );
        formatter.field("log_configuration", &self.log_configuration);
        formatter.field("manifest_processing_rules", &self.manifest_processing_rules);
        formatter.field("name", &self.name);
        formatter.field(
            "personalization_threshold_seconds",
            &self.personalization_threshold_seconds,
        );
        formatter.field(
            "playback_configuration_arn",
            &self.playback_configuration_arn,
        );
        formatter.field("playback_endpoint_prefix", &self.playback_endpoint_prefix);
        formatter.field(
            "session_initialization_endpoint_prefix",
            &self.session_initialization_endpoint_prefix,
        );
        formatter.field("slate_ad_url", &self.slate_ad_url);
        formatter.field("tags", &self.tags);
        formatter.field("transcode_profile_name", &self.transcode_profile_name);
        formatter.field("video_content_source_url", &self.video_content_source_url);
        formatter.finish()
    }
}
/// See [`PutPlaybackConfigurationOutput`](crate::output::PutPlaybackConfigurationOutput)
pub mod put_playback_configuration_output {

    /// A builder for [`PutPlaybackConfigurationOutput`](crate::output::PutPlaybackConfigurationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ad_decision_server_url: std::option::Option<std::string::String>,
        pub(crate) avail_suppression: std::option::Option<crate::model::AvailSuppression>,
        pub(crate) bumper: std::option::Option<crate::model::Bumper>,
        pub(crate) cdn_configuration: std::option::Option<crate::model::CdnConfiguration>,
        pub(crate) configuration_aliases: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        >,
        pub(crate) dash_configuration: std::option::Option<crate::model::DashConfiguration>,
        pub(crate) hls_configuration: std::option::Option<crate::model::HlsConfiguration>,
        pub(crate) live_pre_roll_configuration:
            std::option::Option<crate::model::LivePreRollConfiguration>,
        pub(crate) log_configuration: std::option::Option<crate::model::LogConfiguration>,
        pub(crate) manifest_processing_rules:
            std::option::Option<crate::model::ManifestProcessingRules>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) personalization_threshold_seconds: std::option::Option<i32>,
        pub(crate) playback_configuration_arn: std::option::Option<std::string::String>,
        pub(crate) playback_endpoint_prefix: std::option::Option<std::string::String>,
        pub(crate) session_initialization_endpoint_prefix: std::option::Option<std::string::String>,
        pub(crate) slate_ad_url: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) transcode_profile_name: std::option::Option<std::string::String>,
        pub(crate) video_content_source_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
        pub fn ad_decision_server_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.ad_decision_server_url = Some(input.into());
            self
        }
        /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
        pub fn set_ad_decision_server_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ad_decision_server_url = input;
            self
        }
        /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
        pub fn avail_suppression(mut self, input: crate::model::AvailSuppression) -> Self {
            self.avail_suppression = Some(input);
            self
        }
        /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
        pub fn set_avail_suppression(
            mut self,
            input: std::option::Option<crate::model::AvailSuppression>,
        ) -> Self {
            self.avail_suppression = input;
            self
        }
        /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
        pub fn bumper(mut self, input: crate::model::Bumper) -> Self {
            self.bumper = Some(input);
            self
        }
        /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
        pub fn set_bumper(mut self, input: std::option::Option<crate::model::Bumper>) -> Self {
            self.bumper = input;
            self
        }
        /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
        pub fn cdn_configuration(mut self, input: crate::model::CdnConfiguration) -> Self {
            self.cdn_configuration = Some(input);
            self
        }
        /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
        pub fn set_cdn_configuration(
            mut self,
            input: std::option::Option<crate::model::CdnConfiguration>,
        ) -> Self {
            self.cdn_configuration = input;
            self
        }
        /// Adds a key-value pair to `configuration_aliases`.
        ///
        /// To override the contents of this collection use [`set_configuration_aliases`](Self::set_configuration_aliases).
        ///
        /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
        pub fn configuration_aliases(
            mut self,
            k: impl Into<std::string::String>,
            v: std::collections::HashMap<std::string::String, std::string::String>,
        ) -> Self {
            let mut hash_map = self.configuration_aliases.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.configuration_aliases = Some(hash_map);
            self
        }
        /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
        pub fn set_configuration_aliases(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::collections::HashMap<std::string::String, std::string::String>,
                >,
            >,
        ) -> Self {
            self.configuration_aliases = input;
            self
        }
        /// <p>The configuration for DASH content.</p>
        pub fn dash_configuration(mut self, input: crate::model::DashConfiguration) -> Self {
            self.dash_configuration = Some(input);
            self
        }
        /// <p>The configuration for DASH content.</p>
        pub fn set_dash_configuration(
            mut self,
            input: std::option::Option<crate::model::DashConfiguration>,
        ) -> Self {
            self.dash_configuration = input;
            self
        }
        /// <p>The configuration for HLS content.</p>
        pub fn hls_configuration(mut self, input: crate::model::HlsConfiguration) -> Self {
            self.hls_configuration = Some(input);
            self
        }
        /// <p>The configuration for HLS content.</p>
        pub fn set_hls_configuration(
            mut self,
            input: std::option::Option<crate::model::HlsConfiguration>,
        ) -> Self {
            self.hls_configuration = input;
            self
        }
        /// <p>The configuration for pre-roll ad insertion.</p>
        pub fn live_pre_roll_configuration(
            mut self,
            input: crate::model::LivePreRollConfiguration,
        ) -> Self {
            self.live_pre_roll_configuration = Some(input);
            self
        }
        /// <p>The configuration for pre-roll ad insertion.</p>
        pub fn set_live_pre_roll_configuration(
            mut self,
            input: std::option::Option<crate::model::LivePreRollConfiguration>,
        ) -> Self {
            self.live_pre_roll_configuration = input;
            self
        }
        /// <p>The Amazon CloudWatch log settings for a playback configuration.</p>
        pub fn log_configuration(mut self, input: crate::model::LogConfiguration) -> Self {
            self.log_configuration = Some(input);
            self
        }
        /// <p>The Amazon CloudWatch log settings for a playback configuration.</p>
        pub fn set_log_configuration(
            mut self,
            input: std::option::Option<crate::model::LogConfiguration>,
        ) -> Self {
            self.log_configuration = input;
            self
        }
        /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
        pub fn manifest_processing_rules(
            mut self,
            input: crate::model::ManifestProcessingRules,
        ) -> Self {
            self.manifest_processing_rules = Some(input);
            self
        }
        /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
        pub fn set_manifest_processing_rules(
            mut self,
            input: std::option::Option<crate::model::ManifestProcessingRules>,
        ) -> Self {
            self.manifest_processing_rules = input;
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
        pub fn personalization_threshold_seconds(mut self, input: i32) -> Self {
            self.personalization_threshold_seconds = Some(input);
            self
        }
        /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
        pub fn set_personalization_threshold_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.personalization_threshold_seconds = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
        pub fn playback_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.playback_configuration_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
        pub fn set_playback_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_configuration_arn = input;
            self
        }
        /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.</p>
        pub fn playback_endpoint_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.playback_endpoint_prefix = Some(input.into());
            self
        }
        /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.</p>
        pub fn set_playback_endpoint_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_endpoint_prefix = input;
            self
        }
        /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
        pub fn session_initialization_endpoint_prefix(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.session_initialization_endpoint_prefix = Some(input.into());
            self
        }
        /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
        pub fn set_session_initialization_endpoint_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.session_initialization_endpoint_prefix = input;
            self
        }
        /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
        pub fn slate_ad_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.slate_ad_url = Some(input.into());
            self
        }
        /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
        pub fn set_slate_ad_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.slate_ad_url = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the playback configuration.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the playback configuration.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
        pub fn transcode_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcode_profile_name = Some(input.into());
            self
        }
        /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
        pub fn set_transcode_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcode_profile_name = input;
            self
        }
        /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
        pub fn video_content_source_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.video_content_source_url = Some(input.into());
            self
        }
        /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
        pub fn set_video_content_source_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.video_content_source_url = input;
            self
        }
        /// Consumes the builder and constructs a [`PutPlaybackConfigurationOutput`](crate::output::PutPlaybackConfigurationOutput)
        pub fn build(self) -> crate::output::PutPlaybackConfigurationOutput {
            crate::output::PutPlaybackConfigurationOutput {
                ad_decision_server_url: self.ad_decision_server_url,
                avail_suppression: self.avail_suppression,
                bumper: self.bumper,
                cdn_configuration: self.cdn_configuration,
                configuration_aliases: self.configuration_aliases,
                dash_configuration: self.dash_configuration,
                hls_configuration: self.hls_configuration,
                live_pre_roll_configuration: self.live_pre_roll_configuration,
                log_configuration: self.log_configuration,
                manifest_processing_rules: self.manifest_processing_rules,
                name: self.name,
                personalization_threshold_seconds: self
                    .personalization_threshold_seconds
                    .unwrap_or_default(),
                playback_configuration_arn: self.playback_configuration_arn,
                playback_endpoint_prefix: self.playback_endpoint_prefix,
                session_initialization_endpoint_prefix: self.session_initialization_endpoint_prefix,
                slate_ad_url: self.slate_ad_url,
                tags: self.tags,
                transcode_profile_name: self.transcode_profile_name,
                video_content_source_url: self.video_content_source_url,
            }
        }
    }
}
impl PutPlaybackConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`PutPlaybackConfigurationOutput`](crate::output::PutPlaybackConfigurationOutput)
    pub fn builder() -> crate::output::put_playback_configuration_output::Builder {
        crate::output::put_playback_configuration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutChannelPolicyOutput {}
impl std::fmt::Debug for PutChannelPolicyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutChannelPolicyOutput");
        formatter.finish()
    }
}
/// See [`PutChannelPolicyOutput`](crate::output::PutChannelPolicyOutput)
pub mod put_channel_policy_output {

    /// A builder for [`PutChannelPolicyOutput`](crate::output::PutChannelPolicyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`PutChannelPolicyOutput`](crate::output::PutChannelPolicyOutput)
        pub fn build(self) -> crate::output::PutChannelPolicyOutput {
            crate::output::PutChannelPolicyOutput {}
        }
    }
}
impl PutChannelPolicyOutput {
    /// Creates a new builder-style object to manufacture [`PutChannelPolicyOutput`](crate::output::PutChannelPolicyOutput)
    pub fn builder() -> crate::output::put_channel_policy_output::Builder {
        crate::output::put_channel_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListVodSourcesOutput {
    /// <p>Lists the VOD sources.</p>
    pub items: std::option::Option<std::vec::Vec<crate::model::VodSource>>,
    /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListVodSourcesOutput {
    /// <p>Lists the VOD sources.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::VodSource]> {
        self.items.as_deref()
    }
    /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListVodSourcesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListVodSourcesOutput");
        formatter.field("items", &self.items);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListVodSourcesOutput`](crate::output::ListVodSourcesOutput)
pub mod list_vod_sources_output {

    /// A builder for [`ListVodSourcesOutput`](crate::output::ListVodSourcesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::VodSource>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Lists the VOD sources.</p>
        pub fn items(mut self, input: crate::model::VodSource) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>Lists the VOD sources.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VodSource>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVodSourcesOutput`](crate::output::ListVodSourcesOutput)
        pub fn build(self) -> crate::output::ListVodSourcesOutput {
            crate::output::ListVodSourcesOutput {
                items: self.items,
                next_token: self.next_token,
            }
        }
    }
}
impl ListVodSourcesOutput {
    /// Creates a new builder-style object to manufacture [`ListVodSourcesOutput`](crate::output::ListVodSourcesOutput)
    pub fn builder() -> crate::output::list_vod_sources_output::Builder {
        crate::output::list_vod_sources_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutput {
    /// <p>A comma-separated list of tag key:value pairs.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ListTagsForResourceOutput {
    /// <p>A comma-separated list of tag key:value pairs.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for ListTagsForResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutput");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
pub mod list_tags_for_resource_output {

    /// A builder for [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A comma-separated list of tag key:value pairs.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A comma-separated list of tag key:value pairs.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
        pub fn build(self) -> crate::output::ListTagsForResourceOutput {
            crate::output::ListTagsForResourceOutput { tags: self.tags }
        }
    }
}
impl ListTagsForResourceOutput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    pub fn builder() -> crate::output::list_tags_for_resource_output::Builder {
        crate::output::list_tags_for_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSourceLocationsOutput {
    /// <p>A list of source locations.</p>
    pub items: std::option::Option<std::vec::Vec<crate::model::SourceLocation>>,
    /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListSourceLocationsOutput {
    /// <p>A list of source locations.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::SourceLocation]> {
        self.items.as_deref()
    }
    /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListSourceLocationsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSourceLocationsOutput");
        formatter.field("items", &self.items);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListSourceLocationsOutput`](crate::output::ListSourceLocationsOutput)
pub mod list_source_locations_output {

    /// A builder for [`ListSourceLocationsOutput`](crate::output::ListSourceLocationsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::SourceLocation>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>A list of source locations.</p>
        pub fn items(mut self, input: crate::model::SourceLocation) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>A list of source locations.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SourceLocation>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSourceLocationsOutput`](crate::output::ListSourceLocationsOutput)
        pub fn build(self) -> crate::output::ListSourceLocationsOutput {
            crate::output::ListSourceLocationsOutput {
                items: self.items,
                next_token: self.next_token,
            }
        }
    }
}
impl ListSourceLocationsOutput {
    /// Creates a new builder-style object to manufacture [`ListSourceLocationsOutput`](crate::output::ListSourceLocationsOutput)
    pub fn builder() -> crate::output::list_source_locations_output::Builder {
        crate::output::list_source_locations_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPrefetchSchedulesOutput {
    /// <p>Lists the prefetch schedules. An empty Items list doesn't mean there aren't more items to fetch, just that that page was empty.</p>
    pub items: std::option::Option<std::vec::Vec<crate::model::PrefetchSchedule>>,
    /// <p>The value that you will use forNextToken in the next ListPrefetchSchedulesRequest request.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListPrefetchSchedulesOutput {
    /// <p>Lists the prefetch schedules. An empty Items list doesn't mean there aren't more items to fetch, just that that page was empty.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::PrefetchSchedule]> {
        self.items.as_deref()
    }
    /// <p>The value that you will use forNextToken in the next ListPrefetchSchedulesRequest request.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListPrefetchSchedulesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPrefetchSchedulesOutput");
        formatter.field("items", &self.items);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListPrefetchSchedulesOutput`](crate::output::ListPrefetchSchedulesOutput)
pub mod list_prefetch_schedules_output {

    /// A builder for [`ListPrefetchSchedulesOutput`](crate::output::ListPrefetchSchedulesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::PrefetchSchedule>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Lists the prefetch schedules. An empty Items list doesn't mean there aren't more items to fetch, just that that page was empty.</p>
        pub fn items(mut self, input: crate::model::PrefetchSchedule) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>Lists the prefetch schedules. An empty Items list doesn't mean there aren't more items to fetch, just that that page was empty.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PrefetchSchedule>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// <p>The value that you will use forNextToken in the next ListPrefetchSchedulesRequest request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The value that you will use forNextToken in the next ListPrefetchSchedulesRequest request.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPrefetchSchedulesOutput`](crate::output::ListPrefetchSchedulesOutput)
        pub fn build(self) -> crate::output::ListPrefetchSchedulesOutput {
            crate::output::ListPrefetchSchedulesOutput {
                items: self.items,
                next_token: self.next_token,
            }
        }
    }
}
impl ListPrefetchSchedulesOutput {
    /// Creates a new builder-style object to manufacture [`ListPrefetchSchedulesOutput`](crate::output::ListPrefetchSchedulesOutput)
    pub fn builder() -> crate::output::list_prefetch_schedules_output::Builder {
        crate::output::list_prefetch_schedules_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPlaybackConfigurationsOutput {
    /// <p>Array of playback configurations. This might be all the available configurations or a subset, depending on the settings that you provide and the total number of configurations stored.</p>
    pub items: std::option::Option<std::vec::Vec<crate::model::PlaybackConfiguration>>,
    /// <p>Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListPlaybackConfigurationsOutput {
    /// <p>Array of playback configurations. This might be all the available configurations or a subset, depending on the settings that you provide and the total number of configurations stored.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::PlaybackConfiguration]> {
        self.items.as_deref()
    }
    /// <p>Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListPlaybackConfigurationsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPlaybackConfigurationsOutput");
        formatter.field("items", &self.items);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListPlaybackConfigurationsOutput`](crate::output::ListPlaybackConfigurationsOutput)
pub mod list_playback_configurations_output {

    /// A builder for [`ListPlaybackConfigurationsOutput`](crate::output::ListPlaybackConfigurationsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::PlaybackConfiguration>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Array of playback configurations. This might be all the available configurations or a subset, depending on the settings that you provide and the total number of configurations stored.</p>
        pub fn items(mut self, input: crate::model::PlaybackConfiguration) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>Array of playback configurations. This might be all the available configurations or a subset, depending on the settings that you provide and the total number of configurations stored.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlaybackConfiguration>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// <p>Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPlaybackConfigurationsOutput`](crate::output::ListPlaybackConfigurationsOutput)
        pub fn build(self) -> crate::output::ListPlaybackConfigurationsOutput {
            crate::output::ListPlaybackConfigurationsOutput {
                items: self.items,
                next_token: self.next_token,
            }
        }
    }
}
impl ListPlaybackConfigurationsOutput {
    /// Creates a new builder-style object to manufacture [`ListPlaybackConfigurationsOutput`](crate::output::ListPlaybackConfigurationsOutput)
    pub fn builder() -> crate::output::list_playback_configurations_output::Builder {
        crate::output::list_playback_configurations_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLiveSourcesOutput {
    /// <p>Lists the live sources.</p>
    pub items: std::option::Option<std::vec::Vec<crate::model::LiveSource>>,
    /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListLiveSourcesOutput {
    /// <p>Lists the live sources.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::LiveSource]> {
        self.items.as_deref()
    }
    /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListLiveSourcesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLiveSourcesOutput");
        formatter.field("items", &self.items);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListLiveSourcesOutput`](crate::output::ListLiveSourcesOutput)
pub mod list_live_sources_output {

    /// A builder for [`ListLiveSourcesOutput`](crate::output::ListLiveSourcesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::LiveSource>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Lists the live sources.</p>
        pub fn items(mut self, input: crate::model::LiveSource) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>Lists the live sources.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LiveSource>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListLiveSourcesOutput`](crate::output::ListLiveSourcesOutput)
        pub fn build(self) -> crate::output::ListLiveSourcesOutput {
            crate::output::ListLiveSourcesOutput {
                items: self.items,
                next_token: self.next_token,
            }
        }
    }
}
impl ListLiveSourcesOutput {
    /// Creates a new builder-style object to manufacture [`ListLiveSourcesOutput`](crate::output::ListLiveSourcesOutput)
    pub fn builder() -> crate::output::list_live_sources_output::Builder {
        crate::output::list_live_sources_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelsOutput {
    /// <p>A list of channels that are associated with this account.</p>
    pub items: std::option::Option<std::vec::Vec<crate::model::Channel>>,
    /// <p>Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListChannelsOutput {
    /// <p>A list of channels that are associated with this account.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::Channel]> {
        self.items.as_deref()
    }
    /// <p>Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListChannelsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelsOutput");
        formatter.field("items", &self.items);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListChannelsOutput`](crate::output::ListChannelsOutput)
pub mod list_channels_output {

    /// A builder for [`ListChannelsOutput`](crate::output::ListChannelsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>A list of channels that are associated with this account.</p>
        pub fn items(mut self, input: crate::model::Channel) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>A list of channels that are associated with this account.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// <p>Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelsOutput`](crate::output::ListChannelsOutput)
        pub fn build(self) -> crate::output::ListChannelsOutput {
            crate::output::ListChannelsOutput {
                items: self.items,
                next_token: self.next_token,
            }
        }
    }
}
impl ListChannelsOutput {
    /// Creates a new builder-style object to manufacture [`ListChannelsOutput`](crate::output::ListChannelsOutput)
    pub fn builder() -> crate::output::list_channels_output::Builder {
        crate::output::list_channels_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAlertsOutput {
    /// <p>A list of alerts that are associated with this resource.</p>
    pub items: std::option::Option<std::vec::Vec<crate::model::Alert>>,
    /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListAlertsOutput {
    /// <p>A list of alerts that are associated with this resource.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::Alert]> {
        self.items.as_deref()
    }
    /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListAlertsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAlertsOutput");
        formatter.field("items", &self.items);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListAlertsOutput`](crate::output::ListAlertsOutput)
pub mod list_alerts_output {

    /// A builder for [`ListAlertsOutput`](crate::output::ListAlertsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::Alert>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>A list of alerts that are associated with this resource.</p>
        pub fn items(mut self, input: crate::model::Alert) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>A list of alerts that are associated with this resource.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Alert>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAlertsOutput`](crate::output::ListAlertsOutput)
        pub fn build(self) -> crate::output::ListAlertsOutput {
            crate::output::ListAlertsOutput {
                items: self.items,
                next_token: self.next_token,
            }
        }
    }
}
impl ListAlertsOutput {
    /// Creates a new builder-style object to manufacture [`ListAlertsOutput`](crate::output::ListAlertsOutput)
    pub fn builder() -> crate::output::list_alerts_output::Builder {
        crate::output::list_alerts_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPrefetchScheduleOutput {
    /// <p>The Amazon Resource Name (ARN) of the prefetch schedule.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a <i>consumption window</i>. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.</p>
    pub consumption: std::option::Option<crate::model::PrefetchConsumption>,
    /// <p>The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the playback configuration to create the prefetch schedule for.</p>
    pub playback_configuration_name: std::option::Option<std::string::String>,
    /// <p>A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).</p>
    pub retrieval: std::option::Option<crate::model::PrefetchRetrieval>,
    /// <p>An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.</p>
    pub stream_id: std::option::Option<std::string::String>,
}
impl GetPrefetchScheduleOutput {
    /// <p>The Amazon Resource Name (ARN) of the prefetch schedule.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a <i>consumption window</i>. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.</p>
    pub fn consumption(&self) -> std::option::Option<&crate::model::PrefetchConsumption> {
        self.consumption.as_ref()
    }
    /// <p>The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the playback configuration to create the prefetch schedule for.</p>
    pub fn playback_configuration_name(&self) -> std::option::Option<&str> {
        self.playback_configuration_name.as_deref()
    }
    /// <p>A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).</p>
    pub fn retrieval(&self) -> std::option::Option<&crate::model::PrefetchRetrieval> {
        self.retrieval.as_ref()
    }
    /// <p>An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
}
impl std::fmt::Debug for GetPrefetchScheduleOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPrefetchScheduleOutput");
        formatter.field("arn", &self.arn);
        formatter.field("consumption", &self.consumption);
        formatter.field("name", &self.name);
        formatter.field(
            "playback_configuration_name",
            &self.playback_configuration_name,
        );
        formatter.field("retrieval", &self.retrieval);
        formatter.field("stream_id", &self.stream_id);
        formatter.finish()
    }
}
/// See [`GetPrefetchScheduleOutput`](crate::output::GetPrefetchScheduleOutput)
pub mod get_prefetch_schedule_output {

    /// A builder for [`GetPrefetchScheduleOutput`](crate::output::GetPrefetchScheduleOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) consumption: std::option::Option<crate::model::PrefetchConsumption>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) playback_configuration_name: std::option::Option<std::string::String>,
        pub(crate) retrieval: std::option::Option<crate::model::PrefetchRetrieval>,
        pub(crate) stream_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the prefetch schedule.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the prefetch schedule.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a <i>consumption window</i>. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.</p>
        pub fn consumption(mut self, input: crate::model::PrefetchConsumption) -> Self {
            self.consumption = Some(input);
            self
        }
        /// <p>Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a <i>consumption window</i>. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.</p>
        pub fn set_consumption(
            mut self,
            input: std::option::Option<crate::model::PrefetchConsumption>,
        ) -> Self {
            self.consumption = input;
            self
        }
        /// <p>The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the playback configuration to create the prefetch schedule for.</p>
        pub fn playback_configuration_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the playback configuration to create the prefetch schedule for.</p>
        pub fn set_playback_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = input;
            self
        }
        /// <p>A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).</p>
        pub fn retrieval(mut self, input: crate::model::PrefetchRetrieval) -> Self {
            self.retrieval = Some(input);
            self
        }
        /// <p>A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).</p>
        pub fn set_retrieval(
            mut self,
            input: std::option::Option<crate::model::PrefetchRetrieval>,
        ) -> Self {
            self.retrieval = input;
            self
        }
        /// <p>An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPrefetchScheduleOutput`](crate::output::GetPrefetchScheduleOutput)
        pub fn build(self) -> crate::output::GetPrefetchScheduleOutput {
            crate::output::GetPrefetchScheduleOutput {
                arn: self.arn,
                consumption: self.consumption,
                name: self.name,
                playback_configuration_name: self.playback_configuration_name,
                retrieval: self.retrieval,
                stream_id: self.stream_id,
            }
        }
    }
}
impl GetPrefetchScheduleOutput {
    /// Creates a new builder-style object to manufacture [`GetPrefetchScheduleOutput`](crate::output::GetPrefetchScheduleOutput)
    pub fn builder() -> crate::output::get_prefetch_schedule_output::Builder {
        crate::output::get_prefetch_schedule_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPlaybackConfigurationOutput {
    /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    pub ad_decision_server_url: std::option::Option<std::string::String>,
    /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
    pub avail_suppression: std::option::Option<crate::model::AvailSuppression>,
    /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
    pub bumper: std::option::Option<crate::model::Bumper>,
    /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
    pub cdn_configuration: std::option::Option<crate::model::CdnConfiguration>,
    /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
    pub configuration_aliases: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    >,
    /// <p>The configuration for DASH content.</p>
    pub dash_configuration: std::option::Option<crate::model::DashConfiguration>,
    /// <p>The configuration for HLS content.</p>
    pub hls_configuration: std::option::Option<crate::model::HlsConfiguration>,
    /// <p>The configuration for pre-roll ad insertion.</p>
    pub live_pre_roll_configuration: std::option::Option<crate::model::LivePreRollConfiguration>,
    /// <p>The Amazon CloudWatch log settings for a playback configuration.</p>
    pub log_configuration: std::option::Option<crate::model::LogConfiguration>,
    /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
    pub manifest_processing_rules: std::option::Option<crate::model::ManifestProcessingRules>,
    /// <p>The identifier for the playback configuration.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
    pub personalization_threshold_seconds: i32,
    /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
    pub playback_configuration_arn: std::option::Option<std::string::String>,
    /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.</p>
    pub playback_endpoint_prefix: std::option::Option<std::string::String>,
    /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
    pub session_initialization_endpoint_prefix: std::option::Option<std::string::String>,
    /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
    pub slate_ad_url: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the playback configuration.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
    pub transcode_profile_name: std::option::Option<std::string::String>,
    /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
    pub video_content_source_url: std::option::Option<std::string::String>,
}
impl GetPlaybackConfigurationOutput {
    /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    pub fn ad_decision_server_url(&self) -> std::option::Option<&str> {
        self.ad_decision_server_url.as_deref()
    }
    /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
    pub fn avail_suppression(&self) -> std::option::Option<&crate::model::AvailSuppression> {
        self.avail_suppression.as_ref()
    }
    /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
    pub fn bumper(&self) -> std::option::Option<&crate::model::Bumper> {
        self.bumper.as_ref()
    }
    /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
    pub fn cdn_configuration(&self) -> std::option::Option<&crate::model::CdnConfiguration> {
        self.cdn_configuration.as_ref()
    }
    /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
    pub fn configuration_aliases(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    > {
        self.configuration_aliases.as_ref()
    }
    /// <p>The configuration for DASH content.</p>
    pub fn dash_configuration(&self) -> std::option::Option<&crate::model::DashConfiguration> {
        self.dash_configuration.as_ref()
    }
    /// <p>The configuration for HLS content.</p>
    pub fn hls_configuration(&self) -> std::option::Option<&crate::model::HlsConfiguration> {
        self.hls_configuration.as_ref()
    }
    /// <p>The configuration for pre-roll ad insertion.</p>
    pub fn live_pre_roll_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LivePreRollConfiguration> {
        self.live_pre_roll_configuration.as_ref()
    }
    /// <p>The Amazon CloudWatch log settings for a playback configuration.</p>
    pub fn log_configuration(&self) -> std::option::Option<&crate::model::LogConfiguration> {
        self.log_configuration.as_ref()
    }
    /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
    pub fn manifest_processing_rules(
        &self,
    ) -> std::option::Option<&crate::model::ManifestProcessingRules> {
        self.manifest_processing_rules.as_ref()
    }
    /// <p>The identifier for the playback configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
    pub fn personalization_threshold_seconds(&self) -> i32 {
        self.personalization_threshold_seconds
    }
    /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
    pub fn playback_configuration_arn(&self) -> std::option::Option<&str> {
        self.playback_configuration_arn.as_deref()
    }
    /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.</p>
    pub fn playback_endpoint_prefix(&self) -> std::option::Option<&str> {
        self.playback_endpoint_prefix.as_deref()
    }
    /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
    pub fn session_initialization_endpoint_prefix(&self) -> std::option::Option<&str> {
        self.session_initialization_endpoint_prefix.as_deref()
    }
    /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
    pub fn slate_ad_url(&self) -> std::option::Option<&str> {
        self.slate_ad_url.as_deref()
    }
    /// <p>The tags assigned to the playback configuration.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
    pub fn transcode_profile_name(&self) -> std::option::Option<&str> {
        self.transcode_profile_name.as_deref()
    }
    /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
    pub fn video_content_source_url(&self) -> std::option::Option<&str> {
        self.video_content_source_url.as_deref()
    }
}
impl std::fmt::Debug for GetPlaybackConfigurationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPlaybackConfigurationOutput");
        formatter.field("ad_decision_server_url", &self.ad_decision_server_url);
        formatter.field("avail_suppression", &self.avail_suppression);
        formatter.field("bumper", &self.bumper);
        formatter.field("cdn_configuration", &self.cdn_configuration);
        formatter.field("configuration_aliases", &self.configuration_aliases);
        formatter.field("dash_configuration", &self.dash_configuration);
        formatter.field("hls_configuration", &self.hls_configuration);
        formatter.field(
            "live_pre_roll_configuration",
            &self.live_pre_roll_configuration,
        );
        formatter.field("log_configuration", &self.log_configuration);
        formatter.field("manifest_processing_rules", &self.manifest_processing_rules);
        formatter.field("name", &self.name);
        formatter.field(
            "personalization_threshold_seconds",
            &self.personalization_threshold_seconds,
        );
        formatter.field(
            "playback_configuration_arn",
            &self.playback_configuration_arn,
        );
        formatter.field("playback_endpoint_prefix", &self.playback_endpoint_prefix);
        formatter.field(
            "session_initialization_endpoint_prefix",
            &self.session_initialization_endpoint_prefix,
        );
        formatter.field("slate_ad_url", &self.slate_ad_url);
        formatter.field("tags", &self.tags);
        formatter.field("transcode_profile_name", &self.transcode_profile_name);
        formatter.field("video_content_source_url", &self.video_content_source_url);
        formatter.finish()
    }
}
/// See [`GetPlaybackConfigurationOutput`](crate::output::GetPlaybackConfigurationOutput)
pub mod get_playback_configuration_output {

    /// A builder for [`GetPlaybackConfigurationOutput`](crate::output::GetPlaybackConfigurationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ad_decision_server_url: std::option::Option<std::string::String>,
        pub(crate) avail_suppression: std::option::Option<crate::model::AvailSuppression>,
        pub(crate) bumper: std::option::Option<crate::model::Bumper>,
        pub(crate) cdn_configuration: std::option::Option<crate::model::CdnConfiguration>,
        pub(crate) configuration_aliases: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        >,
        pub(crate) dash_configuration: std::option::Option<crate::model::DashConfiguration>,
        pub(crate) hls_configuration: std::option::Option<crate::model::HlsConfiguration>,
        pub(crate) live_pre_roll_configuration:
            std::option::Option<crate::model::LivePreRollConfiguration>,
        pub(crate) log_configuration: std::option::Option<crate::model::LogConfiguration>,
        pub(crate) manifest_processing_rules:
            std::option::Option<crate::model::ManifestProcessingRules>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) personalization_threshold_seconds: std::option::Option<i32>,
        pub(crate) playback_configuration_arn: std::option::Option<std::string::String>,
        pub(crate) playback_endpoint_prefix: std::option::Option<std::string::String>,
        pub(crate) session_initialization_endpoint_prefix: std::option::Option<std::string::String>,
        pub(crate) slate_ad_url: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) transcode_profile_name: std::option::Option<std::string::String>,
        pub(crate) video_content_source_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
        pub fn ad_decision_server_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.ad_decision_server_url = Some(input.into());
            self
        }
        /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
        pub fn set_ad_decision_server_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ad_decision_server_url = input;
            self
        }
        /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
        pub fn avail_suppression(mut self, input: crate::model::AvailSuppression) -> Self {
            self.avail_suppression = Some(input);
            self
        }
        /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
        pub fn set_avail_suppression(
            mut self,
            input: std::option::Option<crate::model::AvailSuppression>,
        ) -> Self {
            self.avail_suppression = input;
            self
        }
        /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
        pub fn bumper(mut self, input: crate::model::Bumper) -> Self {
            self.bumper = Some(input);
            self
        }
        /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
        pub fn set_bumper(mut self, input: std::option::Option<crate::model::Bumper>) -> Self {
            self.bumper = input;
            self
        }
        /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
        pub fn cdn_configuration(mut self, input: crate::model::CdnConfiguration) -> Self {
            self.cdn_configuration = Some(input);
            self
        }
        /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
        pub fn set_cdn_configuration(
            mut self,
            input: std::option::Option<crate::model::CdnConfiguration>,
        ) -> Self {
            self.cdn_configuration = input;
            self
        }
        /// Adds a key-value pair to `configuration_aliases`.
        ///
        /// To override the contents of this collection use [`set_configuration_aliases`](Self::set_configuration_aliases).
        ///
        /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
        pub fn configuration_aliases(
            mut self,
            k: impl Into<std::string::String>,
            v: std::collections::HashMap<std::string::String, std::string::String>,
        ) -> Self {
            let mut hash_map = self.configuration_aliases.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.configuration_aliases = Some(hash_map);
            self
        }
        /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
        pub fn set_configuration_aliases(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::collections::HashMap<std::string::String, std::string::String>,
                >,
            >,
        ) -> Self {
            self.configuration_aliases = input;
            self
        }
        /// <p>The configuration for DASH content.</p>
        pub fn dash_configuration(mut self, input: crate::model::DashConfiguration) -> Self {
            self.dash_configuration = Some(input);
            self
        }
        /// <p>The configuration for DASH content.</p>
        pub fn set_dash_configuration(
            mut self,
            input: std::option::Option<crate::model::DashConfiguration>,
        ) -> Self {
            self.dash_configuration = input;
            self
        }
        /// <p>The configuration for HLS content.</p>
        pub fn hls_configuration(mut self, input: crate::model::HlsConfiguration) -> Self {
            self.hls_configuration = Some(input);
            self
        }
        /// <p>The configuration for HLS content.</p>
        pub fn set_hls_configuration(
            mut self,
            input: std::option::Option<crate::model::HlsConfiguration>,
        ) -> Self {
            self.hls_configuration = input;
            self
        }
        /// <p>The configuration for pre-roll ad insertion.</p>
        pub fn live_pre_roll_configuration(
            mut self,
            input: crate::model::LivePreRollConfiguration,
        ) -> Self {
            self.live_pre_roll_configuration = Some(input);
            self
        }
        /// <p>The configuration for pre-roll ad insertion.</p>
        pub fn set_live_pre_roll_configuration(
            mut self,
            input: std::option::Option<crate::model::LivePreRollConfiguration>,
        ) -> Self {
            self.live_pre_roll_configuration = input;
            self
        }
        /// <p>The Amazon CloudWatch log settings for a playback configuration.</p>
        pub fn log_configuration(mut self, input: crate::model::LogConfiguration) -> Self {
            self.log_configuration = Some(input);
            self
        }
        /// <p>The Amazon CloudWatch log settings for a playback configuration.</p>
        pub fn set_log_configuration(
            mut self,
            input: std::option::Option<crate::model::LogConfiguration>,
        ) -> Self {
            self.log_configuration = input;
            self
        }
        /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
        pub fn manifest_processing_rules(
            mut self,
            input: crate::model::ManifestProcessingRules,
        ) -> Self {
            self.manifest_processing_rules = Some(input);
            self
        }
        /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
        pub fn set_manifest_processing_rules(
            mut self,
            input: std::option::Option<crate::model::ManifestProcessingRules>,
        ) -> Self {
            self.manifest_processing_rules = input;
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The identifier for the playback configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
        pub fn personalization_threshold_seconds(mut self, input: i32) -> Self {
            self.personalization_threshold_seconds = Some(input);
            self
        }
        /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
        pub fn set_personalization_threshold_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.personalization_threshold_seconds = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
        pub fn playback_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.playback_configuration_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
        pub fn set_playback_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_configuration_arn = input;
            self
        }
        /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.</p>
        pub fn playback_endpoint_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.playback_endpoint_prefix = Some(input.into());
            self
        }
        /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.</p>
        pub fn set_playback_endpoint_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_endpoint_prefix = input;
            self
        }
        /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
        pub fn session_initialization_endpoint_prefix(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.session_initialization_endpoint_prefix = Some(input.into());
            self
        }
        /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
        pub fn set_session_initialization_endpoint_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.session_initialization_endpoint_prefix = input;
            self
        }
        /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
        pub fn slate_ad_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.slate_ad_url = Some(input.into());
            self
        }
        /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
        pub fn set_slate_ad_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.slate_ad_url = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the playback configuration.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the playback configuration.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
        pub fn transcode_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcode_profile_name = Some(input.into());
            self
        }
        /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
        pub fn set_transcode_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcode_profile_name = input;
            self
        }
        /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
        pub fn video_content_source_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.video_content_source_url = Some(input.into());
            self
        }
        /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
        pub fn set_video_content_source_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.video_content_source_url = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPlaybackConfigurationOutput`](crate::output::GetPlaybackConfigurationOutput)
        pub fn build(self) -> crate::output::GetPlaybackConfigurationOutput {
            crate::output::GetPlaybackConfigurationOutput {
                ad_decision_server_url: self.ad_decision_server_url,
                avail_suppression: self.avail_suppression,
                bumper: self.bumper,
                cdn_configuration: self.cdn_configuration,
                configuration_aliases: self.configuration_aliases,
                dash_configuration: self.dash_configuration,
                hls_configuration: self.hls_configuration,
                live_pre_roll_configuration: self.live_pre_roll_configuration,
                log_configuration: self.log_configuration,
                manifest_processing_rules: self.manifest_processing_rules,
                name: self.name,
                personalization_threshold_seconds: self
                    .personalization_threshold_seconds
                    .unwrap_or_default(),
                playback_configuration_arn: self.playback_configuration_arn,
                playback_endpoint_prefix: self.playback_endpoint_prefix,
                session_initialization_endpoint_prefix: self.session_initialization_endpoint_prefix,
                slate_ad_url: self.slate_ad_url,
                tags: self.tags,
                transcode_profile_name: self.transcode_profile_name,
                video_content_source_url: self.video_content_source_url,
            }
        }
    }
}
impl GetPlaybackConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`GetPlaybackConfigurationOutput`](crate::output::GetPlaybackConfigurationOutput)
    pub fn builder() -> crate::output::get_playback_configuration_output::Builder {
        crate::output::get_playback_configuration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetChannelScheduleOutput {
    /// <p>A list of schedule entries for the channel.</p>
    pub items: std::option::Option<std::vec::Vec<crate::model::ScheduleEntry>>,
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetChannelScheduleOutput {
    /// <p>A list of schedule entries for the channel.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::ScheduleEntry]> {
        self.items.as_deref()
    }
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetChannelScheduleOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetChannelScheduleOutput");
        formatter.field("items", &self.items);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`GetChannelScheduleOutput`](crate::output::GetChannelScheduleOutput)
pub mod get_channel_schedule_output {

    /// A builder for [`GetChannelScheduleOutput`](crate::output::GetChannelScheduleOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::ScheduleEntry>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>A list of schedule entries for the channel.</p>
        pub fn items(mut self, input: crate::model::ScheduleEntry) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>A list of schedule entries for the channel.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ScheduleEntry>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetChannelScheduleOutput`](crate::output::GetChannelScheduleOutput)
        pub fn build(self) -> crate::output::GetChannelScheduleOutput {
            crate::output::GetChannelScheduleOutput {
                items: self.items,
                next_token: self.next_token,
            }
        }
    }
}
impl GetChannelScheduleOutput {
    /// Creates a new builder-style object to manufacture [`GetChannelScheduleOutput`](crate::output::GetChannelScheduleOutput)
    pub fn builder() -> crate::output::get_channel_schedule_output::Builder {
        crate::output::get_channel_schedule_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetChannelPolicyOutput {
    /// <p>The IAM policy for the channel.</p>
    pub policy: std::option::Option<std::string::String>,
}
impl GetChannelPolicyOutput {
    /// <p>The IAM policy for the channel.</p>
    pub fn policy(&self) -> std::option::Option<&str> {
        self.policy.as_deref()
    }
}
impl std::fmt::Debug for GetChannelPolicyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetChannelPolicyOutput");
        formatter.field("policy", &self.policy);
        formatter.finish()
    }
}
/// See [`GetChannelPolicyOutput`](crate::output::GetChannelPolicyOutput)
pub mod get_channel_policy_output {

    /// A builder for [`GetChannelPolicyOutput`](crate::output::GetChannelPolicyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IAM policy for the channel.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        /// <p>The IAM policy for the channel.</p>
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// Consumes the builder and constructs a [`GetChannelPolicyOutput`](crate::output::GetChannelPolicyOutput)
        pub fn build(self) -> crate::output::GetChannelPolicyOutput {
            crate::output::GetChannelPolicyOutput {
                policy: self.policy,
            }
        }
    }
}
impl GetChannelPolicyOutput {
    /// Creates a new builder-style object to manufacture [`GetChannelPolicyOutput`](crate::output::GetChannelPolicyOutput)
    pub fn builder() -> crate::output::get_channel_policy_output::Builder {
        crate::output::get_channel_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeVodSourceOutput {
    /// <p>The ARN of the VOD source.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates when the VOD source was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The HTTP package configurations.</p>
    pub http_package_configurations:
        std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
    /// <p>The last modified time of the VOD source.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the source location associated with the VOD source.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the VOD source.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name of the VOD source.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl DescribeVodSourceOutput {
    /// <p>The ARN of the VOD source.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The timestamp that indicates when the VOD source was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The HTTP package configurations.</p>
    pub fn http_package_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::HttpPackageConfiguration]> {
        self.http_package_configurations.as_deref()
    }
    /// <p>The last modified time of the VOD source.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The name of the source location associated with the VOD source.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags assigned to the VOD source.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The name of the VOD source.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeVodSourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeVodSourceOutput");
        formatter.field("arn", &self.arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "http_package_configurations",
            &self.http_package_configurations,
        );
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("tags", &self.tags);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}
/// See [`DescribeVodSourceOutput`](crate::output::DescribeVodSourceOutput)
pub mod describe_vod_source_output {

    /// A builder for [`DescribeVodSourceOutput`](crate::output::DescribeVodSourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) http_package_configurations:
            std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the VOD source.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the VOD source.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The timestamp that indicates when the VOD source was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the VOD source was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Appends an item to `http_package_configurations`.
        ///
        /// To override the contents of this collection use [`set_http_package_configurations`](Self::set_http_package_configurations).
        ///
        /// <p>The HTTP package configurations.</p>
        pub fn http_package_configurations(
            mut self,
            input: crate::model::HttpPackageConfiguration,
        ) -> Self {
            let mut v = self.http_package_configurations.unwrap_or_default();
            v.push(input);
            self.http_package_configurations = Some(v);
            self
        }
        /// <p>The HTTP package configurations.</p>
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.http_package_configurations = input;
            self
        }
        /// <p>The last modified time of the VOD source.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last modified time of the VOD source.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The name of the source location associated with the VOD source.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location associated with the VOD source.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the VOD source.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the VOD source.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The name of the VOD source.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The name of the VOD source.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeVodSourceOutput`](crate::output::DescribeVodSourceOutput)
        pub fn build(self) -> crate::output::DescribeVodSourceOutput {
            crate::output::DescribeVodSourceOutput {
                arn: self.arn,
                creation_time: self.creation_time,
                http_package_configurations: self.http_package_configurations,
                last_modified_time: self.last_modified_time,
                source_location_name: self.source_location_name,
                tags: self.tags,
                vod_source_name: self.vod_source_name,
            }
        }
    }
}
impl DescribeVodSourceOutput {
    /// Creates a new builder-style object to manufacture [`DescribeVodSourceOutput`](crate::output::DescribeVodSourceOutput)
    pub fn builder() -> crate::output::describe_vod_source_output::Builder {
        crate::output::describe_vod_source_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSourceLocationOutput {
    /// <p>The access configuration for the source location.</p>
    pub access_configuration: std::option::Option<crate::model::AccessConfiguration>,
    /// <p>The ARN of the source location.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates when the source location was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The default segment delivery configuration settings.</p>
    pub default_segment_delivery_configuration:
        std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
    /// <p>The HTTP package configuration settings for the source location.</p>
    pub http_configuration: std::option::Option<crate::model::HttpConfiguration>,
    /// <p>The timestamp that indicates when the source location was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A list of the segment delivery configurations associated with this resource.</p>
    pub segment_delivery_configurations:
        std::option::Option<std::vec::Vec<crate::model::SegmentDeliveryConfiguration>>,
    /// <p>The name of the source location.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the source location.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl DescribeSourceLocationOutput {
    /// <p>The access configuration for the source location.</p>
    pub fn access_configuration(&self) -> std::option::Option<&crate::model::AccessConfiguration> {
        self.access_configuration.as_ref()
    }
    /// <p>The ARN of the source location.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The timestamp that indicates when the source location was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The default segment delivery configuration settings.</p>
    pub fn default_segment_delivery_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DefaultSegmentDeliveryConfiguration> {
        self.default_segment_delivery_configuration.as_ref()
    }
    /// <p>The HTTP package configuration settings for the source location.</p>
    pub fn http_configuration(&self) -> std::option::Option<&crate::model::HttpConfiguration> {
        self.http_configuration.as_ref()
    }
    /// <p>The timestamp that indicates when the source location was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>A list of the segment delivery configurations associated with this resource.</p>
    pub fn segment_delivery_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::SegmentDeliveryConfiguration]> {
        self.segment_delivery_configurations.as_deref()
    }
    /// <p>The name of the source location.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags assigned to the source location.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for DescribeSourceLocationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSourceLocationOutput");
        formatter.field("access_configuration", &self.access_configuration);
        formatter.field("arn", &self.arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "default_segment_delivery_configuration",
            &self.default_segment_delivery_configuration,
        );
        formatter.field("http_configuration", &self.http_configuration);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "segment_delivery_configurations",
            &self.segment_delivery_configurations,
        );
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`DescribeSourceLocationOutput`](crate::output::DescribeSourceLocationOutput)
pub mod describe_source_location_output {

    /// A builder for [`DescribeSourceLocationOutput`](crate::output::DescribeSourceLocationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_configuration: std::option::Option<crate::model::AccessConfiguration>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) default_segment_delivery_configuration:
            std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        pub(crate) http_configuration: std::option::Option<crate::model::HttpConfiguration>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) segment_delivery_configurations:
            std::option::Option<std::vec::Vec<crate::model::SegmentDeliveryConfiguration>>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The access configuration for the source location.</p>
        pub fn access_configuration(mut self, input: crate::model::AccessConfiguration) -> Self {
            self.access_configuration = Some(input);
            self
        }
        /// <p>The access configuration for the source location.</p>
        pub fn set_access_configuration(
            mut self,
            input: std::option::Option<crate::model::AccessConfiguration>,
        ) -> Self {
            self.access_configuration = input;
            self
        }
        /// <p>The ARN of the source location.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the source location.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The timestamp that indicates when the source location was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the source location was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The default segment delivery configuration settings.</p>
        pub fn default_segment_delivery_configuration(
            mut self,
            input: crate::model::DefaultSegmentDeliveryConfiguration,
        ) -> Self {
            self.default_segment_delivery_configuration = Some(input);
            self
        }
        /// <p>The default segment delivery configuration settings.</p>
        pub fn set_default_segment_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        ) -> Self {
            self.default_segment_delivery_configuration = input;
            self
        }
        /// <p>The HTTP package configuration settings for the source location.</p>
        pub fn http_configuration(mut self, input: crate::model::HttpConfiguration) -> Self {
            self.http_configuration = Some(input);
            self
        }
        /// <p>The HTTP package configuration settings for the source location.</p>
        pub fn set_http_configuration(
            mut self,
            input: std::option::Option<crate::model::HttpConfiguration>,
        ) -> Self {
            self.http_configuration = input;
            self
        }
        /// <p>The timestamp that indicates when the source location was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the source location was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Appends an item to `segment_delivery_configurations`.
        ///
        /// To override the contents of this collection use [`set_segment_delivery_configurations`](Self::set_segment_delivery_configurations).
        ///
        /// <p>A list of the segment delivery configurations associated with this resource.</p>
        pub fn segment_delivery_configurations(
            mut self,
            input: crate::model::SegmentDeliveryConfiguration,
        ) -> Self {
            let mut v = self.segment_delivery_configurations.unwrap_or_default();
            v.push(input);
            self.segment_delivery_configurations = Some(v);
            self
        }
        /// <p>A list of the segment delivery configurations associated with this resource.</p>
        pub fn set_segment_delivery_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SegmentDeliveryConfiguration>>,
        ) -> Self {
            self.segment_delivery_configurations = input;
            self
        }
        /// <p>The name of the source location.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the source location.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the source location.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeSourceLocationOutput`](crate::output::DescribeSourceLocationOutput)
        pub fn build(self) -> crate::output::DescribeSourceLocationOutput {
            crate::output::DescribeSourceLocationOutput {
                access_configuration: self.access_configuration,
                arn: self.arn,
                creation_time: self.creation_time,
                default_segment_delivery_configuration: self.default_segment_delivery_configuration,
                http_configuration: self.http_configuration,
                last_modified_time: self.last_modified_time,
                segment_delivery_configurations: self.segment_delivery_configurations,
                source_location_name: self.source_location_name,
                tags: self.tags,
            }
        }
    }
}
impl DescribeSourceLocationOutput {
    /// Creates a new builder-style object to manufacture [`DescribeSourceLocationOutput`](crate::output::DescribeSourceLocationOutput)
    pub fn builder() -> crate::output::describe_source_location_output::Builder {
        crate::output::describe_source_location_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProgramOutput {
    /// <p>The ad break configuration settings.</p>
    pub ad_breaks: std::option::Option<std::vec::Vec<crate::model::AdBreak>>,
    /// <p>The ARN of the program.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the channel that the program belongs to.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The timestamp of when the program was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the LiveSource for this Program.</p>
    pub live_source_name: std::option::Option<std::string::String>,
    /// <p>The name of the program.</p>
    pub program_name: std::option::Option<std::string::String>,
    /// <p>The date and time that the program is scheduled to start in ISO 8601 format and Coordinated Universal Time (UTC). For example, the value 2021-03-27T17:48:16.751Z represents March 27, 2021 at 17:48:16.751 UTC.</p>
    pub scheduled_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The source location name.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The name that's used to refer to a VOD source.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl DescribeProgramOutput {
    /// <p>The ad break configuration settings.</p>
    pub fn ad_breaks(&self) -> std::option::Option<&[crate::model::AdBreak]> {
        self.ad_breaks.as_deref()
    }
    /// <p>The ARN of the program.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the channel that the program belongs to.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>The timestamp of when the program was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The name of the LiveSource for this Program.</p>
    pub fn live_source_name(&self) -> std::option::Option<&str> {
        self.live_source_name.as_deref()
    }
    /// <p>The name of the program.</p>
    pub fn program_name(&self) -> std::option::Option<&str> {
        self.program_name.as_deref()
    }
    /// <p>The date and time that the program is scheduled to start in ISO 8601 format and Coordinated Universal Time (UTC). For example, the value 2021-03-27T17:48:16.751Z represents March 27, 2021 at 17:48:16.751 UTC.</p>
    pub fn scheduled_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.scheduled_start_time.as_ref()
    }
    /// <p>The source location name.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The name that's used to refer to a VOD source.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeProgramOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProgramOutput");
        formatter.field("ad_breaks", &self.ad_breaks);
        formatter.field("arn", &self.arn);
        formatter.field("channel_name", &self.channel_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("live_source_name", &self.live_source_name);
        formatter.field("program_name", &self.program_name);
        formatter.field("scheduled_start_time", &self.scheduled_start_time);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}
/// See [`DescribeProgramOutput`](crate::output::DescribeProgramOutput)
pub mod describe_program_output {

    /// A builder for [`DescribeProgramOutput`](crate::output::DescribeProgramOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ad_breaks: std::option::Option<std::vec::Vec<crate::model::AdBreak>>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) live_source_name: std::option::Option<std::string::String>,
        pub(crate) program_name: std::option::Option<std::string::String>,
        pub(crate) scheduled_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `ad_breaks`.
        ///
        /// To override the contents of this collection use [`set_ad_breaks`](Self::set_ad_breaks).
        ///
        /// <p>The ad break configuration settings.</p>
        pub fn ad_breaks(mut self, input: crate::model::AdBreak) -> Self {
            let mut v = self.ad_breaks.unwrap_or_default();
            v.push(input);
            self.ad_breaks = Some(v);
            self
        }
        /// <p>The ad break configuration settings.</p>
        pub fn set_ad_breaks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AdBreak>>,
        ) -> Self {
            self.ad_breaks = input;
            self
        }
        /// <p>The ARN of the program.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the program.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the channel that the program belongs to.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The name of the channel that the program belongs to.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The timestamp of when the program was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp of when the program was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The name of the LiveSource for this Program.</p>
        pub fn live_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.live_source_name = Some(input.into());
            self
        }
        /// <p>The name of the LiveSource for this Program.</p>
        pub fn set_live_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.live_source_name = input;
            self
        }
        /// <p>The name of the program.</p>
        pub fn program_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.program_name = Some(input.into());
            self
        }
        /// <p>The name of the program.</p>
        pub fn set_program_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.program_name = input;
            self
        }
        /// <p>The date and time that the program is scheduled to start in ISO 8601 format and Coordinated Universal Time (UTC). For example, the value 2021-03-27T17:48:16.751Z represents March 27, 2021 at 17:48:16.751 UTC.</p>
        pub fn scheduled_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.scheduled_start_time = Some(input);
            self
        }
        /// <p>The date and time that the program is scheduled to start in ISO 8601 format and Coordinated Universal Time (UTC). For example, the value 2021-03-27T17:48:16.751Z represents March 27, 2021 at 17:48:16.751 UTC.</p>
        pub fn set_scheduled_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.scheduled_start_time = input;
            self
        }
        /// <p>The source location name.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The source location name.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// <p>The name that's used to refer to a VOD source.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The name that's used to refer to a VOD source.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeProgramOutput`](crate::output::DescribeProgramOutput)
        pub fn build(self) -> crate::output::DescribeProgramOutput {
            crate::output::DescribeProgramOutput {
                ad_breaks: self.ad_breaks,
                arn: self.arn,
                channel_name: self.channel_name,
                creation_time: self.creation_time,
                live_source_name: self.live_source_name,
                program_name: self.program_name,
                scheduled_start_time: self.scheduled_start_time,
                source_location_name: self.source_location_name,
                vod_source_name: self.vod_source_name,
            }
        }
    }
}
impl DescribeProgramOutput {
    /// Creates a new builder-style object to manufacture [`DescribeProgramOutput`](crate::output::DescribeProgramOutput)
    pub fn builder() -> crate::output::describe_program_output::Builder {
        crate::output::describe_program_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLiveSourceOutput {
    /// <p>The ARN of the live source.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates when the live source was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The HTTP package configurations.</p>
    pub http_package_configurations:
        std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
    /// <p>The timestamp that indicates when the live source was modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the live source.</p>
    pub live_source_name: std::option::Option<std::string::String>,
    /// <p>The name of the source location associated with the VOD source.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the live source.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl DescribeLiveSourceOutput {
    /// <p>The ARN of the live source.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The timestamp that indicates when the live source was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The HTTP package configurations.</p>
    pub fn http_package_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::HttpPackageConfiguration]> {
        self.http_package_configurations.as_deref()
    }
    /// <p>The timestamp that indicates when the live source was modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The name of the live source.</p>
    pub fn live_source_name(&self) -> std::option::Option<&str> {
        self.live_source_name.as_deref()
    }
    /// <p>The name of the source location associated with the VOD source.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags assigned to the live source.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for DescribeLiveSourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLiveSourceOutput");
        formatter.field("arn", &self.arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "http_package_configurations",
            &self.http_package_configurations,
        );
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("live_source_name", &self.live_source_name);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`DescribeLiveSourceOutput`](crate::output::DescribeLiveSourceOutput)
pub mod describe_live_source_output {

    /// A builder for [`DescribeLiveSourceOutput`](crate::output::DescribeLiveSourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) http_package_configurations:
            std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) live_source_name: std::option::Option<std::string::String>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ARN of the live source.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the live source.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The timestamp that indicates when the live source was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the live source was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Appends an item to `http_package_configurations`.
        ///
        /// To override the contents of this collection use [`set_http_package_configurations`](Self::set_http_package_configurations).
        ///
        /// <p>The HTTP package configurations.</p>
        pub fn http_package_configurations(
            mut self,
            input: crate::model::HttpPackageConfiguration,
        ) -> Self {
            let mut v = self.http_package_configurations.unwrap_or_default();
            v.push(input);
            self.http_package_configurations = Some(v);
            self
        }
        /// <p>The HTTP package configurations.</p>
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.http_package_configurations = input;
            self
        }
        /// <p>The timestamp that indicates when the live source was modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the live source was modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The name of the live source.</p>
        pub fn live_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.live_source_name = Some(input.into());
            self
        }
        /// <p>The name of the live source.</p>
        pub fn set_live_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.live_source_name = input;
            self
        }
        /// <p>The name of the source location associated with the VOD source.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location associated with the VOD source.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the live source.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the live source.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeLiveSourceOutput`](crate::output::DescribeLiveSourceOutput)
        pub fn build(self) -> crate::output::DescribeLiveSourceOutput {
            crate::output::DescribeLiveSourceOutput {
                arn: self.arn,
                creation_time: self.creation_time,
                http_package_configurations: self.http_package_configurations,
                last_modified_time: self.last_modified_time,
                live_source_name: self.live_source_name,
                source_location_name: self.source_location_name,
                tags: self.tags,
            }
        }
    }
}
impl DescribeLiveSourceOutput {
    /// Creates a new builder-style object to manufacture [`DescribeLiveSourceOutput`](crate::output::DescribeLiveSourceOutput)
    pub fn builder() -> crate::output::describe_live_source_output::Builder {
        crate::output::describe_live_source_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelOutput {
    /// <p>The ARN of the channel.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the channel.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>Indicates whether the channel is in a running state or not.</p>
    pub channel_state: std::option::Option<crate::model::ChannelState>,
    /// <p>The timestamp of when the channel was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Contains information about the slate used to fill gaps between programs in the schedule.</p>
    pub filler_slate: std::option::Option<crate::model::SlateSource>,
    /// <p>The timestamp of when the channel was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The channel's output properties.</p>
    pub outputs: std::option::Option<std::vec::Vec<crate::model::ResponseOutputItem>>,
    /// <p>The channel's playback mode.</p>
    pub playback_mode: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the channel.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The channel's tier.</p>
    pub tier: std::option::Option<std::string::String>,
}
impl DescribeChannelOutput {
    /// <p>The ARN of the channel.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the channel.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>Indicates whether the channel is in a running state or not.</p>
    pub fn channel_state(&self) -> std::option::Option<&crate::model::ChannelState> {
        self.channel_state.as_ref()
    }
    /// <p>The timestamp of when the channel was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Contains information about the slate used to fill gaps between programs in the schedule.</p>
    pub fn filler_slate(&self) -> std::option::Option<&crate::model::SlateSource> {
        self.filler_slate.as_ref()
    }
    /// <p>The timestamp of when the channel was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The channel's output properties.</p>
    pub fn outputs(&self) -> std::option::Option<&[crate::model::ResponseOutputItem]> {
        self.outputs.as_deref()
    }
    /// <p>The channel's playback mode.</p>
    pub fn playback_mode(&self) -> std::option::Option<&str> {
        self.playback_mode.as_deref()
    }
    /// <p>The tags assigned to the channel.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The channel's tier.</p>
    pub fn tier(&self) -> std::option::Option<&str> {
        self.tier.as_deref()
    }
}
impl std::fmt::Debug for DescribeChannelOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelOutput");
        formatter.field("arn", &self.arn);
        formatter.field("channel_name", &self.channel_name);
        formatter.field("channel_state", &self.channel_state);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("filler_slate", &self.filler_slate);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("outputs", &self.outputs);
        formatter.field("playback_mode", &self.playback_mode);
        formatter.field("tags", &self.tags);
        formatter.field("tier", &self.tier);
        formatter.finish()
    }
}
/// See [`DescribeChannelOutput`](crate::output::DescribeChannelOutput)
pub mod describe_channel_output {

    /// A builder for [`DescribeChannelOutput`](crate::output::DescribeChannelOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) channel_state: std::option::Option<crate::model::ChannelState>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) filler_slate: std::option::Option<crate::model::SlateSource>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) outputs: std::option::Option<std::vec::Vec<crate::model::ResponseOutputItem>>,
        pub(crate) playback_mode: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) tier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the channel.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The name of the channel.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>Indicates whether the channel is in a running state or not.</p>
        pub fn channel_state(mut self, input: crate::model::ChannelState) -> Self {
            self.channel_state = Some(input);
            self
        }
        /// <p>Indicates whether the channel is in a running state or not.</p>
        pub fn set_channel_state(
            mut self,
            input: std::option::Option<crate::model::ChannelState>,
        ) -> Self {
            self.channel_state = input;
            self
        }
        /// <p>The timestamp of when the channel was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp of when the channel was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Contains information about the slate used to fill gaps between programs in the schedule.</p>
        pub fn filler_slate(mut self, input: crate::model::SlateSource) -> Self {
            self.filler_slate = Some(input);
            self
        }
        /// <p>Contains information about the slate used to fill gaps between programs in the schedule.</p>
        pub fn set_filler_slate(
            mut self,
            input: std::option::Option<crate::model::SlateSource>,
        ) -> Self {
            self.filler_slate = input;
            self
        }
        /// <p>The timestamp of when the channel was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp of when the channel was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Appends an item to `outputs`.
        ///
        /// To override the contents of this collection use [`set_outputs`](Self::set_outputs).
        ///
        /// <p>The channel's output properties.</p>
        pub fn outputs(mut self, input: crate::model::ResponseOutputItem) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(input);
            self.outputs = Some(v);
            self
        }
        /// <p>The channel's output properties.</p>
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResponseOutputItem>>,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// <p>The channel's playback mode.</p>
        pub fn playback_mode(mut self, input: impl Into<std::string::String>) -> Self {
            self.playback_mode = Some(input.into());
            self
        }
        /// <p>The channel's playback mode.</p>
        pub fn set_playback_mode(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_mode = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the channel.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the channel.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The channel's tier.</p>
        pub fn tier(mut self, input: impl Into<std::string::String>) -> Self {
            self.tier = Some(input.into());
            self
        }
        /// <p>The channel's tier.</p>
        pub fn set_tier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tier = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelOutput`](crate::output::DescribeChannelOutput)
        pub fn build(self) -> crate::output::DescribeChannelOutput {
            crate::output::DescribeChannelOutput {
                arn: self.arn,
                channel_name: self.channel_name,
                channel_state: self.channel_state,
                creation_time: self.creation_time,
                filler_slate: self.filler_slate,
                last_modified_time: self.last_modified_time,
                outputs: self.outputs,
                playback_mode: self.playback_mode,
                tags: self.tags,
                tier: self.tier,
            }
        }
    }
}
impl DescribeChannelOutput {
    /// Creates a new builder-style object to manufacture [`DescribeChannelOutput`](crate::output::DescribeChannelOutput)
    pub fn builder() -> crate::output::describe_channel_output::Builder {
        crate::output::describe_channel_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVodSourceOutput {}
impl std::fmt::Debug for DeleteVodSourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVodSourceOutput");
        formatter.finish()
    }
}
/// See [`DeleteVodSourceOutput`](crate::output::DeleteVodSourceOutput)
pub mod delete_vod_source_output {

    /// A builder for [`DeleteVodSourceOutput`](crate::output::DeleteVodSourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteVodSourceOutput`](crate::output::DeleteVodSourceOutput)
        pub fn build(self) -> crate::output::DeleteVodSourceOutput {
            crate::output::DeleteVodSourceOutput {}
        }
    }
}
impl DeleteVodSourceOutput {
    /// Creates a new builder-style object to manufacture [`DeleteVodSourceOutput`](crate::output::DeleteVodSourceOutput)
    pub fn builder() -> crate::output::delete_vod_source_output::Builder {
        crate::output::delete_vod_source_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSourceLocationOutput {}
impl std::fmt::Debug for DeleteSourceLocationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSourceLocationOutput");
        formatter.finish()
    }
}
/// See [`DeleteSourceLocationOutput`](crate::output::DeleteSourceLocationOutput)
pub mod delete_source_location_output {

    /// A builder for [`DeleteSourceLocationOutput`](crate::output::DeleteSourceLocationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteSourceLocationOutput`](crate::output::DeleteSourceLocationOutput)
        pub fn build(self) -> crate::output::DeleteSourceLocationOutput {
            crate::output::DeleteSourceLocationOutput {}
        }
    }
}
impl DeleteSourceLocationOutput {
    /// Creates a new builder-style object to manufacture [`DeleteSourceLocationOutput`](crate::output::DeleteSourceLocationOutput)
    pub fn builder() -> crate::output::delete_source_location_output::Builder {
        crate::output::delete_source_location_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProgramOutput {}
impl std::fmt::Debug for DeleteProgramOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProgramOutput");
        formatter.finish()
    }
}
/// See [`DeleteProgramOutput`](crate::output::DeleteProgramOutput)
pub mod delete_program_output {

    /// A builder for [`DeleteProgramOutput`](crate::output::DeleteProgramOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteProgramOutput`](crate::output::DeleteProgramOutput)
        pub fn build(self) -> crate::output::DeleteProgramOutput {
            crate::output::DeleteProgramOutput {}
        }
    }
}
impl DeleteProgramOutput {
    /// Creates a new builder-style object to manufacture [`DeleteProgramOutput`](crate::output::DeleteProgramOutput)
    pub fn builder() -> crate::output::delete_program_output::Builder {
        crate::output::delete_program_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePrefetchScheduleOutput {}
impl std::fmt::Debug for DeletePrefetchScheduleOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePrefetchScheduleOutput");
        formatter.finish()
    }
}
/// See [`DeletePrefetchScheduleOutput`](crate::output::DeletePrefetchScheduleOutput)
pub mod delete_prefetch_schedule_output {

    /// A builder for [`DeletePrefetchScheduleOutput`](crate::output::DeletePrefetchScheduleOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeletePrefetchScheduleOutput`](crate::output::DeletePrefetchScheduleOutput)
        pub fn build(self) -> crate::output::DeletePrefetchScheduleOutput {
            crate::output::DeletePrefetchScheduleOutput {}
        }
    }
}
impl DeletePrefetchScheduleOutput {
    /// Creates a new builder-style object to manufacture [`DeletePrefetchScheduleOutput`](crate::output::DeletePrefetchScheduleOutput)
    pub fn builder() -> crate::output::delete_prefetch_schedule_output::Builder {
        crate::output::delete_prefetch_schedule_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePlaybackConfigurationOutput {}
impl std::fmt::Debug for DeletePlaybackConfigurationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePlaybackConfigurationOutput");
        formatter.finish()
    }
}
/// See [`DeletePlaybackConfigurationOutput`](crate::output::DeletePlaybackConfigurationOutput)
pub mod delete_playback_configuration_output {

    /// A builder for [`DeletePlaybackConfigurationOutput`](crate::output::DeletePlaybackConfigurationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeletePlaybackConfigurationOutput`](crate::output::DeletePlaybackConfigurationOutput)
        pub fn build(self) -> crate::output::DeletePlaybackConfigurationOutput {
            crate::output::DeletePlaybackConfigurationOutput {}
        }
    }
}
impl DeletePlaybackConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`DeletePlaybackConfigurationOutput`](crate::output::DeletePlaybackConfigurationOutput)
    pub fn builder() -> crate::output::delete_playback_configuration_output::Builder {
        crate::output::delete_playback_configuration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLiveSourceOutput {}
impl std::fmt::Debug for DeleteLiveSourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLiveSourceOutput");
        formatter.finish()
    }
}
/// See [`DeleteLiveSourceOutput`](crate::output::DeleteLiveSourceOutput)
pub mod delete_live_source_output {

    /// A builder for [`DeleteLiveSourceOutput`](crate::output::DeleteLiveSourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteLiveSourceOutput`](crate::output::DeleteLiveSourceOutput)
        pub fn build(self) -> crate::output::DeleteLiveSourceOutput {
            crate::output::DeleteLiveSourceOutput {}
        }
    }
}
impl DeleteLiveSourceOutput {
    /// Creates a new builder-style object to manufacture [`DeleteLiveSourceOutput`](crate::output::DeleteLiveSourceOutput)
    pub fn builder() -> crate::output::delete_live_source_output::Builder {
        crate::output::delete_live_source_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelPolicyOutput {}
impl std::fmt::Debug for DeleteChannelPolicyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelPolicyOutput");
        formatter.finish()
    }
}
/// See [`DeleteChannelPolicyOutput`](crate::output::DeleteChannelPolicyOutput)
pub mod delete_channel_policy_output {

    /// A builder for [`DeleteChannelPolicyOutput`](crate::output::DeleteChannelPolicyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteChannelPolicyOutput`](crate::output::DeleteChannelPolicyOutput)
        pub fn build(self) -> crate::output::DeleteChannelPolicyOutput {
            crate::output::DeleteChannelPolicyOutput {}
        }
    }
}
impl DeleteChannelPolicyOutput {
    /// Creates a new builder-style object to manufacture [`DeleteChannelPolicyOutput`](crate::output::DeleteChannelPolicyOutput)
    pub fn builder() -> crate::output::delete_channel_policy_output::Builder {
        crate::output::delete_channel_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelOutput {}
impl std::fmt::Debug for DeleteChannelOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelOutput");
        formatter.finish()
    }
}
/// See [`DeleteChannelOutput`](crate::output::DeleteChannelOutput)
pub mod delete_channel_output {

    /// A builder for [`DeleteChannelOutput`](crate::output::DeleteChannelOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteChannelOutput`](crate::output::DeleteChannelOutput)
        pub fn build(self) -> crate::output::DeleteChannelOutput {
            crate::output::DeleteChannelOutput {}
        }
    }
}
impl DeleteChannelOutput {
    /// Creates a new builder-style object to manufacture [`DeleteChannelOutput`](crate::output::DeleteChannelOutput)
    pub fn builder() -> crate::output::delete_channel_output::Builder {
        crate::output::delete_channel_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateVodSourceOutput {
    /// <p>The ARN of the VOD source.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates when the VOD source was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The HTTP package configurations.</p>
    pub http_package_configurations:
        std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
    /// <p>The last modified time of the VOD source.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the source location associated with the VOD source.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the VOD source.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name of the VOD source.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl CreateVodSourceOutput {
    /// <p>The ARN of the VOD source.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The timestamp that indicates when the VOD source was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The HTTP package configurations.</p>
    pub fn http_package_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::HttpPackageConfiguration]> {
        self.http_package_configurations.as_deref()
    }
    /// <p>The last modified time of the VOD source.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The name of the source location associated with the VOD source.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags assigned to the VOD source.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The name of the VOD source.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl std::fmt::Debug for CreateVodSourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateVodSourceOutput");
        formatter.field("arn", &self.arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "http_package_configurations",
            &self.http_package_configurations,
        );
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("tags", &self.tags);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}
/// See [`CreateVodSourceOutput`](crate::output::CreateVodSourceOutput)
pub mod create_vod_source_output {

    /// A builder for [`CreateVodSourceOutput`](crate::output::CreateVodSourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) http_package_configurations:
            std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the VOD source.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the VOD source.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The timestamp that indicates when the VOD source was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the VOD source was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Appends an item to `http_package_configurations`.
        ///
        /// To override the contents of this collection use [`set_http_package_configurations`](Self::set_http_package_configurations).
        ///
        /// <p>The HTTP package configurations.</p>
        pub fn http_package_configurations(
            mut self,
            input: crate::model::HttpPackageConfiguration,
        ) -> Self {
            let mut v = self.http_package_configurations.unwrap_or_default();
            v.push(input);
            self.http_package_configurations = Some(v);
            self
        }
        /// <p>The HTTP package configurations.</p>
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.http_package_configurations = input;
            self
        }
        /// <p>The last modified time of the VOD source.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last modified time of the VOD source.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The name of the source location associated with the VOD source.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location associated with the VOD source.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the VOD source.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the VOD source.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The name of the VOD source.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The name of the VOD source.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVodSourceOutput`](crate::output::CreateVodSourceOutput)
        pub fn build(self) -> crate::output::CreateVodSourceOutput {
            crate::output::CreateVodSourceOutput {
                arn: self.arn,
                creation_time: self.creation_time,
                http_package_configurations: self.http_package_configurations,
                last_modified_time: self.last_modified_time,
                source_location_name: self.source_location_name,
                tags: self.tags,
                vod_source_name: self.vod_source_name,
            }
        }
    }
}
impl CreateVodSourceOutput {
    /// Creates a new builder-style object to manufacture [`CreateVodSourceOutput`](crate::output::CreateVodSourceOutput)
    pub fn builder() -> crate::output::create_vod_source_output::Builder {
        crate::output::create_vod_source_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSourceLocationOutput {
    /// <p>The access configuration for the source location.</p>
    pub access_configuration: std::option::Option<crate::model::AccessConfiguration>,
    /// <p>The ARN of the source location.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates when the source location was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The default segment delivery configuration settings.</p>
    pub default_segment_delivery_configuration:
        std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
    /// <p>The HTTP package configuration settings for the source location.</p>
    pub http_configuration: std::option::Option<crate::model::HttpConfiguration>,
    /// <p>The timestamp that indicates when the source location was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A list of the segment delivery configurations associated with this resource.</p>
    pub segment_delivery_configurations:
        std::option::Option<std::vec::Vec<crate::model::SegmentDeliveryConfiguration>>,
    /// <p>The name of the source location.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the source location.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateSourceLocationOutput {
    /// <p>The access configuration for the source location.</p>
    pub fn access_configuration(&self) -> std::option::Option<&crate::model::AccessConfiguration> {
        self.access_configuration.as_ref()
    }
    /// <p>The ARN of the source location.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The timestamp that indicates when the source location was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The default segment delivery configuration settings.</p>
    pub fn default_segment_delivery_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DefaultSegmentDeliveryConfiguration> {
        self.default_segment_delivery_configuration.as_ref()
    }
    /// <p>The HTTP package configuration settings for the source location.</p>
    pub fn http_configuration(&self) -> std::option::Option<&crate::model::HttpConfiguration> {
        self.http_configuration.as_ref()
    }
    /// <p>The timestamp that indicates when the source location was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>A list of the segment delivery configurations associated with this resource.</p>
    pub fn segment_delivery_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::SegmentDeliveryConfiguration]> {
        self.segment_delivery_configurations.as_deref()
    }
    /// <p>The name of the source location.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags assigned to the source location.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for CreateSourceLocationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSourceLocationOutput");
        formatter.field("access_configuration", &self.access_configuration);
        formatter.field("arn", &self.arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "default_segment_delivery_configuration",
            &self.default_segment_delivery_configuration,
        );
        formatter.field("http_configuration", &self.http_configuration);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "segment_delivery_configurations",
            &self.segment_delivery_configurations,
        );
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`CreateSourceLocationOutput`](crate::output::CreateSourceLocationOutput)
pub mod create_source_location_output {

    /// A builder for [`CreateSourceLocationOutput`](crate::output::CreateSourceLocationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_configuration: std::option::Option<crate::model::AccessConfiguration>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) default_segment_delivery_configuration:
            std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        pub(crate) http_configuration: std::option::Option<crate::model::HttpConfiguration>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) segment_delivery_configurations:
            std::option::Option<std::vec::Vec<crate::model::SegmentDeliveryConfiguration>>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The access configuration for the source location.</p>
        pub fn access_configuration(mut self, input: crate::model::AccessConfiguration) -> Self {
            self.access_configuration = Some(input);
            self
        }
        /// <p>The access configuration for the source location.</p>
        pub fn set_access_configuration(
            mut self,
            input: std::option::Option<crate::model::AccessConfiguration>,
        ) -> Self {
            self.access_configuration = input;
            self
        }
        /// <p>The ARN of the source location.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the source location.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The timestamp that indicates when the source location was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the source location was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The default segment delivery configuration settings.</p>
        pub fn default_segment_delivery_configuration(
            mut self,
            input: crate::model::DefaultSegmentDeliveryConfiguration,
        ) -> Self {
            self.default_segment_delivery_configuration = Some(input);
            self
        }
        /// <p>The default segment delivery configuration settings.</p>
        pub fn set_default_segment_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::DefaultSegmentDeliveryConfiguration>,
        ) -> Self {
            self.default_segment_delivery_configuration = input;
            self
        }
        /// <p>The HTTP package configuration settings for the source location.</p>
        pub fn http_configuration(mut self, input: crate::model::HttpConfiguration) -> Self {
            self.http_configuration = Some(input);
            self
        }
        /// <p>The HTTP package configuration settings for the source location.</p>
        pub fn set_http_configuration(
            mut self,
            input: std::option::Option<crate::model::HttpConfiguration>,
        ) -> Self {
            self.http_configuration = input;
            self
        }
        /// <p>The timestamp that indicates when the source location was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the source location was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Appends an item to `segment_delivery_configurations`.
        ///
        /// To override the contents of this collection use [`set_segment_delivery_configurations`](Self::set_segment_delivery_configurations).
        ///
        /// <p>A list of the segment delivery configurations associated with this resource.</p>
        pub fn segment_delivery_configurations(
            mut self,
            input: crate::model::SegmentDeliveryConfiguration,
        ) -> Self {
            let mut v = self.segment_delivery_configurations.unwrap_or_default();
            v.push(input);
            self.segment_delivery_configurations = Some(v);
            self
        }
        /// <p>A list of the segment delivery configurations associated with this resource.</p>
        pub fn set_segment_delivery_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SegmentDeliveryConfiguration>>,
        ) -> Self {
            self.segment_delivery_configurations = input;
            self
        }
        /// <p>The name of the source location.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the source location.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the source location.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSourceLocationOutput`](crate::output::CreateSourceLocationOutput)
        pub fn build(self) -> crate::output::CreateSourceLocationOutput {
            crate::output::CreateSourceLocationOutput {
                access_configuration: self.access_configuration,
                arn: self.arn,
                creation_time: self.creation_time,
                default_segment_delivery_configuration: self.default_segment_delivery_configuration,
                http_configuration: self.http_configuration,
                last_modified_time: self.last_modified_time,
                segment_delivery_configurations: self.segment_delivery_configurations,
                source_location_name: self.source_location_name,
                tags: self.tags,
            }
        }
    }
}
impl CreateSourceLocationOutput {
    /// Creates a new builder-style object to manufacture [`CreateSourceLocationOutput`](crate::output::CreateSourceLocationOutput)
    pub fn builder() -> crate::output::create_source_location_output::Builder {
        crate::output::create_source_location_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProgramOutput {
    /// <p>The ad break configuration settings.</p>
    pub ad_breaks: std::option::Option<std::vec::Vec<crate::model::AdBreak>>,
    /// <p>The ARN of the program.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the channel that the program belongs to.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The timestamp of when the program was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the LiveSource for this Program.</p>
    pub live_source_name: std::option::Option<std::string::String>,
    /// <p>The name of the program.</p>
    pub program_name: std::option::Option<std::string::String>,
    /// <p>The date and time that the program is scheduled to start in ISO 8601 format and Coordinated Universal Time (UTC). For example, the value 2021-03-27T17:48:16.751Z represents March 27, 2021 at 17:48:16.751 UTC.</p>
    pub scheduled_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The source location name.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The name that's used to refer to a VOD source.</p>
    pub vod_source_name: std::option::Option<std::string::String>,
}
impl CreateProgramOutput {
    /// <p>The ad break configuration settings.</p>
    pub fn ad_breaks(&self) -> std::option::Option<&[crate::model::AdBreak]> {
        self.ad_breaks.as_deref()
    }
    /// <p>The ARN of the program.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the channel that the program belongs to.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>The timestamp of when the program was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The name of the LiveSource for this Program.</p>
    pub fn live_source_name(&self) -> std::option::Option<&str> {
        self.live_source_name.as_deref()
    }
    /// <p>The name of the program.</p>
    pub fn program_name(&self) -> std::option::Option<&str> {
        self.program_name.as_deref()
    }
    /// <p>The date and time that the program is scheduled to start in ISO 8601 format and Coordinated Universal Time (UTC). For example, the value 2021-03-27T17:48:16.751Z represents March 27, 2021 at 17:48:16.751 UTC.</p>
    pub fn scheduled_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.scheduled_start_time.as_ref()
    }
    /// <p>The source location name.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The name that's used to refer to a VOD source.</p>
    pub fn vod_source_name(&self) -> std::option::Option<&str> {
        self.vod_source_name.as_deref()
    }
}
impl std::fmt::Debug for CreateProgramOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProgramOutput");
        formatter.field("ad_breaks", &self.ad_breaks);
        formatter.field("arn", &self.arn);
        formatter.field("channel_name", &self.channel_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("live_source_name", &self.live_source_name);
        formatter.field("program_name", &self.program_name);
        formatter.field("scheduled_start_time", &self.scheduled_start_time);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("vod_source_name", &self.vod_source_name);
        formatter.finish()
    }
}
/// See [`CreateProgramOutput`](crate::output::CreateProgramOutput)
pub mod create_program_output {

    /// A builder for [`CreateProgramOutput`](crate::output::CreateProgramOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ad_breaks: std::option::Option<std::vec::Vec<crate::model::AdBreak>>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) live_source_name: std::option::Option<std::string::String>,
        pub(crate) program_name: std::option::Option<std::string::String>,
        pub(crate) scheduled_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) vod_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `ad_breaks`.
        ///
        /// To override the contents of this collection use [`set_ad_breaks`](Self::set_ad_breaks).
        ///
        /// <p>The ad break configuration settings.</p>
        pub fn ad_breaks(mut self, input: crate::model::AdBreak) -> Self {
            let mut v = self.ad_breaks.unwrap_or_default();
            v.push(input);
            self.ad_breaks = Some(v);
            self
        }
        /// <p>The ad break configuration settings.</p>
        pub fn set_ad_breaks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AdBreak>>,
        ) -> Self {
            self.ad_breaks = input;
            self
        }
        /// <p>The ARN of the program.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the program.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the channel that the program belongs to.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The name of the channel that the program belongs to.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The timestamp of when the program was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp of when the program was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The name of the LiveSource for this Program.</p>
        pub fn live_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.live_source_name = Some(input.into());
            self
        }
        /// <p>The name of the LiveSource for this Program.</p>
        pub fn set_live_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.live_source_name = input;
            self
        }
        /// <p>The name of the program.</p>
        pub fn program_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.program_name = Some(input.into());
            self
        }
        /// <p>The name of the program.</p>
        pub fn set_program_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.program_name = input;
            self
        }
        /// <p>The date and time that the program is scheduled to start in ISO 8601 format and Coordinated Universal Time (UTC). For example, the value 2021-03-27T17:48:16.751Z represents March 27, 2021 at 17:48:16.751 UTC.</p>
        pub fn scheduled_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.scheduled_start_time = Some(input);
            self
        }
        /// <p>The date and time that the program is scheduled to start in ISO 8601 format and Coordinated Universal Time (UTC). For example, the value 2021-03-27T17:48:16.751Z represents March 27, 2021 at 17:48:16.751 UTC.</p>
        pub fn set_scheduled_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.scheduled_start_time = input;
            self
        }
        /// <p>The source location name.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The source location name.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// <p>The name that's used to refer to a VOD source.</p>
        pub fn vod_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vod_source_name = Some(input.into());
            self
        }
        /// <p>The name that's used to refer to a VOD source.</p>
        pub fn set_vod_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vod_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateProgramOutput`](crate::output::CreateProgramOutput)
        pub fn build(self) -> crate::output::CreateProgramOutput {
            crate::output::CreateProgramOutput {
                ad_breaks: self.ad_breaks,
                arn: self.arn,
                channel_name: self.channel_name,
                creation_time: self.creation_time,
                live_source_name: self.live_source_name,
                program_name: self.program_name,
                scheduled_start_time: self.scheduled_start_time,
                source_location_name: self.source_location_name,
                vod_source_name: self.vod_source_name,
            }
        }
    }
}
impl CreateProgramOutput {
    /// Creates a new builder-style object to manufacture [`CreateProgramOutput`](crate::output::CreateProgramOutput)
    pub fn builder() -> crate::output::create_program_output::Builder {
        crate::output::create_program_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePrefetchScheduleOutput {
    /// <p>The Amazon Resource Name (ARN) of the prefetch schedule.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a <i>consumption window</i>. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.</p>
    pub consumption: std::option::Option<crate::model::PrefetchConsumption>,
    /// <p>The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the playback configuration to create the prefetch schedule for.</p>
    pub playback_configuration_name: std::option::Option<std::string::String>,
    /// <p>A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).</p>
    pub retrieval: std::option::Option<crate::model::PrefetchRetrieval>,
    /// <p>An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.</p>
    pub stream_id: std::option::Option<std::string::String>,
}
impl CreatePrefetchScheduleOutput {
    /// <p>The Amazon Resource Name (ARN) of the prefetch schedule.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a <i>consumption window</i>. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.</p>
    pub fn consumption(&self) -> std::option::Option<&crate::model::PrefetchConsumption> {
        self.consumption.as_ref()
    }
    /// <p>The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the playback configuration to create the prefetch schedule for.</p>
    pub fn playback_configuration_name(&self) -> std::option::Option<&str> {
        self.playback_configuration_name.as_deref()
    }
    /// <p>A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).</p>
    pub fn retrieval(&self) -> std::option::Option<&crate::model::PrefetchRetrieval> {
        self.retrieval.as_ref()
    }
    /// <p>An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
}
impl std::fmt::Debug for CreatePrefetchScheduleOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePrefetchScheduleOutput");
        formatter.field("arn", &self.arn);
        formatter.field("consumption", &self.consumption);
        formatter.field("name", &self.name);
        formatter.field(
            "playback_configuration_name",
            &self.playback_configuration_name,
        );
        formatter.field("retrieval", &self.retrieval);
        formatter.field("stream_id", &self.stream_id);
        formatter.finish()
    }
}
/// See [`CreatePrefetchScheduleOutput`](crate::output::CreatePrefetchScheduleOutput)
pub mod create_prefetch_schedule_output {

    /// A builder for [`CreatePrefetchScheduleOutput`](crate::output::CreatePrefetchScheduleOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) consumption: std::option::Option<crate::model::PrefetchConsumption>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) playback_configuration_name: std::option::Option<std::string::String>,
        pub(crate) retrieval: std::option::Option<crate::model::PrefetchRetrieval>,
        pub(crate) stream_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the prefetch schedule.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the prefetch schedule.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a <i>consumption window</i>. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.</p>
        pub fn consumption(mut self, input: crate::model::PrefetchConsumption) -> Self {
            self.consumption = Some(input);
            self
        }
        /// <p>Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a <i>consumption window</i>. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.</p>
        pub fn set_consumption(
            mut self,
            input: std::option::Option<crate::model::PrefetchConsumption>,
        ) -> Self {
            self.consumption = input;
            self
        }
        /// <p>The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the playback configuration to create the prefetch schedule for.</p>
        pub fn playback_configuration_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the playback configuration to create the prefetch schedule for.</p>
        pub fn set_playback_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = input;
            self
        }
        /// <p>A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).</p>
        pub fn retrieval(mut self, input: crate::model::PrefetchRetrieval) -> Self {
            self.retrieval = Some(input);
            self
        }
        /// <p>A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).</p>
        pub fn set_retrieval(
            mut self,
            input: std::option::Option<crate::model::PrefetchRetrieval>,
        ) -> Self {
            self.retrieval = input;
            self
        }
        /// <p>An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CreatePrefetchScheduleOutput`](crate::output::CreatePrefetchScheduleOutput)
        pub fn build(self) -> crate::output::CreatePrefetchScheduleOutput {
            crate::output::CreatePrefetchScheduleOutput {
                arn: self.arn,
                consumption: self.consumption,
                name: self.name,
                playback_configuration_name: self.playback_configuration_name,
                retrieval: self.retrieval,
                stream_id: self.stream_id,
            }
        }
    }
}
impl CreatePrefetchScheduleOutput {
    /// Creates a new builder-style object to manufacture [`CreatePrefetchScheduleOutput`](crate::output::CreatePrefetchScheduleOutput)
    pub fn builder() -> crate::output::create_prefetch_schedule_output::Builder {
        crate::output::create_prefetch_schedule_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLiveSourceOutput {
    /// <p>The ARN of the live source.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates when the live source was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The HTTP package configurations.</p>
    pub http_package_configurations:
        std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
    /// <p>The timestamp that indicates when the live source was modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the live source.</p>
    pub live_source_name: std::option::Option<std::string::String>,
    /// <p>The name of the source location associated with the VOD source.</p>
    pub source_location_name: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the live source.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateLiveSourceOutput {
    /// <p>The ARN of the live source.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The timestamp that indicates when the live source was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The HTTP package configurations.</p>
    pub fn http_package_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::HttpPackageConfiguration]> {
        self.http_package_configurations.as_deref()
    }
    /// <p>The timestamp that indicates when the live source was modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The name of the live source.</p>
    pub fn live_source_name(&self) -> std::option::Option<&str> {
        self.live_source_name.as_deref()
    }
    /// <p>The name of the source location associated with the VOD source.</p>
    pub fn source_location_name(&self) -> std::option::Option<&str> {
        self.source_location_name.as_deref()
    }
    /// <p>The tags assigned to the live source.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for CreateLiveSourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLiveSourceOutput");
        formatter.field("arn", &self.arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "http_package_configurations",
            &self.http_package_configurations,
        );
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("live_source_name", &self.live_source_name);
        formatter.field("source_location_name", &self.source_location_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`CreateLiveSourceOutput`](crate::output::CreateLiveSourceOutput)
pub mod create_live_source_output {

    /// A builder for [`CreateLiveSourceOutput`](crate::output::CreateLiveSourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) http_package_configurations:
            std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) live_source_name: std::option::Option<std::string::String>,
        pub(crate) source_location_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ARN of the live source.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the live source.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The timestamp that indicates when the live source was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the live source was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Appends an item to `http_package_configurations`.
        ///
        /// To override the contents of this collection use [`set_http_package_configurations`](Self::set_http_package_configurations).
        ///
        /// <p>The HTTP package configurations.</p>
        pub fn http_package_configurations(
            mut self,
            input: crate::model::HttpPackageConfiguration,
        ) -> Self {
            let mut v = self.http_package_configurations.unwrap_or_default();
            v.push(input);
            self.http_package_configurations = Some(v);
            self
        }
        /// <p>The HTTP package configurations.</p>
        pub fn set_http_package_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpPackageConfiguration>>,
        ) -> Self {
            self.http_package_configurations = input;
            self
        }
        /// <p>The timestamp that indicates when the live source was modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the live source was modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The name of the live source.</p>
        pub fn live_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.live_source_name = Some(input.into());
            self
        }
        /// <p>The name of the live source.</p>
        pub fn set_live_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.live_source_name = input;
            self
        }
        /// <p>The name of the source location associated with the VOD source.</p>
        pub fn source_location_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_location_name = Some(input.into());
            self
        }
        /// <p>The name of the source location associated with the VOD source.</p>
        pub fn set_source_location_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_location_name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the live source.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the live source.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateLiveSourceOutput`](crate::output::CreateLiveSourceOutput)
        pub fn build(self) -> crate::output::CreateLiveSourceOutput {
            crate::output::CreateLiveSourceOutput {
                arn: self.arn,
                creation_time: self.creation_time,
                http_package_configurations: self.http_package_configurations,
                last_modified_time: self.last_modified_time,
                live_source_name: self.live_source_name,
                source_location_name: self.source_location_name,
                tags: self.tags,
            }
        }
    }
}
impl CreateLiveSourceOutput {
    /// Creates a new builder-style object to manufacture [`CreateLiveSourceOutput`](crate::output::CreateLiveSourceOutput)
    pub fn builder() -> crate::output::create_live_source_output::Builder {
        crate::output::create_live_source_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelOutput {
    /// <p>The ARN of the channel.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the channel.</p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>Indicates whether the channel is in a running state or not.</p>
    pub channel_state: std::option::Option<crate::model::ChannelState>,
    /// <p>The timestamp of when the channel was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Contains information about the slate used to fill gaps between programs in the schedule.</p>
    pub filler_slate: std::option::Option<crate::model::SlateSource>,
    /// <p>The timestamp of when the channel was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The channel's output properties.</p>
    pub outputs: std::option::Option<std::vec::Vec<crate::model::ResponseOutputItem>>,
    /// <p>The channel's playback mode.</p>
    pub playback_mode: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the channel.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The channel's tier.</p>
    pub tier: std::option::Option<std::string::String>,
}
impl CreateChannelOutput {
    /// <p>The ARN of the channel.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the channel.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>Indicates whether the channel is in a running state or not.</p>
    pub fn channel_state(&self) -> std::option::Option<&crate::model::ChannelState> {
        self.channel_state.as_ref()
    }
    /// <p>The timestamp of when the channel was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Contains information about the slate used to fill gaps between programs in the schedule.</p>
    pub fn filler_slate(&self) -> std::option::Option<&crate::model::SlateSource> {
        self.filler_slate.as_ref()
    }
    /// <p>The timestamp of when the channel was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The channel's output properties.</p>
    pub fn outputs(&self) -> std::option::Option<&[crate::model::ResponseOutputItem]> {
        self.outputs.as_deref()
    }
    /// <p>The channel's playback mode.</p>
    pub fn playback_mode(&self) -> std::option::Option<&str> {
        self.playback_mode.as_deref()
    }
    /// <p>The tags assigned to the channel.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The channel's tier.</p>
    pub fn tier(&self) -> std::option::Option<&str> {
        self.tier.as_deref()
    }
}
impl std::fmt::Debug for CreateChannelOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelOutput");
        formatter.field("arn", &self.arn);
        formatter.field("channel_name", &self.channel_name);
        formatter.field("channel_state", &self.channel_state);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("filler_slate", &self.filler_slate);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("outputs", &self.outputs);
        formatter.field("playback_mode", &self.playback_mode);
        formatter.field("tags", &self.tags);
        formatter.field("tier", &self.tier);
        formatter.finish()
    }
}
/// See [`CreateChannelOutput`](crate::output::CreateChannelOutput)
pub mod create_channel_output {

    /// A builder for [`CreateChannelOutput`](crate::output::CreateChannelOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) channel_state: std::option::Option<crate::model::ChannelState>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) filler_slate: std::option::Option<crate::model::SlateSource>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) outputs: std::option::Option<std::vec::Vec<crate::model::ResponseOutputItem>>,
        pub(crate) playback_mode: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) tier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the channel.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The name of the channel.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>Indicates whether the channel is in a running state or not.</p>
        pub fn channel_state(mut self, input: crate::model::ChannelState) -> Self {
            self.channel_state = Some(input);
            self
        }
        /// <p>Indicates whether the channel is in a running state or not.</p>
        pub fn set_channel_state(
            mut self,
            input: std::option::Option<crate::model::ChannelState>,
        ) -> Self {
            self.channel_state = input;
            self
        }
        /// <p>The timestamp of when the channel was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp of when the channel was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Contains information about the slate used to fill gaps between programs in the schedule.</p>
        pub fn filler_slate(mut self, input: crate::model::SlateSource) -> Self {
            self.filler_slate = Some(input);
            self
        }
        /// <p>Contains information about the slate used to fill gaps between programs in the schedule.</p>
        pub fn set_filler_slate(
            mut self,
            input: std::option::Option<crate::model::SlateSource>,
        ) -> Self {
            self.filler_slate = input;
            self
        }
        /// <p>The timestamp of when the channel was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The timestamp of when the channel was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Appends an item to `outputs`.
        ///
        /// To override the contents of this collection use [`set_outputs`](Self::set_outputs).
        ///
        /// <p>The channel's output properties.</p>
        pub fn outputs(mut self, input: crate::model::ResponseOutputItem) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(input);
            self.outputs = Some(v);
            self
        }
        /// <p>The channel's output properties.</p>
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResponseOutputItem>>,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// <p>The channel's playback mode.</p>
        pub fn playback_mode(mut self, input: impl Into<std::string::String>) -> Self {
            self.playback_mode = Some(input.into());
            self
        }
        /// <p>The channel's playback mode.</p>
        pub fn set_playback_mode(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_mode = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the channel.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the channel.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The channel's tier.</p>
        pub fn tier(mut self, input: impl Into<std::string::String>) -> Self {
            self.tier = Some(input.into());
            self
        }
        /// <p>The channel's tier.</p>
        pub fn set_tier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tier = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateChannelOutput`](crate::output::CreateChannelOutput)
        pub fn build(self) -> crate::output::CreateChannelOutput {
            crate::output::CreateChannelOutput {
                arn: self.arn,
                channel_name: self.channel_name,
                channel_state: self.channel_state,
                creation_time: self.creation_time,
                filler_slate: self.filler_slate,
                last_modified_time: self.last_modified_time,
                outputs: self.outputs,
                playback_mode: self.playback_mode,
                tags: self.tags,
                tier: self.tier,
            }
        }
    }
}
impl CreateChannelOutput {
    /// Creates a new builder-style object to manufacture [`CreateChannelOutput`](crate::output::CreateChannelOutput)
    pub fn builder() -> crate::output::create_channel_output::Builder {
        crate::output::create_channel_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConfigureLogsForPlaybackConfigurationOutput {
    /// <p>The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account.</p>
    pub percent_enabled: i32,
    /// <p>The name of the playback configuration.</p>
    pub playback_configuration_name: std::option::Option<std::string::String>,
}
impl ConfigureLogsForPlaybackConfigurationOutput {
    /// <p>The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account.</p>
    pub fn percent_enabled(&self) -> i32 {
        self.percent_enabled
    }
    /// <p>The name of the playback configuration.</p>
    pub fn playback_configuration_name(&self) -> std::option::Option<&str> {
        self.playback_configuration_name.as_deref()
    }
}
impl std::fmt::Debug for ConfigureLogsForPlaybackConfigurationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConfigureLogsForPlaybackConfigurationOutput");
        formatter.field("percent_enabled", &self.percent_enabled);
        formatter.field(
            "playback_configuration_name",
            &self.playback_configuration_name,
        );
        formatter.finish()
    }
}
/// See [`ConfigureLogsForPlaybackConfigurationOutput`](crate::output::ConfigureLogsForPlaybackConfigurationOutput)
pub mod configure_logs_for_playback_configuration_output {

    /// A builder for [`ConfigureLogsForPlaybackConfigurationOutput`](crate::output::ConfigureLogsForPlaybackConfigurationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) percent_enabled: std::option::Option<i32>,
        pub(crate) playback_configuration_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account.</p>
        pub fn percent_enabled(mut self, input: i32) -> Self {
            self.percent_enabled = Some(input);
            self
        }
        /// <p>The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account.</p>
        pub fn set_percent_enabled(mut self, input: std::option::Option<i32>) -> Self {
            self.percent_enabled = input;
            self
        }
        /// <p>The name of the playback configuration.</p>
        pub fn playback_configuration_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the playback configuration.</p>
        pub fn set_playback_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.playback_configuration_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigureLogsForPlaybackConfigurationOutput`](crate::output::ConfigureLogsForPlaybackConfigurationOutput)
        pub fn build(self) -> crate::output::ConfigureLogsForPlaybackConfigurationOutput {
            crate::output::ConfigureLogsForPlaybackConfigurationOutput {
                percent_enabled: self.percent_enabled.unwrap_or_default(),
                playback_configuration_name: self.playback_configuration_name,
            }
        }
    }
}
impl ConfigureLogsForPlaybackConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`ConfigureLogsForPlaybackConfigurationOutput`](crate::output::ConfigureLogsForPlaybackConfigurationOutput)
    pub fn builder() -> crate::output::configure_logs_for_playback_configuration_output::Builder {
        crate::output::configure_logs_for_playback_configuration_output::Builder::default()
    }
}
