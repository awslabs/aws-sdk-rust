// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Cancels a cluster job. You can only cancel a cluster job while it's in the
/// <code>AwaitingQuorum</code> status. You'll have at least an hour after creating a cluster
/// job to cancel it.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelCluster {
    _private: (),
}
impl CancelCluster {
    /// Creates a new builder-style object to manufacture [`CancelClusterInput`](crate::input::CancelClusterInput)
    pub fn builder() -> crate::input::cancel_cluster_input::Builder {
        crate::input::cancel_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelCluster {
    type Output =
        std::result::Result<crate::output::CancelClusterOutput, crate::error::CancelClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_cancel_cluster_error(response)
        } else {
            crate::operation_ser::parse_cancel_cluster_response(response)
        }
    }
}

/// <p>Cancels the specified job. You can only cancel a job before its <code>JobState</code>
/// value changes to <code>PreparingAppliance</code>. Requesting the <code>ListJobs</code> or
/// <code>DescribeJob</code> action returns a job's <code>JobState</code> as part of the
/// response element data returned.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelJob {
    _private: (),
}
impl CancelJob {
    /// Creates a new builder-style object to manufacture [`CancelJobInput`](crate::input::CancelJobInput)
    pub fn builder() -> crate::input::cancel_job_input::Builder {
        crate::input::cancel_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelJob {
    type Output = std::result::Result<crate::output::CancelJobOutput, crate::error::CancelJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_cancel_job_error(response)
        } else {
            crate::operation_ser::parse_cancel_job_response(response)
        }
    }
}

/// <p>Creates an address for a Snow device to be shipped to. In most regions,
/// addresses are validated at the time of creation. The address you provide must be located
/// within the serviceable area of your region. If the address is invalid or unsupported, then an
/// exception is thrown.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateAddress {
    _private: (),
}
impl CreateAddress {
    /// Creates a new builder-style object to manufacture [`CreateAddressInput`](crate::input::CreateAddressInput)
    pub fn builder() -> crate::input::create_address_input::Builder {
        crate::input::create_address_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateAddress {
    type Output =
        std::result::Result<crate::output::CreateAddressOutput, crate::error::CreateAddressError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_address_error(response)
        } else {
            crate::operation_ser::parse_create_address_response(response)
        }
    }
}

/// <p>Creates an empty cluster. Each cluster supports five nodes. You use the <a>CreateJob</a> action separately to create the jobs for each of these nodes. The
/// cluster does not ship until these five node jobs have been created.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCluster {
    _private: (),
}
impl CreateCluster {
    /// Creates a new builder-style object to manufacture [`CreateClusterInput`](crate::input::CreateClusterInput)
    pub fn builder() -> crate::input::create_cluster_input::Builder {
        crate::input::create_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCluster {
    type Output =
        std::result::Result<crate::output::CreateClusterOutput, crate::error::CreateClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_cluster_error(response)
        } else {
            crate::operation_ser::parse_create_cluster_response(response)
        }
    }
}

/// <p>Creates a job to import or export data between Amazon S3 and your on-premises data
/// center. Your AWS account must have the right trust policies and permissions in place to create
/// a job for a Snow device. If you're creating a job for a node in a cluster, you only need to provide
/// the <code>clusterId</code> value; the other job attributes are inherited from the cluster.
/// </p>
/// <note>
/// <p>Only the Snowball; Edge device type is supported when ordering clustered jobs.</p>
/// <p>The device capacity is optional.</p>
/// <p>Availability of device types differ by AWS Region. For more information about Region
/// availability, see <a href="https://aws.amazon.com/about-aws/global-infrastructure/regional-product-services/?p=ngi&loc=4">AWS Regional Services</a>.</p>
/// </note>
/// <p></p>
/// <p class="title">
/// <b>AWS Snow Family device types and their capacities.</b>
/// </p>
/// <ul>
/// <li>
/// <p>Snow Family device type: <b>SNC1_SSD</b>
/// </p>
/// <ul>
/// <li>
/// <p>Capacity: T14</p>
/// </li>
/// <li>
/// <p>Description: Snowcone </p>
/// </li>
/// </ul>
/// <p></p>
/// </li>
/// <li>
/// <p>Snow Family device type: <b>SNC1_HDD</b>
/// </p>
/// <ul>
/// <li>
/// <p>Capacity: T8</p>
/// </li>
/// <li>
/// <p>Description: Snowcone </p>
/// </li>
/// </ul>
/// <p></p>
/// </li>
/// <li>
/// <p>Device type: <b>EDGE_S</b>
/// </p>
/// <ul>
/// <li>
/// <p>Capacity: T98</p>
/// </li>
/// <li>
/// <p>Description: Snowball Edge Storage Optimized for data transfer only </p>
/// </li>
/// </ul>
/// <p></p>
/// </li>
/// <li>
/// <p>Device type: <b>EDGE_CG</b>
/// </p>
/// <ul>
/// <li>
/// <p>Capacity: T42</p>
/// </li>
/// <li>
/// <p>Description: Snowball Edge Compute Optimized with GPU</p>
/// </li>
/// </ul>
/// <p></p>
/// </li>
/// <li>
/// <p>Device type: <b>EDGE_C</b>
/// </p>
/// <ul>
/// <li>
/// <p>Capacity: T42</p>
/// </li>
/// <li>
/// <p>Description: Snowball Edge Compute Optimized without GPU</p>
/// </li>
/// </ul>
/// <p></p>
/// </li>
/// <li>
/// <p>Device type: <b>EDGE</b>
/// </p>
/// <ul>
/// <li>
/// <p>Capacity: T100</p>
/// </li>
/// <li>
/// <p>Description: Snowball Edge Storage Optimized with EC2 Compute</p>
/// </li>
/// </ul>
/// <p></p>
/// </li>
/// <li>
/// <p>Device type: <b>STANDARD</b>
/// </p>
/// <ul>
/// <li>
/// <p>Capacity: T50</p>
/// </li>
/// <li>
/// <p>Description: Original Snowball device</p>
/// <note>
/// <p>This device is only available in the Ningxia, Beijing, and Singapore AWS Regions. </p>
/// </note>
/// </li>
/// </ul>
/// <p></p>
/// </li>
/// <li>
/// <p>Device type: <b>STANDARD</b>
/// </p>
/// <ul>
/// <li>
/// <p>Capacity: T80</p>
/// </li>
/// <li>
/// <p>Description: Original Snowball device</p>
/// <note>
/// <p>This device is only available in the Ningxia, Beijing, and Singapore AWS Regions. </p>
/// </note>
/// </li>
/// </ul>
/// <p></p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateJob {
    _private: (),
}
impl CreateJob {
    /// Creates a new builder-style object to manufacture [`CreateJobInput`](crate::input::CreateJobInput)
    pub fn builder() -> crate::input::create_job_input::Builder {
        crate::input::create_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateJob {
    type Output = std::result::Result<crate::output::CreateJobOutput, crate::error::CreateJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_job_error(response)
        } else {
            crate::operation_ser::parse_create_job_response(response)
        }
    }
}

/// <p>Creates a job with the long-term usage option for a device. The long-term usage is a
/// 1-year or 3-year long-term pricing type for the device. You are billed upfront, and AWS
/// provides discounts for long-term pricing.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLongTermPricing {
    _private: (),
}
impl CreateLongTermPricing {
    /// Creates a new builder-style object to manufacture [`CreateLongTermPricingInput`](crate::input::CreateLongTermPricingInput)
    pub fn builder() -> crate::input::create_long_term_pricing_input::Builder {
        crate::input::create_long_term_pricing_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLongTermPricing {
    type Output = std::result::Result<
        crate::output::CreateLongTermPricingOutput,
        crate::error::CreateLongTermPricingError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_long_term_pricing_error(response)
        } else {
            crate::operation_ser::parse_create_long_term_pricing_response(response)
        }
    }
}

/// <p>Creates a shipping label that will be used to return the Snow device to AWS.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateReturnShippingLabel {
    _private: (),
}
impl CreateReturnShippingLabel {
    /// Creates a new builder-style object to manufacture [`CreateReturnShippingLabelInput`](crate::input::CreateReturnShippingLabelInput)
    pub fn builder() -> crate::input::create_return_shipping_label_input::Builder {
        crate::input::create_return_shipping_label_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateReturnShippingLabel {
    type Output = std::result::Result<
        crate::output::CreateReturnShippingLabelOutput,
        crate::error::CreateReturnShippingLabelError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_return_shipping_label_error(response)
        } else {
            crate::operation_ser::parse_create_return_shipping_label_response(response)
        }
    }
}

/// <p>Takes an <code>AddressId</code> and returns specific details about that address in the
/// form of an <code>Address</code> object.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAddress {
    _private: (),
}
impl DescribeAddress {
    /// Creates a new builder-style object to manufacture [`DescribeAddressInput`](crate::input::DescribeAddressInput)
    pub fn builder() -> crate::input::describe_address_input::Builder {
        crate::input::describe_address_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAddress {
    type Output = std::result::Result<
        crate::output::DescribeAddressOutput,
        crate::error::DescribeAddressError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_address_error(response)
        } else {
            crate::operation_ser::parse_describe_address_response(response)
        }
    }
}

/// <p>Returns a specified number of <code>ADDRESS</code> objects. Calling this API in one of
/// the US regions will return addresses from the list of all addresses associated with this
/// account in all US regions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAddresses {
    _private: (),
}
impl DescribeAddresses {
    /// Creates a new builder-style object to manufacture [`DescribeAddressesInput`](crate::input::DescribeAddressesInput)
    pub fn builder() -> crate::input::describe_addresses_input::Builder {
        crate::input::describe_addresses_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAddresses {
    type Output = std::result::Result<
        crate::output::DescribeAddressesOutput,
        crate::error::DescribeAddressesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_addresses_error(response)
        } else {
            crate::operation_ser::parse_describe_addresses_response(response)
        }
    }
}

/// <p>Returns information about a specific cluster including shipping information, cluster
/// status, and other important metadata.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeCluster {
    _private: (),
}
impl DescribeCluster {
    /// Creates a new builder-style object to manufacture [`DescribeClusterInput`](crate::input::DescribeClusterInput)
    pub fn builder() -> crate::input::describe_cluster_input::Builder {
        crate::input::describe_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeCluster {
    type Output = std::result::Result<
        crate::output::DescribeClusterOutput,
        crate::error::DescribeClusterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_cluster_error(response)
        } else {
            crate::operation_ser::parse_describe_cluster_response(response)
        }
    }
}

/// <p>Returns information about a specific job including shipping information, job status,
/// and other important metadata. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeJob {
    _private: (),
}
impl DescribeJob {
    /// Creates a new builder-style object to manufacture [`DescribeJobInput`](crate::input::DescribeJobInput)
    pub fn builder() -> crate::input::describe_job_input::Builder {
        crate::input::describe_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeJob {
    type Output =
        std::result::Result<crate::output::DescribeJobOutput, crate::error::DescribeJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_job_error(response)
        } else {
            crate::operation_ser::parse_describe_job_response(response)
        }
    }
}

/// <p>Information on the shipping label of a Snow device that is being returned to AWS.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeReturnShippingLabel {
    _private: (),
}
impl DescribeReturnShippingLabel {
    /// Creates a new builder-style object to manufacture [`DescribeReturnShippingLabelInput`](crate::input::DescribeReturnShippingLabelInput)
    pub fn builder() -> crate::input::describe_return_shipping_label_input::Builder {
        crate::input::describe_return_shipping_label_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeReturnShippingLabel {
    type Output = std::result::Result<
        crate::output::DescribeReturnShippingLabelOutput,
        crate::error::DescribeReturnShippingLabelError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_return_shipping_label_error(response)
        } else {
            crate::operation_ser::parse_describe_return_shipping_label_response(response)
        }
    }
}

/// <p>Returns a link to an Amazon S3 presigned URL for the manifest file associated with the
/// specified <code>JobId</code> value. You can access the manifest file for up to 60 minutes
/// after this request has been made. To access the manifest file after 60 minutes have passed,
/// you'll have to make another call to the <code>GetJobManifest</code> action.</p>
/// <p>The manifest is an encrypted file that you can download after your job enters the
/// <code>WithCustomer</code> status. The manifest is decrypted by using the
/// <code>UnlockCode</code> code value, when you pass both values to the Snow device through the
/// Snowball client when the client is started for the first time.</p>
/// <p>As a best practice, we recommend that you don't save a copy of an
/// <code>UnlockCode</code> value in the same location as the manifest file for that job. Saving
/// these separately helps prevent unauthorized parties from gaining access to the Snow device
/// associated with that job.</p>
/// <p>The credentials of a given job, including its manifest file and unlock code, expire 360
/// days after the job is created.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetJobManifest {
    _private: (),
}
impl GetJobManifest {
    /// Creates a new builder-style object to manufacture [`GetJobManifestInput`](crate::input::GetJobManifestInput)
    pub fn builder() -> crate::input::get_job_manifest_input::Builder {
        crate::input::get_job_manifest_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetJobManifest {
    type Output =
        std::result::Result<crate::output::GetJobManifestOutput, crate::error::GetJobManifestError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_job_manifest_error(response)
        } else {
            crate::operation_ser::parse_get_job_manifest_response(response)
        }
    }
}

/// <p>Returns the <code>UnlockCode</code> code value for the specified job. A particular
/// <code>UnlockCode</code> value can be accessed for up to 360 days after the associated job
/// has been created.</p>
/// <p>The <code>UnlockCode</code> value is a 29-character code with 25 alphanumeric
/// characters and 4 hyphens. This code is used to decrypt the manifest file when it is passed
/// along with the manifest to the Snow device through the Snowball client when the client is started
/// for the first time.</p>
/// <p>As a best practice, we recommend that you don't save a copy of the
/// <code>UnlockCode</code> in the same location as the manifest file for that job. Saving these
/// separately helps prevent unauthorized parties from gaining access to the Snow device associated
/// with that job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetJobUnlockCode {
    _private: (),
}
impl GetJobUnlockCode {
    /// Creates a new builder-style object to manufacture [`GetJobUnlockCodeInput`](crate::input::GetJobUnlockCodeInput)
    pub fn builder() -> crate::input::get_job_unlock_code_input::Builder {
        crate::input::get_job_unlock_code_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetJobUnlockCode {
    type Output = std::result::Result<
        crate::output::GetJobUnlockCodeOutput,
        crate::error::GetJobUnlockCodeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_job_unlock_code_error(response)
        } else {
            crate::operation_ser::parse_get_job_unlock_code_response(response)
        }
    }
}

/// <p>Returns information about the Snow Family service limit for your account, and also the
/// number of Snow devices your account has in use.</p>
/// <p>The default service limit for the number of Snow devices that you can have at one time is
/// 1. If you want to increase your service limit, contact AWS Support.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSnowballUsage {
    _private: (),
}
impl GetSnowballUsage {
    /// Creates a new builder-style object to manufacture [`GetSnowballUsageInput`](crate::input::GetSnowballUsageInput)
    pub fn builder() -> crate::input::get_snowball_usage_input::Builder {
        crate::input::get_snowball_usage_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSnowballUsage {
    type Output = std::result::Result<
        crate::output::GetSnowballUsageOutput,
        crate::error::GetSnowballUsageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_snowball_usage_error(response)
        } else {
            crate::operation_ser::parse_get_snowball_usage_response(response)
        }
    }
}

/// <p>Returns an Amazon S3 presigned URL for an update file associated with a specified
/// <code>JobId</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSoftwareUpdates {
    _private: (),
}
impl GetSoftwareUpdates {
    /// Creates a new builder-style object to manufacture [`GetSoftwareUpdatesInput`](crate::input::GetSoftwareUpdatesInput)
    pub fn builder() -> crate::input::get_software_updates_input::Builder {
        crate::input::get_software_updates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSoftwareUpdates {
    type Output = std::result::Result<
        crate::output::GetSoftwareUpdatesOutput,
        crate::error::GetSoftwareUpdatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_software_updates_error(response)
        } else {
            crate::operation_ser::parse_get_software_updates_response(response)
        }
    }
}

/// <p>Returns an array of <code>JobListEntry</code> objects of the specified length. Each
/// <code>JobListEntry</code> object is for a job in the specified cluster and contains a job's
/// state, a job's ID, and other information.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListClusterJobs {
    _private: (),
}
impl ListClusterJobs {
    /// Creates a new builder-style object to manufacture [`ListClusterJobsInput`](crate::input::ListClusterJobsInput)
    pub fn builder() -> crate::input::list_cluster_jobs_input::Builder {
        crate::input::list_cluster_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListClusterJobs {
    type Output = std::result::Result<
        crate::output::ListClusterJobsOutput,
        crate::error::ListClusterJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_cluster_jobs_error(response)
        } else {
            crate::operation_ser::parse_list_cluster_jobs_response(response)
        }
    }
}

/// <p>Returns an array of <code>ClusterListEntry</code> objects of the specified length. Each
/// <code>ClusterListEntry</code> object contains a cluster's state, a cluster's ID, and other
/// important status information.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListClusters {
    _private: (),
}
impl ListClusters {
    /// Creates a new builder-style object to manufacture [`ListClustersInput`](crate::input::ListClustersInput)
    pub fn builder() -> crate::input::list_clusters_input::Builder {
        crate::input::list_clusters_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListClusters {
    type Output =
        std::result::Result<crate::output::ListClustersOutput, crate::error::ListClustersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_clusters_error(response)
        } else {
            crate::operation_ser::parse_list_clusters_response(response)
        }
    }
}

/// <p>This action returns a list of the different Amazon EC2 Amazon Machine Images (AMIs)
/// that are owned by your AWS account that would be supported for use on a Snow device.
/// Currently, supported AMIs are based on the CentOS 7 (x86_64) - with Updates HVM, Ubuntu Server
/// 14.04 LTS (HVM), and Ubuntu 16.04 LTS - Xenial (HVM) images, available on the AWS
/// Marketplace.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCompatibleImages {
    _private: (),
}
impl ListCompatibleImages {
    /// Creates a new builder-style object to manufacture [`ListCompatibleImagesInput`](crate::input::ListCompatibleImagesInput)
    pub fn builder() -> crate::input::list_compatible_images_input::Builder {
        crate::input::list_compatible_images_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCompatibleImages {
    type Output = std::result::Result<
        crate::output::ListCompatibleImagesOutput,
        crate::error::ListCompatibleImagesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_compatible_images_error(response)
        } else {
            crate::operation_ser::parse_list_compatible_images_response(response)
        }
    }
}

/// <p>Returns an array of <code>JobListEntry</code> objects of the specified length. Each
/// <code>JobListEntry</code> object contains a job's state, a job's ID, and a value that
/// indicates whether the job is a job part, in the case of export jobs. Calling this API action
/// in one of the US regions will return jobs from the list of all jobs associated with this
/// account in all US regions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListJobs {
    _private: (),
}
impl ListJobs {
    /// Creates a new builder-style object to manufacture [`ListJobsInput`](crate::input::ListJobsInput)
    pub fn builder() -> crate::input::list_jobs_input::Builder {
        crate::input::list_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListJobs {
    type Output = std::result::Result<crate::output::ListJobsOutput, crate::error::ListJobsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_jobs_error(response)
        } else {
            crate::operation_ser::parse_list_jobs_response(response)
        }
    }
}

/// <p>Lists all long-term pricing types.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListLongTermPricing {
    _private: (),
}
impl ListLongTermPricing {
    /// Creates a new builder-style object to manufacture [`ListLongTermPricingInput`](crate::input::ListLongTermPricingInput)
    pub fn builder() -> crate::input::list_long_term_pricing_input::Builder {
        crate::input::list_long_term_pricing_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListLongTermPricing {
    type Output = std::result::Result<
        crate::output::ListLongTermPricingOutput,
        crate::error::ListLongTermPricingError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_long_term_pricing_error(response)
        } else {
            crate::operation_ser::parse_list_long_term_pricing_response(response)
        }
    }
}

/// <p>While a cluster's <code>ClusterState</code> value is in the <code>AwaitingQuorum</code>
/// state, you can update some of the information associated with a cluster. Once the cluster
/// changes to a different job state, usually 60 minutes after the cluster being created, this
/// action is no longer available.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCluster {
    _private: (),
}
impl UpdateCluster {
    /// Creates a new builder-style object to manufacture [`UpdateClusterInput`](crate::input::UpdateClusterInput)
    pub fn builder() -> crate::input::update_cluster_input::Builder {
        crate::input::update_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCluster {
    type Output =
        std::result::Result<crate::output::UpdateClusterOutput, crate::error::UpdateClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_cluster_error(response)
        } else {
            crate::operation_ser::parse_update_cluster_response(response)
        }
    }
}

/// <p>While a job's <code>JobState</code> value is <code>New</code>, you can update some of
/// the information associated with a job. Once the job changes to a different job state, usually
/// within 60 minutes of the job being created, this action is no longer available.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateJob {
    _private: (),
}
impl UpdateJob {
    /// Creates a new builder-style object to manufacture [`UpdateJobInput`](crate::input::UpdateJobInput)
    pub fn builder() -> crate::input::update_job_input::Builder {
        crate::input::update_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateJob {
    type Output = std::result::Result<crate::output::UpdateJobOutput, crate::error::UpdateJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_job_error(response)
        } else {
            crate::operation_ser::parse_update_job_response(response)
        }
    }
}

/// <p>Updates the state when a shipment state changes to a different state.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateJobShipmentState {
    _private: (),
}
impl UpdateJobShipmentState {
    /// Creates a new builder-style object to manufacture [`UpdateJobShipmentStateInput`](crate::input::UpdateJobShipmentStateInput)
    pub fn builder() -> crate::input::update_job_shipment_state_input::Builder {
        crate::input::update_job_shipment_state_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateJobShipmentState {
    type Output = std::result::Result<
        crate::output::UpdateJobShipmentStateOutput,
        crate::error::UpdateJobShipmentStateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_job_shipment_state_error(response)
        } else {
            crate::operation_ser::parse_update_job_shipment_state_response(response)
        }
    }
}

/// <p>Updates the long-term pricing type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateLongTermPricing {
    _private: (),
}
impl UpdateLongTermPricing {
    /// Creates a new builder-style object to manufacture [`UpdateLongTermPricingInput`](crate::input::UpdateLongTermPricingInput)
    pub fn builder() -> crate::input::update_long_term_pricing_input::Builder {
        crate::input::update_long_term_pricing_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateLongTermPricing {
    type Output = std::result::Result<
        crate::output::UpdateLongTermPricingOutput,
        crate::error::UpdateLongTermPricingError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_long_term_pricing_error(response)
        } else {
            crate::operation_ser::parse_update_long_term_pricing_response(response)
        }
    }
}
