// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelClusterError {
    pub kind: CancelClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelClusterErrorKind {
    InvalidJobStateException(crate::error::InvalidJobStateException),
    InvalidResourceException(crate::error::InvalidResourceException),
    KmsRequestFailedException(crate::error::KmsRequestFailedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelClusterErrorKind::InvalidJobStateException(_inner) => _inner.fmt(f),
            CancelClusterErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            CancelClusterErrorKind::KmsRequestFailedException(_inner) => _inner.fmt(f),
            CancelClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelClusterError {
    fn code(&self) -> Option<&str> {
        CancelClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelClusterError {
    pub fn new(kind: CancelClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_job_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelClusterErrorKind::InvalidJobStateException(_)
        )
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelClusterErrorKind::InvalidResourceException(_)
        )
    }
    pub fn is_kms_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelClusterErrorKind::KmsRequestFailedException(_)
        )
    }
}
impl std::error::Error for CancelClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelClusterErrorKind::InvalidJobStateException(_inner) => Some(_inner),
            CancelClusterErrorKind::InvalidResourceException(_inner) => Some(_inner),
            CancelClusterErrorKind::KmsRequestFailedException(_inner) => Some(_inner),
            CancelClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelJobError {
    pub kind: CancelJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelJobErrorKind {
    InvalidJobStateException(crate::error::InvalidJobStateException),
    InvalidResourceException(crate::error::InvalidResourceException),
    KmsRequestFailedException(crate::error::KmsRequestFailedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelJobErrorKind::InvalidJobStateException(_inner) => _inner.fmt(f),
            CancelJobErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            CancelJobErrorKind::KmsRequestFailedException(_inner) => _inner.fmt(f),
            CancelJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelJobError {
    fn code(&self) -> Option<&str> {
        CancelJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelJobError {
    pub fn new(kind: CancelJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_job_state_exception(&self) -> bool {
        matches!(&self.kind, CancelJobErrorKind::InvalidJobStateException(_))
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(&self.kind, CancelJobErrorKind::InvalidResourceException(_))
    }
    pub fn is_kms_request_failed_exception(&self) -> bool {
        matches!(&self.kind, CancelJobErrorKind::KmsRequestFailedException(_))
    }
}
impl std::error::Error for CancelJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelJobErrorKind::InvalidJobStateException(_inner) => Some(_inner),
            CancelJobErrorKind::InvalidResourceException(_inner) => Some(_inner),
            CancelJobErrorKind::KmsRequestFailedException(_inner) => Some(_inner),
            CancelJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAddressError {
    pub kind: CreateAddressErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAddressErrorKind {
    InvalidAddressException(crate::error::InvalidAddressException),
    UnsupportedAddressException(crate::error::UnsupportedAddressException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAddressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAddressErrorKind::InvalidAddressException(_inner) => _inner.fmt(f),
            CreateAddressErrorKind::UnsupportedAddressException(_inner) => _inner.fmt(f),
            CreateAddressErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAddressError {
    fn code(&self) -> Option<&str> {
        CreateAddressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAddressError {
    pub fn new(kind: CreateAddressErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAddressErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAddressErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_address_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAddressErrorKind::InvalidAddressException(_)
        )
    }
    pub fn is_unsupported_address_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAddressErrorKind::UnsupportedAddressException(_)
        )
    }
}
impl std::error::Error for CreateAddressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAddressErrorKind::InvalidAddressException(_inner) => Some(_inner),
            CreateAddressErrorKind::UnsupportedAddressException(_inner) => Some(_inner),
            CreateAddressErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateClusterError {
    pub kind: CreateClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateClusterErrorKind {
    Ec2RequestFailedException(crate::error::Ec2RequestFailedException),
    InvalidInputCombinationException(crate::error::InvalidInputCombinationException),
    InvalidResourceException(crate::error::InvalidResourceException),
    KmsRequestFailedException(crate::error::KmsRequestFailedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateClusterErrorKind::Ec2RequestFailedException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::InvalidInputCombinationException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::KmsRequestFailedException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateClusterError {
    fn code(&self) -> Option<&str> {
        CreateClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateClusterError {
    pub fn new(kind: CreateClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_ec2_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClusterErrorKind::Ec2RequestFailedException(_)
        )
    }
    pub fn is_invalid_input_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClusterErrorKind::InvalidInputCombinationException(_)
        )
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClusterErrorKind::InvalidResourceException(_)
        )
    }
    pub fn is_kms_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClusterErrorKind::KmsRequestFailedException(_)
        )
    }
}
impl std::error::Error for CreateClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateClusterErrorKind::Ec2RequestFailedException(_inner) => Some(_inner),
            CreateClusterErrorKind::InvalidInputCombinationException(_inner) => Some(_inner),
            CreateClusterErrorKind::InvalidResourceException(_inner) => Some(_inner),
            CreateClusterErrorKind::KmsRequestFailedException(_inner) => Some(_inner),
            CreateClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateJobError {
    pub kind: CreateJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateJobErrorKind {
    ClusterLimitExceededException(crate::error::ClusterLimitExceededException),
    Ec2RequestFailedException(crate::error::Ec2RequestFailedException),
    InvalidInputCombinationException(crate::error::InvalidInputCombinationException),
    InvalidResourceException(crate::error::InvalidResourceException),
    KmsRequestFailedException(crate::error::KmsRequestFailedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateJobErrorKind::ClusterLimitExceededException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::Ec2RequestFailedException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::InvalidInputCombinationException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::KmsRequestFailedException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateJobError {
    fn code(&self) -> Option<&str> {
        CreateJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateJobError {
    pub fn new(kind: CreateJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cluster_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobErrorKind::ClusterLimitExceededException(_)
        )
    }
    pub fn is_ec2_request_failed_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::Ec2RequestFailedException(_))
    }
    pub fn is_invalid_input_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobErrorKind::InvalidInputCombinationException(_)
        )
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::InvalidResourceException(_))
    }
    pub fn is_kms_request_failed_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::KmsRequestFailedException(_))
    }
}
impl std::error::Error for CreateJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateJobErrorKind::ClusterLimitExceededException(_inner) => Some(_inner),
            CreateJobErrorKind::Ec2RequestFailedException(_inner) => Some(_inner),
            CreateJobErrorKind::InvalidInputCombinationException(_inner) => Some(_inner),
            CreateJobErrorKind::InvalidResourceException(_inner) => Some(_inner),
            CreateJobErrorKind::KmsRequestFailedException(_inner) => Some(_inner),
            CreateJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLongTermPricingError {
    pub kind: CreateLongTermPricingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLongTermPricingErrorKind {
    InvalidResourceException(crate::error::InvalidResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLongTermPricingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLongTermPricingErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            CreateLongTermPricingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLongTermPricingError {
    fn code(&self) -> Option<&str> {
        CreateLongTermPricingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLongTermPricingError {
    pub fn new(kind: CreateLongTermPricingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLongTermPricingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLongTermPricingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLongTermPricingErrorKind::InvalidResourceException(_)
        )
    }
}
impl std::error::Error for CreateLongTermPricingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLongTermPricingErrorKind::InvalidResourceException(_inner) => Some(_inner),
            CreateLongTermPricingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateReturnShippingLabelError {
    pub kind: CreateReturnShippingLabelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateReturnShippingLabelErrorKind {
    ConflictException(crate::error::ConflictException),
    InvalidInputCombinationException(crate::error::InvalidInputCombinationException),
    InvalidJobStateException(crate::error::InvalidJobStateException),
    InvalidResourceException(crate::error::InvalidResourceException),
    ReturnShippingLabelAlreadyExistsException(
        crate::error::ReturnShippingLabelAlreadyExistsException,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateReturnShippingLabelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateReturnShippingLabelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateReturnShippingLabelErrorKind::InvalidInputCombinationException(_inner) => {
                _inner.fmt(f)
            }
            CreateReturnShippingLabelErrorKind::InvalidJobStateException(_inner) => _inner.fmt(f),
            CreateReturnShippingLabelErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            CreateReturnShippingLabelErrorKind::ReturnShippingLabelAlreadyExistsException(
                _inner,
            ) => _inner.fmt(f),
            CreateReturnShippingLabelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateReturnShippingLabelError {
    fn code(&self) -> Option<&str> {
        CreateReturnShippingLabelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateReturnShippingLabelError {
    pub fn new(kind: CreateReturnShippingLabelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateReturnShippingLabelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateReturnShippingLabelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateReturnShippingLabelErrorKind::ConflictException(_)
        )
    }
    pub fn is_invalid_input_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateReturnShippingLabelErrorKind::InvalidInputCombinationException(_)
        )
    }
    pub fn is_invalid_job_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateReturnShippingLabelErrorKind::InvalidJobStateException(_)
        )
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateReturnShippingLabelErrorKind::InvalidResourceException(_)
        )
    }
    pub fn is_return_shipping_label_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateReturnShippingLabelErrorKind::ReturnShippingLabelAlreadyExistsException(_)
        )
    }
}
impl std::error::Error for CreateReturnShippingLabelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateReturnShippingLabelErrorKind::ConflictException(_inner) => Some(_inner),
            CreateReturnShippingLabelErrorKind::InvalidInputCombinationException(_inner) => {
                Some(_inner)
            }
            CreateReturnShippingLabelErrorKind::InvalidJobStateException(_inner) => Some(_inner),
            CreateReturnShippingLabelErrorKind::InvalidResourceException(_inner) => Some(_inner),
            CreateReturnShippingLabelErrorKind::ReturnShippingLabelAlreadyExistsException(
                _inner,
            ) => Some(_inner),
            CreateReturnShippingLabelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAddressError {
    pub kind: DescribeAddressErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAddressErrorKind {
    InvalidResourceException(crate::error::InvalidResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAddressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAddressErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            DescribeAddressErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAddressError {
    fn code(&self) -> Option<&str> {
        DescribeAddressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAddressError {
    pub fn new(kind: DescribeAddressErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAddressErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAddressErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAddressErrorKind::InvalidResourceException(_)
        )
    }
}
impl std::error::Error for DescribeAddressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAddressErrorKind::InvalidResourceException(_inner) => Some(_inner),
            DescribeAddressErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAddressesError {
    pub kind: DescribeAddressesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAddressesErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidResourceException(crate::error::InvalidResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAddressesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAddressesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            DescribeAddressesErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            DescribeAddressesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAddressesError {
    fn code(&self) -> Option<&str> {
        DescribeAddressesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAddressesError {
    pub fn new(kind: DescribeAddressesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAddressesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAddressesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAddressesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAddressesErrorKind::InvalidResourceException(_)
        )
    }
}
impl std::error::Error for DescribeAddressesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAddressesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            DescribeAddressesErrorKind::InvalidResourceException(_inner) => Some(_inner),
            DescribeAddressesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeClusterError {
    pub kind: DescribeClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClusterErrorKind {
    InvalidResourceException(crate::error::InvalidResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeClusterErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            DescribeClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeClusterError {
    fn code(&self) -> Option<&str> {
        DescribeClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClusterError {
    pub fn new(kind: DescribeClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClusterErrorKind::InvalidResourceException(_)
        )
    }
}
impl std::error::Error for DescribeClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeClusterErrorKind::InvalidResourceException(_inner) => Some(_inner),
            DescribeClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeJobError {
    pub kind: DescribeJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeJobErrorKind {
    InvalidResourceException(crate::error::InvalidResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeJobErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            DescribeJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeJobError {
    fn code(&self) -> Option<&str> {
        DescribeJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeJobError {
    pub fn new(kind: DescribeJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobErrorKind::InvalidResourceException(_)
        )
    }
}
impl std::error::Error for DescribeJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeJobErrorKind::InvalidResourceException(_inner) => Some(_inner),
            DescribeJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeReturnShippingLabelError {
    pub kind: DescribeReturnShippingLabelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReturnShippingLabelErrorKind {
    ConflictException(crate::error::ConflictException),
    InvalidJobStateException(crate::error::InvalidJobStateException),
    InvalidResourceException(crate::error::InvalidResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeReturnShippingLabelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeReturnShippingLabelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DescribeReturnShippingLabelErrorKind::InvalidJobStateException(_inner) => _inner.fmt(f),
            DescribeReturnShippingLabelErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            DescribeReturnShippingLabelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeReturnShippingLabelError {
    fn code(&self) -> Option<&str> {
        DescribeReturnShippingLabelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReturnShippingLabelError {
    pub fn new(kind: DescribeReturnShippingLabelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeReturnShippingLabelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeReturnShippingLabelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReturnShippingLabelErrorKind::ConflictException(_)
        )
    }
    pub fn is_invalid_job_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReturnShippingLabelErrorKind::InvalidJobStateException(_)
        )
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReturnShippingLabelErrorKind::InvalidResourceException(_)
        )
    }
}
impl std::error::Error for DescribeReturnShippingLabelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeReturnShippingLabelErrorKind::ConflictException(_inner) => Some(_inner),
            DescribeReturnShippingLabelErrorKind::InvalidJobStateException(_inner) => Some(_inner),
            DescribeReturnShippingLabelErrorKind::InvalidResourceException(_inner) => Some(_inner),
            DescribeReturnShippingLabelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJobManifestError {
    pub kind: GetJobManifestErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJobManifestErrorKind {
    InvalidJobStateException(crate::error::InvalidJobStateException),
    InvalidResourceException(crate::error::InvalidResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJobManifestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJobManifestErrorKind::InvalidJobStateException(_inner) => _inner.fmt(f),
            GetJobManifestErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            GetJobManifestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetJobManifestError {
    fn code(&self) -> Option<&str> {
        GetJobManifestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJobManifestError {
    pub fn new(kind: GetJobManifestErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJobManifestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJobManifestErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_job_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobManifestErrorKind::InvalidJobStateException(_)
        )
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobManifestErrorKind::InvalidResourceException(_)
        )
    }
}
impl std::error::Error for GetJobManifestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJobManifestErrorKind::InvalidJobStateException(_inner) => Some(_inner),
            GetJobManifestErrorKind::InvalidResourceException(_inner) => Some(_inner),
            GetJobManifestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJobUnlockCodeError {
    pub kind: GetJobUnlockCodeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJobUnlockCodeErrorKind {
    InvalidJobStateException(crate::error::InvalidJobStateException),
    InvalidResourceException(crate::error::InvalidResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJobUnlockCodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJobUnlockCodeErrorKind::InvalidJobStateException(_inner) => _inner.fmt(f),
            GetJobUnlockCodeErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            GetJobUnlockCodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetJobUnlockCodeError {
    fn code(&self) -> Option<&str> {
        GetJobUnlockCodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJobUnlockCodeError {
    pub fn new(kind: GetJobUnlockCodeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJobUnlockCodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJobUnlockCodeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_job_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobUnlockCodeErrorKind::InvalidJobStateException(_)
        )
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobUnlockCodeErrorKind::InvalidResourceException(_)
        )
    }
}
impl std::error::Error for GetJobUnlockCodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJobUnlockCodeErrorKind::InvalidJobStateException(_inner) => Some(_inner),
            GetJobUnlockCodeErrorKind::InvalidResourceException(_inner) => Some(_inner),
            GetJobUnlockCodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSnowballUsageError {
    pub kind: GetSnowballUsageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSnowballUsageErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSnowballUsageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSnowballUsageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSnowballUsageError {
    fn code(&self) -> Option<&str> {
        GetSnowballUsageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSnowballUsageError {
    pub fn new(kind: GetSnowballUsageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSnowballUsageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSnowballUsageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetSnowballUsageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSnowballUsageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSoftwareUpdatesError {
    pub kind: GetSoftwareUpdatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSoftwareUpdatesErrorKind {
    InvalidJobStateException(crate::error::InvalidJobStateException),
    InvalidResourceException(crate::error::InvalidResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSoftwareUpdatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSoftwareUpdatesErrorKind::InvalidJobStateException(_inner) => _inner.fmt(f),
            GetSoftwareUpdatesErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            GetSoftwareUpdatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSoftwareUpdatesError {
    fn code(&self) -> Option<&str> {
        GetSoftwareUpdatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSoftwareUpdatesError {
    pub fn new(kind: GetSoftwareUpdatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSoftwareUpdatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSoftwareUpdatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_job_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSoftwareUpdatesErrorKind::InvalidJobStateException(_)
        )
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSoftwareUpdatesErrorKind::InvalidResourceException(_)
        )
    }
}
impl std::error::Error for GetSoftwareUpdatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSoftwareUpdatesErrorKind::InvalidJobStateException(_inner) => Some(_inner),
            GetSoftwareUpdatesErrorKind::InvalidResourceException(_inner) => Some(_inner),
            GetSoftwareUpdatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListClusterJobsError {
    pub kind: ListClusterJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListClusterJobsErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidResourceException(crate::error::InvalidResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListClusterJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListClusterJobsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListClusterJobsErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            ListClusterJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListClusterJobsError {
    fn code(&self) -> Option<&str> {
        ListClusterJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListClusterJobsError {
    pub fn new(kind: ListClusterJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListClusterJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListClusterJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListClusterJobsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListClusterJobsErrorKind::InvalidResourceException(_)
        )
    }
}
impl std::error::Error for ListClusterJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListClusterJobsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListClusterJobsErrorKind::InvalidResourceException(_inner) => Some(_inner),
            ListClusterJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListClustersError {
    pub kind: ListClustersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListClustersErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListClustersErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListClustersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListClustersError {
    fn code(&self) -> Option<&str> {
        ListClustersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListClustersError {
    pub fn new(kind: ListClustersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListClustersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListClustersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListClustersErrorKind::InvalidNextTokenException(_)
        )
    }
}
impl std::error::Error for ListClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListClustersErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListClustersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCompatibleImagesError {
    pub kind: ListCompatibleImagesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCompatibleImagesErrorKind {
    Ec2RequestFailedException(crate::error::Ec2RequestFailedException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCompatibleImagesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCompatibleImagesErrorKind::Ec2RequestFailedException(_inner) => _inner.fmt(f),
            ListCompatibleImagesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListCompatibleImagesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCompatibleImagesError {
    fn code(&self) -> Option<&str> {
        ListCompatibleImagesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCompatibleImagesError {
    pub fn new(kind: ListCompatibleImagesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCompatibleImagesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCompatibleImagesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_ec2_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCompatibleImagesErrorKind::Ec2RequestFailedException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCompatibleImagesErrorKind::InvalidNextTokenException(_)
        )
    }
}
impl std::error::Error for ListCompatibleImagesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCompatibleImagesErrorKind::Ec2RequestFailedException(_inner) => Some(_inner),
            ListCompatibleImagesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListCompatibleImagesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListJobsError {
    pub kind: ListJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListJobsErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListJobsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListJobsError {
    fn code(&self) -> Option<&str> {
        ListJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListJobsError {
    pub fn new(kind: ListJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::InvalidNextTokenException(_))
    }
}
impl std::error::Error for ListJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListJobsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLongTermPricingError {
    pub kind: ListLongTermPricingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLongTermPricingErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidResourceException(crate::error::InvalidResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLongTermPricingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLongTermPricingErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListLongTermPricingErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            ListLongTermPricingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLongTermPricingError {
    fn code(&self) -> Option<&str> {
        ListLongTermPricingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLongTermPricingError {
    pub fn new(kind: ListLongTermPricingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLongTermPricingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLongTermPricingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLongTermPricingErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLongTermPricingErrorKind::InvalidResourceException(_)
        )
    }
}
impl std::error::Error for ListLongTermPricingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLongTermPricingErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListLongTermPricingErrorKind::InvalidResourceException(_inner) => Some(_inner),
            ListLongTermPricingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateClusterError {
    pub kind: UpdateClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateClusterErrorKind {
    Ec2RequestFailedException(crate::error::Ec2RequestFailedException),
    InvalidInputCombinationException(crate::error::InvalidInputCombinationException),
    InvalidJobStateException(crate::error::InvalidJobStateException),
    InvalidResourceException(crate::error::InvalidResourceException),
    KmsRequestFailedException(crate::error::KmsRequestFailedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateClusterErrorKind::Ec2RequestFailedException(_inner) => _inner.fmt(f),
            UpdateClusterErrorKind::InvalidInputCombinationException(_inner) => _inner.fmt(f),
            UpdateClusterErrorKind::InvalidJobStateException(_inner) => _inner.fmt(f),
            UpdateClusterErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            UpdateClusterErrorKind::KmsRequestFailedException(_inner) => _inner.fmt(f),
            UpdateClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateClusterError {
    fn code(&self) -> Option<&str> {
        UpdateClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateClusterError {
    pub fn new(kind: UpdateClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_ec2_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterErrorKind::Ec2RequestFailedException(_)
        )
    }
    pub fn is_invalid_input_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterErrorKind::InvalidInputCombinationException(_)
        )
    }
    pub fn is_invalid_job_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterErrorKind::InvalidJobStateException(_)
        )
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterErrorKind::InvalidResourceException(_)
        )
    }
    pub fn is_kms_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterErrorKind::KmsRequestFailedException(_)
        )
    }
}
impl std::error::Error for UpdateClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateClusterErrorKind::Ec2RequestFailedException(_inner) => Some(_inner),
            UpdateClusterErrorKind::InvalidInputCombinationException(_inner) => Some(_inner),
            UpdateClusterErrorKind::InvalidJobStateException(_inner) => Some(_inner),
            UpdateClusterErrorKind::InvalidResourceException(_inner) => Some(_inner),
            UpdateClusterErrorKind::KmsRequestFailedException(_inner) => Some(_inner),
            UpdateClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateJobError {
    pub kind: UpdateJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateJobErrorKind {
    ClusterLimitExceededException(crate::error::ClusterLimitExceededException),
    Ec2RequestFailedException(crate::error::Ec2RequestFailedException),
    InvalidInputCombinationException(crate::error::InvalidInputCombinationException),
    InvalidJobStateException(crate::error::InvalidJobStateException),
    InvalidResourceException(crate::error::InvalidResourceException),
    KmsRequestFailedException(crate::error::KmsRequestFailedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateJobErrorKind::ClusterLimitExceededException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::Ec2RequestFailedException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::InvalidInputCombinationException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::InvalidJobStateException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::KmsRequestFailedException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateJobError {
    fn code(&self) -> Option<&str> {
        UpdateJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateJobError {
    pub fn new(kind: UpdateJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cluster_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJobErrorKind::ClusterLimitExceededException(_)
        )
    }
    pub fn is_ec2_request_failed_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::Ec2RequestFailedException(_))
    }
    pub fn is_invalid_input_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJobErrorKind::InvalidInputCombinationException(_)
        )
    }
    pub fn is_invalid_job_state_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::InvalidJobStateException(_))
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::InvalidResourceException(_))
    }
    pub fn is_kms_request_failed_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::KmsRequestFailedException(_))
    }
}
impl std::error::Error for UpdateJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateJobErrorKind::ClusterLimitExceededException(_inner) => Some(_inner),
            UpdateJobErrorKind::Ec2RequestFailedException(_inner) => Some(_inner),
            UpdateJobErrorKind::InvalidInputCombinationException(_inner) => Some(_inner),
            UpdateJobErrorKind::InvalidJobStateException(_inner) => Some(_inner),
            UpdateJobErrorKind::InvalidResourceException(_inner) => Some(_inner),
            UpdateJobErrorKind::KmsRequestFailedException(_inner) => Some(_inner),
            UpdateJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateJobShipmentStateError {
    pub kind: UpdateJobShipmentStateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateJobShipmentStateErrorKind {
    InvalidJobStateException(crate::error::InvalidJobStateException),
    InvalidResourceException(crate::error::InvalidResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateJobShipmentStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateJobShipmentStateErrorKind::InvalidJobStateException(_inner) => _inner.fmt(f),
            UpdateJobShipmentStateErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            UpdateJobShipmentStateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateJobShipmentStateError {
    fn code(&self) -> Option<&str> {
        UpdateJobShipmentStateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateJobShipmentStateError {
    pub fn new(kind: UpdateJobShipmentStateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateJobShipmentStateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateJobShipmentStateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_job_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJobShipmentStateErrorKind::InvalidJobStateException(_)
        )
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJobShipmentStateErrorKind::InvalidResourceException(_)
        )
    }
}
impl std::error::Error for UpdateJobShipmentStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateJobShipmentStateErrorKind::InvalidJobStateException(_inner) => Some(_inner),
            UpdateJobShipmentStateErrorKind::InvalidResourceException(_inner) => Some(_inner),
            UpdateJobShipmentStateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateLongTermPricingError {
    pub kind: UpdateLongTermPricingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateLongTermPricingErrorKind {
    InvalidResourceException(crate::error::InvalidResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateLongTermPricingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateLongTermPricingErrorKind::InvalidResourceException(_inner) => _inner.fmt(f),
            UpdateLongTermPricingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateLongTermPricingError {
    fn code(&self) -> Option<&str> {
        UpdateLongTermPricingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateLongTermPricingError {
    pub fn new(kind: UpdateLongTermPricingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateLongTermPricingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateLongTermPricingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLongTermPricingErrorKind::InvalidResourceException(_)
        )
    }
}
impl std::error::Error for UpdateLongTermPricingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateLongTermPricingErrorKind::InvalidResourceException(_inner) => Some(_inner),
            UpdateLongTermPricingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The specified resource can't be found. Check the information you provided in your last
/// request, and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidResourceException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The provided resource value is invalid.</p>
    pub resource_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidResourceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidResourceException");
        formatter.field("message", &self.message);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
impl InvalidResourceException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidResourceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResourceException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidResourceException {}
/// See [`InvalidResourceException`](crate::error::InvalidResourceException)
pub mod invalid_resource_exception {
    /// A builder for [`InvalidResourceException`](crate::error::InvalidResourceException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The provided resource value is invalid.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidResourceException`](crate::error::InvalidResourceException)
        pub fn build(self) -> crate::error::InvalidResourceException {
            crate::error::InvalidResourceException {
                message: self.message,
                resource_type: self.resource_type,
            }
        }
    }
}
impl InvalidResourceException {
    /// Creates a new builder-style object to manufacture [`InvalidResourceException`](crate::error::InvalidResourceException)
    pub fn builder() -> crate::error::invalid_resource_exception::Builder {
        crate::error::invalid_resource_exception::Builder::default()
    }
}

/// <p>The action can't be performed because the job's current state doesn't allow that action
/// to be performed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidJobStateException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidJobStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidJobStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidJobStateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidJobStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidJobStateException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidJobStateException {}
/// See [`InvalidJobStateException`](crate::error::InvalidJobStateException)
pub mod invalid_job_state_exception {
    /// A builder for [`InvalidJobStateException`](crate::error::InvalidJobStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidJobStateException`](crate::error::InvalidJobStateException)
        pub fn build(self) -> crate::error::InvalidJobStateException {
            crate::error::InvalidJobStateException {
                message: self.message,
            }
        }
    }
}
impl InvalidJobStateException {
    /// Creates a new builder-style object to manufacture [`InvalidJobStateException`](crate::error::InvalidJobStateException)
    pub fn builder() -> crate::error::invalid_job_state_exception::Builder {
        crate::error::invalid_job_state_exception::Builder::default()
    }
}

/// <p>The provided AWS Key Management Service key lacks the permissions to perform the
/// specified <a>CreateJob</a> or <a>UpdateJob</a> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KmsRequestFailedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KmsRequestFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KmsRequestFailedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KmsRequestFailedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KmsRequestFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KmsRequestFailedException [KMSRequestFailedException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for KmsRequestFailedException {}
/// See [`KmsRequestFailedException`](crate::error::KmsRequestFailedException)
pub mod kms_request_failed_exception {
    /// A builder for [`KmsRequestFailedException`](crate::error::KmsRequestFailedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KmsRequestFailedException`](crate::error::KmsRequestFailedException)
        pub fn build(self) -> crate::error::KmsRequestFailedException {
            crate::error::KmsRequestFailedException {
                message: self.message,
            }
        }
    }
}
impl KmsRequestFailedException {
    /// Creates a new builder-style object to manufacture [`KmsRequestFailedException`](crate::error::KmsRequestFailedException)
    pub fn builder() -> crate::error::kms_request_failed_exception::Builder {
        crate::error::kms_request_failed_exception::Builder::default()
    }
}

/// <p>Job or cluster creation failed. One or more inputs were invalid. Confirm that the
/// <a>CreateClusterRequest$SnowballType</a> value supports your <a>CreateJobRequest$JobType</a>, and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInputCombinationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidInputCombinationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInputCombinationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidInputCombinationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInputCombinationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInputCombinationException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInputCombinationException {}
/// See [`InvalidInputCombinationException`](crate::error::InvalidInputCombinationException)
pub mod invalid_input_combination_exception {
    /// A builder for [`InvalidInputCombinationException`](crate::error::InvalidInputCombinationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInputCombinationException`](crate::error::InvalidInputCombinationException)
        pub fn build(self) -> crate::error::InvalidInputCombinationException {
            crate::error::InvalidInputCombinationException {
                message: self.message,
            }
        }
    }
}
impl InvalidInputCombinationException {
    /// Creates a new builder-style object to manufacture [`InvalidInputCombinationException`](crate::error::InvalidInputCombinationException)
    pub fn builder() -> crate::error::invalid_input_combination_exception::Builder {
        crate::error::invalid_input_combination_exception::Builder::default()
    }
}

/// <p>Your IAM user lacks the necessary Amazon EC2 permissions to perform the attempted
/// action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ec2RequestFailedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ec2RequestFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ec2RequestFailedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl Ec2RequestFailedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for Ec2RequestFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Ec2RequestFailedException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for Ec2RequestFailedException {}
/// See [`Ec2RequestFailedException`](crate::error::Ec2RequestFailedException)
pub mod ec2_request_failed_exception {
    /// A builder for [`Ec2RequestFailedException`](crate::error::Ec2RequestFailedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`Ec2RequestFailedException`](crate::error::Ec2RequestFailedException)
        pub fn build(self) -> crate::error::Ec2RequestFailedException {
            crate::error::Ec2RequestFailedException {
                message: self.message,
            }
        }
    }
}
impl Ec2RequestFailedException {
    /// Creates a new builder-style object to manufacture [`Ec2RequestFailedException`](crate::error::Ec2RequestFailedException)
    pub fn builder() -> crate::error::ec2_request_failed_exception::Builder {
        crate::error::ec2_request_failed_exception::Builder::default()
    }
}

/// <p>Job creation failed. Currently, clusters support five nodes. If you have fewer than
/// five nodes for your cluster and you have more nodes to create for this cluster, try again and
/// create jobs until your cluster has exactly five nodes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterLimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClusterLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterLimitExceededException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClusterLimitExceededException {}
/// See [`ClusterLimitExceededException`](crate::error::ClusterLimitExceededException)
pub mod cluster_limit_exceeded_exception {
    /// A builder for [`ClusterLimitExceededException`](crate::error::ClusterLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterLimitExceededException`](crate::error::ClusterLimitExceededException)
        pub fn build(self) -> crate::error::ClusterLimitExceededException {
            crate::error::ClusterLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl ClusterLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ClusterLimitExceededException`](crate::error::ClusterLimitExceededException)
    pub fn builder() -> crate::error::cluster_limit_exceeded_exception::Builder {
        crate::error::cluster_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The <code>NextToken</code> string was altered unexpectedly, and the operation has
/// stopped. Run the operation without changing the <code>NextToken</code> string, and try
/// again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNextTokenException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNextTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidNextTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenException {}
/// See [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
pub mod invalid_next_token_exception {
    /// A builder for [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
        pub fn build(self) -> crate::error::InvalidNextTokenException {
            crate::error::InvalidNextTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidNextTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    pub fn builder() -> crate::error::invalid_next_token_exception::Builder {
        crate::error::invalid_next_token_exception::Builder::default()
    }
}

/// <p>You get this exception when you call <code>CreateReturnShippingLabel</code> more than once when other requests are not completed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub conflict_resource: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("conflict_resource", &self.conflict_resource);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conflict_resource: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn conflict_resource(mut self, input: impl Into<std::string::String>) -> Self {
            self.conflict_resource = Some(input.into());
            self
        }
        pub fn set_conflict_resource(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conflict_resource = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                conflict_resource: self.conflict_resource,
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>You get this exception if you call <code>CreateReturnShippingLabel</code> and a valid return
/// shipping label already exists. In this case, use
/// <code>DescribeReturnShippingLabel</code> to get the url.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReturnShippingLabelAlreadyExistsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReturnShippingLabelAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReturnShippingLabelAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReturnShippingLabelAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReturnShippingLabelAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReturnShippingLabelAlreadyExistsException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReturnShippingLabelAlreadyExistsException {}
/// See [`ReturnShippingLabelAlreadyExistsException`](crate::error::ReturnShippingLabelAlreadyExistsException)
pub mod return_shipping_label_already_exists_exception {
    /// A builder for [`ReturnShippingLabelAlreadyExistsException`](crate::error::ReturnShippingLabelAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReturnShippingLabelAlreadyExistsException`](crate::error::ReturnShippingLabelAlreadyExistsException)
        pub fn build(self) -> crate::error::ReturnShippingLabelAlreadyExistsException {
            crate::error::ReturnShippingLabelAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl ReturnShippingLabelAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ReturnShippingLabelAlreadyExistsException`](crate::error::ReturnShippingLabelAlreadyExistsException)
    pub fn builder() -> crate::error::return_shipping_label_already_exists_exception::Builder {
        crate::error::return_shipping_label_already_exists_exception::Builder::default()
    }
}

/// <p>The address is either outside the serviceable area for your region, or an error
/// occurred. Check the address with your region's carrier and try again. If the issue persists,
/// contact AWS Support.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedAddressException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedAddressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedAddressException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedAddressException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedAddressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedAddressException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedAddressException {}
/// See [`UnsupportedAddressException`](crate::error::UnsupportedAddressException)
pub mod unsupported_address_exception {
    /// A builder for [`UnsupportedAddressException`](crate::error::UnsupportedAddressException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedAddressException`](crate::error::UnsupportedAddressException)
        pub fn build(self) -> crate::error::UnsupportedAddressException {
            crate::error::UnsupportedAddressException {
                message: self.message,
            }
        }
    }
}
impl UnsupportedAddressException {
    /// Creates a new builder-style object to manufacture [`UnsupportedAddressException`](crate::error::UnsupportedAddressException)
    pub fn builder() -> crate::error::unsupported_address_exception::Builder {
        crate::error::unsupported_address_exception::Builder::default()
    }
}

/// <p>The address provided was invalid. Check the address with your region's carrier, and try
/// again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAddressException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAddressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAddressException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAddressException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAddressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAddressException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAddressException {}
/// See [`InvalidAddressException`](crate::error::InvalidAddressException)
pub mod invalid_address_exception {
    /// A builder for [`InvalidAddressException`](crate::error::InvalidAddressException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAddressException`](crate::error::InvalidAddressException)
        pub fn build(self) -> crate::error::InvalidAddressException {
            crate::error::InvalidAddressException {
                message: self.message,
            }
        }
    }
}
impl InvalidAddressException {
    /// Creates a new builder-style object to manufacture [`InvalidAddressException`](crate::error::InvalidAddressException)
    pub fn builder() -> crate::error::invalid_address_exception::Builder {
        crate::error::invalid_address_exception::Builder::default()
    }
}
