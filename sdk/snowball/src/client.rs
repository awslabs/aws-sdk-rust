// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `AWSIESnowballJobManagementService`.
///
/// This client allows ergonomic access to a `AWSIESnowballJobManagementService`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn cancel_cluster(&self) -> fluent_builders::CancelCluster<C, M, R> {
        fluent_builders::CancelCluster::new(self.handle.clone())
    }
    pub fn cancel_job(&self) -> fluent_builders::CancelJob<C, M, R> {
        fluent_builders::CancelJob::new(self.handle.clone())
    }
    pub fn create_address(&self) -> fluent_builders::CreateAddress<C, M, R> {
        fluent_builders::CreateAddress::new(self.handle.clone())
    }
    pub fn create_cluster(&self) -> fluent_builders::CreateCluster<C, M, R> {
        fluent_builders::CreateCluster::new(self.handle.clone())
    }
    pub fn create_job(&self) -> fluent_builders::CreateJob<C, M, R> {
        fluent_builders::CreateJob::new(self.handle.clone())
    }
    pub fn create_long_term_pricing(&self) -> fluent_builders::CreateLongTermPricing<C, M, R> {
        fluent_builders::CreateLongTermPricing::new(self.handle.clone())
    }
    pub fn create_return_shipping_label(
        &self,
    ) -> fluent_builders::CreateReturnShippingLabel<C, M, R> {
        fluent_builders::CreateReturnShippingLabel::new(self.handle.clone())
    }
    pub fn describe_address(&self) -> fluent_builders::DescribeAddress<C, M, R> {
        fluent_builders::DescribeAddress::new(self.handle.clone())
    }
    pub fn describe_addresses(&self) -> fluent_builders::DescribeAddresses<C, M, R> {
        fluent_builders::DescribeAddresses::new(self.handle.clone())
    }
    pub fn describe_cluster(&self) -> fluent_builders::DescribeCluster<C, M, R> {
        fluent_builders::DescribeCluster::new(self.handle.clone())
    }
    pub fn describe_job(&self) -> fluent_builders::DescribeJob<C, M, R> {
        fluent_builders::DescribeJob::new(self.handle.clone())
    }
    pub fn describe_return_shipping_label(
        &self,
    ) -> fluent_builders::DescribeReturnShippingLabel<C, M, R> {
        fluent_builders::DescribeReturnShippingLabel::new(self.handle.clone())
    }
    pub fn get_job_manifest(&self) -> fluent_builders::GetJobManifest<C, M, R> {
        fluent_builders::GetJobManifest::new(self.handle.clone())
    }
    pub fn get_job_unlock_code(&self) -> fluent_builders::GetJobUnlockCode<C, M, R> {
        fluent_builders::GetJobUnlockCode::new(self.handle.clone())
    }
    pub fn get_snowball_usage(&self) -> fluent_builders::GetSnowballUsage<C, M, R> {
        fluent_builders::GetSnowballUsage::new(self.handle.clone())
    }
    pub fn get_software_updates(&self) -> fluent_builders::GetSoftwareUpdates<C, M, R> {
        fluent_builders::GetSoftwareUpdates::new(self.handle.clone())
    }
    pub fn list_cluster_jobs(&self) -> fluent_builders::ListClusterJobs<C, M, R> {
        fluent_builders::ListClusterJobs::new(self.handle.clone())
    }
    pub fn list_clusters(&self) -> fluent_builders::ListClusters<C, M, R> {
        fluent_builders::ListClusters::new(self.handle.clone())
    }
    pub fn list_compatible_images(&self) -> fluent_builders::ListCompatibleImages<C, M, R> {
        fluent_builders::ListCompatibleImages::new(self.handle.clone())
    }
    pub fn list_jobs(&self) -> fluent_builders::ListJobs<C, M, R> {
        fluent_builders::ListJobs::new(self.handle.clone())
    }
    pub fn list_long_term_pricing(&self) -> fluent_builders::ListLongTermPricing<C, M, R> {
        fluent_builders::ListLongTermPricing::new(self.handle.clone())
    }
    pub fn update_cluster(&self) -> fluent_builders::UpdateCluster<C, M, R> {
        fluent_builders::UpdateCluster::new(self.handle.clone())
    }
    pub fn update_job(&self) -> fluent_builders::UpdateJob<C, M, R> {
        fluent_builders::UpdateJob::new(self.handle.clone())
    }
    pub fn update_job_shipment_state(&self) -> fluent_builders::UpdateJobShipmentState<C, M, R> {
        fluent_builders::UpdateJobShipmentState::new(self.handle.clone())
    }
    pub fn update_long_term_pricing(&self) -> fluent_builders::UpdateLongTermPricing<C, M, R> {
        fluent_builders::UpdateLongTermPricing::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CancelCluster<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::cancel_cluster_input::Builder,
    }
    impl<C, M, R> CancelCluster<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelClusterOutput,
            smithy_http::result::SdkError<crate::error::CancelClusterError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CancelClusterInputOperationOutputAlias,
                crate::output::CancelClusterOutput,
                crate::error::CancelClusterError,
                crate::input::CancelClusterInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The 39-character ID for the cluster that you want to cancel, for example
        /// <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn cluster_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(inp);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelJob<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::cancel_job_input::Builder,
    }
    impl<C, M, R> CancelJob<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelJobOutput,
            smithy_http::result::SdkError<crate::error::CancelJobError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CancelJobInputOperationOutputAlias,
                crate::output::CancelJobOutput,
                crate::error::CancelJobError,
                crate::input::CancelJobInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The 39-character job ID for the job that you want to cancel, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAddress<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_address_input::Builder,
    }
    impl<C, M, R> CreateAddress<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAddressOutput,
            smithy_http::result::SdkError<crate::error::CreateAddressError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateAddressInputOperationOutputAlias,
                crate::output::CreateAddressOutput,
                crate::error::CreateAddressError,
                crate::input::CreateAddressInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The address that you want the Snow device shipped to.</p>
        pub fn address(mut self, inp: crate::model::Address) -> Self {
            self.inner = self.inner.address(inp);
            self
        }
        pub fn set_address(mut self, input: std::option::Option<crate::model::Address>) -> Self {
            self.inner = self.inner.set_address(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCluster<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_cluster_input::Builder,
    }
    impl<C, M, R> CreateCluster<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateClusterOutput,
            smithy_http::result::SdkError<crate::error::CreateClusterError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateClusterInputOperationOutputAlias,
                crate::output::CreateClusterOutput,
                crate::error::CreateClusterError,
                crate::input::CreateClusterInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of job for this cluster. Currently, the only job type supported for clusters
        /// is <code>LOCAL_USE</code>.</p>
        /// <p>For more information, see
        /// "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
        /// "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
        pub fn job_type(mut self, inp: crate::model::JobType) -> Self {
            self.inner = self.inner.job_type(inp);
            self
        }
        pub fn set_job_type(mut self, input: std::option::Option<crate::model::JobType>) -> Self {
            self.inner = self.inner.set_job_type(input);
            self
        }
        /// <p>The resources associated with the cluster job. These resources include Amazon S3
        /// buckets and optional AWS Lambda functions written in the Python language. </p>
        pub fn resources(mut self, inp: crate::model::JobResource) -> Self {
            self.inner = self.inner.resources(inp);
            self
        }
        pub fn set_resources(
            mut self,
            input: std::option::Option<crate::model::JobResource>,
        ) -> Self {
            self.inner = self.inner.set_resources(input);
            self
        }
        /// <p>Specifies the service or services on the Snow Family device that your
        /// transferred data will be exported from or imported into. AWS Snow Family supports Amazon S3 and NFS (Network File System).</p>
        pub fn on_device_service_configuration(
            mut self,
            inp: crate::model::OnDeviceServiceConfiguration,
        ) -> Self {
            self.inner = self.inner.on_device_service_configuration(inp);
            self
        }
        pub fn set_on_device_service_configuration(
            mut self,
            input: std::option::Option<crate::model::OnDeviceServiceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_on_device_service_configuration(input);
            self
        }
        /// <p>An optional description of this specific cluster, for example <code>Environmental Data
        /// Cluster-01</code>.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The ID for the address that you want the cluster shipped to.</p>
        pub fn address_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.address_id(inp);
            self
        }
        pub fn set_address_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_address_id(input);
            self
        }
        /// <p>The <code>KmsKeyARN</code> value that you want to associate with this cluster.
        /// <code>KmsKeyARN</code> values are created by using the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html">CreateKey</a> API action in AWS Key
        /// Management Service (AWS KMS). </p>
        pub fn kms_key_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_arn(inp);
            self
        }
        pub fn set_kms_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_arn(input);
            self
        }
        /// <p>The <code>RoleARN</code> that you want to associate with this cluster.
        /// <code>RoleArn</code> values are created by using the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a> API action in AWS
        /// Identity and Access Management (IAM).</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The type of AWS Snow Family device to use for this cluster.
        /// </p>
        /// <note>
        /// <p>For cluster jobs, AWS Snow Family currently supports only the <code>EDGE</code> device type.</p>
        /// </note>
        /// <p>For more information, see
        /// "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
        /// "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
        pub fn snowball_type(mut self, inp: crate::model::SnowballType) -> Self {
            self.inner = self.inner.snowball_type(inp);
            self
        }
        pub fn set_snowball_type(
            mut self,
            input: std::option::Option<crate::model::SnowballType>,
        ) -> Self {
            self.inner = self.inner.set_snowball_type(input);
            self
        }
        /// <p>The shipping speed for each node in this cluster. This speed doesn't dictate how soon
        /// you'll get each Snowball Edge device, rather it represents how quickly each device moves to
        /// its destination while in transit. Regional shipping speeds are as follows:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>In Australia, you have access to express shipping. Typically, Snow devices shipped
        /// express are delivered in about a day.</p>
        /// </li>
        /// <li>
        /// <p>In the European Union (EU), you have access to express shipping. Typically,
        /// Snow devices shipped express are delivered in about a day. In addition, most countries in the
        /// EU have access to standard shipping, which typically takes less than a week, one
        /// way.</p>
        /// </li>
        /// <li>
        /// <p>In India, Snow devices are delivered in one to seven days.</p>
        /// </li>
        /// <li>
        /// <p>In the United States of America (US), you have access to one-day shipping and
        /// two-day shipping.</p>
        /// </li>
        /// </ul>
        /// <ul>
        /// <li>
        /// <p>In Australia, you have access to express shipping. Typically, devices shipped
        /// express are delivered in about a day.</p>
        /// </li>
        /// <li>
        /// <p>In the European Union (EU), you have access to express shipping. Typically,
        /// Snow devices shipped express are delivered in about a day. In addition, most countries
        /// in the EU have access to standard shipping, which typically takes less than a week, one
        /// way.</p>
        /// </li>
        /// <li>
        /// <p>In India, Snow devices are delivered in one to seven days.</p>
        /// </li>
        /// <li>
        /// <p>In the US, you have access to one-day shipping and two-day shipping.</p>
        /// </li>
        /// </ul>
        pub fn shipping_option(mut self, inp: crate::model::ShippingOption) -> Self {
            self.inner = self.inner.shipping_option(inp);
            self
        }
        pub fn set_shipping_option(
            mut self,
            input: std::option::Option<crate::model::ShippingOption>,
        ) -> Self {
            self.inner = self.inner.set_shipping_option(input);
            self
        }
        /// <p>The Amazon Simple Notification Service (Amazon SNS) notification settings for this
        /// cluster.</p>
        pub fn notification(mut self, inp: crate::model::Notification) -> Self {
            self.inner = self.inner.notification(inp);
            self
        }
        pub fn set_notification(
            mut self,
            input: std::option::Option<crate::model::Notification>,
        ) -> Self {
            self.inner = self.inner.set_notification(input);
            self
        }
        /// <p>The forwarding address ID for a cluster. This field is not supported in most
        /// regions.</p>
        pub fn forwarding_address_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.forwarding_address_id(inp);
            self
        }
        pub fn set_forwarding_address_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_forwarding_address_id(input);
            self
        }
        /// <p>The tax documents required in your AWS Region.</p>
        pub fn tax_documents(mut self, inp: crate::model::TaxDocuments) -> Self {
            self.inner = self.inner.tax_documents(inp);
            self
        }
        pub fn set_tax_documents(
            mut self,
            input: std::option::Option<crate::model::TaxDocuments>,
        ) -> Self {
            self.inner = self.inner.set_tax_documents(input);
            self
        }
        /// <p>Allows you to securely operate and manage Snow devices in a cluster remotely from outside
        /// of your internal network. When set to <code>INSTALLED_AUTOSTART</code>, remote management will
        /// automatically be available when the device arrives at your location. Otherwise, you need to
        /// use the Snowball Client to manage the device.</p>
        pub fn remote_management(mut self, inp: crate::model::RemoteManagement) -> Self {
            self.inner = self.inner.remote_management(inp);
            self
        }
        pub fn set_remote_management(
            mut self,
            input: std::option::Option<crate::model::RemoteManagement>,
        ) -> Self {
            self.inner = self.inner.set_remote_management(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateJob<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_job_input::Builder,
    }
    impl<C, M, R> CreateJob<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateJobOutput,
            smithy_http::result::SdkError<crate::error::CreateJobError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateJobInputOperationOutputAlias,
                crate::output::CreateJobOutput,
                crate::error::CreateJobError,
                crate::input::CreateJobInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Defines the type of job that you're creating.
        /// </p>
        pub fn job_type(mut self, inp: crate::model::JobType) -> Self {
            self.inner = self.inner.job_type(inp);
            self
        }
        pub fn set_job_type(mut self, input: std::option::Option<crate::model::JobType>) -> Self {
            self.inner = self.inner.set_job_type(input);
            self
        }
        /// <p>Defines the Amazon S3 buckets associated with this job.</p>
        /// <p>With <code>IMPORT</code> jobs, you specify the bucket or buckets that your transferred
        /// data will be imported into.</p>
        /// <p>With <code>EXPORT</code> jobs, you specify the bucket or buckets that your transferred
        /// data will be exported from. Optionally, you can also specify a <code>KeyRange</code> value. If
        /// you choose to export a range, you define the length of the range by providing either an
        /// inclusive <code>BeginMarker</code> value, an inclusive <code>EndMarker</code> value, or both.
        /// Ranges are UTF-8 binary sorted.</p>
        pub fn resources(mut self, inp: crate::model::JobResource) -> Self {
            self.inner = self.inner.resources(inp);
            self
        }
        pub fn set_resources(
            mut self,
            input: std::option::Option<crate::model::JobResource>,
        ) -> Self {
            self.inner = self.inner.set_resources(input);
            self
        }
        /// <p>Specifies the service or services on the Snow Family device that your
        /// transferred data will be exported from or imported into. AWS Snow Family supports Amazon S3 and NFS (Network File System).</p>
        pub fn on_device_service_configuration(
            mut self,
            inp: crate::model::OnDeviceServiceConfiguration,
        ) -> Self {
            self.inner = self.inner.on_device_service_configuration(inp);
            self
        }
        pub fn set_on_device_service_configuration(
            mut self,
            input: std::option::Option<crate::model::OnDeviceServiceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_on_device_service_configuration(input);
            self
        }
        /// <p>Defines an optional description of this specific job, for example <code>Important
        /// Photos 2016-08-11</code>.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The ID for the address that you want the Snow device shipped to.</p>
        pub fn address_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.address_id(inp);
            self
        }
        pub fn set_address_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_address_id(input);
            self
        }
        /// <p>The <code>KmsKeyARN</code> that you want to associate with this job.
        /// <code>KmsKeyARN</code>s are created using the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html">CreateKey</a> AWS Key Management
        /// Service (KMS) API action.</p>
        pub fn kms_key_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_arn(inp);
            self
        }
        pub fn set_kms_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_arn(input);
            self
        }
        /// <p>The <code>RoleARN</code> that you want to associate with this job.
        /// <code>RoleArn</code>s are created using the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a> AWS Identity and
        /// Access Management (IAM) API action.</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>If your job is being created in one of the US regions, you have the option of
        /// specifying what size Snow device you'd like for this job. In all other regions, Snowballs come
        /// with 80 TB in storage capacity.</p>
        /// <p>For more information, see
        /// "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
        /// "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
        pub fn snowball_capacity_preference(mut self, inp: crate::model::SnowballCapacity) -> Self {
            self.inner = self.inner.snowball_capacity_preference(inp);
            self
        }
        pub fn set_snowball_capacity_preference(
            mut self,
            input: std::option::Option<crate::model::SnowballCapacity>,
        ) -> Self {
            self.inner = self.inner.set_snowball_capacity_preference(input);
            self
        }
        /// <p>The shipping speed for this job. This speed doesn't dictate how soon you'll get the
        /// Snow device, rather it represents how quickly the Snow device moves to its destination while in
        /// transit. Regional shipping speeds are as follows:</p>
        /// <ul>
        /// <li>
        /// <p>In Australia, you have access to express shipping. Typically, Snow devices shipped
        /// express are delivered in about a day.</p>
        /// </li>
        /// <li>
        /// <p>In the European Union (EU), you have access to express shipping. Typically,
        /// Snow devices shipped express are delivered in about a day. In addition, most countries in the
        /// EU have access to standard shipping, which typically takes less than a week, one
        /// way.</p>
        /// </li>
        /// <li>
        /// <p>In India, Snow devices are delivered in one to seven days.</p>
        /// </li>
        /// <li>
        /// <p>In the US, you have access to one-day shipping and two-day shipping.</p>
        /// </li>
        /// </ul>
        pub fn shipping_option(mut self, inp: crate::model::ShippingOption) -> Self {
            self.inner = self.inner.shipping_option(inp);
            self
        }
        pub fn set_shipping_option(
            mut self,
            input: std::option::Option<crate::model::ShippingOption>,
        ) -> Self {
            self.inner = self.inner.set_shipping_option(input);
            self
        }
        /// <p>Defines the Amazon Simple Notification Service (Amazon SNS) notification settings for
        /// this job.</p>
        pub fn notification(mut self, inp: crate::model::Notification) -> Self {
            self.inner = self.inner.notification(inp);
            self
        }
        pub fn set_notification(
            mut self,
            input: std::option::Option<crate::model::Notification>,
        ) -> Self {
            self.inner = self.inner.set_notification(input);
            self
        }
        /// <p>The ID of a cluster. If you're creating a job for a node in a cluster, you need to
        /// provide only this <code>clusterId</code> value. The other job attributes are inherited from
        /// the cluster.</p>
        pub fn cluster_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(inp);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
        /// <p>The type of AWS Snow Family device to use for this job.
        /// </p>
        /// <note>
        /// <p>For cluster jobs, AWS Snow Family currently supports only the <code>EDGE</code> device type.</p>
        /// </note>
        /// <p>The type of AWS Snow device to use for this job. Currently, the only supported
        /// device type for cluster jobs is <code>EDGE</code>.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/snowball/latest/developer-guide/device-differences.html">Snowball Edge Device
        /// Options</a> in the Snowball Edge Developer Guide.</p>
        /// <p>For more information, see
        /// "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
        /// "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
        pub fn snowball_type(mut self, inp: crate::model::SnowballType) -> Self {
            self.inner = self.inner.snowball_type(inp);
            self
        }
        pub fn set_snowball_type(
            mut self,
            input: std::option::Option<crate::model::SnowballType>,
        ) -> Self {
            self.inner = self.inner.set_snowball_type(input);
            self
        }
        /// <p>The forwarding address ID for a job. This field is not supported in most
        /// Regions.</p>
        pub fn forwarding_address_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.forwarding_address_id(inp);
            self
        }
        pub fn set_forwarding_address_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_forwarding_address_id(input);
            self
        }
        /// <p>The tax documents required in your AWS Region.</p>
        pub fn tax_documents(mut self, inp: crate::model::TaxDocuments) -> Self {
            self.inner = self.inner.tax_documents(inp);
            self
        }
        pub fn set_tax_documents(
            mut self,
            input: std::option::Option<crate::model::TaxDocuments>,
        ) -> Self {
            self.inner = self.inner.set_tax_documents(input);
            self
        }
        /// <p>Defines the device configuration for an AWS Snowcone job.</p>
        /// <p>For more information, see
        /// "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
        /// "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
        pub fn device_configuration(mut self, inp: crate::model::DeviceConfiguration) -> Self {
            self.inner = self.inner.device_configuration(inp);
            self
        }
        pub fn set_device_configuration(
            mut self,
            input: std::option::Option<crate::model::DeviceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_device_configuration(input);
            self
        }
        /// <p>Allows you to securely operate and manage Snowcone devices remotely from outside of your
        /// internal network. When set to <code>INSTALLED_AUTOSTART</code>, remote management will
        /// automatically be available when the device arrives at your location. Otherwise, you need to
        /// use the Snowball Client to manage the device.</p>
        pub fn remote_management(mut self, inp: crate::model::RemoteManagement) -> Self {
            self.inner = self.inner.remote_management(inp);
            self
        }
        pub fn set_remote_management(
            mut self,
            input: std::option::Option<crate::model::RemoteManagement>,
        ) -> Self {
            self.inner = self.inner.set_remote_management(input);
            self
        }
        /// <p>The ID of the long-term pricing type for the device.</p>
        pub fn long_term_pricing_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.long_term_pricing_id(inp);
            self
        }
        pub fn set_long_term_pricing_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_long_term_pricing_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLongTermPricing<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_long_term_pricing_input::Builder,
    }
    impl<C, M, R> CreateLongTermPricing<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLongTermPricingOutput,
            smithy_http::result::SdkError<crate::error::CreateLongTermPricingError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLongTermPricingInputOperationOutputAlias,
                crate::output::CreateLongTermPricingOutput,
                crate::error::CreateLongTermPricingError,
                crate::input::CreateLongTermPricingInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of long-term pricing option you want for the device, either 1-year or 3-year
        /// long-term pricing.</p>
        pub fn long_term_pricing_type(mut self, inp: crate::model::LongTermPricingType) -> Self {
            self.inner = self.inner.long_term_pricing_type(inp);
            self
        }
        pub fn set_long_term_pricing_type(
            mut self,
            input: std::option::Option<crate::model::LongTermPricingType>,
        ) -> Self {
            self.inner = self.inner.set_long_term_pricing_type(input);
            self
        }
        /// <p>Specifies whether the current long-term pricing type for the device should be renewed.</p>
        pub fn is_long_term_pricing_auto_renew(mut self, inp: bool) -> Self {
            self.inner = self.inner.is_long_term_pricing_auto_renew(inp);
            self
        }
        pub fn set_is_long_term_pricing_auto_renew(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_is_long_term_pricing_auto_renew(input);
            self
        }
        /// <p>The type of AWS Snow Family device to use for the long-term pricing job.</p>
        pub fn snowball_type(mut self, inp: crate::model::SnowballType) -> Self {
            self.inner = self.inner.snowball_type(inp);
            self
        }
        pub fn set_snowball_type(
            mut self,
            input: std::option::Option<crate::model::SnowballType>,
        ) -> Self {
            self.inner = self.inner.set_snowball_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateReturnShippingLabel<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_return_shipping_label_input::Builder,
    }
    impl<C, M, R> CreateReturnShippingLabel<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateReturnShippingLabelOutput,
            smithy_http::result::SdkError<crate::error::CreateReturnShippingLabelError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateReturnShippingLabelInputOperationOutputAlias,
                crate::output::CreateReturnShippingLabelOutput,
                crate::error::CreateReturnShippingLabelError,
                crate::input::CreateReturnShippingLabelInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for a job that you want to create the return shipping label for; for example,
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The shipping speed for a particular job. This speed doesn't dictate how soon the device is returned to AWS.
        /// This speed represents how quickly it moves to its
        /// destination while in transit. Regional shipping speeds are as follows:</p>
        pub fn shipping_option(mut self, inp: crate::model::ShippingOption) -> Self {
            self.inner = self.inner.shipping_option(inp);
            self
        }
        pub fn set_shipping_option(
            mut self,
            input: std::option::Option<crate::model::ShippingOption>,
        ) -> Self {
            self.inner = self.inner.set_shipping_option(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAddress<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_address_input::Builder,
    }
    impl<C, M, R> DescribeAddress<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAddressOutput,
            smithy_http::result::SdkError<crate::error::DescribeAddressError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeAddressInputOperationOutputAlias,
                crate::output::DescribeAddressOutput,
                crate::error::DescribeAddressError,
                crate::input::DescribeAddressInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The automatically generated ID for a specific address.</p>
        pub fn address_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.address_id(inp);
            self
        }
        pub fn set_address_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_address_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAddresses<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_addresses_input::Builder,
    }
    impl<C, M, R> DescribeAddresses<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAddressesOutput,
            smithy_http::result::SdkError<crate::error::DescribeAddressesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeAddressesInputOperationOutputAlias,
                crate::output::DescribeAddressesOutput,
                crate::error::DescribeAddressesError,
                crate::input::DescribeAddressesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The number of <code>ADDRESS</code> objects to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
        /// <code>ADDRESS</code> objects, you have the option of specifying a value for
        /// <code>NextToken</code> as the starting point for your list of returned addresses.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCluster<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_cluster_input::Builder,
    }
    impl<C, M, R> DescribeCluster<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClusterOutput,
            smithy_http::result::SdkError<crate::error::DescribeClusterError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeClusterInputOperationOutputAlias,
                crate::output::DescribeClusterOutput,
                crate::error::DescribeClusterError,
                crate::input::DescribeClusterInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The automatically generated ID for a cluster.</p>
        pub fn cluster_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(inp);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeJob<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_job_input::Builder,
    }
    impl<C, M, R> DescribeJob<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeJobOutput,
            smithy_http::result::SdkError<crate::error::DescribeJobError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeJobInputOperationOutputAlias,
                crate::output::DescribeJobOutput,
                crate::error::DescribeJobError,
                crate::input::DescribeJobInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The automatically generated ID for a job, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReturnShippingLabel<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_return_shipping_label_input::Builder,
    }
    impl<C, M, R> DescribeReturnShippingLabel<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReturnShippingLabelOutput,
            smithy_http::result::SdkError<crate::error::DescribeReturnShippingLabelError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeReturnShippingLabelInputOperationOutputAlias,
                crate::output::DescribeReturnShippingLabelOutput,
                crate::error::DescribeReturnShippingLabelError,
                crate::input::DescribeReturnShippingLabelInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The automatically generated ID for a job, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetJobManifest<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_job_manifest_input::Builder,
    }
    impl<C, M, R> GetJobManifest<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetJobManifestOutput,
            smithy_http::result::SdkError<crate::error::GetJobManifestError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetJobManifestInputOperationOutputAlias,
                crate::output::GetJobManifestOutput,
                crate::error::GetJobManifestError,
                crate::input::GetJobManifestInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for a job that you want to get the manifest file for, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetJobUnlockCode<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_job_unlock_code_input::Builder,
    }
    impl<C, M, R> GetJobUnlockCode<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetJobUnlockCodeOutput,
            smithy_http::result::SdkError<crate::error::GetJobUnlockCodeError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetJobUnlockCodeInputOperationOutputAlias,
                crate::output::GetJobUnlockCodeOutput,
                crate::error::GetJobUnlockCodeError,
                crate::input::GetJobUnlockCodeInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for the job that you want to get the <code>UnlockCode</code> value for, for
        /// example <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSnowballUsage<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_snowball_usage_input::Builder,
    }
    impl<C, M, R> GetSnowballUsage<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSnowballUsageOutput,
            smithy_http::result::SdkError<crate::error::GetSnowballUsageError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetSnowballUsageInputOperationOutputAlias,
                crate::output::GetSnowballUsageOutput,
                crate::error::GetSnowballUsageError,
                crate::input::GetSnowballUsageInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSoftwareUpdates<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_software_updates_input::Builder,
    }
    impl<C, M, R> GetSoftwareUpdates<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSoftwareUpdatesOutput,
            smithy_http::result::SdkError<crate::error::GetSoftwareUpdatesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetSoftwareUpdatesInputOperationOutputAlias,
                crate::output::GetSoftwareUpdatesOutput,
                crate::error::GetSoftwareUpdatesError,
                crate::input::GetSoftwareUpdatesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for a job that you want to get the software update file for, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListClusterJobs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_cluster_jobs_input::Builder,
    }
    impl<C, M, R> ListClusterJobs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListClusterJobsOutput,
            smithy_http::result::SdkError<crate::error::ListClusterJobsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListClusterJobsInputOperationOutputAlias,
                crate::output::ListClusterJobsOutput,
                crate::error::ListClusterJobsError,
                crate::input::ListClusterJobsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The 39-character ID for the cluster that you want to list, for example
        /// <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn cluster_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(inp);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
        /// <p>The number of <code>JobListEntry</code> objects to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
        /// <code>JobListEntry</code> objects, you have the option of specifying <code>NextToken</code>
        /// as the starting point for your returned list.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListClusters<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_clusters_input::Builder,
    }
    impl<C, M, R> ListClusters<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListClustersOutput,
            smithy_http::result::SdkError<crate::error::ListClustersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListClustersInputOperationOutputAlias,
                crate::output::ListClustersOutput,
                crate::error::ListClustersError,
                crate::input::ListClustersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The number of <code>ClusterListEntry</code> objects to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
        /// <code>ClusterListEntry</code> objects, you have the option of specifying
        /// <code>NextToken</code> as the starting point for your returned list.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCompatibleImages<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_compatible_images_input::Builder,
    }
    impl<C, M, R> ListCompatibleImages<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCompatibleImagesOutput,
            smithy_http::result::SdkError<crate::error::ListCompatibleImagesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListCompatibleImagesInputOperationOutputAlias,
                crate::output::ListCompatibleImagesOutput,
                crate::error::ListCompatibleImagesError,
                crate::input::ListCompatibleImagesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results for the list of compatible images. Currently, a Snowball
        /// Edge device can store 10 AMIs.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
        /// compatible images, you can specify a value for <code>NextToken</code> as the starting point
        /// for your list of returned images.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJobs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_jobs_input::Builder,
    }
    impl<C, M, R> ListJobs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListJobsOutput,
            smithy_http::result::SdkError<crate::error::ListJobsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListJobsInputOperationOutputAlias,
                crate::output::ListJobsOutput,
                crate::error::ListJobsError,
                crate::input::ListJobsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The number of <code>JobListEntry</code> objects to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
        /// <code>JobListEntry</code> objects, you have the option of specifying <code>NextToken</code>
        /// as the starting point for your returned list.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLongTermPricing<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_long_term_pricing_input::Builder,
    }
    impl<C, M, R> ListLongTermPricing<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLongTermPricingOutput,
            smithy_http::result::SdkError<crate::error::ListLongTermPricingError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListLongTermPricingInputOperationOutputAlias,
                crate::output::ListLongTermPricingOutput,
                crate::error::ListLongTermPricingError,
                crate::input::ListLongTermPricingInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of <code>ListLongTermPricing</code> objects to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Because HTTP requests are stateless, this is the starting point for your next list of
        /// <code>ListLongTermPricing</code> to return.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCluster<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_cluster_input::Builder,
    }
    impl<C, M, R> UpdateCluster<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateClusterOutput,
            smithy_http::result::SdkError<crate::error::UpdateClusterError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateClusterInputOperationOutputAlias,
                crate::output::UpdateClusterOutput,
                crate::error::UpdateClusterError,
                crate::input::UpdateClusterInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The cluster ID of the cluster that you want to update, for example
        /// <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn cluster_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(inp);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
        /// <p>The new role Amazon Resource Name (ARN) that you want to associate with this cluster.
        /// To create a role ARN, use the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a> API action in AWS
        /// Identity and Access Management (IAM).</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The updated description of this cluster.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The updated arrays of <a>JobResource</a> objects that can include updated
        /// <a>S3Resource</a> objects or <a>LambdaResource</a> objects.</p>
        pub fn resources(mut self, inp: crate::model::JobResource) -> Self {
            self.inner = self.inner.resources(inp);
            self
        }
        pub fn set_resources(
            mut self,
            input: std::option::Option<crate::model::JobResource>,
        ) -> Self {
            self.inner = self.inner.set_resources(input);
            self
        }
        /// <p>Specifies the service or services on the Snow Family device that your
        /// transferred data will be exported from or imported into. AWS Snow Family supports Amazon S3 and NFS (Network File System).</p>
        pub fn on_device_service_configuration(
            mut self,
            inp: crate::model::OnDeviceServiceConfiguration,
        ) -> Self {
            self.inner = self.inner.on_device_service_configuration(inp);
            self
        }
        pub fn set_on_device_service_configuration(
            mut self,
            input: std::option::Option<crate::model::OnDeviceServiceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_on_device_service_configuration(input);
            self
        }
        /// <p>The ID of the updated <a>Address</a> object.</p>
        pub fn address_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.address_id(inp);
            self
        }
        pub fn set_address_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_address_id(input);
            self
        }
        /// <p>The updated shipping option value of this cluster's <a>ShippingDetails</a>
        /// object.</p>
        pub fn shipping_option(mut self, inp: crate::model::ShippingOption) -> Self {
            self.inner = self.inner.shipping_option(inp);
            self
        }
        pub fn set_shipping_option(
            mut self,
            input: std::option::Option<crate::model::ShippingOption>,
        ) -> Self {
            self.inner = self.inner.set_shipping_option(input);
            self
        }
        /// <p>The new or updated <a>Notification</a> object.</p>
        pub fn notification(mut self, inp: crate::model::Notification) -> Self {
            self.inner = self.inner.notification(inp);
            self
        }
        pub fn set_notification(
            mut self,
            input: std::option::Option<crate::model::Notification>,
        ) -> Self {
            self.inner = self.inner.set_notification(input);
            self
        }
        /// <p>The updated ID for the forwarding address for a cluster. This field is not
        /// supported in most regions.</p>
        pub fn forwarding_address_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.forwarding_address_id(inp);
            self
        }
        pub fn set_forwarding_address_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_forwarding_address_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateJob<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_job_input::Builder,
    }
    impl<C, M, R> UpdateJob<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateJobOutput,
            smithy_http::result::SdkError<crate::error::UpdateJobError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateJobInputOperationOutputAlias,
                crate::output::UpdateJobOutput,
                crate::error::UpdateJobError,
                crate::input::UpdateJobInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The job ID of the job that you want to update, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The new role Amazon Resource Name (ARN) that you want to associate with this job. To
        /// create a role ARN, use the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a>AWS Identity and Access
        /// Management (IAM) API action.</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The new or updated <a>Notification</a> object.</p>
        pub fn notification(mut self, inp: crate::model::Notification) -> Self {
            self.inner = self.inner.notification(inp);
            self
        }
        pub fn set_notification(
            mut self,
            input: std::option::Option<crate::model::Notification>,
        ) -> Self {
            self.inner = self.inner.set_notification(input);
            self
        }
        /// <p>The updated <code>JobResource</code> object, or the updated <a>JobResource</a> object. </p>
        pub fn resources(mut self, inp: crate::model::JobResource) -> Self {
            self.inner = self.inner.resources(inp);
            self
        }
        pub fn set_resources(
            mut self,
            input: std::option::Option<crate::model::JobResource>,
        ) -> Self {
            self.inner = self.inner.set_resources(input);
            self
        }
        /// <p>Specifies the service or services on the Snow Family device that your
        /// transferred data will be exported from or imported into. AWS Snow Family supports Amazon S3 and NFS (Network File System).</p>
        pub fn on_device_service_configuration(
            mut self,
            inp: crate::model::OnDeviceServiceConfiguration,
        ) -> Self {
            self.inner = self.inner.on_device_service_configuration(inp);
            self
        }
        pub fn set_on_device_service_configuration(
            mut self,
            input: std::option::Option<crate::model::OnDeviceServiceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_on_device_service_configuration(input);
            self
        }
        /// <p>The ID of the updated <a>Address</a> object.</p>
        pub fn address_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.address_id(inp);
            self
        }
        pub fn set_address_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_address_id(input);
            self
        }
        /// <p>The updated shipping option value of this job's <a>ShippingDetails</a>
        /// object.</p>
        pub fn shipping_option(mut self, inp: crate::model::ShippingOption) -> Self {
            self.inner = self.inner.shipping_option(inp);
            self
        }
        pub fn set_shipping_option(
            mut self,
            input: std::option::Option<crate::model::ShippingOption>,
        ) -> Self {
            self.inner = self.inner.set_shipping_option(input);
            self
        }
        /// <p>The updated description of this job's <a>JobMetadata</a> object.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The updated <code>SnowballCapacityPreference</code> of this job's <a>JobMetadata</a> object. The 50 TB Snowballs are only available in the US
        /// regions.</p>
        /// <p>For more information, see
        /// "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
        /// "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
        pub fn snowball_capacity_preference(mut self, inp: crate::model::SnowballCapacity) -> Self {
            self.inner = self.inner.snowball_capacity_preference(inp);
            self
        }
        pub fn set_snowball_capacity_preference(
            mut self,
            input: std::option::Option<crate::model::SnowballCapacity>,
        ) -> Self {
            self.inner = self.inner.set_snowball_capacity_preference(input);
            self
        }
        /// <p>The updated ID for the forwarding address for a job. This field is not
        /// supported in most regions.</p>
        pub fn forwarding_address_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.forwarding_address_id(inp);
            self
        }
        pub fn set_forwarding_address_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_forwarding_address_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateJobShipmentState<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_job_shipment_state_input::Builder,
    }
    impl<C, M, R> UpdateJobShipmentState<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateJobShipmentStateOutput,
            smithy_http::result::SdkError<crate::error::UpdateJobShipmentStateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateJobShipmentStateInputOperationOutputAlias,
                crate::output::UpdateJobShipmentStateOutput,
                crate::error::UpdateJobShipmentStateError,
                crate::input::UpdateJobShipmentStateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The job ID of the job whose shipment date you want to update, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The state of a device when it is being shipped. </p>
        /// <p>Set to <code>RECEIVED</code> when the device arrives at your location.</p>
        /// <p>Set to <code>RETURNED</code> when you have returned the device to AWS.</p>
        pub fn shipment_state(mut self, inp: crate::model::ShipmentState) -> Self {
            self.inner = self.inner.shipment_state(inp);
            self
        }
        pub fn set_shipment_state(
            mut self,
            input: std::option::Option<crate::model::ShipmentState>,
        ) -> Self {
            self.inner = self.inner.set_shipment_state(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLongTermPricing<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_long_term_pricing_input::Builder,
    }
    impl<C, M, R> UpdateLongTermPricing<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLongTermPricingOutput,
            smithy_http::result::SdkError<crate::error::UpdateLongTermPricingError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateLongTermPricingInputOperationOutputAlias,
                crate::output::UpdateLongTermPricingOutput,
                crate::error::UpdateLongTermPricingError,
                crate::input::UpdateLongTermPricingInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the long-term pricing type for the device.</p>
        pub fn long_term_pricing_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.long_term_pricing_id(inp);
            self
        }
        pub fn set_long_term_pricing_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_long_term_pricing_id(input);
            self
        }
        /// <p>Specifies that a device that is ordered with long-term pricing should be replaced with a new device.</p>
        pub fn replacement_job(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replacement_job(inp);
            self
        }
        pub fn set_replacement_job(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replacement_job(input);
            self
        }
        /// <p>If set to <code>true</code>, specifies that the current long-term pricing type for the
        /// device should be automatically renewed before the long-term pricing contract expires.</p>
        pub fn is_long_term_pricing_auto_renew(mut self, inp: bool) -> Self {
            self.inner = self.inner.is_long_term_pricing_auto_renew(inp);
            self
        }
        pub fn set_is_long_term_pricing_auto_renew(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_is_long_term_pricing_auto_renew(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
